const E = (t) => Array.isArray(t), L = (t) => typeof t == "string";
function m(t) {
  return (...e) => {
    const r = e.map((i) => b(i)), n = r[0], s = r[1];
    return r.length === 1 ? (i) => t(n(i)) : r.length === 2 ? (i) => t(n(i), s(i)) : (i) => t(...r.map((j) => j(i)));
  };
}
const N = {
  pipe: (...t) => {
    const e = t.map((r) => b(r));
    return (r) => e.reduce((n, s) => s(n), r);
  },
  object: (t) => {
    const e = Object.keys(t).map((r) => [r, b(t[r])]);
    return (r) => {
      const n = {};
      for (const [s, i] of e)
        n[s] = i(r);
      return n;
    };
  },
  array: (...t) => {
    const e = t.map((r) => b(r));
    return (r) => e.map((n) => n(r));
  },
  get: (...t) => {
    if (t.length === 0)
      return (e) => e;
    if (t.length === 1) {
      const e = t[0];
      return (r) => r == null ? void 0 : r[e];
    }
    return (e) => {
      let r = e;
      for (const n of t)
        r = r == null ? void 0 : r[n];
      return r;
    };
  },
  map: (t) => {
    const e = b(t);
    return (r) => r.map(e);
  },
  filter: (t) => {
    const e = b(t);
    return (r) => r.filter(e);
  },
  sort: (t = ["get"], e) => {
    const r = b(t), n = e === "desc" ? -1 : 1;
    function s(i, j) {
      const w = r(i), y = r(j);
      return w > y ? n : w < y ? -n : 0;
    }
    return (i) => i.slice().sort(s);
  },
  pick: (...t) => {
    const e = t.map(
      ([n, ...s]) => [s[s.length - 1], N.get(...s)]
    ), r = (n, s) => {
      const i = {};
      for (const [j, w] of s)
        i[j] = w(n);
      return i;
    };
    return (n) => E(n) ? n.map((s) => r(s, e)) : r(n, e);
  },
  groupBy: (t) => {
    const e = b(t);
    return (r) => {
      const n = {};
      for (const s of r) {
        const i = e(s);
        n[i] ? n[i].push(s) : n[i] = [s];
      }
      return n;
    };
  },
  keyBy: (t) => {
    const e = b(t);
    return (r) => {
      const n = {};
      for (const s of r) {
        const i = e(s);
        n[i] = n[i] ?? s;
      }
      return n;
    };
  },
  flatten: () => (t) => t.flat(),
  uniq: () => (t) => [...new Set(t)],
  uniqBy: (t) => (e) => Object.values(N.groupBy(t)(e)).map((r) => r[0]),
  limit: (t) => (e) => e.slice(0, t),
  size: () => (t) => t.length,
  keys: () => Object.keys,
  values: () => Object.values,
  prod: () => (t) => t.reduce((e, r) => e * r),
  sum: () => (t) => t.reduce((e, r) => e + r),
  average: () => (t) => N.sum()(t) / t.length,
  min: () => (t) => Math.min(...t),
  max: () => (t) => Math.max(...t),
  in: (t, e) => {
    const r = b(t), n = b(e);
    return (s) => n(s).includes(r(s));
  },
  "not in": (t, e) => {
    const r = N.in(t, e);
    return (n) => !r(n);
  },
  regex: (t, e, r) => {
    const n = new RegExp(e, r), s = b(t);
    return (i) => n.test(s(i));
  },
  and: m((t, e) => t && e),
  or: m((t, e) => t || e),
  not: m((t) => !t),
  exists: m((t) => t !== void 0),
  eq: m((t, e) => t === e),
  gt: m((t, e) => t > e),
  gte: m((t, e) => t >= e),
  lt: m((t, e) => t < e),
  lte: m((t, e) => t <= e),
  ne: m((t, e) => t !== e),
  add: m((t, e) => t + e),
  subtract: m((t, e) => t - e),
  multiply: m((t, e) => t * e),
  divide: m((t, e) => t / e),
  pow: m((t, e) => t ** e),
  mod: m((t, e) => t % e),
  abs: m(Math.abs),
  round: m((t, e = 0) => +`${Math.round(+`${t}e${e}`)}e${-e}`)
}, S = [];
function b(t, e) {
  S.unshift({ ...N, ...S[0], ...e == null ? void 0 : e.functions });
  try {
    const r = E(t) ? P(t, S[0]) : () => t;
    return (n) => {
      try {
        return r(n);
      } catch (s) {
        throw s.jsonquery = [{ data: n, query: t }, ...s.jsonquery ?? []], s;
      }
    };
  } finally {
    S.shift();
  }
}
function P(t, e) {
  const [r, ...n] = t, s = e[r];
  if (!s)
    throw new Error(`Unknown function '${r}'`);
  return s(...n);
}
const R = {
  and: "and",
  or: "or",
  eq: "==",
  gt: ">",
  gte: ">=",
  lt: "<",
  lte: "<=",
  ne: "!=",
  add: "+",
  subtract: "-",
  multiply: "*",
  divide: "/",
  pow: "^",
  mod: "%",
  in: "in",
  "not in": "not in"
}, W = /^[a-zA-Z_$][a-zA-Z\d_$]*$/, I = /^[a-zA-Z_$][a-zA-Z\d_$]*/, U = /^"(?:[^"\\]|\\.)*"/, F = /^-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?/, J = /^(0|[1-9][0-9]*)/, z = /^(true|false|null)/, B = /^[ \n\t\r]+/;
function M(t, e) {
  const r = () => {
    h();
    const o = n();
    if (h(), t[c] === "|") {
      const g = [o];
      for (; t[c] === "|"; )
        c++, h(), g.push(n());
      return ["pipe", ...g];
    }
    return o;
  }, n = () => {
    const o = { ...R, ...e == null ? void 0 : e.operators }, g = s();
    h();
    for (const x of Object.keys(o).sort((k, v) => v.length - k.length)) {
      const k = o[x];
      if (t.substring(c, c + k.length) === k) {
        c += k.length, h();
        const v = s();
        return [x, g, v];
      }
    }
    return g;
  }, s = () => {
    if (t[c] === "(") {
      c++;
      const o = r();
      return p(")"), o;
    }
    return i();
  }, i = () => {
    const o = [];
    if (t[c] === ".") {
      for (; t[c] === "."; )
        c++, o.push(
          a() ?? u() ?? f() ?? $("Property expected")
        );
      return ["get", ...o];
    }
    return j();
  }, j = () => {
    const o = c, g = u();
    if (h(), !g || t[c] !== "(")
      return c = o, w();
    c++, !(e != null && e.functions[g]) && !N[g] && $(`Unknown function '${g}'`), h();
    const x = t[c] !== ")" ? [r()] : [];
    for (; c < t.length && t[c] !== ")"; )
      h(), p(","), x.push(r());
    return p(")"), [g, ...x];
  }, w = () => {
    if (t[c] === "{") {
      c++, h();
      const o = {};
      let g = !0;
      for (; c < t.length && t[c] !== "}"; ) {
        g ? g = !1 : (p(","), h());
        const x = a() ?? u() ?? f() ?? $("Key expected");
        h(), p(":"), o[x] = r();
      }
      return p("}"), ["object", o];
    }
    return y();
  }, y = () => {
    if (t[c] === "[") {
      c++, h();
      const o = [];
      let g = !0;
      for (; c < t.length && t[c] !== "]"; )
        g ? g = !1 : (p(","), h()), o.push(r());
      return p("]"), ["array", ...o];
    }
    return a() ?? l() ?? _();
  }, a = () => d(U, JSON.parse), u = () => d(I, (o) => o), l = () => d(F, JSON.parse), f = () => d(J, JSON.parse), _ = () => {
    const o = d(z, JSON.parse);
    if (o !== void 0)
      return o;
    $("Value expected");
  }, O = () => {
    h(), c < t.length && $(`Unexpected part '${t.substring(c)}'`);
  }, d = (o, g) => {
    const x = t.substring(c).match(o);
    if (x)
      return c += x[0].length, g(x[0]);
  }, h = () => d(B, (o) => o), p = (o) => {
    t[c] !== o && $(`Character '${o}' expected`), c++;
  }, $ = (o, g = c) => {
    throw new SyntaxError(`${o} (pos: ${g})`);
  };
  let c = 0;
  const A = r();
  return O(), A;
}
const T = 40, Z = "  ", D = (t, e) => {
  const r = (e == null ? void 0 : e.indentation) ?? Z, n = (a, u) => E(a) ? s(a, u) : JSON.stringify(a), s = (a, u) => {
    var h;
    const [l, ...f] = a;
    if (l === "get" && f.length > 0)
      return j(f);
    if (l === "pipe") {
      const p = f.map(($) => n($, u + r));
      return y(p, ["", " | ", ""], ["", `
${u + r}| `, ""]);
    }
    if (l === "object")
      return i(f[0], u);
    if (l === "array") {
      const p = f.map(($) => n($, u));
      return y(
        p,
        ["[", ", ", "]"],
        [`[
${u + r}`, `,
${u + r}`, `
${u}]`]
      );
    }
    const _ = ((h = e == null ? void 0 : e.operators) == null ? void 0 : h[l]) ?? R[l];
    if (_ && f.length === 2) {
      const [p, $] = f, c = n(p, u), A = n($, u);
      return `(${c} ${_} ${A})`;
    }
    const O = f.length === 1 ? u : u + r, d = f.map((p) => n(p, O));
    return f.length === 1 && d[0][0] === "(" ? `${l}${d}` : y(
      d,
      [`${l}(`, ", ", ")"],
      f.length === 1 ? [`${l}(`, `,
${u}`, ")"] : [`${l}(
${O}`, `,
${O}`, `
${u})`]
    );
  }, i = (a, u) => {
    const l = u + r, f = Object.entries(a).map(([_, O]) => `${w(_)}: ${n(O, l)}`);
    return y(
      f,
      ["{ ", ", ", " }"],
      [`{
${l}`, `,
${l}`, `
${u}}`]
    );
  }, j = (a) => a.map((u) => `.${w(u)}`).join(""), w = (a) => W.test(a) ? a : JSON.stringify(a), y = (a, [u, l, f], [_, O, d]) => u.length + a.reduce((p, $) => p + $.length + l.length, 0) - l.length + f.length <= ((e == null ? void 0 : e.maxLineLength) ?? T) ? u + a.join(l) + f : _ + a.join(O) + d;
  return n(t, "");
};
function K(t, e, r) {
  return b(L(e) ? M(e, r) : e, r)(t);
}
export {
  m as buildFunction,
  b as compile,
  K as jsonquery,
  M as parse,
  D as stringify
};
//# sourceMappingURL=jsonquery.js.map
