{"version":3,"file":"jsonquery.js","sources":["../src/is.ts","../src/functions.ts","../src/compile.ts","../src/constants.ts","../src/parse.ts","../src/stringify.ts","../src/jsonquery.ts"],"sourcesContent":["export const isArray = <T>(value: unknown): value is T[] => Array.isArray(value)\n\nexport const isObject = (value: unknown): value is object =>\n  value && typeof value === 'object' && !isArray(value)\n\nexport const isString = (value: unknown): value is string => typeof value === 'string'\n","import { compile } from './compile'\nimport { isArray } from './is'\nimport type {\n  FunctionBuilder,\n  FunctionBuildersMap,\n  Getter,\n  JSONPath,\n  JSONQuery,\n  JSONQueryObject,\n  JSONQueryProperty\n} from './types'\n\nexport function buildFunction(fn: (...args: unknown[]) => unknown): FunctionBuilder {\n  return (...args: JSONQuery[]) => {\n    const compiledArgs = args.map((arg) => compile(arg))\n\n    const arg0 = compiledArgs[0]\n    const arg1 = compiledArgs[1]\n\n    return compiledArgs.length === 1\n      ? (data: unknown) => fn(arg0(data))\n      : compiledArgs.length === 2\n        ? (data: unknown) => fn(arg0(data), arg1(data))\n        : (data: unknown) => fn(...compiledArgs.map((arg) => arg(data)))\n  }\n}\n\nexport const functions: FunctionBuildersMap = {\n  pipe: (...entries: JSONQuery[]) => {\n    const _entries = entries.map((entry) => compile(entry))\n\n    return (data: unknown) => _entries.reduce((data, evaluator) => evaluator(data), data)\n  },\n\n  object: (query: JSONQueryObject) => {\n    const getters: Getter[] = Object.keys(query).map((key) => [key, compile(query[key])])\n\n    return (data: unknown) => {\n      const obj = {}\n      for (const [key, getter] of getters) {\n        obj[key] = getter(data)\n      }\n      return obj\n    }\n  },\n\n  array: (...items: JSONQuery[]) => {\n    const _items = items.map((entry: JSONQuery) => compile(entry))\n\n    return (data: unknown) => _items.map((item) => item(data))\n  },\n\n  get: (...path: JSONPath) => {\n    if (path.length === 0) {\n      return (data: unknown) => data\n    }\n\n    if (path.length === 1) {\n      const prop = path[0]\n      return (data: unknown) => data?.[prop]\n    }\n\n    return (data: unknown) => {\n      let value = data\n\n      for (const prop of path) {\n        value = value?.[prop]\n      }\n\n      return value\n    }\n  },\n\n  map: <T>(callback: JSONQuery) => {\n    const _callback = compile(callback)\n\n    return (data: T[]) => data.map(_callback)\n  },\n\n  filter: <T>(predicate: JSONQuery[]) => {\n    const _predicate = compile(predicate)\n\n    return (data: T[]) => data.filter(_predicate)\n  },\n\n  sort: <T>(path: JSONQueryProperty = ['get'], direction?: 'asc' | 'desc') => {\n    const getter = compile(path)\n    const sign = direction === 'desc' ? -1 : 1\n\n    function compare(itemA: unknown, itemB: unknown) {\n      const a = getter(itemA)\n      const b = getter(itemB)\n      return a > b ? sign : a < b ? -sign : 0\n    }\n\n    return (data: T[]) => data.slice().sort(compare)\n  },\n\n  pick: (...properties: JSONQueryProperty[]) => {\n    const getters = properties.map(\n      ([_get, ...path]) => [path[path.length - 1], functions.get(...path)] as Getter\n    )\n\n    const _pick = (object: Record<string, unknown>, getters: Getter[]): unknown => {\n      const out = {}\n      for (const [key, getter] of getters) {\n        out[key] = getter(object)\n      }\n      return out\n    }\n\n    return (data: Record<string, unknown>): unknown => {\n      if (isArray(data)) {\n        return data.map((item: Record<string, unknown>) => _pick(item, getters))\n      }\n\n      return _pick(data, getters)\n    }\n  },\n\n  groupBy: <T>(path: JSONQueryProperty) => {\n    const getter = compile(path)\n\n    return (data: T[]) => {\n      const res = {}\n\n      for (const item of data) {\n        const value = getter(item) as string\n        if (res[value]) {\n          res[value].push(item)\n        } else {\n          res[value] = [item]\n        }\n      }\n\n      return res\n    }\n  },\n\n  keyBy: <T>(path: JSONQueryProperty) => {\n    const getter = compile(path)\n\n    return (data: T[]) => {\n      const res = {}\n\n      for (const item of data) {\n        const value = getter(item) as string\n        res[value] = res[value] ?? item\n      }\n\n      return res\n    }\n  },\n\n  flatten: () => (data: unknown[]) => data.flat(),\n\n  uniq:\n    () =>\n    <T>(data: T[]) => [...new Set(data)],\n\n  uniqBy:\n    <T>(path: JSONQueryProperty) =>\n    (data: T[]): T[] =>\n      Object.values(functions.groupBy(path)(data)).map((groups) => groups[0]),\n\n  limit:\n    (count: number) =>\n    <T>(data: T[]) =>\n      data.slice(0, count),\n\n  size:\n    () =>\n    <T>(data: T[]) =>\n      data.length,\n\n  keys: () => Object.keys,\n\n  values: () => Object.values,\n\n  prod: () => (data: number[]) => data.reduce((a, b) => a * b),\n\n  sum: () => (data: number[]) => data.reduce((a, b) => a + b),\n\n  average: () => (data: number[]) => (functions.sum()(data) as number) / data.length,\n\n  min: () => (data: number[]) => Math.min(...data),\n\n  max: () => (data: number[]) => Math.max(...data),\n\n  in: (path: string, values: JSONQuery) => {\n    const getter = compile(path)\n    const _values = compile(values)\n\n    return (data: unknown) => (_values(data) as string[]).includes(getter(data) as string)\n  },\n\n  'not in': (path: string, values: JSONQuery) => {\n    const _in = functions.in(path, values)\n\n    return (data: unknown) => !_in(data)\n  },\n\n  regex: (path: JSONQuery, expression: string, options?: string) => {\n    const regex = new RegExp(expression, options)\n    const getter = compile(path)\n\n    return (data: unknown) => regex.test(getter(data) as string)\n  },\n\n  and: buildFunction((a, b) => a && b),\n  or: buildFunction((a, b) => a || b),\n  not: buildFunction((a: unknown) => !a),\n  exists: buildFunction((a: unknown) => a !== undefined),\n\n  eq: buildFunction((a, b) => a === b),\n  gt: buildFunction((a, b) => a > b),\n  gte: buildFunction((a, b) => a >= b),\n  lt: buildFunction((a, b) => a < b),\n  lte: buildFunction((a, b) => a <= b),\n  ne: buildFunction((a, b) => a !== b),\n\n  add: buildFunction((a: number, b: number) => a + b),\n  subtract: buildFunction((a: number, b: number) => a - b),\n  multiply: buildFunction((a: number, b: number) => a * b),\n  divide: buildFunction((a: number, b: number) => a / b),\n  pow: buildFunction((a: number, b: number) => a ** b),\n  mod: buildFunction((a: number, b: number) => a % b),\n  abs: buildFunction(Math.abs),\n  round: buildFunction((value: number, digits = 0) => {\n    const num = Math.round(Number(`${value}e${digits}`))\n    return Number(`${num}e${-digits}`)\n  })\n}\n","import { functions } from './functions'\nimport { isArray } from './is'\nimport type {\n  Fun,\n  FunctionBuildersMap,\n  JSONQuery,\n  JSONQueryCompileOptions,\n  JSONQueryFunction\n} from './types'\n\nconst functionsStack: FunctionBuildersMap[] = []\n\nexport function compile(query: JSONQuery, options?: JSONQueryCompileOptions): Fun {\n  functionsStack.unshift({ ...functions, ...functionsStack[0], ...options?.functions })\n\n  try {\n    const exec = isArray(query)\n      ? compileFunction(query as JSONQueryFunction, functionsStack[0]) // function\n      : () => query // primitive value (string, number, boolean, null)\n\n    // create a wrapper function which can attach a stack to the error\n    return (data) => {\n      try {\n        return exec(data)\n      } catch (err) {\n        // attach a stack to the error\n        err.jsonquery = [{ data, query }, ...(err.jsonquery ?? [])]\n\n        throw err\n      }\n    }\n  } finally {\n    functionsStack.shift()\n  }\n}\n\nfunction compileFunction(query: JSONQueryFunction, functions: FunctionBuildersMap) {\n  const [fnName, ...args] = query\n\n  const fnBuilder = functions[fnName]\n  if (!fnBuilder) {\n    throw new Error(`Unknown function '${fnName}'`)\n  }\n\n  return fnBuilder(...args)\n}\n","export const operators = {\n  and: 'and',\n  or: 'or',\n\n  eq: '==',\n  gt: '>',\n  gte: '>=',\n  lt: '<',\n  lte: '<=',\n  ne: '!=',\n\n  add: '+',\n  subtract: '-',\n  multiply: '*',\n  divide: '/',\n  pow: '^',\n  mod: '%',\n\n  in: 'in',\n  'not in': 'not in'\n}\n\nexport const unquotedPropertyRegex = /^[a-zA-Z_$][a-zA-Z\\d_$]*$/\nexport const startsWithUnquotedPropertyRegex = /^[a-zA-Z_$][a-zA-Z\\d_$]*/\nexport const startsWithStringRegex = /^\"(?:[^\"\\\\]|\\\\.)*\"/ // https://stackoverflow.com/a/249937/1262753\nexport const startsWithNumberRegex = /^-?(?:0|[1-9]\\d*)(?:\\.\\d+)?(?:[eE][+-]?\\d+)?/ // https://stackoverflow.com/a/13340826/1262753\nexport const startsWithIntRegex = /^(0|[1-9][0-9]*)/\nexport const startsWithKeywordRegex = /^(true|false|null)/\nexport const startsWithWhitespaceRegex = /^[ \\n\\t\\r]+/\n","import {\n  operators,\n  startsWithIntRegex,\n  startsWithKeywordRegex,\n  startsWithNumberRegex,\n  startsWithStringRegex,\n  startsWithUnquotedPropertyRegex,\n  startsWithWhitespaceRegex\n} from './constants'\nimport { functions } from './functions'\nimport type { JSONQuery, JSONQueryParseOptions } from './types'\n\n/**\n * Parse a string containing a JSON Query into JSON.\n *\n * Example:\n *\n *     const textQuery = '.friends | filter(.city == \"new York\") | sort(.age) | pick(.name, .age)'\n *     const jsonQuery = parse(textQuery)\n *     // jsonQuery = [\n *     //    'pipe',\n *     //    ['get', 'friends'],\n *     //    ['filter', ['eq', ['get', 'city'], 'New York']],\n *     //    ['sort', ['get', 'age']],\n *     //    ['pick', ['get', 'name'], ['get', 'age']]\n *     //  ]\n */\nexport function parse(query: string, options?: JSONQueryParseOptions): JSONQuery {\n  const parsePipe = () => {\n    skipWhitespace()\n    const first = parseOperator()\n    skipWhitespace()\n\n    if (query[i] === '|') {\n      const pipe = [first]\n\n      while (query[i] === '|') {\n        i++\n        skipWhitespace()\n\n        pipe.push(parseOperator())\n      }\n\n      return ['pipe', ...pipe]\n    }\n\n    return first\n  }\n\n  const parseOperator = () => {\n    const allOperators = { ...operators, ...options?.operators }\n\n    const left = parseParentheses()\n\n    skipWhitespace()\n\n    // we sort the operators from longest to shortest, so we first handle \"<=\" and next \"<\"\n    for (const name of Object.keys(allOperators).sort((a, b) => b.length - a.length)) {\n      const op = allOperators[name]\n      if (query.substring(i, i + op.length) === op) {\n        i += op.length\n        skipWhitespace()\n        const right = parseParentheses()\n\n        return [name, left, right]\n      }\n    }\n\n    return left\n  }\n\n  const parseParentheses = () => {\n    if (query[i] === '(') {\n      i++\n      const inner = parsePipe()\n      eatChar(')')\n      return inner\n    }\n\n    return parseProperty()\n  }\n\n  const parseProperty = () => {\n    const props = []\n\n    if (query[i] === '.') {\n      while (query[i] === '.') {\n        i++\n\n        props.push(\n          parseString() ??\n            parseUnquotedString() ??\n            parseInteger() ??\n            throwError('Property expected')\n        )\n      }\n\n      return ['get', ...props]\n    }\n\n    return parseFunction()\n  }\n\n  const parseFunction = () => {\n    const start = i\n    const name = parseUnquotedString()\n    skipWhitespace()\n    if (!name || query[i] !== '(') {\n      i = start\n      return parseObject()\n    }\n    i++\n\n    if (!options?.functions[name] && !functions[name]) {\n      throwError(`Unknown function '${name}'`)\n    }\n\n    skipWhitespace()\n\n    const args = query[i] !== ')' ? [parsePipe()] : []\n    while (i < query.length && query[i] !== ')') {\n      skipWhitespace()\n      eatChar(',')\n      args.push(parsePipe())\n    }\n\n    eatChar(')')\n\n    return [name, ...args]\n  }\n\n  const parseObject = () => {\n    if (query[i] === '{') {\n      i++\n      skipWhitespace()\n\n      const object = {}\n      let first = true\n      while (i < query.length && query[i] !== '}') {\n        if (first) {\n          first = false\n        } else {\n          eatChar(',')\n          skipWhitespace()\n        }\n\n        const key =\n          parseString() ?? parseUnquotedString() ?? parseInteger() ?? throwError('Key expected')\n\n        skipWhitespace()\n        eatChar(':')\n\n        object[key] = parsePipe()\n      }\n\n      eatChar('}')\n\n      return ['object', object]\n    }\n\n    return parseArray()\n  }\n\n  const parseArray = () => {\n    if (query[i] === '[') {\n      i++\n      skipWhitespace()\n\n      const array = []\n\n      let first = true\n      while (i < query.length && query[i] !== ']') {\n        if (first) {\n          first = false\n        } else {\n          eatChar(',')\n          skipWhitespace()\n        }\n\n        array.push(parsePipe())\n      }\n\n      eatChar(']')\n\n      return ['array', ...array]\n    }\n\n    return parseString() ?? parseNumber() ?? parseKeyword()\n  }\n\n  const parseString = () => parseRegex(startsWithStringRegex, JSON.parse)\n\n  const parseUnquotedString = () => parseRegex(startsWithUnquotedPropertyRegex, (text) => text)\n\n  const parseNumber = () => parseRegex(startsWithNumberRegex, JSON.parse)\n\n  const parseInteger = () => parseRegex(startsWithIntRegex, JSON.parse)\n\n  const parseKeyword = () => {\n    const keyword = parseRegex(startsWithKeywordRegex, JSON.parse)\n    if (keyword !== undefined) {\n      return keyword\n    }\n\n    // end of the parsing chain\n    throwError('Value expected')\n  }\n\n  const parseEnd = () => {\n    skipWhitespace()\n\n    if (i < query.length) {\n      throwError(`Unexpected part '${query.substring(i)}'`)\n    }\n  }\n\n  const parseRegex = <T = string>(regex: RegExp, callback: (match: string) => T): T | undefined => {\n    const match = query.substring(i).match(regex)\n    if (match) {\n      i += match[0].length\n      return callback(match[0])\n    }\n  }\n\n  const skipWhitespace = () => parseRegex(startsWithWhitespaceRegex, (text) => text)\n\n  const eatChar = (char: string) => {\n    if (query[i] !== char) {\n      throwError(`Character '${char}' expected`)\n    }\n    i++\n  }\n\n  const throwError = (message: string, pos = i) => {\n    throw new SyntaxError(`${message} (pos: ${pos})`)\n  }\n\n  let i = 0\n  const output = parsePipe()\n  parseEnd()\n\n  return output\n}\n","import { operators, unquotedPropertyRegex } from './constants'\nimport { isArray } from './is'\nimport type {\n  JSONPath,\n  JSONQuery,\n  JSONQueryFunction,\n  JSONQueryObject,\n  JSONQueryStringifyOptions\n} from './types'\n\nconst DEFAULT_MAX_LINE_LENGTH = 40\nconst DEFAULT_INDENTATION = '  '\n\n/**\n * Stringify a JSON Query into a readable, human friendly text syntax.\n *\n * Example:\n *\n *     const jsonQuery = [\n *         ['get', 'friends'],\n *         ['filter', ['eq', ['get', 'city'], 'New York']],\n *         ['sort', ['get', 'age']],\n *         ['pick', ['get', 'name'], ['get', 'age']]\n *       ]\n *     const textQuery = stringify(jsonQuery)\n *     // textQuery = '.friends | filter(.city == \"new York\") | sort(.age) | pick(.name, .age)'\n *\n * @param query The JSON Query to be stringified\n * @param {Object} [options] An object which can have the following options:\n *                 `maxLineLength` Optional maximum line length. When the query exceeds this maximum,\n *                                 It will be formatted over multiple lines. Default value: 40.\n *                 `indentation`   Optional indentation. Defaults to a string with two spaces: '  '.\n */\nexport const stringify = (query: JSONQuery, options?: JSONQueryStringifyOptions) => {\n  const space = options?.indentation ?? DEFAULT_INDENTATION\n\n  const _stringify = (query: JSONQuery, indent: string) =>\n    isArray(query) ? stringifyFunction(query as JSONQueryFunction, indent) : JSON.stringify(query) // value (string, number, boolean, null)\n\n  const stringifyFunction = (query: JSONQueryFunction, indent: string) => {\n    const [name, ...args] = query\n\n    if (name === 'get' && args.length > 0) {\n      return stringifyPath(args as JSONPath)\n    }\n\n    if (name === 'pipe') {\n      const argsStr = args.map((arg) => _stringify(arg, indent + space))\n\n      return join(argsStr, ['', ' | ', ''], ['', `\\n${indent + space}| `, ''])\n    }\n\n    if (name === 'object') {\n      return stringifyObject(args[0] as JSONQueryObject, indent)\n    }\n\n    if (name === 'array') {\n      const argsStr = args.map((arg) => _stringify(arg, indent))\n      return join(\n        argsStr,\n        ['[', ', ', ']'],\n        [`[\\n${indent + space}`, `,\\n${indent + space}`, `\\n${indent}]`]\n      )\n    }\n\n    // operator like \".age >= 18\"\n    const op = options?.operators?.[name] ?? operators[name]\n    if (op && args.length === 2) {\n      const [left, right] = args\n      const leftStr = _stringify(left, indent)\n      const rightStr = _stringify(right, indent)\n      return `(${leftStr} ${op} ${rightStr})`\n    }\n\n    // regular function like sort(.age)\n    const childIndent = args.length === 1 ? indent : indent + space\n    const argsStr = args.map((arg) => _stringify(arg, childIndent))\n    return args.length === 1 && argsStr[0][0] === '('\n      ? `${name}${argsStr}`\n      : join(\n          argsStr,\n          [`${name}(`, ', ', ')'],\n          args.length === 1\n            ? [`${name}(`, `,\\n${indent}`, ')']\n            : [`${name}(\\n${childIndent}`, `,\\n${childIndent}`, `\\n${indent})`]\n        )\n  }\n\n  const stringifyObject = (query: JSONQueryObject, indent: string) => {\n    const childIndent = indent + space\n    const entries = Object.entries(query).map(([key, value]) => {\n      return `${stringifyProperty(key)}: ${_stringify(value, childIndent)}`\n    })\n\n    return join(\n      entries,\n      ['{ ', ', ', ' }'],\n      [`{\\n${childIndent}`, `,\\n${childIndent}`, `\\n${indent}}`]\n    )\n  }\n\n  const stringifyPath = (path: JSONPath): string =>\n    path.map((prop) => `.${stringifyProperty(prop)}`).join('')\n\n  const stringifyProperty = (prop: string): string =>\n    unquotedPropertyRegex.test(prop) ? prop : JSON.stringify(prop)\n\n  type JoinDefinition = [start: string, separator: string, end: string]\n\n  const join = (\n    items: string[],\n    [compactStart, compactSeparator, compactEnd]: JoinDefinition,\n    [formatStart, formatSeparator, formatEnd]: JoinDefinition\n  ): string => {\n    const compactLength =\n      compactStart.length +\n      items.reduce((sum: number, item: string) => sum + item.length + compactSeparator.length, 0) -\n      compactSeparator.length +\n      compactEnd.length\n\n    return compactLength <= (options?.maxLineLength ?? DEFAULT_MAX_LINE_LENGTH)\n      ? compactStart + items.join(compactSeparator) + compactEnd\n      : formatStart + items.join(formatSeparator) + formatEnd\n  }\n\n  return _stringify(query, '')\n}\n","import { compile } from './compile'\nimport { isString } from './is'\nimport { parse } from './parse'\nimport type { JSONQuery, JSONQueryOptions } from './types'\n\nexport function jsonquery(\n  data: unknown,\n  query: string | JSONQuery,\n  options?: JSONQueryOptions\n): unknown {\n  return compile(isString(query) ? parse(query, options) : query, options)(data)\n}\n\nexport { compile } from './compile'\nexport { stringify } from './stringify'\nexport { parse } from './parse'\nexport { buildFunction } from './functions'\n\nexport * from './types'\n"],"names":["isArray","value","isString","buildFunction","fn","args","compiledArgs","arg","compile","arg0","arg1","data","functions","entries","_entries","entry","evaluator","query","getters","key","obj","getter","items","_items","item","path","prop","callback","_callback","predicate","_predicate","direction","sign","compare","itemA","itemB","a","b","properties","_get","_pick","object","out","res","groups","count","values","_values","_in","expression","options","regex","digits","functionsStack","exec","compileFunction","err","fnName","fnBuilder","operators","unquotedPropertyRegex","startsWithUnquotedPropertyRegex","startsWithStringRegex","startsWithNumberRegex","startsWithIntRegex","startsWithKeywordRegex","startsWithWhitespaceRegex","parse","parsePipe","skipWhitespace","first","parseOperator","i","pipe","allOperators","left","parseParentheses","name","op","right","inner","eatChar","parseProperty","props","parseString","parseUnquotedString","parseInteger","throwError","parseFunction","start","parseObject","parseArray","array","parseNumber","parseKeyword","parseRegex","text","keyword","parseEnd","match","char","message","pos","output","DEFAULT_MAX_LINE_LENGTH","DEFAULT_INDENTATION","stringify","space","_stringify","indent","stringifyFunction","_a","stringifyPath","argsStr","join","stringifyObject","leftStr","rightStr","childIndent","stringifyProperty","compactStart","compactSeparator","compactEnd","formatStart","formatSeparator","formatEnd","sum","jsonquery"],"mappings":"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"}