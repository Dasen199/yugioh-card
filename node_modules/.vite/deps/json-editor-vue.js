import {
  cloneDeepWith_default,
  cloneDeep_default,
  debounce_default,
  forEachRight_default,
  groupBy_default,
  head_default,
  initial_default,
  isEmpty_default,
  isEqual_default,
  last_default,
  mapValues_default,
  map_default,
  memoizeOne,
  minBy_default,
  noop_default,
  partition_default,
  range_default,
  sortBy_default,
  times_default,
  uniqueId_default
} from "./chunk-J4GS3PHO.js";
import {
  computed,
  defineComponent,
  getCurrentInstance,
  h,
  onMounted,
  onUnmounted,
  ref,
  unref,
  watch,
  watchEffect
} from "./chunk-6W6OUFZB.js";
import {
  __commonJS,
  __toESM
} from "./chunk-5WRI5ZAA.js";

// node_modules/json-source-map/index.js
var require_json_source_map = __commonJS({
  "node_modules/json-source-map/index.js"(exports2) {
    "use strict";
    var escapedChars = {
      "b": "\b",
      "f": "\f",
      "n": "\n",
      "r": "\r",
      "t": "	",
      '"': '"',
      "/": "/",
      "\\": "\\"
    };
    var A_CODE = "a".charCodeAt();
    exports2.parse = function(source, _2, options) {
      var pointers = {};
      var line = 0;
      var column = 0;
      var pos = 0;
      var bigint = options && options.bigint && typeof BigInt != "undefined";
      return {
        data: _parse("", true),
        pointers
      };
      function _parse(ptr, topLevel) {
        whitespace();
        var data;
        map(ptr, "value");
        var char = getChar();
        switch (char) {
          case "t":
            read("rue");
            data = true;
            break;
          case "f":
            read("alse");
            data = false;
            break;
          case "n":
            read("ull");
            data = null;
            break;
          case '"':
            data = parseString();
            break;
          case "[":
            data = parseArray(ptr);
            break;
          case "{":
            data = parseObject(ptr);
            break;
          default:
            backChar();
            if ("-0123456789".indexOf(char) >= 0)
              data = parseNumber();
            else
              unexpectedToken();
        }
        map(ptr, "valueEnd");
        whitespace();
        if (topLevel && pos < source.length) unexpectedToken();
        return data;
      }
      function whitespace() {
        loop:
          while (pos < source.length) {
            switch (source[pos]) {
              case " ":
                column++;
                break;
              case "	":
                column += 4;
                break;
              case "\r":
                column = 0;
                break;
              case "\n":
                column = 0;
                line++;
                break;
              default:
                break loop;
            }
            pos++;
          }
      }
      function parseString() {
        var str = "";
        var char;
        while (true) {
          char = getChar();
          if (char == '"') {
            break;
          } else if (char == "\\") {
            char = getChar();
            if (char in escapedChars)
              str += escapedChars[char];
            else if (char == "u")
              str += getCharCode();
            else
              wasUnexpectedToken();
          } else {
            str += char;
          }
        }
        return str;
      }
      function parseNumber() {
        var numStr = "";
        var integer = true;
        if (source[pos] == "-") numStr += getChar();
        numStr += source[pos] == "0" ? getChar() : getDigits();
        if (source[pos] == ".") {
          numStr += getChar() + getDigits();
          integer = false;
        }
        if (source[pos] == "e" || source[pos] == "E") {
          numStr += getChar();
          if (source[pos] == "+" || source[pos] == "-") numStr += getChar();
          numStr += getDigits();
          integer = false;
        }
        var result = +numStr;
        return bigint && integer && (result > Number.MAX_SAFE_INTEGER || result < Number.MIN_SAFE_INTEGER) ? BigInt(numStr) : result;
      }
      function parseArray(ptr) {
        whitespace();
        var arr = [];
        var i2 = 0;
        if (getChar() == "]") return arr;
        backChar();
        while (true) {
          var itemPtr = ptr + "/" + i2;
          arr.push(_parse(itemPtr));
          whitespace();
          var char = getChar();
          if (char == "]") break;
          if (char != ",") wasUnexpectedToken();
          whitespace();
          i2++;
        }
        return arr;
      }
      function parseObject(ptr) {
        whitespace();
        var obj = {};
        if (getChar() == "}") return obj;
        backChar();
        while (true) {
          var loc = getLoc();
          if (getChar() != '"') wasUnexpectedToken();
          var key = parseString();
          var propPtr = ptr + "/" + escapeJsonPointer(key);
          mapLoc(propPtr, "key", loc);
          map(propPtr, "keyEnd");
          whitespace();
          if (getChar() != ":") wasUnexpectedToken();
          whitespace();
          obj[key] = _parse(propPtr);
          whitespace();
          var char = getChar();
          if (char == "}") break;
          if (char != ",") wasUnexpectedToken();
          whitespace();
        }
        return obj;
      }
      function read(str) {
        for (var i2 = 0; i2 < str.length; i2++)
          if (getChar() !== str[i2]) wasUnexpectedToken();
      }
      function getChar() {
        checkUnexpectedEnd();
        var char = source[pos];
        pos++;
        column++;
        return char;
      }
      function backChar() {
        pos--;
        column--;
      }
      function getCharCode() {
        var count = 4;
        var code = 0;
        while (count--) {
          code <<= 4;
          var char = getChar().toLowerCase();
          if (char >= "a" && char <= "f")
            code += char.charCodeAt() - A_CODE + 10;
          else if (char >= "0" && char <= "9")
            code += +char;
          else
            wasUnexpectedToken();
        }
        return String.fromCharCode(code);
      }
      function getDigits() {
        var digits = "";
        while (source[pos] >= "0" && source[pos] <= "9")
          digits += getChar();
        if (digits.length) return digits;
        checkUnexpectedEnd();
        unexpectedToken();
      }
      function map(ptr, prop) {
        mapLoc(ptr, prop, getLoc());
      }
      function mapLoc(ptr, prop, loc) {
        pointers[ptr] = pointers[ptr] || {};
        pointers[ptr][prop] = loc;
      }
      function getLoc() {
        return {
          line,
          column,
          pos
        };
      }
      function unexpectedToken() {
        throw new SyntaxError("Unexpected token " + source[pos] + " in JSON at position " + pos);
      }
      function wasUnexpectedToken() {
        backChar();
        unexpectedToken();
      }
      function checkUnexpectedEnd() {
        if (pos >= source.length)
          throw new SyntaxError("Unexpected end of JSON input");
      }
    };
    exports2.stringify = function(data, _2, options) {
      if (!validType(data)) return;
      var wsLine = 0;
      var wsPos, wsColumn;
      var whitespace = typeof options == "object" ? options.space : options;
      switch (typeof whitespace) {
        case "number":
          var len = whitespace > 10 ? 10 : whitespace < 0 ? 0 : Math.floor(whitespace);
          whitespace = len && repeat(len, " ");
          wsPos = len;
          wsColumn = len;
          break;
        case "string":
          whitespace = whitespace.slice(0, 10);
          wsPos = 0;
          wsColumn = 0;
          for (var j = 0; j < whitespace.length; j++) {
            var char = whitespace[j];
            switch (char) {
              case " ":
                wsColumn++;
                break;
              case "	":
                wsColumn += 4;
                break;
              case "\r":
                wsColumn = 0;
                break;
              case "\n":
                wsColumn = 0;
                wsLine++;
                break;
              default:
                throw new Error("whitespace characters not allowed in JSON");
            }
            wsPos++;
          }
          break;
        default:
          whitespace = void 0;
      }
      var json2 = "";
      var pointers = {};
      var line = 0;
      var column = 0;
      var pos = 0;
      var es6 = options && options.es6 && typeof Map == "function";
      _stringify(data, 0, "");
      return {
        json: json2,
        pointers
      };
      function _stringify(_data, lvl, ptr) {
        map(ptr, "value");
        switch (typeof _data) {
          case "number":
          case "bigint":
          case "boolean":
            out("" + _data);
            break;
          case "string":
            out(quoted(_data));
            break;
          case "object":
            if (_data === null) {
              out("null");
            } else if (typeof _data.toJSON == "function") {
              out(quoted(_data.toJSON()));
            } else if (Array.isArray(_data)) {
              stringifyArray();
            } else if (es6) {
              if (_data.constructor.BYTES_PER_ELEMENT)
                stringifyArray();
              else if (_data instanceof Map)
                stringifyMapSet();
              else if (_data instanceof Set)
                stringifyMapSet(true);
              else
                stringifyObject();
            } else {
              stringifyObject();
            }
        }
        map(ptr, "valueEnd");
        function stringifyArray() {
          if (_data.length) {
            out("[");
            var itemLvl = lvl + 1;
            for (var i2 = 0; i2 < _data.length; i2++) {
              if (i2) out(",");
              indent(itemLvl);
              var item = validType(_data[i2]) ? _data[i2] : null;
              var itemPtr = ptr + "/" + i2;
              _stringify(item, itemLvl, itemPtr);
            }
            indent(lvl);
            out("]");
          } else {
            out("[]");
          }
        }
        function stringifyObject() {
          var keys2 = Object.keys(_data);
          if (keys2.length) {
            out("{");
            var propLvl = lvl + 1;
            for (var i2 = 0; i2 < keys2.length; i2++) {
              var key = keys2[i2];
              var value = _data[key];
              if (validType(value)) {
                if (i2) out(",");
                var propPtr = ptr + "/" + escapeJsonPointer(key);
                indent(propLvl);
                map(propPtr, "key");
                out(quoted(key));
                map(propPtr, "keyEnd");
                out(":");
                if (whitespace) out(" ");
                _stringify(value, propLvl, propPtr);
              }
            }
            indent(lvl);
            out("}");
          } else {
            out("{}");
          }
        }
        function stringifyMapSet(isSet) {
          if (_data.size) {
            out("{");
            var propLvl = lvl + 1;
            var first = true;
            var entries = _data.entries();
            var entry = entries.next();
            while (!entry.done) {
              var item = entry.value;
              var key = item[0];
              var value = isSet ? true : item[1];
              if (validType(value)) {
                if (!first) out(",");
                first = false;
                var propPtr = ptr + "/" + escapeJsonPointer(key);
                indent(propLvl);
                map(propPtr, "key");
                out(quoted(key));
                map(propPtr, "keyEnd");
                out(":");
                if (whitespace) out(" ");
                _stringify(value, propLvl, propPtr);
              }
              entry = entries.next();
            }
            indent(lvl);
            out("}");
          } else {
            out("{}");
          }
        }
      }
      function out(str) {
        column += str.length;
        pos += str.length;
        json2 += str;
      }
      function indent(lvl) {
        if (whitespace) {
          json2 += "\n" + repeat(lvl, whitespace);
          line++;
          column = 0;
          while (lvl--) {
            if (wsLine) {
              line += wsLine;
              column = wsColumn;
            } else {
              column += wsColumn;
            }
            pos += wsPos;
          }
          pos += 1;
        }
      }
      function map(ptr, prop) {
        pointers[ptr] = pointers[ptr] || {};
        pointers[ptr][prop] = {
          line,
          column,
          pos
        };
      }
      function repeat(n2, str) {
        return Array(n2 + 1).join(str);
      }
    };
    var VALID_TYPES = ["number", "bigint", "boolean", "string", "object"];
    function validType(data) {
      return VALID_TYPES.indexOf(typeof data) >= 0;
    }
    var ESC_QUOTE = /"|\\/g;
    var ESC_B = /[\b]/g;
    var ESC_F = /\f/g;
    var ESC_N = /\n/g;
    var ESC_R = /\r/g;
    var ESC_T = /\t/g;
    function quoted(str) {
      str = str.replace(ESC_QUOTE, "\\$&").replace(ESC_F, "\\f").replace(ESC_B, "\\b").replace(ESC_N, "\\n").replace(ESC_R, "\\r").replace(ESC_T, "\\t");
      return '"' + str + '"';
    }
    var ESC_0 = /~/g;
    var ESC_1 = /\//g;
    function escapeJsonPointer(str) {
      return str.replace(ESC_0, "~0").replace(ESC_1, "~1");
    }
  }
});

// node_modules/natural-compare-lite/index.js
var require_natural_compare_lite = __commonJS({
  "node_modules/natural-compare-lite/index.js"(exports2, module2) {
    var naturalCompare = function(a2, b2) {
      var i2, codeA, codeB = 1, posA = 0, posB = 0, alphabet = String.alphabet;
      function getCode(str, pos, code) {
        if (code) {
          for (i2 = pos; code = getCode(str, i2), code < 76 && code > 65; ) ++i2;
          return +str.slice(pos - 1, i2);
        }
        code = alphabet && alphabet.indexOf(str.charAt(pos));
        return code > -1 ? code + 76 : (code = str.charCodeAt(pos) || 0, code < 45 || code > 127) ? code : code < 46 ? 65 : code < 48 ? code - 1 : code < 58 ? code + 18 : code < 65 ? code - 11 : code < 91 ? code + 11 : code < 97 ? code - 37 : code < 123 ? code + 5 : code - 63;
      }
      if ((a2 += "") != (b2 += "")) for (; codeB; ) {
        codeA = getCode(a2, posA++);
        codeB = getCode(b2, posB++);
        if (codeA < 76 && codeB < 76 && codeA > 66 && codeB > 66) {
          codeA = getCode(a2, posA, posA);
          codeB = getCode(b2, posB, posA = i2);
          posB = i2;
        }
        if (codeA != codeB) return codeA < codeB ? -1 : 1;
      }
      return 0;
    };
    try {
      module2.exports = naturalCompare;
    } catch (e2) {
      String.naturalCompare = naturalCompare;
    }
  }
});

// node_modules/vanilla-jsoneditor/node_modules/ajv/dist/compile/codegen/code.js
var require_code = __commonJS({
  "node_modules/vanilla-jsoneditor/node_modules/ajv/dist/compile/codegen/code.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.regexpCode = exports2.getEsmExportName = exports2.getProperty = exports2.safeStringify = exports2.stringify = exports2.strConcat = exports2.addCodeArg = exports2.str = exports2._ = exports2.nil = exports2._Code = exports2.Name = exports2.IDENTIFIER = exports2._CodeOrName = void 0;
    var _CodeOrName = class {
    };
    exports2._CodeOrName = _CodeOrName;
    exports2.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
    var Name = class extends _CodeOrName {
      constructor(s2) {
        super();
        if (!exports2.IDENTIFIER.test(s2))
          throw new Error("CodeGen: name must be a valid identifier");
        this.str = s2;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        return false;
      }
      get names() {
        return { [this.str]: 1 };
      }
    };
    exports2.Name = Name;
    var _Code = class extends _CodeOrName {
      constructor(code) {
        super();
        this._items = typeof code === "string" ? [code] : code;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        if (this._items.length > 1)
          return false;
        const item = this._items[0];
        return item === "" || item === '""';
      }
      get str() {
        var _a4;
        return (_a4 = this._str) !== null && _a4 !== void 0 ? _a4 : this._str = this._items.reduce((s2, c) => `${s2}${c}`, "");
      }
      get names() {
        var _a4;
        return (_a4 = this._names) !== null && _a4 !== void 0 ? _a4 : this._names = this._items.reduce((names, c) => {
          if (c instanceof Name)
            names[c.str] = (names[c.str] || 0) + 1;
          return names;
        }, {});
      }
    };
    exports2._Code = _Code;
    exports2.nil = new _Code("");
    function _2(strs, ...args) {
      const code = [strs[0]];
      let i2 = 0;
      while (i2 < args.length) {
        addCodeArg(code, args[i2]);
        code.push(strs[++i2]);
      }
      return new _Code(code);
    }
    exports2._ = _2;
    var plus = new _Code("+");
    function str(strs, ...args) {
      const expr = [safeStringify(strs[0])];
      let i2 = 0;
      while (i2 < args.length) {
        expr.push(plus);
        addCodeArg(expr, args[i2]);
        expr.push(plus, safeStringify(strs[++i2]));
      }
      optimize(expr);
      return new _Code(expr);
    }
    exports2.str = str;
    function addCodeArg(code, arg) {
      if (arg instanceof _Code)
        code.push(...arg._items);
      else if (arg instanceof Name)
        code.push(arg);
      else
        code.push(interpolate(arg));
    }
    exports2.addCodeArg = addCodeArg;
    function optimize(expr) {
      let i2 = 1;
      while (i2 < expr.length - 1) {
        if (expr[i2] === plus) {
          const res = mergeExprItems(expr[i2 - 1], expr[i2 + 1]);
          if (res !== void 0) {
            expr.splice(i2 - 1, 3, res);
            continue;
          }
          expr[i2++] = "+";
        }
        i2++;
      }
    }
    function mergeExprItems(a2, b2) {
      if (b2 === '""')
        return a2;
      if (a2 === '""')
        return b2;
      if (typeof a2 == "string") {
        if (b2 instanceof Name || a2[a2.length - 1] !== '"')
          return;
        if (typeof b2 != "string")
          return `${a2.slice(0, -1)}${b2}"`;
        if (b2[0] === '"')
          return a2.slice(0, -1) + b2.slice(1);
        return;
      }
      if (typeof b2 == "string" && b2[0] === '"' && !(a2 instanceof Name))
        return `"${a2}${b2.slice(1)}`;
      return;
    }
    function strConcat(c1, c2) {
      return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str`${c1}${c2}`;
    }
    exports2.strConcat = strConcat;
    function interpolate(x) {
      return typeof x == "number" || typeof x == "boolean" || x === null ? x : safeStringify(Array.isArray(x) ? x.join(",") : x);
    }
    function stringify(x) {
      return new _Code(safeStringify(x));
    }
    exports2.stringify = stringify;
    function safeStringify(x) {
      return JSON.stringify(x).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
    }
    exports2.safeStringify = safeStringify;
    function getProperty(key) {
      return typeof key == "string" && exports2.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _2`[${key}]`;
    }
    exports2.getProperty = getProperty;
    function getEsmExportName(key) {
      if (typeof key == "string" && exports2.IDENTIFIER.test(key)) {
        return new _Code(`${key}`);
      }
      throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`);
    }
    exports2.getEsmExportName = getEsmExportName;
    function regexpCode(rx2) {
      return new _Code(rx2.toString());
    }
    exports2.regexpCode = regexpCode;
  }
});

// node_modules/vanilla-jsoneditor/node_modules/ajv/dist/compile/codegen/scope.js
var require_scope = __commonJS({
  "node_modules/vanilla-jsoneditor/node_modules/ajv/dist/compile/codegen/scope.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ValueScope = exports2.ValueScopeName = exports2.Scope = exports2.varKinds = exports2.UsedValueState = void 0;
    var code_1 = require_code();
    var ValueError = class extends Error {
      constructor(name2) {
        super(`CodeGen: "code" for ${name2} not defined`);
        this.value = name2.value;
      }
    };
    var UsedValueState;
    (function(UsedValueState2) {
      UsedValueState2[UsedValueState2["Started"] = 0] = "Started";
      UsedValueState2[UsedValueState2["Completed"] = 1] = "Completed";
    })(UsedValueState || (exports2.UsedValueState = UsedValueState = {}));
    exports2.varKinds = {
      const: new code_1.Name("const"),
      let: new code_1.Name("let"),
      var: new code_1.Name("var")
    };
    var Scope = class {
      constructor({ prefixes, parent } = {}) {
        this._names = {};
        this._prefixes = prefixes;
        this._parent = parent;
      }
      toName(nameOrPrefix) {
        return nameOrPrefix instanceof code_1.Name ? nameOrPrefix : this.name(nameOrPrefix);
      }
      name(prefix) {
        return new code_1.Name(this._newName(prefix));
      }
      _newName(prefix) {
        const ng2 = this._names[prefix] || this._nameGroup(prefix);
        return `${prefix}${ng2.index++}`;
      }
      _nameGroup(prefix) {
        var _a4, _b;
        if (((_b = (_a4 = this._parent) === null || _a4 === void 0 ? void 0 : _a4._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix)) || this._prefixes && !this._prefixes.has(prefix)) {
          throw new Error(`CodeGen: prefix "${prefix}" is not allowed in this scope`);
        }
        return this._names[prefix] = { prefix, index: 0 };
      }
    };
    exports2.Scope = Scope;
    var ValueScopeName = class extends code_1.Name {
      constructor(prefix, nameStr) {
        super(nameStr);
        this.prefix = prefix;
      }
      setValue(value, { property, itemIndex }) {
        this.value = value;
        this.scopePath = (0, code_1._)`.${new code_1.Name(property)}[${itemIndex}]`;
      }
    };
    exports2.ValueScopeName = ValueScopeName;
    var line = (0, code_1._)`\n`;
    var ValueScope = class extends Scope {
      constructor(opts) {
        super(opts);
        this._values = {};
        this._scope = opts.scope;
        this.opts = { ...opts, _n: opts.lines ? line : code_1.nil };
      }
      get() {
        return this._scope;
      }
      name(prefix) {
        return new ValueScopeName(prefix, this._newName(prefix));
      }
      value(nameOrPrefix, value) {
        var _a4;
        if (value.ref === void 0)
          throw new Error("CodeGen: ref must be passed in value");
        const name2 = this.toName(nameOrPrefix);
        const { prefix } = name2;
        const valueKey = (_a4 = value.key) !== null && _a4 !== void 0 ? _a4 : value.ref;
        let vs2 = this._values[prefix];
        if (vs2) {
          const _name = vs2.get(valueKey);
          if (_name)
            return _name;
        } else {
          vs2 = this._values[prefix] = /* @__PURE__ */ new Map();
        }
        vs2.set(valueKey, name2);
        const s2 = this._scope[prefix] || (this._scope[prefix] = []);
        const itemIndex = s2.length;
        s2[itemIndex] = value.ref;
        name2.setValue(value, { property: prefix, itemIndex });
        return name2;
      }
      getValue(prefix, keyOrRef) {
        const vs2 = this._values[prefix];
        if (!vs2)
          return;
        return vs2.get(keyOrRef);
      }
      scopeRefs(scopeName, values = this._values) {
        return this._reduceValues(values, (name2) => {
          if (name2.scopePath === void 0)
            throw new Error(`CodeGen: name "${name2}" has no value`);
          return (0, code_1._)`${scopeName}${name2.scopePath}`;
        });
      }
      scopeCode(values = this._values, usedValues, getCode) {
        return this._reduceValues(values, (name2) => {
          if (name2.value === void 0)
            throw new Error(`CodeGen: name "${name2}" has no value`);
          return name2.value.code;
        }, usedValues, getCode);
      }
      _reduceValues(values, valueCode, usedValues = {}, getCode) {
        let code = code_1.nil;
        for (const prefix in values) {
          const vs2 = values[prefix];
          if (!vs2)
            continue;
          const nameSet = usedValues[prefix] = usedValues[prefix] || /* @__PURE__ */ new Map();
          vs2.forEach((name2) => {
            if (nameSet.has(name2))
              return;
            nameSet.set(name2, UsedValueState.Started);
            let c = valueCode(name2);
            if (c) {
              const def = this.opts.es5 ? exports2.varKinds.var : exports2.varKinds.const;
              code = (0, code_1._)`${code}${def} ${name2} = ${c};${this.opts._n}`;
            } else if (c = getCode === null || getCode === void 0 ? void 0 : getCode(name2)) {
              code = (0, code_1._)`${code}${c}${this.opts._n}`;
            } else {
              throw new ValueError(name2);
            }
            nameSet.set(name2, UsedValueState.Completed);
          });
        }
        return code;
      }
    };
    exports2.ValueScope = ValueScope;
  }
});

// node_modules/vanilla-jsoneditor/node_modules/ajv/dist/compile/codegen/index.js
var require_codegen = __commonJS({
  "node_modules/vanilla-jsoneditor/node_modules/ajv/dist/compile/codegen/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.or = exports2.and = exports2.not = exports2.CodeGen = exports2.operators = exports2.varKinds = exports2.ValueScopeName = exports2.ValueScope = exports2.Scope = exports2.Name = exports2.regexpCode = exports2.stringify = exports2.getProperty = exports2.nil = exports2.strConcat = exports2.str = exports2._ = void 0;
    var code_1 = require_code();
    var scope_1 = require_scope();
    var code_2 = require_code();
    Object.defineProperty(exports2, "_", { enumerable: true, get: function() {
      return code_2._;
    } });
    Object.defineProperty(exports2, "str", { enumerable: true, get: function() {
      return code_2.str;
    } });
    Object.defineProperty(exports2, "strConcat", { enumerable: true, get: function() {
      return code_2.strConcat;
    } });
    Object.defineProperty(exports2, "nil", { enumerable: true, get: function() {
      return code_2.nil;
    } });
    Object.defineProperty(exports2, "getProperty", { enumerable: true, get: function() {
      return code_2.getProperty;
    } });
    Object.defineProperty(exports2, "stringify", { enumerable: true, get: function() {
      return code_2.stringify;
    } });
    Object.defineProperty(exports2, "regexpCode", { enumerable: true, get: function() {
      return code_2.regexpCode;
    } });
    Object.defineProperty(exports2, "Name", { enumerable: true, get: function() {
      return code_2.Name;
    } });
    var scope_2 = require_scope();
    Object.defineProperty(exports2, "Scope", { enumerable: true, get: function() {
      return scope_2.Scope;
    } });
    Object.defineProperty(exports2, "ValueScope", { enumerable: true, get: function() {
      return scope_2.ValueScope;
    } });
    Object.defineProperty(exports2, "ValueScopeName", { enumerable: true, get: function() {
      return scope_2.ValueScopeName;
    } });
    Object.defineProperty(exports2, "varKinds", { enumerable: true, get: function() {
      return scope_2.varKinds;
    } });
    exports2.operators = {
      GT: new code_1._Code(">"),
      GTE: new code_1._Code(">="),
      LT: new code_1._Code("<"),
      LTE: new code_1._Code("<="),
      EQ: new code_1._Code("==="),
      NEQ: new code_1._Code("!=="),
      NOT: new code_1._Code("!"),
      OR: new code_1._Code("||"),
      AND: new code_1._Code("&&"),
      ADD: new code_1._Code("+")
    };
    var Node2 = class {
      optimizeNodes() {
        return this;
      }
      optimizeNames(_names, _constants) {
        return this;
      }
    };
    var Def = class extends Node2 {
      constructor(varKind, name2, rhs) {
        super();
        this.varKind = varKind;
        this.name = name2;
        this.rhs = rhs;
      }
      render({ es5, _n: _n3 }) {
        const varKind = es5 ? scope_1.varKinds.var : this.varKind;
        const rhs = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
        return `${varKind} ${this.name}${rhs};` + _n3;
      }
      optimizeNames(names, constants) {
        if (!names[this.name.str])
          return;
        if (this.rhs)
          this.rhs = optimizeExpr(this.rhs, names, constants);
        return this;
      }
      get names() {
        return this.rhs instanceof code_1._CodeOrName ? this.rhs.names : {};
      }
    };
    var Assign = class extends Node2 {
      constructor(lhs, rhs, sideEffects) {
        super();
        this.lhs = lhs;
        this.rhs = rhs;
        this.sideEffects = sideEffects;
      }
      render({ _n: _n3 }) {
        return `${this.lhs} = ${this.rhs};` + _n3;
      }
      optimizeNames(names, constants) {
        if (this.lhs instanceof code_1.Name && !names[this.lhs.str] && !this.sideEffects)
          return;
        this.rhs = optimizeExpr(this.rhs, names, constants);
        return this;
      }
      get names() {
        const names = this.lhs instanceof code_1.Name ? {} : { ...this.lhs.names };
        return addExprNames(names, this.rhs);
      }
    };
    var AssignOp = class extends Assign {
      constructor(lhs, op2, rhs, sideEffects) {
        super(lhs, rhs, sideEffects);
        this.op = op2;
      }
      render({ _n: _n3 }) {
        return `${this.lhs} ${this.op}= ${this.rhs};` + _n3;
      }
    };
    var Label = class extends Node2 {
      constructor(label) {
        super();
        this.label = label;
        this.names = {};
      }
      render({ _n: _n3 }) {
        return `${this.label}:` + _n3;
      }
    };
    var Break2 = class extends Node2 {
      constructor(label) {
        super();
        this.label = label;
        this.names = {};
      }
      render({ _n: _n3 }) {
        const label = this.label ? ` ${this.label}` : "";
        return `break${label};` + _n3;
      }
    };
    var Throw = class extends Node2 {
      constructor(error) {
        super();
        this.error = error;
      }
      render({ _n: _n3 }) {
        return `throw ${this.error};` + _n3;
      }
      get names() {
        return this.error.names;
      }
    };
    var AnyCode = class extends Node2 {
      constructor(code) {
        super();
        this.code = code;
      }
      render({ _n: _n3 }) {
        return `${this.code};` + _n3;
      }
      optimizeNodes() {
        return `${this.code}` ? this : void 0;
      }
      optimizeNames(names, constants) {
        this.code = optimizeExpr(this.code, names, constants);
        return this;
      }
      get names() {
        return this.code instanceof code_1._CodeOrName ? this.code.names : {};
      }
    };
    var ParentNode = class extends Node2 {
      constructor(nodes = []) {
        super();
        this.nodes = nodes;
      }
      render(opts) {
        return this.nodes.reduce((code, n2) => code + n2.render(opts), "");
      }
      optimizeNodes() {
        const { nodes } = this;
        let i2 = nodes.length;
        while (i2--) {
          const n2 = nodes[i2].optimizeNodes();
          if (Array.isArray(n2))
            nodes.splice(i2, 1, ...n2);
          else if (n2)
            nodes[i2] = n2;
          else
            nodes.splice(i2, 1);
        }
        return nodes.length > 0 ? this : void 0;
      }
      optimizeNames(names, constants) {
        const { nodes } = this;
        let i2 = nodes.length;
        while (i2--) {
          const n2 = nodes[i2];
          if (n2.optimizeNames(names, constants))
            continue;
          subtractNames(names, n2.names);
          nodes.splice(i2, 1);
        }
        return nodes.length > 0 ? this : void 0;
      }
      get names() {
        return this.nodes.reduce((names, n2) => addNames(names, n2.names), {});
      }
    };
    var BlockNode = class extends ParentNode {
      render(opts) {
        return "{" + opts._n + super.render(opts) + "}" + opts._n;
      }
    };
    var Root = class extends ParentNode {
    };
    var Else = class extends BlockNode {
    };
    Else.kind = "else";
    var If2 = class _If extends BlockNode {
      constructor(condition, nodes) {
        super(nodes);
        this.condition = condition;
      }
      render(opts) {
        let code = `if(${this.condition})` + super.render(opts);
        if (this.else)
          code += "else " + this.else.render(opts);
        return code;
      }
      optimizeNodes() {
        super.optimizeNodes();
        const cond = this.condition;
        if (cond === true)
          return this.nodes;
        let e2 = this.else;
        if (e2) {
          const ns2 = e2.optimizeNodes();
          e2 = this.else = Array.isArray(ns2) ? new Else(ns2) : ns2;
        }
        if (e2) {
          if (cond === false)
            return e2 instanceof _If ? e2 : e2.nodes;
          if (this.nodes.length)
            return this;
          return new _If(not(cond), e2 instanceof _If ? [e2] : e2.nodes);
        }
        if (cond === false || !this.nodes.length)
          return void 0;
        return this;
      }
      optimizeNames(names, constants) {
        var _a4;
        this.else = (_a4 = this.else) === null || _a4 === void 0 ? void 0 : _a4.optimizeNames(names, constants);
        if (!(super.optimizeNames(names, constants) || this.else))
          return;
        this.condition = optimizeExpr(this.condition, names, constants);
        return this;
      }
      get names() {
        const names = super.names;
        addExprNames(names, this.condition);
        if (this.else)
          addNames(names, this.else.names);
        return names;
      }
    };
    If2.kind = "if";
    var For = class extends BlockNode {
    };
    For.kind = "for";
    var ForLoop = class extends For {
      constructor(iteration) {
        super();
        this.iteration = iteration;
      }
      render(opts) {
        return `for(${this.iteration})` + super.render(opts);
      }
      optimizeNames(names, constants) {
        if (!super.optimizeNames(names, constants))
          return;
        this.iteration = optimizeExpr(this.iteration, names, constants);
        return this;
      }
      get names() {
        return addNames(super.names, this.iteration.names);
      }
    };
    var ForRange = class extends For {
      constructor(varKind, name2, from, to3) {
        super();
        this.varKind = varKind;
        this.name = name2;
        this.from = from;
        this.to = to3;
      }
      render(opts) {
        const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;
        const { name: name2, from, to: to3 } = this;
        return `for(${varKind} ${name2}=${from}; ${name2}<${to3}; ${name2}++)` + super.render(opts);
      }
      get names() {
        const names = addExprNames(super.names, this.from);
        return addExprNames(names, this.to);
      }
    };
    var ForIter = class extends For {
      constructor(loop, varKind, name2, iterable) {
        super();
        this.loop = loop;
        this.varKind = varKind;
        this.name = name2;
        this.iterable = iterable;
      }
      render(opts) {
        return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);
      }
      optimizeNames(names, constants) {
        if (!super.optimizeNames(names, constants))
          return;
        this.iterable = optimizeExpr(this.iterable, names, constants);
        return this;
      }
      get names() {
        return addNames(super.names, this.iterable.names);
      }
    };
    var Func = class extends BlockNode {
      constructor(name2, args, async) {
        super();
        this.name = name2;
        this.args = args;
        this.async = async;
      }
      render(opts) {
        const _async = this.async ? "async " : "";
        return `${_async}function ${this.name}(${this.args})` + super.render(opts);
      }
    };
    Func.kind = "func";
    var Return = class extends ParentNode {
      render(opts) {
        return "return " + super.render(opts);
      }
    };
    Return.kind = "return";
    var Try = class extends BlockNode {
      render(opts) {
        let code = "try" + super.render(opts);
        if (this.catch)
          code += this.catch.render(opts);
        if (this.finally)
          code += this.finally.render(opts);
        return code;
      }
      optimizeNodes() {
        var _a4, _b;
        super.optimizeNodes();
        (_a4 = this.catch) === null || _a4 === void 0 ? void 0 : _a4.optimizeNodes();
        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNodes();
        return this;
      }
      optimizeNames(names, constants) {
        var _a4, _b;
        super.optimizeNames(names, constants);
        (_a4 = this.catch) === null || _a4 === void 0 ? void 0 : _a4.optimizeNames(names, constants);
        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNames(names, constants);
        return this;
      }
      get names() {
        const names = super.names;
        if (this.catch)
          addNames(names, this.catch.names);
        if (this.finally)
          addNames(names, this.finally.names);
        return names;
      }
    };
    var Catch = class extends BlockNode {
      constructor(error) {
        super();
        this.error = error;
      }
      render(opts) {
        return `catch(${this.error})` + super.render(opts);
      }
    };
    Catch.kind = "catch";
    var Finally = class extends BlockNode {
      render(opts) {
        return "finally" + super.render(opts);
      }
    };
    Finally.kind = "finally";
    var CodeGen = class {
      constructor(extScope, opts = {}) {
        this._values = {};
        this._blockStarts = [];
        this._constants = {};
        this.opts = { ...opts, _n: opts.lines ? "\n" : "" };
        this._extScope = extScope;
        this._scope = new scope_1.Scope({ parent: extScope });
        this._nodes = [new Root()];
      }
      toString() {
        return this._root.render(this.opts);
      }
      // returns unique name in the internal scope
      name(prefix) {
        return this._scope.name(prefix);
      }
      // reserves unique name in the external scope
      scopeName(prefix) {
        return this._extScope.name(prefix);
      }
      // reserves unique name in the external scope and assigns value to it
      scopeValue(prefixOrName, value) {
        const name2 = this._extScope.value(prefixOrName, value);
        const vs2 = this._values[name2.prefix] || (this._values[name2.prefix] = /* @__PURE__ */ new Set());
        vs2.add(name2);
        return name2;
      }
      getScopeValue(prefix, keyOrRef) {
        return this._extScope.getValue(prefix, keyOrRef);
      }
      // return code that assigns values in the external scope to the names that are used internally
      // (same names that were returned by gen.scopeName or gen.scopeValue)
      scopeRefs(scopeName) {
        return this._extScope.scopeRefs(scopeName, this._values);
      }
      scopeCode() {
        return this._extScope.scopeCode(this._values);
      }
      _def(varKind, nameOrPrefix, rhs, constant) {
        const name2 = this._scope.toName(nameOrPrefix);
        if (rhs !== void 0 && constant)
          this._constants[name2.str] = rhs;
        this._leafNode(new Def(varKind, name2, rhs));
        return name2;
      }
      // `const` declaration (`var` in es5 mode)
      const(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);
      }
      // `let` declaration with optional assignment (`var` in es5 mode)
      let(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);
      }
      // `var` declaration with optional assignment
      var(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);
      }
      // assignment code
      assign(lhs, rhs, sideEffects) {
        return this._leafNode(new Assign(lhs, rhs, sideEffects));
      }
      // `+=` code
      add(lhs, rhs) {
        return this._leafNode(new AssignOp(lhs, exports2.operators.ADD, rhs));
      }
      // appends passed SafeExpr to code or executes Block
      code(c) {
        if (typeof c == "function")
          c();
        else if (c !== code_1.nil)
          this._leafNode(new AnyCode(c));
        return this;
      }
      // returns code for object literal for the passed argument list of key-value pairs
      object(...keyValues) {
        const code = ["{"];
        for (const [key, value] of keyValues) {
          if (code.length > 1)
            code.push(",");
          code.push(key);
          if (key !== value || this.opts.es5) {
            code.push(":");
            (0, code_1.addCodeArg)(code, value);
          }
        }
        code.push("}");
        return new code_1._Code(code);
      }
      // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
      if(condition, thenBody, elseBody) {
        this._blockNode(new If2(condition));
        if (thenBody && elseBody) {
          this.code(thenBody).else().code(elseBody).endIf();
        } else if (thenBody) {
          this.code(thenBody).endIf();
        } else if (elseBody) {
          throw new Error('CodeGen: "else" body without "then" body');
        }
        return this;
      }
      // `else if` clause - invalid without `if` or after `else` clauses
      elseIf(condition) {
        return this._elseNode(new If2(condition));
      }
      // `else` clause - only valid after `if` or `else if` clauses
      else() {
        return this._elseNode(new Else());
      }
      // end `if` statement (needed if gen.if was used only with condition)
      endIf() {
        return this._endBlockNode(If2, Else);
      }
      _for(node, forBody) {
        this._blockNode(node);
        if (forBody)
          this.code(forBody).endFor();
        return this;
      }
      // a generic `for` clause (or statement if `forBody` is passed)
      for(iteration, forBody) {
        return this._for(new ForLoop(iteration), forBody);
      }
      // `for` statement for a range of values
      forRange(nameOrPrefix, from, to3, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {
        const name2 = this._scope.toName(nameOrPrefix);
        return this._for(new ForRange(varKind, name2, from, to3), () => forBody(name2));
      }
      // `for-of` statement (in es5 mode replace with a normal for loop)
      forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {
        const name2 = this._scope.toName(nameOrPrefix);
        if (this.opts.es5) {
          const arr = iterable instanceof code_1.Name ? iterable : this.var("_arr", iterable);
          return this.forRange("_i", 0, (0, code_1._)`${arr}.length`, (i2) => {
            this.var(name2, (0, code_1._)`${arr}[${i2}]`);
            forBody(name2);
          });
        }
        return this._for(new ForIter("of", varKind, name2, iterable), () => forBody(name2));
      }
      // `for-in` statement.
      // With option `ownProperties` replaced with a `for-of` loop for object keys
      forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {
        if (this.opts.ownProperties) {
          return this.forOf(nameOrPrefix, (0, code_1._)`Object.keys(${obj})`, forBody);
        }
        const name2 = this._scope.toName(nameOrPrefix);
        return this._for(new ForIter("in", varKind, name2, obj), () => forBody(name2));
      }
      // end `for` loop
      endFor() {
        return this._endBlockNode(For);
      }
      // `label` statement
      label(label) {
        return this._leafNode(new Label(label));
      }
      // `break` statement
      break(label) {
        return this._leafNode(new Break2(label));
      }
      // `return` statement
      return(value) {
        const node = new Return();
        this._blockNode(node);
        this.code(value);
        if (node.nodes.length !== 1)
          throw new Error('CodeGen: "return" should have one node');
        return this._endBlockNode(Return);
      }
      // `try` statement
      try(tryBody, catchCode, finallyCode) {
        if (!catchCode && !finallyCode)
          throw new Error('CodeGen: "try" without "catch" and "finally"');
        const node = new Try();
        this._blockNode(node);
        this.code(tryBody);
        if (catchCode) {
          const error = this.name("e");
          this._currNode = node.catch = new Catch(error);
          catchCode(error);
        }
        if (finallyCode) {
          this._currNode = node.finally = new Finally();
          this.code(finallyCode);
        }
        return this._endBlockNode(Catch, Finally);
      }
      // `throw` statement
      throw(error) {
        return this._leafNode(new Throw(error));
      }
      // start self-balancing block
      block(body, nodeCount) {
        this._blockStarts.push(this._nodes.length);
        if (body)
          this.code(body).endBlock(nodeCount);
        return this;
      }
      // end the current self-balancing block
      endBlock(nodeCount) {
        const len = this._blockStarts.pop();
        if (len === void 0)
          throw new Error("CodeGen: not in self-balancing block");
        const toClose = this._nodes.length - len;
        if (toClose < 0 || nodeCount !== void 0 && toClose !== nodeCount) {
          throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);
        }
        this._nodes.length = len;
        return this;
      }
      // `function` heading (or definition if funcBody is passed)
      func(name2, args = code_1.nil, async, funcBody) {
        this._blockNode(new Func(name2, args, async));
        if (funcBody)
          this.code(funcBody).endFunc();
        return this;
      }
      // end function definition
      endFunc() {
        return this._endBlockNode(Func);
      }
      optimize(n2 = 1) {
        while (n2-- > 0) {
          this._root.optimizeNodes();
          this._root.optimizeNames(this._root.names, this._constants);
        }
      }
      _leafNode(node) {
        this._currNode.nodes.push(node);
        return this;
      }
      _blockNode(node) {
        this._currNode.nodes.push(node);
        this._nodes.push(node);
      }
      _endBlockNode(N1, N22) {
        const n2 = this._currNode;
        if (n2 instanceof N1 || N22 && n2 instanceof N22) {
          this._nodes.pop();
          return this;
        }
        throw new Error(`CodeGen: not in block "${N22 ? `${N1.kind}/${N22.kind}` : N1.kind}"`);
      }
      _elseNode(node) {
        const n2 = this._currNode;
        if (!(n2 instanceof If2)) {
          throw new Error('CodeGen: "else" without "if"');
        }
        this._currNode = n2.else = node;
        return this;
      }
      get _root() {
        return this._nodes[0];
      }
      get _currNode() {
        const ns2 = this._nodes;
        return ns2[ns2.length - 1];
      }
      set _currNode(node) {
        const ns2 = this._nodes;
        ns2[ns2.length - 1] = node;
      }
    };
    exports2.CodeGen = CodeGen;
    function addNames(names, from) {
      for (const n2 in from)
        names[n2] = (names[n2] || 0) + (from[n2] || 0);
      return names;
    }
    function addExprNames(names, from) {
      return from instanceof code_1._CodeOrName ? addNames(names, from.names) : names;
    }
    function optimizeExpr(expr, names, constants) {
      if (expr instanceof code_1.Name)
        return replaceName(expr);
      if (!canOptimize(expr))
        return expr;
      return new code_1._Code(expr._items.reduce((items, c) => {
        if (c instanceof code_1.Name)
          c = replaceName(c);
        if (c instanceof code_1._Code)
          items.push(...c._items);
        else
          items.push(c);
        return items;
      }, []));
      function replaceName(n2) {
        const c = constants[n2.str];
        if (c === void 0 || names[n2.str] !== 1)
          return n2;
        delete names[n2.str];
        return c;
      }
      function canOptimize(e2) {
        return e2 instanceof code_1._Code && e2._items.some((c) => c instanceof code_1.Name && names[c.str] === 1 && constants[c.str] !== void 0);
      }
    }
    function subtractNames(names, from) {
      for (const n2 in from)
        names[n2] = (names[n2] || 0) - (from[n2] || 0);
    }
    function not(x) {
      return typeof x == "boolean" || typeof x == "number" || x === null ? !x : (0, code_1._)`!${par(x)}`;
    }
    exports2.not = not;
    var andCode = mappend(exports2.operators.AND);
    function and(...args) {
      return args.reduce(andCode);
    }
    exports2.and = and;
    var orCode = mappend(exports2.operators.OR);
    function or3(...args) {
      return args.reduce(orCode);
    }
    exports2.or = or3;
    function mappend(op2) {
      return (x, y) => x === code_1.nil ? y : y === code_1.nil ? x : (0, code_1._)`${par(x)} ${op2} ${par(y)}`;
    }
    function par(x) {
      return x instanceof code_1.Name ? x : (0, code_1._)`(${x})`;
    }
  }
});

// node_modules/vanilla-jsoneditor/node_modules/ajv/dist/compile/util.js
var require_util = __commonJS({
  "node_modules/vanilla-jsoneditor/node_modules/ajv/dist/compile/util.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.checkStrictMode = exports2.getErrorPath = exports2.Type = exports2.useFunc = exports2.setEvaluated = exports2.evaluatedPropsToName = exports2.mergeEvaluated = exports2.eachItem = exports2.unescapeJsonPointer = exports2.escapeJsonPointer = exports2.escapeFragment = exports2.unescapeFragment = exports2.schemaRefOrVal = exports2.schemaHasRulesButRef = exports2.schemaHasRules = exports2.checkUnknownRules = exports2.alwaysValidSchema = exports2.toHash = void 0;
    var codegen_1 = require_codegen();
    var code_1 = require_code();
    function toHash(arr) {
      const hash = {};
      for (const item of arr)
        hash[item] = true;
      return hash;
    }
    exports2.toHash = toHash;
    function alwaysValidSchema(it2, schema) {
      if (typeof schema == "boolean")
        return schema;
      if (Object.keys(schema).length === 0)
        return true;
      checkUnknownRules(it2, schema);
      return !schemaHasRules(schema, it2.self.RULES.all);
    }
    exports2.alwaysValidSchema = alwaysValidSchema;
    function checkUnknownRules(it2, schema = it2.schema) {
      const { opts, self: self2 } = it2;
      if (!opts.strictSchema)
        return;
      if (typeof schema === "boolean")
        return;
      const rules = self2.RULES.keywords;
      for (const key in schema) {
        if (!rules[key])
          checkStrictMode(it2, `unknown keyword: "${key}"`);
      }
    }
    exports2.checkUnknownRules = checkUnknownRules;
    function schemaHasRules(schema, rules) {
      if (typeof schema == "boolean")
        return !schema;
      for (const key in schema)
        if (rules[key])
          return true;
      return false;
    }
    exports2.schemaHasRules = schemaHasRules;
    function schemaHasRulesButRef(schema, RULES) {
      if (typeof schema == "boolean")
        return !schema;
      for (const key in schema)
        if (key !== "$ref" && RULES.all[key])
          return true;
      return false;
    }
    exports2.schemaHasRulesButRef = schemaHasRulesButRef;
    function schemaRefOrVal({ topSchemaRef, schemaPath }, schema, keyword2, $data) {
      if (!$data) {
        if (typeof schema == "number" || typeof schema == "boolean")
          return schema;
        if (typeof schema == "string")
          return (0, codegen_1._)`${schema}`;
      }
      return (0, codegen_1._)`${topSchemaRef}${schemaPath}${(0, codegen_1.getProperty)(keyword2)}`;
    }
    exports2.schemaRefOrVal = schemaRefOrVal;
    function unescapeFragment(str) {
      return unescapeJsonPointer(decodeURIComponent(str));
    }
    exports2.unescapeFragment = unescapeFragment;
    function escapeFragment(str) {
      return encodeURIComponent(escapeJsonPointer(str));
    }
    exports2.escapeFragment = escapeFragment;
    function escapeJsonPointer(str) {
      if (typeof str == "number")
        return `${str}`;
      return str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
    exports2.escapeJsonPointer = escapeJsonPointer;
    function unescapeJsonPointer(str) {
      return str.replace(/~1/g, "/").replace(/~0/g, "~");
    }
    exports2.unescapeJsonPointer = unescapeJsonPointer;
    function eachItem(xs2, f) {
      if (Array.isArray(xs2)) {
        for (const x of xs2)
          f(x);
      } else {
        f(xs2);
      }
    }
    exports2.eachItem = eachItem;
    function makeMergeEvaluated({ mergeNames, mergeToName, mergeValues, resultToName }) {
      return (gen, from, to3, toName) => {
        const res = to3 === void 0 ? from : to3 instanceof codegen_1.Name ? (from instanceof codegen_1.Name ? mergeNames(gen, from, to3) : mergeToName(gen, from, to3), to3) : from instanceof codegen_1.Name ? (mergeToName(gen, to3, from), from) : mergeValues(from, to3);
        return toName === codegen_1.Name && !(res instanceof codegen_1.Name) ? resultToName(gen, res) : res;
      };
    }
    exports2.mergeEvaluated = {
      props: makeMergeEvaluated({
        mergeNames: (gen, from, to3) => gen.if((0, codegen_1._)`${to3} !== true && ${from} !== undefined`, () => {
          gen.if((0, codegen_1._)`${from} === true`, () => gen.assign(to3, true), () => gen.assign(to3, (0, codegen_1._)`${to3} || {}`).code((0, codegen_1._)`Object.assign(${to3}, ${from})`));
        }),
        mergeToName: (gen, from, to3) => gen.if((0, codegen_1._)`${to3} !== true`, () => {
          if (from === true) {
            gen.assign(to3, true);
          } else {
            gen.assign(to3, (0, codegen_1._)`${to3} || {}`);
            setEvaluated(gen, to3, from);
          }
        }),
        mergeValues: (from, to3) => from === true ? true : { ...from, ...to3 },
        resultToName: evaluatedPropsToName
      }),
      items: makeMergeEvaluated({
        mergeNames: (gen, from, to3) => gen.if((0, codegen_1._)`${to3} !== true && ${from} !== undefined`, () => gen.assign(to3, (0, codegen_1._)`${from} === true ? true : ${to3} > ${from} ? ${to3} : ${from}`)),
        mergeToName: (gen, from, to3) => gen.if((0, codegen_1._)`${to3} !== true`, () => gen.assign(to3, from === true ? true : (0, codegen_1._)`${to3} > ${from} ? ${to3} : ${from}`)),
        mergeValues: (from, to3) => from === true ? true : Math.max(from, to3),
        resultToName: (gen, items) => gen.var("items", items)
      })
    };
    function evaluatedPropsToName(gen, ps2) {
      if (ps2 === true)
        return gen.var("props", true);
      const props = gen.var("props", (0, codegen_1._)`{}`);
      if (ps2 !== void 0)
        setEvaluated(gen, props, ps2);
      return props;
    }
    exports2.evaluatedPropsToName = evaluatedPropsToName;
    function setEvaluated(gen, props, ps2) {
      Object.keys(ps2).forEach((p) => gen.assign((0, codegen_1._)`${props}${(0, codegen_1.getProperty)(p)}`, true));
    }
    exports2.setEvaluated = setEvaluated;
    var snippets = {};
    function useFunc(gen, f) {
      return gen.scopeValue("func", {
        ref: f,
        code: snippets[f.code] || (snippets[f.code] = new code_1._Code(f.code))
      });
    }
    exports2.useFunc = useFunc;
    var Type;
    (function(Type2) {
      Type2[Type2["Num"] = 0] = "Num";
      Type2[Type2["Str"] = 1] = "Str";
    })(Type || (exports2.Type = Type = {}));
    function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {
      if (dataProp instanceof codegen_1.Name) {
        const isNumber = dataPropType === Type.Num;
        return jsPropertySyntax ? isNumber ? (0, codegen_1._)`"[" + ${dataProp} + "]"` : (0, codegen_1._)`"['" + ${dataProp} + "']"` : isNumber ? (0, codegen_1._)`"/" + ${dataProp}` : (0, codegen_1._)`"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
      }
      return jsPropertySyntax ? (0, codegen_1.getProperty)(dataProp).toString() : "/" + escapeJsonPointer(dataProp);
    }
    exports2.getErrorPath = getErrorPath;
    function checkStrictMode(it2, msg, mode = it2.opts.strictSchema) {
      if (!mode)
        return;
      msg = `strict mode: ${msg}`;
      if (mode === true)
        throw new Error(msg);
      it2.self.logger.warn(msg);
    }
    exports2.checkStrictMode = checkStrictMode;
  }
});

// node_modules/vanilla-jsoneditor/node_modules/ajv/dist/compile/names.js
var require_names = __commonJS({
  "node_modules/vanilla-jsoneditor/node_modules/ajv/dist/compile/names.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var names = {
      // validation function arguments
      data: new codegen_1.Name("data"),
      // data passed to validation function
      // args passed from referencing schema
      valCxt: new codegen_1.Name("valCxt"),
      // validation/data context - should not be used directly, it is destructured to the names below
      instancePath: new codegen_1.Name("instancePath"),
      parentData: new codegen_1.Name("parentData"),
      parentDataProperty: new codegen_1.Name("parentDataProperty"),
      rootData: new codegen_1.Name("rootData"),
      // root data - same as the data passed to the first/top validation function
      dynamicAnchors: new codegen_1.Name("dynamicAnchors"),
      // used to support recursiveRef and dynamicRef
      // function scoped variables
      vErrors: new codegen_1.Name("vErrors"),
      // null or array of validation errors
      errors: new codegen_1.Name("errors"),
      // counter of validation errors
      this: new codegen_1.Name("this"),
      // "globals"
      self: new codegen_1.Name("self"),
      scope: new codegen_1.Name("scope"),
      // JTD serialize/parse name for JSON string and position
      json: new codegen_1.Name("json"),
      jsonPos: new codegen_1.Name("jsonPos"),
      jsonLen: new codegen_1.Name("jsonLen"),
      jsonPart: new codegen_1.Name("jsonPart")
    };
    exports2.default = names;
  }
});

// node_modules/vanilla-jsoneditor/node_modules/ajv/dist/compile/errors.js
var require_errors = __commonJS({
  "node_modules/vanilla-jsoneditor/node_modules/ajv/dist/compile/errors.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.extendErrors = exports2.resetErrorsCount = exports2.reportExtraError = exports2.reportError = exports2.keyword$DataError = exports2.keywordError = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var names_1 = require_names();
    exports2.keywordError = {
      message: ({ keyword: keyword2 }) => (0, codegen_1.str)`must pass "${keyword2}" keyword validation`
    };
    exports2.keyword$DataError = {
      message: ({ keyword: keyword2, schemaType }) => schemaType ? (0, codegen_1.str)`"${keyword2}" keyword must be ${schemaType} ($data)` : (0, codegen_1.str)`"${keyword2}" keyword is invalid ($data)`
    };
    function reportError(cxt, error = exports2.keywordError, errorPaths, overrideAllErrors) {
      const { it: it2 } = cxt;
      const { gen, compositeRule, allErrors } = it2;
      const errObj = errorObjectCode(cxt, error, errorPaths);
      if (overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : compositeRule || allErrors) {
        addError(gen, errObj);
      } else {
        returnErrors(it2, (0, codegen_1._)`[${errObj}]`);
      }
    }
    exports2.reportError = reportError;
    function reportExtraError(cxt, error = exports2.keywordError, errorPaths) {
      const { it: it2 } = cxt;
      const { gen, compositeRule, allErrors } = it2;
      const errObj = errorObjectCode(cxt, error, errorPaths);
      addError(gen, errObj);
      if (!(compositeRule || allErrors)) {
        returnErrors(it2, names_1.default.vErrors);
      }
    }
    exports2.reportExtraError = reportExtraError;
    function resetErrorsCount(gen, errsCount) {
      gen.assign(names_1.default.errors, errsCount);
      gen.if((0, codegen_1._)`${names_1.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign((0, codegen_1._)`${names_1.default.vErrors}.length`, errsCount), () => gen.assign(names_1.default.vErrors, null)));
    }
    exports2.resetErrorsCount = resetErrorsCount;
    function extendErrors({ gen, keyword: keyword2, schemaValue, data, errsCount, it: it2 }) {
      if (errsCount === void 0)
        throw new Error("ajv implementation error");
      const err = gen.name("err");
      gen.forRange("i", errsCount, names_1.default.errors, (i2) => {
        gen.const(err, (0, codegen_1._)`${names_1.default.vErrors}[${i2}]`);
        gen.if((0, codegen_1._)`${err}.instancePath === undefined`, () => gen.assign((0, codegen_1._)`${err}.instancePath`, (0, codegen_1.strConcat)(names_1.default.instancePath, it2.errorPath)));
        gen.assign((0, codegen_1._)`${err}.schemaPath`, (0, codegen_1.str)`${it2.errSchemaPath}/${keyword2}`);
        if (it2.opts.verbose) {
          gen.assign((0, codegen_1._)`${err}.schema`, schemaValue);
          gen.assign((0, codegen_1._)`${err}.data`, data);
        }
      });
    }
    exports2.extendErrors = extendErrors;
    function addError(gen, errObj) {
      const err = gen.const("err", errObj);
      gen.if((0, codegen_1._)`${names_1.default.vErrors} === null`, () => gen.assign(names_1.default.vErrors, (0, codegen_1._)`[${err}]`), (0, codegen_1._)`${names_1.default.vErrors}.push(${err})`);
      gen.code((0, codegen_1._)`${names_1.default.errors}++`);
    }
    function returnErrors(it2, errs) {
      const { gen, validateName, schemaEnv } = it2;
      if (schemaEnv.$async) {
        gen.throw((0, codegen_1._)`new ${it2.ValidationError}(${errs})`);
      } else {
        gen.assign((0, codegen_1._)`${validateName}.errors`, errs);
        gen.return(false);
      }
    }
    var E3 = {
      keyword: new codegen_1.Name("keyword"),
      schemaPath: new codegen_1.Name("schemaPath"),
      // also used in JTD errors
      params: new codegen_1.Name("params"),
      propertyName: new codegen_1.Name("propertyName"),
      message: new codegen_1.Name("message"),
      schema: new codegen_1.Name("schema"),
      parentSchema: new codegen_1.Name("parentSchema")
    };
    function errorObjectCode(cxt, error, errorPaths) {
      const { createErrors } = cxt.it;
      if (createErrors === false)
        return (0, codegen_1._)`{}`;
      return errorObject(cxt, error, errorPaths);
    }
    function errorObject(cxt, error, errorPaths = {}) {
      const { gen, it: it2 } = cxt;
      const keyValues = [
        errorInstancePath(it2, errorPaths),
        errorSchemaPath(cxt, errorPaths)
      ];
      extraErrorProps(cxt, error, keyValues);
      return gen.object(...keyValues);
    }
    function errorInstancePath({ errorPath }, { instancePath }) {
      const instPath = instancePath ? (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(instancePath, util_1.Type.Str)}` : errorPath;
      return [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, instPath)];
    }
    function errorSchemaPath({ keyword: keyword2, it: { errSchemaPath } }, { schemaPath, parentSchema }) {
      let schPath = parentSchema ? errSchemaPath : (0, codegen_1.str)`${errSchemaPath}/${keyword2}`;
      if (schemaPath) {
        schPath = (0, codegen_1.str)`${schPath}${(0, util_1.getErrorPath)(schemaPath, util_1.Type.Str)}`;
      }
      return [E3.schemaPath, schPath];
    }
    function extraErrorProps(cxt, { params, message }, keyValues) {
      const { keyword: keyword2, data, schemaValue, it: it2 } = cxt;
      const { opts, propertyName: propertyName2, topSchemaRef, schemaPath } = it2;
      keyValues.push([E3.keyword, keyword2], [E3.params, typeof params == "function" ? params(cxt) : params || (0, codegen_1._)`{}`]);
      if (opts.messages) {
        keyValues.push([E3.message, typeof message == "function" ? message(cxt) : message]);
      }
      if (opts.verbose) {
        keyValues.push([E3.schema, schemaValue], [E3.parentSchema, (0, codegen_1._)`${topSchemaRef}${schemaPath}`], [names_1.default.data, data]);
      }
      if (propertyName2)
        keyValues.push([E3.propertyName, propertyName2]);
    }
  }
});

// node_modules/vanilla-jsoneditor/node_modules/ajv/dist/compile/validate/boolSchema.js
var require_boolSchema = __commonJS({
  "node_modules/vanilla-jsoneditor/node_modules/ajv/dist/compile/validate/boolSchema.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.boolOrEmptySchema = exports2.topBoolOrEmptySchema = void 0;
    var errors_1 = require_errors();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var boolError = {
      message: "boolean schema is false"
    };
    function topBoolOrEmptySchema(it2) {
      const { gen, schema, validateName } = it2;
      if (schema === false) {
        falseSchemaError(it2, false);
      } else if (typeof schema == "object" && schema.$async === true) {
        gen.return(names_1.default.data);
      } else {
        gen.assign((0, codegen_1._)`${validateName}.errors`, null);
        gen.return(true);
      }
    }
    exports2.topBoolOrEmptySchema = topBoolOrEmptySchema;
    function boolOrEmptySchema(it2, valid) {
      const { gen, schema } = it2;
      if (schema === false) {
        gen.var(valid, false);
        falseSchemaError(it2);
      } else {
        gen.var(valid, true);
      }
    }
    exports2.boolOrEmptySchema = boolOrEmptySchema;
    function falseSchemaError(it2, overrideAllErrors) {
      const { gen, data } = it2;
      const cxt = {
        gen,
        keyword: "false schema",
        data,
        schema: false,
        schemaCode: false,
        schemaValue: false,
        params: {},
        it: it2
      };
      (0, errors_1.reportError)(cxt, boolError, void 0, overrideAllErrors);
    }
  }
});

// node_modules/vanilla-jsoneditor/node_modules/ajv/dist/compile/rules.js
var require_rules = __commonJS({
  "node_modules/vanilla-jsoneditor/node_modules/ajv/dist/compile/rules.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getRules = exports2.isJSONType = void 0;
    var _jsonTypes = ["string", "number", "integer", "boolean", "null", "object", "array"];
    var jsonTypes = new Set(_jsonTypes);
    function isJSONType(x) {
      return typeof x == "string" && jsonTypes.has(x);
    }
    exports2.isJSONType = isJSONType;
    function getRules() {
      const groups = {
        number: { type: "number", rules: [] },
        string: { type: "string", rules: [] },
        array: { type: "array", rules: [] },
        object: { type: "object", rules: [] }
      };
      return {
        types: { ...groups, integer: true, boolean: true, null: true },
        rules: [{ rules: [] }, groups.number, groups.string, groups.array, groups.object],
        post: { rules: [] },
        all: {},
        keywords: {}
      };
    }
    exports2.getRules = getRules;
  }
});

// node_modules/vanilla-jsoneditor/node_modules/ajv/dist/compile/validate/applicability.js
var require_applicability = __commonJS({
  "node_modules/vanilla-jsoneditor/node_modules/ajv/dist/compile/validate/applicability.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.shouldUseRule = exports2.shouldUseGroup = exports2.schemaHasRulesForType = void 0;
    function schemaHasRulesForType({ schema, self: self2 }, type) {
      const group = self2.RULES.types[type];
      return group && group !== true && shouldUseGroup(schema, group);
    }
    exports2.schemaHasRulesForType = schemaHasRulesForType;
    function shouldUseGroup(schema, group) {
      return group.rules.some((rule) => shouldUseRule(schema, rule));
    }
    exports2.shouldUseGroup = shouldUseGroup;
    function shouldUseRule(schema, rule) {
      var _a4;
      return schema[rule.keyword] !== void 0 || ((_a4 = rule.definition.implements) === null || _a4 === void 0 ? void 0 : _a4.some((kwd) => schema[kwd] !== void 0));
    }
    exports2.shouldUseRule = shouldUseRule;
  }
});

// node_modules/vanilla-jsoneditor/node_modules/ajv/dist/compile/validate/dataType.js
var require_dataType = __commonJS({
  "node_modules/vanilla-jsoneditor/node_modules/ajv/dist/compile/validate/dataType.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.reportTypeError = exports2.checkDataTypes = exports2.checkDataType = exports2.coerceAndCheckDataType = exports2.getJSONTypes = exports2.getSchemaTypes = exports2.DataType = void 0;
    var rules_1 = require_rules();
    var applicability_1 = require_applicability();
    var errors_1 = require_errors();
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var DataType;
    (function(DataType2) {
      DataType2[DataType2["Correct"] = 0] = "Correct";
      DataType2[DataType2["Wrong"] = 1] = "Wrong";
    })(DataType || (exports2.DataType = DataType = {}));
    function getSchemaTypes(schema) {
      const types2 = getJSONTypes(schema.type);
      const hasNull = types2.includes("null");
      if (hasNull) {
        if (schema.nullable === false)
          throw new Error("type: null contradicts nullable: false");
      } else {
        if (!types2.length && schema.nullable !== void 0) {
          throw new Error('"nullable" cannot be used without "type"');
        }
        if (schema.nullable === true)
          types2.push("null");
      }
      return types2;
    }
    exports2.getSchemaTypes = getSchemaTypes;
    function getJSONTypes(ts2) {
      const types2 = Array.isArray(ts2) ? ts2 : ts2 ? [ts2] : [];
      if (types2.every(rules_1.isJSONType))
        return types2;
      throw new Error("type must be JSONType or JSONType[]: " + types2.join(","));
    }
    exports2.getJSONTypes = getJSONTypes;
    function coerceAndCheckDataType(it2, types2) {
      const { gen, data, opts } = it2;
      const coerceTo = coerceToTypes(types2, opts.coerceTypes);
      const checkTypes = types2.length > 0 && !(coerceTo.length === 0 && types2.length === 1 && (0, applicability_1.schemaHasRulesForType)(it2, types2[0]));
      if (checkTypes) {
        const wrongType = checkDataTypes(types2, data, opts.strictNumbers, DataType.Wrong);
        gen.if(wrongType, () => {
          if (coerceTo.length)
            coerceData(it2, types2, coerceTo);
          else
            reportTypeError(it2);
        });
      }
      return checkTypes;
    }
    exports2.coerceAndCheckDataType = coerceAndCheckDataType;
    var COERCIBLE = /* @__PURE__ */ new Set(["string", "number", "integer", "boolean", "null"]);
    function coerceToTypes(types2, coerceTypes) {
      return coerceTypes ? types2.filter((t3) => COERCIBLE.has(t3) || coerceTypes === "array" && t3 === "array") : [];
    }
    function coerceData(it2, types2, coerceTo) {
      const { gen, data, opts } = it2;
      const dataType = gen.let("dataType", (0, codegen_1._)`typeof ${data}`);
      const coerced = gen.let("coerced", (0, codegen_1._)`undefined`);
      if (opts.coerceTypes === "array") {
        gen.if((0, codegen_1._)`${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen.assign(data, (0, codegen_1._)`${data}[0]`).assign(dataType, (0, codegen_1._)`typeof ${data}`).if(checkDataTypes(types2, data, opts.strictNumbers), () => gen.assign(coerced, data)));
      }
      gen.if((0, codegen_1._)`${coerced} !== undefined`);
      for (const t3 of coerceTo) {
        if (COERCIBLE.has(t3) || t3 === "array" && opts.coerceTypes === "array") {
          coerceSpecificType(t3);
        }
      }
      gen.else();
      reportTypeError(it2);
      gen.endIf();
      gen.if((0, codegen_1._)`${coerced} !== undefined`, () => {
        gen.assign(data, coerced);
        assignParentData(it2, coerced);
      });
      function coerceSpecificType(t3) {
        switch (t3) {
          case "string":
            gen.elseIf((0, codegen_1._)`${dataType} == "number" || ${dataType} == "boolean"`).assign(coerced, (0, codegen_1._)`"" + ${data}`).elseIf((0, codegen_1._)`${data} === null`).assign(coerced, (0, codegen_1._)`""`);
            return;
          case "number":
            gen.elseIf((0, codegen_1._)`${dataType} == "boolean" || ${data} === null
              || (${dataType} == "string" && ${data} && ${data} == +${data})`).assign(coerced, (0, codegen_1._)`+${data}`);
            return;
          case "integer":
            gen.elseIf((0, codegen_1._)`${dataType} === "boolean" || ${data} === null
              || (${dataType} === "string" && ${data} && ${data} == +${data} && !(${data} % 1))`).assign(coerced, (0, codegen_1._)`+${data}`);
            return;
          case "boolean":
            gen.elseIf((0, codegen_1._)`${data} === "false" || ${data} === 0 || ${data} === null`).assign(coerced, false).elseIf((0, codegen_1._)`${data} === "true" || ${data} === 1`).assign(coerced, true);
            return;
          case "null":
            gen.elseIf((0, codegen_1._)`${data} === "" || ${data} === 0 || ${data} === false`);
            gen.assign(coerced, null);
            return;
          case "array":
            gen.elseIf((0, codegen_1._)`${dataType} === "string" || ${dataType} === "number"
              || ${dataType} === "boolean" || ${data} === null`).assign(coerced, (0, codegen_1._)`[${data}]`);
        }
      }
    }
    function assignParentData({ gen, parentData, parentDataProperty }, expr) {
      gen.if((0, codegen_1._)`${parentData} !== undefined`, () => gen.assign((0, codegen_1._)`${parentData}[${parentDataProperty}]`, expr));
    }
    function checkDataType(dataType, data, strictNums, correct = DataType.Correct) {
      const EQ = correct === DataType.Correct ? codegen_1.operators.EQ : codegen_1.operators.NEQ;
      let cond;
      switch (dataType) {
        case "null":
          return (0, codegen_1._)`${data} ${EQ} null`;
        case "array":
          cond = (0, codegen_1._)`Array.isArray(${data})`;
          break;
        case "object":
          cond = (0, codegen_1._)`${data} && typeof ${data} == "object" && !Array.isArray(${data})`;
          break;
        case "integer":
          cond = numCond((0, codegen_1._)`!(${data} % 1) && !isNaN(${data})`);
          break;
        case "number":
          cond = numCond();
          break;
        default:
          return (0, codegen_1._)`typeof ${data} ${EQ} ${dataType}`;
      }
      return correct === DataType.Correct ? cond : (0, codegen_1.not)(cond);
      function numCond(_cond = codegen_1.nil) {
        return (0, codegen_1.and)((0, codegen_1._)`typeof ${data} == "number"`, _cond, strictNums ? (0, codegen_1._)`isFinite(${data})` : codegen_1.nil);
      }
    }
    exports2.checkDataType = checkDataType;
    function checkDataTypes(dataTypes, data, strictNums, correct) {
      if (dataTypes.length === 1) {
        return checkDataType(dataTypes[0], data, strictNums, correct);
      }
      let cond;
      const types2 = (0, util_1.toHash)(dataTypes);
      if (types2.array && types2.object) {
        const notObj = (0, codegen_1._)`typeof ${data} != "object"`;
        cond = types2.null ? notObj : (0, codegen_1._)`!${data} || ${notObj}`;
        delete types2.null;
        delete types2.array;
        delete types2.object;
      } else {
        cond = codegen_1.nil;
      }
      if (types2.number)
        delete types2.integer;
      for (const t3 in types2)
        cond = (0, codegen_1.and)(cond, checkDataType(t3, data, strictNums, correct));
      return cond;
    }
    exports2.checkDataTypes = checkDataTypes;
    var typeError = {
      message: ({ schema }) => `must be ${schema}`,
      params: ({ schema, schemaValue }) => typeof schema == "string" ? (0, codegen_1._)`{type: ${schema}}` : (0, codegen_1._)`{type: ${schemaValue}}`
    };
    function reportTypeError(it2) {
      const cxt = getTypeErrorContext(it2);
      (0, errors_1.reportError)(cxt, typeError);
    }
    exports2.reportTypeError = reportTypeError;
    function getTypeErrorContext(it2) {
      const { gen, data, schema } = it2;
      const schemaCode = (0, util_1.schemaRefOrVal)(it2, schema, "type");
      return {
        gen,
        keyword: "type",
        data,
        schema: schema.type,
        schemaCode,
        schemaValue: schemaCode,
        parentSchema: schema,
        params: {},
        it: it2
      };
    }
  }
});

// node_modules/vanilla-jsoneditor/node_modules/ajv/dist/compile/validate/defaults.js
var require_defaults = __commonJS({
  "node_modules/vanilla-jsoneditor/node_modules/ajv/dist/compile/validate/defaults.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.assignDefaults = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    function assignDefaults(it2, ty) {
      const { properties, items } = it2.schema;
      if (ty === "object" && properties) {
        for (const key in properties) {
          assignDefault(it2, key, properties[key].default);
        }
      } else if (ty === "array" && Array.isArray(items)) {
        items.forEach((sch, i2) => assignDefault(it2, i2, sch.default));
      }
    }
    exports2.assignDefaults = assignDefaults;
    function assignDefault(it2, prop, defaultValue) {
      const { gen, compositeRule, data, opts } = it2;
      if (defaultValue === void 0)
        return;
      const childData = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(prop)}`;
      if (compositeRule) {
        (0, util_1.checkStrictMode)(it2, `default is ignored for: ${childData}`);
        return;
      }
      let condition = (0, codegen_1._)`${childData} === undefined`;
      if (opts.useDefaults === "empty") {
        condition = (0, codegen_1._)`${condition} || ${childData} === null || ${childData} === ""`;
      }
      gen.if(condition, (0, codegen_1._)`${childData} = ${(0, codegen_1.stringify)(defaultValue)}`);
    }
  }
});

// node_modules/vanilla-jsoneditor/node_modules/ajv/dist/vocabularies/code.js
var require_code2 = __commonJS({
  "node_modules/vanilla-jsoneditor/node_modules/ajv/dist/vocabularies/code.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateUnion = exports2.validateArray = exports2.usePattern = exports2.callValidateCode = exports2.schemaProperties = exports2.allSchemaProperties = exports2.noPropertyInData = exports2.propertyInData = exports2.isOwnProperty = exports2.hasPropFunc = exports2.reportMissingProp = exports2.checkMissingProp = exports2.checkReportMissingProp = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var names_1 = require_names();
    var util_2 = require_util();
    function checkReportMissingProp(cxt, prop) {
      const { gen, data, it: it2 } = cxt;
      gen.if(noPropertyInData(gen, data, prop, it2.opts.ownProperties), () => {
        cxt.setParams({ missingProperty: (0, codegen_1._)`${prop}` }, true);
        cxt.error();
      });
    }
    exports2.checkReportMissingProp = checkReportMissingProp;
    function checkMissingProp({ gen, data, it: { opts } }, properties, missing) {
      return (0, codegen_1.or)(...properties.map((prop) => (0, codegen_1.and)(noPropertyInData(gen, data, prop, opts.ownProperties), (0, codegen_1._)`${missing} = ${prop}`)));
    }
    exports2.checkMissingProp = checkMissingProp;
    function reportMissingProp(cxt, missing) {
      cxt.setParams({ missingProperty: missing }, true);
      cxt.error();
    }
    exports2.reportMissingProp = reportMissingProp;
    function hasPropFunc(gen) {
      return gen.scopeValue("func", {
        // eslint-disable-next-line @typescript-eslint/unbound-method
        ref: Object.prototype.hasOwnProperty,
        code: (0, codegen_1._)`Object.prototype.hasOwnProperty`
      });
    }
    exports2.hasPropFunc = hasPropFunc;
    function isOwnProperty(gen, data, property) {
      return (0, codegen_1._)`${hasPropFunc(gen)}.call(${data}, ${property})`;
    }
    exports2.isOwnProperty = isOwnProperty;
    function propertyInData(gen, data, property, ownProperties) {
      const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} !== undefined`;
      return ownProperties ? (0, codegen_1._)`${cond} && ${isOwnProperty(gen, data, property)}` : cond;
    }
    exports2.propertyInData = propertyInData;
    function noPropertyInData(gen, data, property, ownProperties) {
      const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} === undefined`;
      return ownProperties ? (0, codegen_1.or)(cond, (0, codegen_1.not)(isOwnProperty(gen, data, property))) : cond;
    }
    exports2.noPropertyInData = noPropertyInData;
    function allSchemaProperties(schemaMap) {
      return schemaMap ? Object.keys(schemaMap).filter((p) => p !== "__proto__") : [];
    }
    exports2.allSchemaProperties = allSchemaProperties;
    function schemaProperties(it2, schemaMap) {
      return allSchemaProperties(schemaMap).filter((p) => !(0, util_1.alwaysValidSchema)(it2, schemaMap[p]));
    }
    exports2.schemaProperties = schemaProperties;
    function callValidateCode({ schemaCode, data, it: { gen, topSchemaRef, schemaPath, errorPath }, it: it2 }, func, context, passSchema) {
      const dataAndSchema = passSchema ? (0, codegen_1._)`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;
      const valCxt = [
        [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, errorPath)],
        [names_1.default.parentData, it2.parentData],
        [names_1.default.parentDataProperty, it2.parentDataProperty],
        [names_1.default.rootData, names_1.default.rootData]
      ];
      if (it2.opts.dynamicRef)
        valCxt.push([names_1.default.dynamicAnchors, names_1.default.dynamicAnchors]);
      const args = (0, codegen_1._)`${dataAndSchema}, ${gen.object(...valCxt)}`;
      return context !== codegen_1.nil ? (0, codegen_1._)`${func}.call(${context}, ${args})` : (0, codegen_1._)`${func}(${args})`;
    }
    exports2.callValidateCode = callValidateCode;
    var newRegExp = (0, codegen_1._)`new RegExp`;
    function usePattern({ gen, it: { opts } }, pattern) {
      const u = opts.unicodeRegExp ? "u" : "";
      const { regExp } = opts.code;
      const rx2 = regExp(pattern, u);
      return gen.scopeValue("pattern", {
        key: rx2.toString(),
        ref: rx2,
        code: (0, codegen_1._)`${regExp.code === "new RegExp" ? newRegExp : (0, util_2.useFunc)(gen, regExp)}(${pattern}, ${u})`
      });
    }
    exports2.usePattern = usePattern;
    function validateArray(cxt) {
      const { gen, data, keyword: keyword2, it: it2 } = cxt;
      const valid = gen.name("valid");
      if (it2.allErrors) {
        const validArr = gen.let("valid", true);
        validateItems(() => gen.assign(validArr, false));
        return validArr;
      }
      gen.var(valid, true);
      validateItems(() => gen.break());
      return valid;
      function validateItems(notValid) {
        const len = gen.const("len", (0, codegen_1._)`${data}.length`);
        gen.forRange("i", 0, len, (i2) => {
          cxt.subschema({
            keyword: keyword2,
            dataProp: i2,
            dataPropType: util_1.Type.Num
          }, valid);
          gen.if((0, codegen_1.not)(valid), notValid);
        });
      }
    }
    exports2.validateArray = validateArray;
    function validateUnion(cxt) {
      const { gen, schema, keyword: keyword2, it: it2 } = cxt;
      if (!Array.isArray(schema))
        throw new Error("ajv implementation error");
      const alwaysValid = schema.some((sch) => (0, util_1.alwaysValidSchema)(it2, sch));
      if (alwaysValid && !it2.opts.unevaluated)
        return;
      const valid = gen.let("valid", false);
      const schValid = gen.name("_valid");
      gen.block(() => schema.forEach((_sch, i2) => {
        const schCxt = cxt.subschema({
          keyword: keyword2,
          schemaProp: i2,
          compositeRule: true
        }, schValid);
        gen.assign(valid, (0, codegen_1._)`${valid} || ${schValid}`);
        const merged = cxt.mergeValidEvaluated(schCxt, schValid);
        if (!merged)
          gen.if((0, codegen_1.not)(valid));
      }));
      cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
    }
    exports2.validateUnion = validateUnion;
  }
});

// node_modules/vanilla-jsoneditor/node_modules/ajv/dist/compile/validate/keyword.js
var require_keyword = __commonJS({
  "node_modules/vanilla-jsoneditor/node_modules/ajv/dist/compile/validate/keyword.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateKeywordUsage = exports2.validSchemaType = exports2.funcKeywordCode = exports2.macroKeywordCode = void 0;
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var code_1 = require_code2();
    var errors_1 = require_errors();
    function macroKeywordCode(cxt, def) {
      const { gen, keyword: keyword2, schema, parentSchema, it: it2 } = cxt;
      const macroSchema = def.macro.call(it2.self, schema, parentSchema, it2);
      const schemaRef = useKeyword(gen, keyword2, macroSchema);
      if (it2.opts.validateSchema !== false)
        it2.self.validateSchema(macroSchema, true);
      const valid = gen.name("valid");
      cxt.subschema({
        schema: macroSchema,
        schemaPath: codegen_1.nil,
        errSchemaPath: `${it2.errSchemaPath}/${keyword2}`,
        topSchemaRef: schemaRef,
        compositeRule: true
      }, valid);
      cxt.pass(valid, () => cxt.error(true));
    }
    exports2.macroKeywordCode = macroKeywordCode;
    function funcKeywordCode(cxt, def) {
      var _a4;
      const { gen, keyword: keyword2, schema, parentSchema, $data, it: it2 } = cxt;
      checkAsyncKeyword(it2, def);
      const validate = !$data && def.compile ? def.compile.call(it2.self, schema, parentSchema, it2) : def.validate;
      const validateRef = useKeyword(gen, keyword2, validate);
      const valid = gen.let("valid");
      cxt.block$data(valid, validateKeyword);
      cxt.ok((_a4 = def.valid) !== null && _a4 !== void 0 ? _a4 : valid);
      function validateKeyword() {
        if (def.errors === false) {
          assignValid();
          if (def.modifying)
            modifyData(cxt);
          reportErrs(() => cxt.error());
        } else {
          const ruleErrs = def.async ? validateAsync() : validateSync();
          if (def.modifying)
            modifyData(cxt);
          reportErrs(() => addErrs(cxt, ruleErrs));
        }
      }
      function validateAsync() {
        const ruleErrs = gen.let("ruleErrs", null);
        gen.try(() => assignValid((0, codegen_1._)`await `), (e2) => gen.assign(valid, false).if((0, codegen_1._)`${e2} instanceof ${it2.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1._)`${e2}.errors`), () => gen.throw(e2)));
        return ruleErrs;
      }
      function validateSync() {
        const validateErrs = (0, codegen_1._)`${validateRef}.errors`;
        gen.assign(validateErrs, null);
        assignValid(codegen_1.nil);
        return validateErrs;
      }
      function assignValid(_await = def.async ? (0, codegen_1._)`await ` : codegen_1.nil) {
        const passCxt = it2.opts.passContext ? names_1.default.this : names_1.default.self;
        const passSchema = !("compile" in def && !$data || def.schema === false);
        gen.assign(valid, (0, codegen_1._)`${_await}${(0, code_1.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def.modifying);
      }
      function reportErrs(errors) {
        var _a5;
        gen.if((0, codegen_1.not)((_a5 = def.valid) !== null && _a5 !== void 0 ? _a5 : valid), errors);
      }
    }
    exports2.funcKeywordCode = funcKeywordCode;
    function modifyData(cxt) {
      const { gen, data, it: it2 } = cxt;
      gen.if(it2.parentData, () => gen.assign(data, (0, codegen_1._)`${it2.parentData}[${it2.parentDataProperty}]`));
    }
    function addErrs(cxt, errs) {
      const { gen } = cxt;
      gen.if((0, codegen_1._)`Array.isArray(${errs})`, () => {
        gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`).assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
        (0, errors_1.extendErrors)(cxt);
      }, () => cxt.error());
    }
    function checkAsyncKeyword({ schemaEnv }, def) {
      if (def.async && !schemaEnv.$async)
        throw new Error("async keyword in sync schema");
    }
    function useKeyword(gen, keyword2, result) {
      if (result === void 0)
        throw new Error(`keyword "${keyword2}" failed to compile`);
      return gen.scopeValue("keyword", typeof result == "function" ? { ref: result } : { ref: result, code: (0, codegen_1.stringify)(result) });
    }
    function validSchemaType(schema, schemaType, allowUndefined = false) {
      return !schemaType.length || schemaType.some((st2) => st2 === "array" ? Array.isArray(schema) : st2 === "object" ? schema && typeof schema == "object" && !Array.isArray(schema) : typeof schema == st2 || allowUndefined && typeof schema == "undefined");
    }
    exports2.validSchemaType = validSchemaType;
    function validateKeywordUsage({ schema, opts, self: self2, errSchemaPath }, def, keyword2) {
      if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword2) : def.keyword !== keyword2) {
        throw new Error("ajv implementation error");
      }
      const deps = def.dependencies;
      if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {
        throw new Error(`parent schema must have dependencies of ${keyword2}: ${deps.join(",")}`);
      }
      if (def.validateSchema) {
        const valid = def.validateSchema(schema[keyword2]);
        if (!valid) {
          const msg = `keyword "${keyword2}" value is invalid at path "${errSchemaPath}": ` + self2.errorsText(def.validateSchema.errors);
          if (opts.validateSchema === "log")
            self2.logger.error(msg);
          else
            throw new Error(msg);
        }
      }
    }
    exports2.validateKeywordUsage = validateKeywordUsage;
  }
});

// node_modules/vanilla-jsoneditor/node_modules/ajv/dist/compile/validate/subschema.js
var require_subschema = __commonJS({
  "node_modules/vanilla-jsoneditor/node_modules/ajv/dist/compile/validate/subschema.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.extendSubschemaMode = exports2.extendSubschemaData = exports2.getSubschema = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    function getSubschema(it2, { keyword: keyword2, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef }) {
      if (keyword2 !== void 0 && schema !== void 0) {
        throw new Error('both "keyword" and "schema" passed, only one allowed');
      }
      if (keyword2 !== void 0) {
        const sch = it2.schema[keyword2];
        return schemaProp === void 0 ? {
          schema: sch,
          schemaPath: (0, codegen_1._)`${it2.schemaPath}${(0, codegen_1.getProperty)(keyword2)}`,
          errSchemaPath: `${it2.errSchemaPath}/${keyword2}`
        } : {
          schema: sch[schemaProp],
          schemaPath: (0, codegen_1._)`${it2.schemaPath}${(0, codegen_1.getProperty)(keyword2)}${(0, codegen_1.getProperty)(schemaProp)}`,
          errSchemaPath: `${it2.errSchemaPath}/${keyword2}/${(0, util_1.escapeFragment)(schemaProp)}`
        };
      }
      if (schema !== void 0) {
        if (schemaPath === void 0 || errSchemaPath === void 0 || topSchemaRef === void 0) {
          throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
        }
        return {
          schema,
          schemaPath,
          topSchemaRef,
          errSchemaPath
        };
      }
      throw new Error('either "keyword" or "schema" must be passed');
    }
    exports2.getSubschema = getSubschema;
    function extendSubschemaData(subschema, it2, { dataProp, dataPropType: dpType, data, dataTypes, propertyName: propertyName2 }) {
      if (data !== void 0 && dataProp !== void 0) {
        throw new Error('both "data" and "dataProp" passed, only one allowed');
      }
      const { gen } = it2;
      if (dataProp !== void 0) {
        const { errorPath, dataPathArr, opts } = it2;
        const nextData = gen.let("data", (0, codegen_1._)`${it2.data}${(0, codegen_1.getProperty)(dataProp)}`, true);
        dataContextProps(nextData);
        subschema.errorPath = (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`;
        subschema.parentDataProperty = (0, codegen_1._)`${dataProp}`;
        subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty];
      }
      if (data !== void 0) {
        const nextData = data instanceof codegen_1.Name ? data : gen.let("data", data, true);
        dataContextProps(nextData);
        if (propertyName2 !== void 0)
          subschema.propertyName = propertyName2;
      }
      if (dataTypes)
        subschema.dataTypes = dataTypes;
      function dataContextProps(_nextData) {
        subschema.data = _nextData;
        subschema.dataLevel = it2.dataLevel + 1;
        subschema.dataTypes = [];
        it2.definedProperties = /* @__PURE__ */ new Set();
        subschema.parentData = it2.data;
        subschema.dataNames = [...it2.dataNames, _nextData];
      }
    }
    exports2.extendSubschemaData = extendSubschemaData;
    function extendSubschemaMode(subschema, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {
      if (compositeRule !== void 0)
        subschema.compositeRule = compositeRule;
      if (createErrors !== void 0)
        subschema.createErrors = createErrors;
      if (allErrors !== void 0)
        subschema.allErrors = allErrors;
      subschema.jtdDiscriminator = jtdDiscriminator;
      subschema.jtdMetadata = jtdMetadata;
    }
    exports2.extendSubschemaMode = extendSubschemaMode;
  }
});

// node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = __commonJS({
  "node_modules/fast-deep-equal/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function equal(a2, b2) {
      if (a2 === b2) return true;
      if (a2 && b2 && typeof a2 == "object" && typeof b2 == "object") {
        if (a2.constructor !== b2.constructor) return false;
        var length, i2, keys2;
        if (Array.isArray(a2)) {
          length = a2.length;
          if (length != b2.length) return false;
          for (i2 = length; i2-- !== 0; )
            if (!equal(a2[i2], b2[i2])) return false;
          return true;
        }
        if (a2.constructor === RegExp) return a2.source === b2.source && a2.flags === b2.flags;
        if (a2.valueOf !== Object.prototype.valueOf) return a2.valueOf() === b2.valueOf();
        if (a2.toString !== Object.prototype.toString) return a2.toString() === b2.toString();
        keys2 = Object.keys(a2);
        length = keys2.length;
        if (length !== Object.keys(b2).length) return false;
        for (i2 = length; i2-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b2, keys2[i2])) return false;
        for (i2 = length; i2-- !== 0; ) {
          var key = keys2[i2];
          if (!equal(a2[key], b2[key])) return false;
        }
        return true;
      }
      return a2 !== a2 && b2 !== b2;
    };
  }
});

// node_modules/vanilla-jsoneditor/node_modules/json-schema-traverse/index.js
var require_json_schema_traverse = __commonJS({
  "node_modules/vanilla-jsoneditor/node_modules/json-schema-traverse/index.js"(exports2, module2) {
    "use strict";
    var traverse = module2.exports = function(schema, opts, cb) {
      if (typeof opts == "function") {
        cb = opts;
        opts = {};
      }
      cb = opts.cb || cb;
      var pre = typeof cb == "function" ? cb : cb.pre || function() {
      };
      var post = cb.post || function() {
      };
      _traverse(opts, pre, post, schema, "", schema);
    };
    traverse.keywords = {
      additionalItems: true,
      items: true,
      contains: true,
      additionalProperties: true,
      propertyNames: true,
      not: true,
      if: true,
      then: true,
      else: true
    };
    traverse.arrayKeywords = {
      items: true,
      allOf: true,
      anyOf: true,
      oneOf: true
    };
    traverse.propsKeywords = {
      $defs: true,
      definitions: true,
      properties: true,
      patternProperties: true,
      dependencies: true
    };
    traverse.skipKeywords = {
      default: true,
      enum: true,
      const: true,
      required: true,
      maximum: true,
      minimum: true,
      exclusiveMaximum: true,
      exclusiveMinimum: true,
      multipleOf: true,
      maxLength: true,
      minLength: true,
      pattern: true,
      format: true,
      maxItems: true,
      minItems: true,
      uniqueItems: true,
      maxProperties: true,
      minProperties: true
    };
    function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
      if (schema && typeof schema == "object" && !Array.isArray(schema)) {
        pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
        for (var key in schema) {
          var sch = schema[key];
          if (Array.isArray(sch)) {
            if (key in traverse.arrayKeywords) {
              for (var i2 = 0; i2 < sch.length; i2++)
                _traverse(opts, pre, post, sch[i2], jsonPtr + "/" + key + "/" + i2, rootSchema, jsonPtr, key, schema, i2);
            }
          } else if (key in traverse.propsKeywords) {
            if (sch && typeof sch == "object") {
              for (var prop in sch)
                _traverse(opts, pre, post, sch[prop], jsonPtr + "/" + key + "/" + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
            }
          } else if (key in traverse.keywords || opts.allKeys && !(key in traverse.skipKeywords)) {
            _traverse(opts, pre, post, sch, jsonPtr + "/" + key, rootSchema, jsonPtr, key, schema);
          }
        }
        post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
      }
    }
    function escapeJsonPtr(str) {
      return str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
  }
});

// node_modules/vanilla-jsoneditor/node_modules/ajv/dist/compile/resolve.js
var require_resolve = __commonJS({
  "node_modules/vanilla-jsoneditor/node_modules/ajv/dist/compile/resolve.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getSchemaRefs = exports2.resolveUrl = exports2.normalizeId = exports2._getFullPath = exports2.getFullPath = exports2.inlineRef = void 0;
    var util_1 = require_util();
    var equal = require_fast_deep_equal();
    var traverse = require_json_schema_traverse();
    var SIMPLE_INLINED = /* @__PURE__ */ new Set([
      "type",
      "format",
      "pattern",
      "maxLength",
      "minLength",
      "maxProperties",
      "minProperties",
      "maxItems",
      "minItems",
      "maximum",
      "minimum",
      "uniqueItems",
      "multipleOf",
      "required",
      "enum",
      "const"
    ]);
    function inlineRef(schema, limit = true) {
      if (typeof schema == "boolean")
        return true;
      if (limit === true)
        return !hasRef(schema);
      if (!limit)
        return false;
      return countKeys(schema) <= limit;
    }
    exports2.inlineRef = inlineRef;
    var REF_KEYWORDS = /* @__PURE__ */ new Set([
      "$ref",
      "$recursiveRef",
      "$recursiveAnchor",
      "$dynamicRef",
      "$dynamicAnchor"
    ]);
    function hasRef(schema) {
      for (const key in schema) {
        if (REF_KEYWORDS.has(key))
          return true;
        const sch = schema[key];
        if (Array.isArray(sch) && sch.some(hasRef))
          return true;
        if (typeof sch == "object" && hasRef(sch))
          return true;
      }
      return false;
    }
    function countKeys(schema) {
      let count = 0;
      for (const key in schema) {
        if (key === "$ref")
          return Infinity;
        count++;
        if (SIMPLE_INLINED.has(key))
          continue;
        if (typeof schema[key] == "object") {
          (0, util_1.eachItem)(schema[key], (sch) => count += countKeys(sch));
        }
        if (count === Infinity)
          return Infinity;
      }
      return count;
    }
    function getFullPath(resolver, id2 = "", normalize) {
      if (normalize !== false)
        id2 = normalizeId(id2);
      const p = resolver.parse(id2);
      return _getFullPath(resolver, p);
    }
    exports2.getFullPath = getFullPath;
    function _getFullPath(resolver, p) {
      const serialized = resolver.serialize(p);
      return serialized.split("#")[0] + "#";
    }
    exports2._getFullPath = _getFullPath;
    var TRAILING_SLASH_HASH = /#\/?$/;
    function normalizeId(id2) {
      return id2 ? id2.replace(TRAILING_SLASH_HASH, "") : "";
    }
    exports2.normalizeId = normalizeId;
    function resolveUrl(resolver, baseId, id2) {
      id2 = normalizeId(id2);
      return resolver.resolve(baseId, id2);
    }
    exports2.resolveUrl = resolveUrl;
    var ANCHOR = /^[a-z_][-a-z0-9._]*$/i;
    function getSchemaRefs(schema, baseId) {
      if (typeof schema == "boolean")
        return {};
      const { schemaId, uriResolver } = this.opts;
      const schId = normalizeId(schema[schemaId] || baseId);
      const baseIds = { "": schId };
      const pathPrefix = getFullPath(uriResolver, schId, false);
      const localRefs = {};
      const schemaRefs = /* @__PURE__ */ new Set();
      traverse(schema, { allKeys: true }, (sch, jsonPtr, _2, parentJsonPtr) => {
        if (parentJsonPtr === void 0)
          return;
        const fullPath = pathPrefix + jsonPtr;
        let innerBaseId = baseIds[parentJsonPtr];
        if (typeof sch[schemaId] == "string")
          innerBaseId = addRef.call(this, sch[schemaId]);
        addAnchor.call(this, sch.$anchor);
        addAnchor.call(this, sch.$dynamicAnchor);
        baseIds[jsonPtr] = innerBaseId;
        function addRef(ref2) {
          const _resolve = this.opts.uriResolver.resolve;
          ref2 = normalizeId(innerBaseId ? _resolve(innerBaseId, ref2) : ref2);
          if (schemaRefs.has(ref2))
            throw ambiguos(ref2);
          schemaRefs.add(ref2);
          let schOrRef = this.refs[ref2];
          if (typeof schOrRef == "string")
            schOrRef = this.refs[schOrRef];
          if (typeof schOrRef == "object") {
            checkAmbiguosRef(sch, schOrRef.schema, ref2);
          } else if (ref2 !== normalizeId(fullPath)) {
            if (ref2[0] === "#") {
              checkAmbiguosRef(sch, localRefs[ref2], ref2);
              localRefs[ref2] = sch;
            } else {
              this.refs[ref2] = fullPath;
            }
          }
          return ref2;
        }
        function addAnchor(anchor) {
          if (typeof anchor == "string") {
            if (!ANCHOR.test(anchor))
              throw new Error(`invalid anchor "${anchor}"`);
            addRef.call(this, `#${anchor}`);
          }
        }
      });
      return localRefs;
      function checkAmbiguosRef(sch1, sch2, ref2) {
        if (sch2 !== void 0 && !equal(sch1, sch2))
          throw ambiguos(ref2);
      }
      function ambiguos(ref2) {
        return new Error(`reference "${ref2}" resolves to more than one schema`);
      }
    }
    exports2.getSchemaRefs = getSchemaRefs;
  }
});

// node_modules/vanilla-jsoneditor/node_modules/ajv/dist/compile/validate/index.js
var require_validate = __commonJS({
  "node_modules/vanilla-jsoneditor/node_modules/ajv/dist/compile/validate/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getData = exports2.KeywordCxt = exports2.validateFunctionCode = void 0;
    var boolSchema_1 = require_boolSchema();
    var dataType_1 = require_dataType();
    var applicability_1 = require_applicability();
    var dataType_2 = require_dataType();
    var defaults_1 = require_defaults();
    var keyword_1 = require_keyword();
    var subschema_1 = require_subschema();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var resolve_1 = require_resolve();
    var util_1 = require_util();
    var errors_1 = require_errors();
    function validateFunctionCode(it2) {
      if (isSchemaObj(it2)) {
        checkKeywords(it2);
        if (schemaCxtHasRules(it2)) {
          topSchemaObjCode(it2);
          return;
        }
      }
      validateFunction(it2, () => (0, boolSchema_1.topBoolOrEmptySchema)(it2));
    }
    exports2.validateFunctionCode = validateFunctionCode;
    function validateFunction({ gen, validateName, schema, schemaEnv, opts }, body) {
      if (opts.code.es5) {
        gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${names_1.default.valCxt}`, schemaEnv.$async, () => {
          gen.code((0, codegen_1._)`"use strict"; ${funcSourceUrl(schema, opts)}`);
          destructureValCxtES5(gen, opts);
          gen.code(body);
        });
      } else {
        gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema, opts)).code(body));
      }
    }
    function destructureValCxt(opts) {
      return (0, codegen_1._)`{${names_1.default.instancePath}="", ${names_1.default.parentData}, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${names_1.default.data}${opts.dynamicRef ? (0, codegen_1._)`, ${names_1.default.dynamicAnchors}={}` : codegen_1.nil}}={}`;
    }
    function destructureValCxtES5(gen, opts) {
      gen.if(names_1.default.valCxt, () => {
        gen.var(names_1.default.instancePath, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.instancePath}`);
        gen.var(names_1.default.parentData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentData}`);
        gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentDataProperty}`);
        gen.var(names_1.default.rootData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.rootData}`);
        if (opts.dynamicRef)
          gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`);
      }, () => {
        gen.var(names_1.default.instancePath, (0, codegen_1._)`""`);
        gen.var(names_1.default.parentData, (0, codegen_1._)`undefined`);
        gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`undefined`);
        gen.var(names_1.default.rootData, names_1.default.data);
        if (opts.dynamicRef)
          gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`{}`);
      });
    }
    function topSchemaObjCode(it2) {
      const { schema, opts, gen } = it2;
      validateFunction(it2, () => {
        if (opts.$comment && schema.$comment)
          commentKeyword(it2);
        checkNoDefault(it2);
        gen.let(names_1.default.vErrors, null);
        gen.let(names_1.default.errors, 0);
        if (opts.unevaluated)
          resetEvaluated(it2);
        typeAndKeywords(it2);
        returnResults(it2);
      });
      return;
    }
    function resetEvaluated(it2) {
      const { gen, validateName } = it2;
      it2.evaluated = gen.const("evaluated", (0, codegen_1._)`${validateName}.evaluated`);
      gen.if((0, codegen_1._)`${it2.evaluated}.dynamicProps`, () => gen.assign((0, codegen_1._)`${it2.evaluated}.props`, (0, codegen_1._)`undefined`));
      gen.if((0, codegen_1._)`${it2.evaluated}.dynamicItems`, () => gen.assign((0, codegen_1._)`${it2.evaluated}.items`, (0, codegen_1._)`undefined`));
    }
    function funcSourceUrl(schema, opts) {
      const schId = typeof schema == "object" && schema[opts.schemaId];
      return schId && (opts.code.source || opts.code.process) ? (0, codegen_1._)`/*# sourceURL=${schId} */` : codegen_1.nil;
    }
    function subschemaCode(it2, valid) {
      if (isSchemaObj(it2)) {
        checkKeywords(it2);
        if (schemaCxtHasRules(it2)) {
          subSchemaObjCode(it2, valid);
          return;
        }
      }
      (0, boolSchema_1.boolOrEmptySchema)(it2, valid);
    }
    function schemaCxtHasRules({ schema, self: self2 }) {
      if (typeof schema == "boolean")
        return !schema;
      for (const key in schema)
        if (self2.RULES.all[key])
          return true;
      return false;
    }
    function isSchemaObj(it2) {
      return typeof it2.schema != "boolean";
    }
    function subSchemaObjCode(it2, valid) {
      const { schema, gen, opts } = it2;
      if (opts.$comment && schema.$comment)
        commentKeyword(it2);
      updateContext(it2);
      checkAsyncSchema(it2);
      const errsCount = gen.const("_errs", names_1.default.errors);
      typeAndKeywords(it2, errsCount);
      gen.var(valid, (0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
    }
    function checkKeywords(it2) {
      (0, util_1.checkUnknownRules)(it2);
      checkRefsAndKeywords(it2);
    }
    function typeAndKeywords(it2, errsCount) {
      if (it2.opts.jtd)
        return schemaKeywords(it2, [], false, errsCount);
      const types2 = (0, dataType_1.getSchemaTypes)(it2.schema);
      const checkedTypes = (0, dataType_1.coerceAndCheckDataType)(it2, types2);
      schemaKeywords(it2, types2, !checkedTypes, errsCount);
    }
    function checkRefsAndKeywords(it2) {
      const { schema, errSchemaPath, opts, self: self2 } = it2;
      if (schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1.schemaHasRulesButRef)(schema, self2.RULES)) {
        self2.logger.warn(`$ref: keywords ignored in schema at path "${errSchemaPath}"`);
      }
    }
    function checkNoDefault(it2) {
      const { schema, opts } = it2;
      if (schema.default !== void 0 && opts.useDefaults && opts.strictSchema) {
        (0, util_1.checkStrictMode)(it2, "default is ignored in the schema root");
      }
    }
    function updateContext(it2) {
      const schId = it2.schema[it2.opts.schemaId];
      if (schId)
        it2.baseId = (0, resolve_1.resolveUrl)(it2.opts.uriResolver, it2.baseId, schId);
    }
    function checkAsyncSchema(it2) {
      if (it2.schema.$async && !it2.schemaEnv.$async)
        throw new Error("async schema in sync schema");
    }
    function commentKeyword({ gen, schemaEnv, schema, errSchemaPath, opts }) {
      const msg = schema.$comment;
      if (opts.$comment === true) {
        gen.code((0, codegen_1._)`${names_1.default.self}.logger.log(${msg})`);
      } else if (typeof opts.$comment == "function") {
        const schemaPath = (0, codegen_1.str)`${errSchemaPath}/$comment`;
        const rootName = gen.scopeValue("root", { ref: schemaEnv.root });
        gen.code((0, codegen_1._)`${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);
      }
    }
    function returnResults(it2) {
      const { gen, schemaEnv, validateName, ValidationError, opts } = it2;
      if (schemaEnv.$async) {
        gen.if((0, codegen_1._)`${names_1.default.errors} === 0`, () => gen.return(names_1.default.data), () => gen.throw((0, codegen_1._)`new ${ValidationError}(${names_1.default.vErrors})`));
      } else {
        gen.assign((0, codegen_1._)`${validateName}.errors`, names_1.default.vErrors);
        if (opts.unevaluated)
          assignEvaluated(it2);
        gen.return((0, codegen_1._)`${names_1.default.errors} === 0`);
      }
    }
    function assignEvaluated({ gen, evaluated, props, items }) {
      if (props instanceof codegen_1.Name)
        gen.assign((0, codegen_1._)`${evaluated}.props`, props);
      if (items instanceof codegen_1.Name)
        gen.assign((0, codegen_1._)`${evaluated}.items`, items);
    }
    function schemaKeywords(it2, types2, typeErrors, errsCount) {
      const { gen, schema, data, allErrors, opts, self: self2 } = it2;
      const { RULES } = self2;
      if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1.schemaHasRulesButRef)(schema, RULES))) {
        gen.block(() => keywordCode(it2, "$ref", RULES.all.$ref.definition));
        return;
      }
      if (!opts.jtd)
        checkStrictTypes(it2, types2);
      gen.block(() => {
        for (const group of RULES.rules)
          groupKeywords(group);
        groupKeywords(RULES.post);
      });
      function groupKeywords(group) {
        if (!(0, applicability_1.shouldUseGroup)(schema, group))
          return;
        if (group.type) {
          gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers));
          iterateKeywords(it2, group);
          if (types2.length === 1 && types2[0] === group.type && typeErrors) {
            gen.else();
            (0, dataType_2.reportTypeError)(it2);
          }
          gen.endIf();
        } else {
          iterateKeywords(it2, group);
        }
        if (!allErrors)
          gen.if((0, codegen_1._)`${names_1.default.errors} === ${errsCount || 0}`);
      }
    }
    function iterateKeywords(it2, group) {
      const { gen, schema, opts: { useDefaults } } = it2;
      if (useDefaults)
        (0, defaults_1.assignDefaults)(it2, group.type);
      gen.block(() => {
        for (const rule of group.rules) {
          if ((0, applicability_1.shouldUseRule)(schema, rule)) {
            keywordCode(it2, rule.keyword, rule.definition, group.type);
          }
        }
      });
    }
    function checkStrictTypes(it2, types2) {
      if (it2.schemaEnv.meta || !it2.opts.strictTypes)
        return;
      checkContextTypes(it2, types2);
      if (!it2.opts.allowUnionTypes)
        checkMultipleTypes(it2, types2);
      checkKeywordTypes(it2, it2.dataTypes);
    }
    function checkContextTypes(it2, types2) {
      if (!types2.length)
        return;
      if (!it2.dataTypes.length) {
        it2.dataTypes = types2;
        return;
      }
      types2.forEach((t3) => {
        if (!includesType(it2.dataTypes, t3)) {
          strictTypesError(it2, `type "${t3}" not allowed by context "${it2.dataTypes.join(",")}"`);
        }
      });
      narrowSchemaTypes(it2, types2);
    }
    function checkMultipleTypes(it2, ts2) {
      if (ts2.length > 1 && !(ts2.length === 2 && ts2.includes("null"))) {
        strictTypesError(it2, "use allowUnionTypes to allow union type keyword");
      }
    }
    function checkKeywordTypes(it2, ts2) {
      const rules = it2.self.RULES.all;
      for (const keyword2 in rules) {
        const rule = rules[keyword2];
        if (typeof rule == "object" && (0, applicability_1.shouldUseRule)(it2.schema, rule)) {
          const { type } = rule.definition;
          if (type.length && !type.some((t3) => hasApplicableType(ts2, t3))) {
            strictTypesError(it2, `missing type "${type.join(",")}" for keyword "${keyword2}"`);
          }
        }
      }
    }
    function hasApplicableType(schTs, kwdT) {
      return schTs.includes(kwdT) || kwdT === "number" && schTs.includes("integer");
    }
    function includesType(ts2, t3) {
      return ts2.includes(t3) || t3 === "integer" && ts2.includes("number");
    }
    function narrowSchemaTypes(it2, withTypes) {
      const ts2 = [];
      for (const t3 of it2.dataTypes) {
        if (includesType(withTypes, t3))
          ts2.push(t3);
        else if (withTypes.includes("integer") && t3 === "number")
          ts2.push("integer");
      }
      it2.dataTypes = ts2;
    }
    function strictTypesError(it2, msg) {
      const schemaPath = it2.schemaEnv.baseId + it2.errSchemaPath;
      msg += ` at "${schemaPath}" (strictTypes)`;
      (0, util_1.checkStrictMode)(it2, msg, it2.opts.strictTypes);
    }
    var KeywordCxt = class {
      constructor(it2, def, keyword2) {
        (0, keyword_1.validateKeywordUsage)(it2, def, keyword2);
        this.gen = it2.gen;
        this.allErrors = it2.allErrors;
        this.keyword = keyword2;
        this.data = it2.data;
        this.schema = it2.schema[keyword2];
        this.$data = def.$data && it2.opts.$data && this.schema && this.schema.$data;
        this.schemaValue = (0, util_1.schemaRefOrVal)(it2, this.schema, keyword2, this.$data);
        this.schemaType = def.schemaType;
        this.parentSchema = it2.schema;
        this.params = {};
        this.it = it2;
        this.def = def;
        if (this.$data) {
          this.schemaCode = it2.gen.const("vSchema", getData(this.$data, it2));
        } else {
          this.schemaCode = this.schemaValue;
          if (!(0, keyword_1.validSchemaType)(this.schema, def.schemaType, def.allowUndefined)) {
            throw new Error(`${keyword2} value must be ${JSON.stringify(def.schemaType)}`);
          }
        }
        if ("code" in def ? def.trackErrors : def.errors !== false) {
          this.errsCount = it2.gen.const("_errs", names_1.default.errors);
        }
      }
      result(condition, successAction, failAction) {
        this.failResult((0, codegen_1.not)(condition), successAction, failAction);
      }
      failResult(condition, successAction, failAction) {
        this.gen.if(condition);
        if (failAction)
          failAction();
        else
          this.error();
        if (successAction) {
          this.gen.else();
          successAction();
          if (this.allErrors)
            this.gen.endIf();
        } else {
          if (this.allErrors)
            this.gen.endIf();
          else
            this.gen.else();
        }
      }
      pass(condition, failAction) {
        this.failResult((0, codegen_1.not)(condition), void 0, failAction);
      }
      fail(condition) {
        if (condition === void 0) {
          this.error();
          if (!this.allErrors)
            this.gen.if(false);
          return;
        }
        this.gen.if(condition);
        this.error();
        if (this.allErrors)
          this.gen.endIf();
        else
          this.gen.else();
      }
      fail$data(condition) {
        if (!this.$data)
          return this.fail(condition);
        const { schemaCode } = this;
        this.fail((0, codegen_1._)`${schemaCode} !== undefined && (${(0, codegen_1.or)(this.invalid$data(), condition)})`);
      }
      error(append, errorParams, errorPaths) {
        if (errorParams) {
          this.setParams(errorParams);
          this._error(append, errorPaths);
          this.setParams({});
          return;
        }
        this._error(append, errorPaths);
      }
      _error(append, errorPaths) {
        ;
        (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);
      }
      $dataError() {
        (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);
      }
      reset() {
        if (this.errsCount === void 0)
          throw new Error('add "trackErrors" to keyword definition');
        (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);
      }
      ok(cond) {
        if (!this.allErrors)
          this.gen.if(cond);
      }
      setParams(obj, assign) {
        if (assign)
          Object.assign(this.params, obj);
        else
          this.params = obj;
      }
      block$data(valid, codeBlock, $dataValid = codegen_1.nil) {
        this.gen.block(() => {
          this.check$data(valid, $dataValid);
          codeBlock();
        });
      }
      check$data(valid = codegen_1.nil, $dataValid = codegen_1.nil) {
        if (!this.$data)
          return;
        const { gen, schemaCode, schemaType, def } = this;
        gen.if((0, codegen_1.or)((0, codegen_1._)`${schemaCode} === undefined`, $dataValid));
        if (valid !== codegen_1.nil)
          gen.assign(valid, true);
        if (schemaType.length || def.validateSchema) {
          gen.elseIf(this.invalid$data());
          this.$dataError();
          if (valid !== codegen_1.nil)
            gen.assign(valid, false);
        }
        gen.else();
      }
      invalid$data() {
        const { gen, schemaCode, schemaType, def, it: it2 } = this;
        return (0, codegen_1.or)(wrong$DataType(), invalid$DataSchema());
        function wrong$DataType() {
          if (schemaType.length) {
            if (!(schemaCode instanceof codegen_1.Name))
              throw new Error("ajv implementation error");
            const st2 = Array.isArray(schemaType) ? schemaType : [schemaType];
            return (0, codegen_1._)`${(0, dataType_2.checkDataTypes)(st2, schemaCode, it2.opts.strictNumbers, dataType_2.DataType.Wrong)}`;
          }
          return codegen_1.nil;
        }
        function invalid$DataSchema() {
          if (def.validateSchema) {
            const validateSchemaRef = gen.scopeValue("validate$data", { ref: def.validateSchema });
            return (0, codegen_1._)`!${validateSchemaRef}(${schemaCode})`;
          }
          return codegen_1.nil;
        }
      }
      subschema(appl, valid) {
        const subschema = (0, subschema_1.getSubschema)(this.it, appl);
        (0, subschema_1.extendSubschemaData)(subschema, this.it, appl);
        (0, subschema_1.extendSubschemaMode)(subschema, appl);
        const nextContext = { ...this.it, ...subschema, items: void 0, props: void 0 };
        subschemaCode(nextContext, valid);
        return nextContext;
      }
      mergeEvaluated(schemaCxt, toName) {
        const { it: it2, gen } = this;
        if (!it2.opts.unevaluated)
          return;
        if (it2.props !== true && schemaCxt.props !== void 0) {
          it2.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it2.props, toName);
        }
        if (it2.items !== true && schemaCxt.items !== void 0) {
          it2.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it2.items, toName);
        }
      }
      mergeValidEvaluated(schemaCxt, valid) {
        const { it: it2, gen } = this;
        if (it2.opts.unevaluated && (it2.props !== true || it2.items !== true)) {
          gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1.Name));
          return true;
        }
      }
    };
    exports2.KeywordCxt = KeywordCxt;
    function keywordCode(it2, keyword2, def, ruleType) {
      const cxt = new KeywordCxt(it2, def, keyword2);
      if ("code" in def) {
        def.code(cxt, ruleType);
      } else if (cxt.$data && def.validate) {
        (0, keyword_1.funcKeywordCode)(cxt, def);
      } else if ("macro" in def) {
        (0, keyword_1.macroKeywordCode)(cxt, def);
      } else if (def.compile || def.validate) {
        (0, keyword_1.funcKeywordCode)(cxt, def);
      }
    }
    var JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
    var RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
    function getData($data, { dataLevel, dataNames, dataPathArr }) {
      let jsonPointer;
      let data;
      if ($data === "")
        return names_1.default.rootData;
      if ($data[0] === "/") {
        if (!JSON_POINTER.test($data))
          throw new Error(`Invalid JSON-pointer: ${$data}`);
        jsonPointer = $data;
        data = names_1.default.rootData;
      } else {
        const matches = RELATIVE_JSON_POINTER.exec($data);
        if (!matches)
          throw new Error(`Invalid JSON-pointer: ${$data}`);
        const up2 = +matches[1];
        jsonPointer = matches[2];
        if (jsonPointer === "#") {
          if (up2 >= dataLevel)
            throw new Error(errorMsg("property/index", up2));
          return dataPathArr[dataLevel - up2];
        }
        if (up2 > dataLevel)
          throw new Error(errorMsg("data", up2));
        data = dataNames[dataLevel - up2];
        if (!jsonPointer)
          return data;
      }
      let expr = data;
      const segments = jsonPointer.split("/");
      for (const segment of segments) {
        if (segment) {
          data = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)((0, util_1.unescapeJsonPointer)(segment))}`;
          expr = (0, codegen_1._)`${expr} && ${data}`;
        }
      }
      return expr;
      function errorMsg(pointerType, up2) {
        return `Cannot access ${pointerType} ${up2} levels up, current level is ${dataLevel}`;
      }
    }
    exports2.getData = getData;
  }
});

// node_modules/vanilla-jsoneditor/node_modules/ajv/dist/runtime/validation_error.js
var require_validation_error = __commonJS({
  "node_modules/vanilla-jsoneditor/node_modules/ajv/dist/runtime/validation_error.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var ValidationError = class extends Error {
      constructor(errors) {
        super("validation failed");
        this.errors = errors;
        this.ajv = this.validation = true;
      }
    };
    exports2.default = ValidationError;
  }
});

// node_modules/vanilla-jsoneditor/node_modules/ajv/dist/compile/ref_error.js
var require_ref_error = __commonJS({
  "node_modules/vanilla-jsoneditor/node_modules/ajv/dist/compile/ref_error.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var resolve_1 = require_resolve();
    var MissingRefError = class extends Error {
      constructor(resolver, baseId, ref2, msg) {
        super(msg || `can't resolve reference ${ref2} from id ${baseId}`);
        this.missingRef = (0, resolve_1.resolveUrl)(resolver, baseId, ref2);
        this.missingSchema = (0, resolve_1.normalizeId)((0, resolve_1.getFullPath)(resolver, this.missingRef));
      }
    };
    exports2.default = MissingRefError;
  }
});

// node_modules/vanilla-jsoneditor/node_modules/ajv/dist/compile/index.js
var require_compile = __commonJS({
  "node_modules/vanilla-jsoneditor/node_modules/ajv/dist/compile/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.resolveSchema = exports2.getCompilingSchema = exports2.resolveRef = exports2.compileSchema = exports2.SchemaEnv = void 0;
    var codegen_1 = require_codegen();
    var validation_error_1 = require_validation_error();
    var names_1 = require_names();
    var resolve_1 = require_resolve();
    var util_1 = require_util();
    var validate_1 = require_validate();
    var SchemaEnv = class {
      constructor(env) {
        var _a4;
        this.refs = {};
        this.dynamicAnchors = {};
        let schema;
        if (typeof env.schema == "object")
          schema = env.schema;
        this.schema = env.schema;
        this.schemaId = env.schemaId;
        this.root = env.root || this;
        this.baseId = (_a4 = env.baseId) !== null && _a4 !== void 0 ? _a4 : (0, resolve_1.normalizeId)(schema === null || schema === void 0 ? void 0 : schema[env.schemaId || "$id"]);
        this.schemaPath = env.schemaPath;
        this.localRefs = env.localRefs;
        this.meta = env.meta;
        this.$async = schema === null || schema === void 0 ? void 0 : schema.$async;
        this.refs = {};
      }
    };
    exports2.SchemaEnv = SchemaEnv;
    function compileSchema(sch) {
      const _sch = getCompilingSchema.call(this, sch);
      if (_sch)
        return _sch;
      const rootId = (0, resolve_1.getFullPath)(this.opts.uriResolver, sch.root.baseId);
      const { es5, lines } = this.opts.code;
      const { ownProperties } = this.opts;
      const gen = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties });
      let _ValidationError;
      if (sch.$async) {
        _ValidationError = gen.scopeValue("Error", {
          ref: validation_error_1.default,
          code: (0, codegen_1._)`require("ajv/dist/runtime/validation_error").default`
        });
      }
      const validateName = gen.scopeName("validate");
      sch.validateName = validateName;
      const schemaCxt = {
        gen,
        allErrors: this.opts.allErrors,
        data: names_1.default.data,
        parentData: names_1.default.parentData,
        parentDataProperty: names_1.default.parentDataProperty,
        dataNames: [names_1.default.data],
        dataPathArr: [codegen_1.nil],
        // TODO can its length be used as dataLevel if nil is removed?
        dataLevel: 0,
        dataTypes: [],
        definedProperties: /* @__PURE__ */ new Set(),
        topSchemaRef: gen.scopeValue("schema", this.opts.code.source === true ? { ref: sch.schema, code: (0, codegen_1.stringify)(sch.schema) } : { ref: sch.schema }),
        validateName,
        ValidationError: _ValidationError,
        schema: sch.schema,
        schemaEnv: sch,
        rootId,
        baseId: sch.baseId || rootId,
        schemaPath: codegen_1.nil,
        errSchemaPath: sch.schemaPath || (this.opts.jtd ? "" : "#"),
        errorPath: (0, codegen_1._)`""`,
        opts: this.opts,
        self: this
      };
      let sourceCode;
      try {
        this._compilations.add(sch);
        (0, validate_1.validateFunctionCode)(schemaCxt);
        gen.optimize(this.opts.code.optimize);
        const validateCode = gen.toString();
        sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${validateCode}`;
        if (this.opts.code.process)
          sourceCode = this.opts.code.process(sourceCode, sch);
        const makeValidate = new Function(`${names_1.default.self}`, `${names_1.default.scope}`, sourceCode);
        const validate = makeValidate(this, this.scope.get());
        this.scope.value(validateName, { ref: validate });
        validate.errors = null;
        validate.schema = sch.schema;
        validate.schemaEnv = sch;
        if (sch.$async)
          validate.$async = true;
        if (this.opts.code.source === true) {
          validate.source = { validateName, validateCode, scopeValues: gen._values };
        }
        if (this.opts.unevaluated) {
          const { props, items } = schemaCxt;
          validate.evaluated = {
            props: props instanceof codegen_1.Name ? void 0 : props,
            items: items instanceof codegen_1.Name ? void 0 : items,
            dynamicProps: props instanceof codegen_1.Name,
            dynamicItems: items instanceof codegen_1.Name
          };
          if (validate.source)
            validate.source.evaluated = (0, codegen_1.stringify)(validate.evaluated);
        }
        sch.validate = validate;
        return sch;
      } catch (e2) {
        delete sch.validate;
        delete sch.validateName;
        if (sourceCode)
          this.logger.error("Error compiling schema, function code:", sourceCode);
        throw e2;
      } finally {
        this._compilations.delete(sch);
      }
    }
    exports2.compileSchema = compileSchema;
    function resolveRef(root, baseId, ref2) {
      var _a4;
      ref2 = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, ref2);
      const schOrFunc = root.refs[ref2];
      if (schOrFunc)
        return schOrFunc;
      let _sch = resolve.call(this, root, ref2);
      if (_sch === void 0) {
        const schema = (_a4 = root.localRefs) === null || _a4 === void 0 ? void 0 : _a4[ref2];
        const { schemaId } = this.opts;
        if (schema)
          _sch = new SchemaEnv({ schema, schemaId, root, baseId });
      }
      if (_sch === void 0)
        return;
      return root.refs[ref2] = inlineOrCompile.call(this, _sch);
    }
    exports2.resolveRef = resolveRef;
    function inlineOrCompile(sch) {
      if ((0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs))
        return sch.schema;
      return sch.validate ? sch : compileSchema.call(this, sch);
    }
    function getCompilingSchema(schEnv) {
      for (const sch of this._compilations) {
        if (sameSchemaEnv(sch, schEnv))
          return sch;
      }
    }
    exports2.getCompilingSchema = getCompilingSchema;
    function sameSchemaEnv(s1, s2) {
      return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;
    }
    function resolve(root, ref2) {
      let sch;
      while (typeof (sch = this.refs[ref2]) == "string")
        ref2 = sch;
      return sch || this.schemas[ref2] || resolveSchema.call(this, root, ref2);
    }
    function resolveSchema(root, ref2) {
      const p = this.opts.uriResolver.parse(ref2);
      const refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p);
      let baseId = (0, resolve_1.getFullPath)(this.opts.uriResolver, root.baseId, void 0);
      if (Object.keys(root.schema).length > 0 && refPath === baseId) {
        return getJsonPointer.call(this, p, root);
      }
      const id2 = (0, resolve_1.normalizeId)(refPath);
      const schOrRef = this.refs[id2] || this.schemas[id2];
      if (typeof schOrRef == "string") {
        const sch = resolveSchema.call(this, root, schOrRef);
        if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== "object")
          return;
        return getJsonPointer.call(this, p, sch);
      }
      if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== "object")
        return;
      if (!schOrRef.validate)
        compileSchema.call(this, schOrRef);
      if (id2 === (0, resolve_1.normalizeId)(ref2)) {
        const { schema } = schOrRef;
        const { schemaId } = this.opts;
        const schId = schema[schemaId];
        if (schId)
          baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
        return new SchemaEnv({ schema, schemaId, root, baseId });
      }
      return getJsonPointer.call(this, p, schOrRef);
    }
    exports2.resolveSchema = resolveSchema;
    var PREVENT_SCOPE_CHANGE = /* @__PURE__ */ new Set([
      "properties",
      "patternProperties",
      "enum",
      "dependencies",
      "definitions"
    ]);
    function getJsonPointer(parsedRef, { baseId, schema, root }) {
      var _a4;
      if (((_a4 = parsedRef.fragment) === null || _a4 === void 0 ? void 0 : _a4[0]) !== "/")
        return;
      for (const part of parsedRef.fragment.slice(1).split("/")) {
        if (typeof schema === "boolean")
          return;
        const partSchema = schema[(0, util_1.unescapeFragment)(part)];
        if (partSchema === void 0)
          return;
        schema = partSchema;
        const schId = typeof schema === "object" && schema[this.opts.schemaId];
        if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {
          baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
        }
      }
      let env;
      if (typeof schema != "boolean" && schema.$ref && !(0, util_1.schemaHasRulesButRef)(schema, this.RULES)) {
        const $ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schema.$ref);
        env = resolveSchema.call(this, root, $ref);
      }
      const { schemaId } = this.opts;
      env = env || new SchemaEnv({ schema, schemaId, root, baseId });
      if (env.schema !== env.root.schema)
        return env;
      return void 0;
    }
  }
});

// node_modules/vanilla-jsoneditor/node_modules/ajv/dist/refs/data.json
var require_data = __commonJS({
  "node_modules/vanilla-jsoneditor/node_modules/ajv/dist/refs/data.json"(exports2, module2) {
    module2.exports = {
      $id: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
      description: "Meta-schema for $data reference (JSON AnySchema extension proposal)",
      type: "object",
      required: ["$data"],
      properties: {
        $data: {
          type: "string",
          anyOf: [{ format: "relative-json-pointer" }, { format: "json-pointer" }]
        }
      },
      additionalProperties: false
    };
  }
});

// node_modules/fast-uri/lib/scopedChars.js
var require_scopedChars = __commonJS({
  "node_modules/fast-uri/lib/scopedChars.js"(exports2, module2) {
    "use strict";
    var HEX = {
      0: 0,
      1: 1,
      2: 2,
      3: 3,
      4: 4,
      5: 5,
      6: 6,
      7: 7,
      8: 8,
      9: 9,
      a: 10,
      A: 10,
      b: 11,
      B: 11,
      c: 12,
      C: 12,
      d: 13,
      D: 13,
      e: 14,
      E: 14,
      f: 15,
      F: 15
    };
    module2.exports = {
      HEX
    };
  }
});

// node_modules/fast-uri/lib/utils.js
var require_utils = __commonJS({
  "node_modules/fast-uri/lib/utils.js"(exports2, module2) {
    "use strict";
    var { HEX } = require_scopedChars();
    function normalizeIPv4(host) {
      if (findToken(host, ".") < 3) {
        return { host, isIPV4: false };
      }
      const matches = host.match(/^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/u) || [];
      const [address] = matches;
      if (address) {
        return { host: stripLeadingZeros(address, "."), isIPV4: true };
      } else {
        return { host, isIPV4: false };
      }
    }
    function stringArrayToHexStripped(input, keepZero = false) {
      let acc = "";
      let strip = true;
      for (const c of input) {
        if (HEX[c] === void 0) return void 0;
        if (c !== "0" && strip === true) strip = false;
        if (!strip) acc += c;
      }
      if (keepZero && acc.length === 0) acc = "0";
      return acc;
    }
    function getIPV6(input) {
      let tokenCount = 0;
      const output = { error: false, address: "", zone: "" };
      const address = [];
      const buffer = [];
      let isZone = false;
      let endipv6Encountered = false;
      let endIpv6 = false;
      function consume() {
        if (buffer.length) {
          if (isZone === false) {
            const hex = stringArrayToHexStripped(buffer);
            if (hex !== void 0) {
              address.push(hex);
            } else {
              output.error = true;
              return false;
            }
          }
          buffer.length = 0;
        }
        return true;
      }
      for (let i2 = 0; i2 < input.length; i2++) {
        const cursor = input[i2];
        if (cursor === "[" || cursor === "]") {
          continue;
        }
        if (cursor === ":") {
          if (endipv6Encountered === true) {
            endIpv6 = true;
          }
          if (!consume()) {
            break;
          }
          tokenCount++;
          address.push(":");
          if (tokenCount > 7) {
            output.error = true;
            break;
          }
          if (i2 - 1 >= 0 && input[i2 - 1] === ":") {
            endipv6Encountered = true;
          }
          continue;
        } else if (cursor === "%") {
          if (!consume()) {
            break;
          }
          isZone = true;
        } else {
          buffer.push(cursor);
          continue;
        }
      }
      if (buffer.length) {
        if (isZone) {
          output.zone = buffer.join("");
        } else if (endIpv6) {
          address.push(buffer.join(""));
        } else {
          address.push(stringArrayToHexStripped(buffer));
        }
      }
      output.address = address.join("");
      return output;
    }
    function normalizeIPv6(host, opts = {}) {
      if (findToken(host, ":") < 2) {
        return { host, isIPV6: false };
      }
      const ipv6 = getIPV6(host);
      if (!ipv6.error) {
        let newHost = ipv6.address;
        let escapedHost = ipv6.address;
        if (ipv6.zone) {
          newHost += "%" + ipv6.zone;
          escapedHost += "%25" + ipv6.zone;
        }
        return { host: newHost, escapedHost, isIPV6: true };
      } else {
        return { host, isIPV6: false };
      }
    }
    function stripLeadingZeros(str, token) {
      let out = "";
      let skip = true;
      const l = str.length;
      for (let i2 = 0; i2 < l; i2++) {
        const c = str[i2];
        if (c === "0" && skip) {
          if (i2 + 1 <= l && str[i2 + 1] === token || i2 + 1 === l) {
            out += c;
            skip = false;
          }
        } else {
          if (c === token) {
            skip = true;
          } else {
            skip = false;
          }
          out += c;
        }
      }
      return out;
    }
    function findToken(str, token) {
      let ind = 0;
      for (let i2 = 0; i2 < str.length; i2++) {
        if (str[i2] === token) ind++;
      }
      return ind;
    }
    var RDS1 = /^\.\.?\//u;
    var RDS2 = /^\/\.(?:\/|$)/u;
    var RDS3 = /^\/\.\.(?:\/|$)/u;
    var RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/u;
    function removeDotSegments(input) {
      const output = [];
      while (input.length) {
        if (input.match(RDS1)) {
          input = input.replace(RDS1, "");
        } else if (input.match(RDS2)) {
          input = input.replace(RDS2, "/");
        } else if (input.match(RDS3)) {
          input = input.replace(RDS3, "/");
          output.pop();
        } else if (input === "." || input === "..") {
          input = "";
        } else {
          const im2 = input.match(RDS5);
          if (im2) {
            const s2 = im2[0];
            input = input.slice(s2.length);
            output.push(s2);
          } else {
            throw new Error("Unexpected dot segment condition");
          }
        }
      }
      return output.join("");
    }
    function normalizeComponentEncoding(components, esc) {
      const func = esc !== true ? escape : unescape;
      if (components.scheme !== void 0) {
        components.scheme = func(components.scheme);
      }
      if (components.userinfo !== void 0) {
        components.userinfo = func(components.userinfo);
      }
      if (components.host !== void 0) {
        components.host = func(components.host);
      }
      if (components.path !== void 0) {
        components.path = func(components.path);
      }
      if (components.query !== void 0) {
        components.query = func(components.query);
      }
      if (components.fragment !== void 0) {
        components.fragment = func(components.fragment);
      }
      return components;
    }
    function recomposeAuthority(components, options) {
      const uriTokens = [];
      if (components.userinfo !== void 0) {
        uriTokens.push(components.userinfo);
        uriTokens.push("@");
      }
      if (components.host !== void 0) {
        let host = unescape(components.host);
        const ipV4res = normalizeIPv4(host);
        if (ipV4res.isIPV4) {
          host = ipV4res.host;
        } else {
          const ipV6res = normalizeIPv6(ipV4res.host, { isIPV4: false });
          if (ipV6res.isIPV6 === true) {
            host = `[${ipV6res.escapedHost}]`;
          } else {
            host = components.host;
          }
        }
        uriTokens.push(host);
      }
      if (typeof components.port === "number" || typeof components.port === "string") {
        uriTokens.push(":");
        uriTokens.push(String(components.port));
      }
      return uriTokens.length ? uriTokens.join("") : void 0;
    }
    module2.exports = {
      recomposeAuthority,
      normalizeComponentEncoding,
      removeDotSegments,
      normalizeIPv4,
      normalizeIPv6,
      stringArrayToHexStripped
    };
  }
});

// node_modules/fast-uri/lib/schemes.js
var require_schemes = __commonJS({
  "node_modules/fast-uri/lib/schemes.js"(exports2, module2) {
    "use strict";
    var UUID_REG = /^[\da-f]{8}\b-[\da-f]{4}\b-[\da-f]{4}\b-[\da-f]{4}\b-[\da-f]{12}$/iu;
    var URN_REG = /([\da-z][\d\-a-z]{0,31}):((?:[\w!$'()*+,\-.:;=@]|%[\da-f]{2})+)/iu;
    function isSecure(wsComponents) {
      return typeof wsComponents.secure === "boolean" ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === "wss";
    }
    function httpParse(components) {
      if (!components.host) {
        components.error = components.error || "HTTP URIs must have a host.";
      }
      return components;
    }
    function httpSerialize(components) {
      const secure = String(components.scheme).toLowerCase() === "https";
      if (components.port === (secure ? 443 : 80) || components.port === "") {
        components.port = void 0;
      }
      if (!components.path) {
        components.path = "/";
      }
      return components;
    }
    function wsParse(wsComponents) {
      wsComponents.secure = isSecure(wsComponents);
      wsComponents.resourceName = (wsComponents.path || "/") + (wsComponents.query ? "?" + wsComponents.query : "");
      wsComponents.path = void 0;
      wsComponents.query = void 0;
      return wsComponents;
    }
    function wsSerialize(wsComponents) {
      if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === "") {
        wsComponents.port = void 0;
      }
      if (typeof wsComponents.secure === "boolean") {
        wsComponents.scheme = wsComponents.secure ? "wss" : "ws";
        wsComponents.secure = void 0;
      }
      if (wsComponents.resourceName) {
        const [path, query] = wsComponents.resourceName.split("?");
        wsComponents.path = path && path !== "/" ? path : void 0;
        wsComponents.query = query;
        wsComponents.resourceName = void 0;
      }
      wsComponents.fragment = void 0;
      return wsComponents;
    }
    function urnParse(urnComponents, options) {
      if (!urnComponents.path) {
        urnComponents.error = "URN can not be parsed";
        return urnComponents;
      }
      const matches = urnComponents.path.match(URN_REG);
      if (matches) {
        const scheme = options.scheme || urnComponents.scheme || "urn";
        urnComponents.nid = matches[1].toLowerCase();
        urnComponents.nss = matches[2];
        const urnScheme = `${scheme}:${options.nid || urnComponents.nid}`;
        const schemeHandler = SCHEMES[urnScheme];
        urnComponents.path = void 0;
        if (schemeHandler) {
          urnComponents = schemeHandler.parse(urnComponents, options);
        }
      } else {
        urnComponents.error = urnComponents.error || "URN can not be parsed.";
      }
      return urnComponents;
    }
    function urnSerialize(urnComponents, options) {
      const scheme = options.scheme || urnComponents.scheme || "urn";
      const nid = urnComponents.nid.toLowerCase();
      const urnScheme = `${scheme}:${options.nid || nid}`;
      const schemeHandler = SCHEMES[urnScheme];
      if (schemeHandler) {
        urnComponents = schemeHandler.serialize(urnComponents, options);
      }
      const uriComponents = urnComponents;
      const nss = urnComponents.nss;
      uriComponents.path = `${nid || options.nid}:${nss}`;
      options.skipEscape = true;
      return uriComponents;
    }
    function urnuuidParse(urnComponents, options) {
      const uuidComponents = urnComponents;
      uuidComponents.uuid = uuidComponents.nss;
      uuidComponents.nss = void 0;
      if (!options.tolerant && (!uuidComponents.uuid || !UUID_REG.test(uuidComponents.uuid))) {
        uuidComponents.error = uuidComponents.error || "UUID is not valid.";
      }
      return uuidComponents;
    }
    function urnuuidSerialize(uuidComponents) {
      const urnComponents = uuidComponents;
      urnComponents.nss = (uuidComponents.uuid || "").toLowerCase();
      return urnComponents;
    }
    var http = {
      scheme: "http",
      domainHost: true,
      parse: httpParse,
      serialize: httpSerialize
    };
    var https = {
      scheme: "https",
      domainHost: http.domainHost,
      parse: httpParse,
      serialize: httpSerialize
    };
    var ws2 = {
      scheme: "ws",
      domainHost: true,
      parse: wsParse,
      serialize: wsSerialize
    };
    var wss = {
      scheme: "wss",
      domainHost: ws2.domainHost,
      parse: ws2.parse,
      serialize: ws2.serialize
    };
    var urn = {
      scheme: "urn",
      parse: urnParse,
      serialize: urnSerialize,
      skipNormalize: true
    };
    var urnuuid = {
      scheme: "urn:uuid",
      parse: urnuuidParse,
      serialize: urnuuidSerialize,
      skipNormalize: true
    };
    var SCHEMES = {
      http,
      https,
      ws: ws2,
      wss,
      urn,
      "urn:uuid": urnuuid
    };
    module2.exports = SCHEMES;
  }
});

// node_modules/fast-uri/index.js
var require_fast_uri = __commonJS({
  "node_modules/fast-uri/index.js"(exports2, module2) {
    "use strict";
    var { normalizeIPv6, normalizeIPv4, removeDotSegments, recomposeAuthority, normalizeComponentEncoding } = require_utils();
    var SCHEMES = require_schemes();
    function normalize(uri, options) {
      if (typeof uri === "string") {
        uri = serialize(parse(uri, options), options);
      } else if (typeof uri === "object") {
        uri = parse(serialize(uri, options), options);
      }
      return uri;
    }
    function resolve(baseURI, relativeURI, options) {
      const schemelessOptions = Object.assign({ scheme: "null" }, options);
      const resolved = resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true);
      return serialize(resolved, { ...schemelessOptions, skipEscape: true });
    }
    function resolveComponents(base2, relative, options, skipNormalization) {
      const target = {};
      if (!skipNormalization) {
        base2 = parse(serialize(base2, options), options);
        relative = parse(serialize(relative, options), options);
      }
      options = options || {};
      if (!options.tolerant && relative.scheme) {
        target.scheme = relative.scheme;
        target.userinfo = relative.userinfo;
        target.host = relative.host;
        target.port = relative.port;
        target.path = removeDotSegments(relative.path || "");
        target.query = relative.query;
      } else {
        if (relative.userinfo !== void 0 || relative.host !== void 0 || relative.port !== void 0) {
          target.userinfo = relative.userinfo;
          target.host = relative.host;
          target.port = relative.port;
          target.path = removeDotSegments(relative.path || "");
          target.query = relative.query;
        } else {
          if (!relative.path) {
            target.path = base2.path;
            if (relative.query !== void 0) {
              target.query = relative.query;
            } else {
              target.query = base2.query;
            }
          } else {
            if (relative.path.charAt(0) === "/") {
              target.path = removeDotSegments(relative.path);
            } else {
              if ((base2.userinfo !== void 0 || base2.host !== void 0 || base2.port !== void 0) && !base2.path) {
                target.path = "/" + relative.path;
              } else if (!base2.path) {
                target.path = relative.path;
              } else {
                target.path = base2.path.slice(0, base2.path.lastIndexOf("/") + 1) + relative.path;
              }
              target.path = removeDotSegments(target.path);
            }
            target.query = relative.query;
          }
          target.userinfo = base2.userinfo;
          target.host = base2.host;
          target.port = base2.port;
        }
        target.scheme = base2.scheme;
      }
      target.fragment = relative.fragment;
      return target;
    }
    function equal(uriA, uriB, options) {
      if (typeof uriA === "string") {
        uriA = unescape(uriA);
        uriA = serialize(normalizeComponentEncoding(parse(uriA, options), true), { ...options, skipEscape: true });
      } else if (typeof uriA === "object") {
        uriA = serialize(normalizeComponentEncoding(uriA, true), { ...options, skipEscape: true });
      }
      if (typeof uriB === "string") {
        uriB = unescape(uriB);
        uriB = serialize(normalizeComponentEncoding(parse(uriB, options), true), { ...options, skipEscape: true });
      } else if (typeof uriB === "object") {
        uriB = serialize(normalizeComponentEncoding(uriB, true), { ...options, skipEscape: true });
      }
      return uriA.toLowerCase() === uriB.toLowerCase();
    }
    function serialize(cmpts, opts) {
      const components = {
        host: cmpts.host,
        scheme: cmpts.scheme,
        userinfo: cmpts.userinfo,
        port: cmpts.port,
        path: cmpts.path,
        query: cmpts.query,
        nid: cmpts.nid,
        nss: cmpts.nss,
        uuid: cmpts.uuid,
        fragment: cmpts.fragment,
        reference: cmpts.reference,
        resourceName: cmpts.resourceName,
        secure: cmpts.secure,
        error: ""
      };
      const options = Object.assign({}, opts);
      const uriTokens = [];
      const schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
      if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);
      if (components.path !== void 0) {
        if (!options.skipEscape) {
          components.path = escape(components.path);
          if (components.scheme !== void 0) {
            components.path = components.path.split("%3A").join(":");
          }
        } else {
          components.path = unescape(components.path);
        }
      }
      if (options.reference !== "suffix" && components.scheme) {
        uriTokens.push(components.scheme, ":");
      }
      const authority = recomposeAuthority(components, options);
      if (authority !== void 0) {
        if (options.reference !== "suffix") {
          uriTokens.push("//");
        }
        uriTokens.push(authority);
        if (components.path && components.path.charAt(0) !== "/") {
          uriTokens.push("/");
        }
      }
      if (components.path !== void 0) {
        let s2 = components.path;
        if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
          s2 = removeDotSegments(s2);
        }
        if (authority === void 0) {
          s2 = s2.replace(/^\/\//u, "/%2F");
        }
        uriTokens.push(s2);
      }
      if (components.query !== void 0) {
        uriTokens.push("?", components.query);
      }
      if (components.fragment !== void 0) {
        uriTokens.push("#", components.fragment);
      }
      return uriTokens.join("");
    }
    var hexLookUp = Array.from({ length: 127 }, (v, k2) => /[^!"$&'()*+,\-.;=_`a-z{}~]/u.test(String.fromCharCode(k2)));
    function nonSimpleDomain(value) {
      let code = 0;
      for (let i2 = 0, len = value.length; i2 < len; ++i2) {
        code = value.charCodeAt(i2);
        if (code > 126 || hexLookUp[code]) {
          return true;
        }
      }
      return false;
    }
    var URI_PARSE = /^(?:([^#/:?]+):)?(?:\/\/((?:([^#/?@]*)@)?(\[[^#/?\]]+\]|[^#/:?]*)(?::(\d*))?))?([^#?]*)(?:\?([^#]*))?(?:#((?:.|[\n\r])*))?/u;
    function parse(uri, opts) {
      const options = Object.assign({}, opts);
      const parsed = {
        scheme: void 0,
        userinfo: void 0,
        host: "",
        port: void 0,
        path: "",
        query: void 0,
        fragment: void 0
      };
      const gotEncoding = uri.indexOf("%") !== -1;
      let isIP = false;
      if (options.reference === "suffix") uri = (options.scheme ? options.scheme + ":" : "") + "//" + uri;
      const matches = uri.match(URI_PARSE);
      if (matches) {
        parsed.scheme = matches[1];
        parsed.userinfo = matches[3];
        parsed.host = matches[4];
        parsed.port = parseInt(matches[5], 10);
        parsed.path = matches[6] || "";
        parsed.query = matches[7];
        parsed.fragment = matches[8];
        if (isNaN(parsed.port)) {
          parsed.port = matches[5];
        }
        if (parsed.host) {
          const ipv4result = normalizeIPv4(parsed.host);
          if (ipv4result.isIPV4 === false) {
            const ipv6result = normalizeIPv6(ipv4result.host, { isIPV4: false });
            parsed.host = ipv6result.host.toLowerCase();
            isIP = ipv6result.isIPV6;
          } else {
            parsed.host = ipv4result.host;
            isIP = true;
          }
        }
        if (parsed.scheme === void 0 && parsed.userinfo === void 0 && parsed.host === void 0 && parsed.port === void 0 && !parsed.path && parsed.query === void 0) {
          parsed.reference = "same-document";
        } else if (parsed.scheme === void 0) {
          parsed.reference = "relative";
        } else if (parsed.fragment === void 0) {
          parsed.reference = "absolute";
        } else {
          parsed.reference = "uri";
        }
        if (options.reference && options.reference !== "suffix" && options.reference !== parsed.reference) {
          parsed.error = parsed.error || "URI is not a " + options.reference + " reference.";
        }
        const schemeHandler = SCHEMES[(options.scheme || parsed.scheme || "").toLowerCase()];
        if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
          if (parsed.host && (options.domainHost || schemeHandler && schemeHandler.domainHost) && isIP === false && nonSimpleDomain(parsed.host)) {
            try {
              parsed.host = URL.domainToASCII(parsed.host.toLowerCase());
            } catch (e2) {
              parsed.error = parsed.error || "Host's domain name can not be converted to ASCII: " + e2;
            }
          }
        }
        if (!schemeHandler || schemeHandler && !schemeHandler.skipNormalize) {
          if (gotEncoding && parsed.scheme !== void 0) {
            parsed.scheme = unescape(parsed.scheme);
          }
          if (gotEncoding && parsed.host !== void 0) {
            parsed.host = unescape(parsed.host);
          }
          if (parsed.path !== void 0 && parsed.path.length) {
            parsed.path = escape(unescape(parsed.path));
          }
          if (parsed.fragment !== void 0 && parsed.fragment.length) {
            parsed.fragment = encodeURI(decodeURIComponent(parsed.fragment));
          }
        }
        if (schemeHandler && schemeHandler.parse) {
          schemeHandler.parse(parsed, options);
        }
      } else {
        parsed.error = parsed.error || "URI can not be parsed.";
      }
      return parsed;
    }
    var fastUri = {
      SCHEMES,
      normalize,
      resolve,
      resolveComponents,
      equal,
      serialize,
      parse
    };
    module2.exports = fastUri;
    module2.exports.default = fastUri;
    module2.exports.fastUri = fastUri;
  }
});

// node_modules/vanilla-jsoneditor/node_modules/ajv/dist/runtime/uri.js
var require_uri = __commonJS({
  "node_modules/vanilla-jsoneditor/node_modules/ajv/dist/runtime/uri.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var uri = require_fast_uri();
    uri.code = 'require("ajv/dist/runtime/uri").default';
    exports2.default = uri;
  }
});

// node_modules/vanilla-jsoneditor/node_modules/ajv/dist/core.js
var require_core = __commonJS({
  "node_modules/vanilla-jsoneditor/node_modules/ajv/dist/core.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CodeGen = exports2.Name = exports2.nil = exports2.stringify = exports2.str = exports2._ = exports2.KeywordCxt = void 0;
    var validate_1 = require_validate();
    Object.defineProperty(exports2, "KeywordCxt", { enumerable: true, get: function() {
      return validate_1.KeywordCxt;
    } });
    var codegen_1 = require_codegen();
    Object.defineProperty(exports2, "_", { enumerable: true, get: function() {
      return codegen_1._;
    } });
    Object.defineProperty(exports2, "str", { enumerable: true, get: function() {
      return codegen_1.str;
    } });
    Object.defineProperty(exports2, "stringify", { enumerable: true, get: function() {
      return codegen_1.stringify;
    } });
    Object.defineProperty(exports2, "nil", { enumerable: true, get: function() {
      return codegen_1.nil;
    } });
    Object.defineProperty(exports2, "Name", { enumerable: true, get: function() {
      return codegen_1.Name;
    } });
    Object.defineProperty(exports2, "CodeGen", { enumerable: true, get: function() {
      return codegen_1.CodeGen;
    } });
    var validation_error_1 = require_validation_error();
    var ref_error_1 = require_ref_error();
    var rules_1 = require_rules();
    var compile_1 = require_compile();
    var codegen_2 = require_codegen();
    var resolve_1 = require_resolve();
    var dataType_1 = require_dataType();
    var util_1 = require_util();
    var $dataRefSchema = require_data();
    var uri_1 = require_uri();
    var defaultRegExp = (str, flags) => new RegExp(str, flags);
    defaultRegExp.code = "new RegExp";
    var META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes"];
    var EXT_SCOPE_NAMES = /* @__PURE__ */ new Set([
      "validate",
      "serialize",
      "parse",
      "wrapper",
      "root",
      "schema",
      "keyword",
      "pattern",
      "formats",
      "validate$data",
      "func",
      "obj",
      "Error"
    ]);
    var removedOptions = {
      errorDataPath: "",
      format: "`validateFormats: false` can be used instead.",
      nullable: '"nullable" keyword is supported by default.',
      jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
      extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
      missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
      processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
      sourceCode: "Use option `code: {source: true}`",
      strictDefaults: "It is default now, see option `strict`.",
      strictKeywords: "It is default now, see option `strict`.",
      uniqueItems: '"uniqueItems" keyword is always validated.',
      unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
      cache: "Map is used as cache, schema object as key.",
      serialize: "Map is used as cache, schema object as key.",
      ajvErrors: "It is default now."
    };
    var deprecatedOptions = {
      ignoreKeywordsWithRef: "",
      jsPropertySyntax: "",
      unicode: '"minLength"/"maxLength" account for unicode characters by default.'
    };
    var MAX_EXPRESSION = 200;
    function requiredOptions(o2) {
      var _a4, _b, _c2, _d2, _e2, _f2, _g2, _h2, _j2, _k, _l2, _m2, _o3, _p2, _q, _r3, _s2, _t3, _u3, _v2, _w, _x2, _y, _z, _0;
      const s2 = o2.strict;
      const _optz = (_a4 = o2.code) === null || _a4 === void 0 ? void 0 : _a4.optimize;
      const optimize = _optz === true || _optz === void 0 ? 1 : _optz || 0;
      const regExp = (_c2 = (_b = o2.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c2 !== void 0 ? _c2 : defaultRegExp;
      const uriResolver = (_d2 = o2.uriResolver) !== null && _d2 !== void 0 ? _d2 : uri_1.default;
      return {
        strictSchema: (_f2 = (_e2 = o2.strictSchema) !== null && _e2 !== void 0 ? _e2 : s2) !== null && _f2 !== void 0 ? _f2 : true,
        strictNumbers: (_h2 = (_g2 = o2.strictNumbers) !== null && _g2 !== void 0 ? _g2 : s2) !== null && _h2 !== void 0 ? _h2 : true,
        strictTypes: (_k = (_j2 = o2.strictTypes) !== null && _j2 !== void 0 ? _j2 : s2) !== null && _k !== void 0 ? _k : "log",
        strictTuples: (_m2 = (_l2 = o2.strictTuples) !== null && _l2 !== void 0 ? _l2 : s2) !== null && _m2 !== void 0 ? _m2 : "log",
        strictRequired: (_p2 = (_o3 = o2.strictRequired) !== null && _o3 !== void 0 ? _o3 : s2) !== null && _p2 !== void 0 ? _p2 : false,
        code: o2.code ? { ...o2.code, optimize, regExp } : { optimize, regExp },
        loopRequired: (_q = o2.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,
        loopEnum: (_r3 = o2.loopEnum) !== null && _r3 !== void 0 ? _r3 : MAX_EXPRESSION,
        meta: (_s2 = o2.meta) !== null && _s2 !== void 0 ? _s2 : true,
        messages: (_t3 = o2.messages) !== null && _t3 !== void 0 ? _t3 : true,
        inlineRefs: (_u3 = o2.inlineRefs) !== null && _u3 !== void 0 ? _u3 : true,
        schemaId: (_v2 = o2.schemaId) !== null && _v2 !== void 0 ? _v2 : "$id",
        addUsedSchema: (_w = o2.addUsedSchema) !== null && _w !== void 0 ? _w : true,
        validateSchema: (_x2 = o2.validateSchema) !== null && _x2 !== void 0 ? _x2 : true,
        validateFormats: (_y = o2.validateFormats) !== null && _y !== void 0 ? _y : true,
        unicodeRegExp: (_z = o2.unicodeRegExp) !== null && _z !== void 0 ? _z : true,
        int32range: (_0 = o2.int32range) !== null && _0 !== void 0 ? _0 : true,
        uriResolver
      };
    }
    var Ajv = class {
      constructor(opts = {}) {
        this.schemas = {};
        this.refs = {};
        this.formats = {};
        this._compilations = /* @__PURE__ */ new Set();
        this._loading = {};
        this._cache = /* @__PURE__ */ new Map();
        opts = this.opts = { ...opts, ...requiredOptions(opts) };
        const { es5, lines } = this.opts.code;
        this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });
        this.logger = getLogger(opts.logger);
        const formatOpt = opts.validateFormats;
        opts.validateFormats = false;
        this.RULES = (0, rules_1.getRules)();
        checkOptions.call(this, removedOptions, opts, "NOT SUPPORTED");
        checkOptions.call(this, deprecatedOptions, opts, "DEPRECATED", "warn");
        this._metaOpts = getMetaSchemaOptions.call(this);
        if (opts.formats)
          addInitialFormats.call(this);
        this._addVocabularies();
        this._addDefaultMetaSchema();
        if (opts.keywords)
          addInitialKeywords.call(this, opts.keywords);
        if (typeof opts.meta == "object")
          this.addMetaSchema(opts.meta);
        addInitialSchemas.call(this);
        opts.validateFormats = formatOpt;
      }
      _addVocabularies() {
        this.addKeyword("$async");
      }
      _addDefaultMetaSchema() {
        const { $data, meta: meta2, schemaId } = this.opts;
        let _dataRefSchema = $dataRefSchema;
        if (schemaId === "id") {
          _dataRefSchema = { ...$dataRefSchema };
          _dataRefSchema.id = _dataRefSchema.$id;
          delete _dataRefSchema.$id;
        }
        if (meta2 && $data)
          this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);
      }
      defaultMeta() {
        const { meta: meta2, schemaId } = this.opts;
        return this.opts.defaultMeta = typeof meta2 == "object" ? meta2[schemaId] || meta2 : void 0;
      }
      validate(schemaKeyRef, data) {
        let v;
        if (typeof schemaKeyRef == "string") {
          v = this.getSchema(schemaKeyRef);
          if (!v)
            throw new Error(`no schema with key or ref "${schemaKeyRef}"`);
        } else {
          v = this.compile(schemaKeyRef);
        }
        const valid = v(data);
        if (!("$async" in v))
          this.errors = v.errors;
        return valid;
      }
      compile(schema, _meta) {
        const sch = this._addSchema(schema, _meta);
        return sch.validate || this._compileSchemaEnv(sch);
      }
      compileAsync(schema, meta2) {
        if (typeof this.opts.loadSchema != "function") {
          throw new Error("options.loadSchema should be a function");
        }
        const { loadSchema } = this.opts;
        return runCompileAsync.call(this, schema, meta2);
        async function runCompileAsync(_schema, _meta) {
          await loadMetaSchema.call(this, _schema.$schema);
          const sch = this._addSchema(_schema, _meta);
          return sch.validate || _compileAsync.call(this, sch);
        }
        async function loadMetaSchema($ref) {
          if ($ref && !this.getSchema($ref)) {
            await runCompileAsync.call(this, { $ref }, true);
          }
        }
        async function _compileAsync(sch) {
          try {
            return this._compileSchemaEnv(sch);
          } catch (e2) {
            if (!(e2 instanceof ref_error_1.default))
              throw e2;
            checkLoaded.call(this, e2);
            await loadMissingSchema.call(this, e2.missingSchema);
            return _compileAsync.call(this, sch);
          }
        }
        function checkLoaded({ missingSchema: ref2, missingRef }) {
          if (this.refs[ref2]) {
            throw new Error(`AnySchema ${ref2} is loaded but ${missingRef} cannot be resolved`);
          }
        }
        async function loadMissingSchema(ref2) {
          const _schema = await _loadSchema.call(this, ref2);
          if (!this.refs[ref2])
            await loadMetaSchema.call(this, _schema.$schema);
          if (!this.refs[ref2])
            this.addSchema(_schema, ref2, meta2);
        }
        async function _loadSchema(ref2) {
          const p = this._loading[ref2];
          if (p)
            return p;
          try {
            return await (this._loading[ref2] = loadSchema(ref2));
          } finally {
            delete this._loading[ref2];
          }
        }
      }
      // Adds schema to the instance
      addSchema(schema, key, _meta, _validateSchema = this.opts.validateSchema) {
        if (Array.isArray(schema)) {
          for (const sch of schema)
            this.addSchema(sch, void 0, _meta, _validateSchema);
          return this;
        }
        let id2;
        if (typeof schema === "object") {
          const { schemaId } = this.opts;
          id2 = schema[schemaId];
          if (id2 !== void 0 && typeof id2 != "string") {
            throw new Error(`schema ${schemaId} must be string`);
          }
        }
        key = (0, resolve_1.normalizeId)(key || id2);
        this._checkUnique(key);
        this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true);
        return this;
      }
      // Add schema that will be used to validate other schemas
      // options in META_IGNORE_OPTIONS are alway set to false
      addMetaSchema(schema, key, _validateSchema = this.opts.validateSchema) {
        this.addSchema(schema, key, true, _validateSchema);
        return this;
      }
      //  Validate schema against its meta-schema
      validateSchema(schema, throwOrLogError) {
        if (typeof schema == "boolean")
          return true;
        let $schema;
        $schema = schema.$schema;
        if ($schema !== void 0 && typeof $schema != "string") {
          throw new Error("$schema must be a string");
        }
        $schema = $schema || this.opts.defaultMeta || this.defaultMeta();
        if (!$schema) {
          this.logger.warn("meta-schema not available");
          this.errors = null;
          return true;
        }
        const valid = this.validate($schema, schema);
        if (!valid && throwOrLogError) {
          const message = "schema is invalid: " + this.errorsText();
          if (this.opts.validateSchema === "log")
            this.logger.error(message);
          else
            throw new Error(message);
        }
        return valid;
      }
      // Get compiled schema by `key` or `ref`.
      // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
      getSchema(keyRef) {
        let sch;
        while (typeof (sch = getSchEnv.call(this, keyRef)) == "string")
          keyRef = sch;
        if (sch === void 0) {
          const { schemaId } = this.opts;
          const root = new compile_1.SchemaEnv({ schema: {}, schemaId });
          sch = compile_1.resolveSchema.call(this, root, keyRef);
          if (!sch)
            return;
          this.refs[keyRef] = sch;
        }
        return sch.validate || this._compileSchemaEnv(sch);
      }
      // Remove cached schema(s).
      // If no parameter is passed all schemas but meta-schemas are removed.
      // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
      // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
      removeSchema(schemaKeyRef) {
        if (schemaKeyRef instanceof RegExp) {
          this._removeAllSchemas(this.schemas, schemaKeyRef);
          this._removeAllSchemas(this.refs, schemaKeyRef);
          return this;
        }
        switch (typeof schemaKeyRef) {
          case "undefined":
            this._removeAllSchemas(this.schemas);
            this._removeAllSchemas(this.refs);
            this._cache.clear();
            return this;
          case "string": {
            const sch = getSchEnv.call(this, schemaKeyRef);
            if (typeof sch == "object")
              this._cache.delete(sch.schema);
            delete this.schemas[schemaKeyRef];
            delete this.refs[schemaKeyRef];
            return this;
          }
          case "object": {
            const cacheKey = schemaKeyRef;
            this._cache.delete(cacheKey);
            let id2 = schemaKeyRef[this.opts.schemaId];
            if (id2) {
              id2 = (0, resolve_1.normalizeId)(id2);
              delete this.schemas[id2];
              delete this.refs[id2];
            }
            return this;
          }
          default:
            throw new Error("ajv.removeSchema: invalid parameter");
        }
      }
      // add "vocabulary" - a collection of keywords
      addVocabulary(definitions) {
        for (const def of definitions)
          this.addKeyword(def);
        return this;
      }
      addKeyword(kwdOrDef, def) {
        let keyword2;
        if (typeof kwdOrDef == "string") {
          keyword2 = kwdOrDef;
          if (typeof def == "object") {
            this.logger.warn("these parameters are deprecated, see docs for addKeyword");
            def.keyword = keyword2;
          }
        } else if (typeof kwdOrDef == "object" && def === void 0) {
          def = kwdOrDef;
          keyword2 = def.keyword;
          if (Array.isArray(keyword2) && !keyword2.length) {
            throw new Error("addKeywords: keyword must be string or non-empty array");
          }
        } else {
          throw new Error("invalid addKeywords parameters");
        }
        checkKeyword.call(this, keyword2, def);
        if (!def) {
          (0, util_1.eachItem)(keyword2, (kwd) => addRule.call(this, kwd));
          return this;
        }
        keywordMetaschema.call(this, def);
        const definition = {
          ...def,
          type: (0, dataType_1.getJSONTypes)(def.type),
          schemaType: (0, dataType_1.getJSONTypes)(def.schemaType)
        };
        (0, util_1.eachItem)(keyword2, definition.type.length === 0 ? (k2) => addRule.call(this, k2, definition) : (k2) => definition.type.forEach((t3) => addRule.call(this, k2, definition, t3)));
        return this;
      }
      getKeyword(keyword2) {
        const rule = this.RULES.all[keyword2];
        return typeof rule == "object" ? rule.definition : !!rule;
      }
      // Remove keyword
      removeKeyword(keyword2) {
        const { RULES } = this;
        delete RULES.keywords[keyword2];
        delete RULES.all[keyword2];
        for (const group of RULES.rules) {
          const i2 = group.rules.findIndex((rule) => rule.keyword === keyword2);
          if (i2 >= 0)
            group.rules.splice(i2, 1);
        }
        return this;
      }
      // Add format
      addFormat(name2, format) {
        if (typeof format == "string")
          format = new RegExp(format);
        this.formats[name2] = format;
        return this;
      }
      errorsText(errors = this.errors, { separator = ", ", dataVar = "data" } = {}) {
        if (!errors || errors.length === 0)
          return "No errors";
        return errors.map((e2) => `${dataVar}${e2.instancePath} ${e2.message}`).reduce((text, msg) => text + separator + msg);
      }
      $dataMetaSchema(metaSchema, keywordsJsonPointers) {
        const rules = this.RULES.all;
        metaSchema = JSON.parse(JSON.stringify(metaSchema));
        for (const jsonPointer of keywordsJsonPointers) {
          const segments = jsonPointer.split("/").slice(1);
          let keywords = metaSchema;
          for (const seg of segments)
            keywords = keywords[seg];
          for (const key in rules) {
            const rule = rules[key];
            if (typeof rule != "object")
              continue;
            const { $data } = rule.definition;
            const schema = keywords[key];
            if ($data && schema)
              keywords[key] = schemaOrData(schema);
          }
        }
        return metaSchema;
      }
      _removeAllSchemas(schemas, regex) {
        for (const keyRef in schemas) {
          const sch = schemas[keyRef];
          if (!regex || regex.test(keyRef)) {
            if (typeof sch == "string") {
              delete schemas[keyRef];
            } else if (sch && !sch.meta) {
              this._cache.delete(sch.schema);
              delete schemas[keyRef];
            }
          }
        }
      }
      _addSchema(schema, meta2, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {
        let id2;
        const { schemaId } = this.opts;
        if (typeof schema == "object") {
          id2 = schema[schemaId];
        } else {
          if (this.opts.jtd)
            throw new Error("schema must be object");
          else if (typeof schema != "boolean")
            throw new Error("schema must be object or boolean");
        }
        let sch = this._cache.get(schema);
        if (sch !== void 0)
          return sch;
        baseId = (0, resolve_1.normalizeId)(id2 || baseId);
        const localRefs = resolve_1.getSchemaRefs.call(this, schema, baseId);
        sch = new compile_1.SchemaEnv({ schema, schemaId, meta: meta2, baseId, localRefs });
        this._cache.set(sch.schema, sch);
        if (addSchema && !baseId.startsWith("#")) {
          if (baseId)
            this._checkUnique(baseId);
          this.refs[baseId] = sch;
        }
        if (validateSchema)
          this.validateSchema(schema, true);
        return sch;
      }
      _checkUnique(id2) {
        if (this.schemas[id2] || this.refs[id2]) {
          throw new Error(`schema with key or id "${id2}" already exists`);
        }
      }
      _compileSchemaEnv(sch) {
        if (sch.meta)
          this._compileMetaSchema(sch);
        else
          compile_1.compileSchema.call(this, sch);
        if (!sch.validate)
          throw new Error("ajv implementation error");
        return sch.validate;
      }
      _compileMetaSchema(sch) {
        const currentOpts = this.opts;
        this.opts = this._metaOpts;
        try {
          compile_1.compileSchema.call(this, sch);
        } finally {
          this.opts = currentOpts;
        }
      }
    };
    Ajv.ValidationError = validation_error_1.default;
    Ajv.MissingRefError = ref_error_1.default;
    exports2.default = Ajv;
    function checkOptions(checkOpts, options, msg, log = "error") {
      for (const key in checkOpts) {
        const opt = key;
        if (opt in options)
          this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);
      }
    }
    function getSchEnv(keyRef) {
      keyRef = (0, resolve_1.normalizeId)(keyRef);
      return this.schemas[keyRef] || this.refs[keyRef];
    }
    function addInitialSchemas() {
      const optsSchemas = this.opts.schemas;
      if (!optsSchemas)
        return;
      if (Array.isArray(optsSchemas))
        this.addSchema(optsSchemas);
      else
        for (const key in optsSchemas)
          this.addSchema(optsSchemas[key], key);
    }
    function addInitialFormats() {
      for (const name2 in this.opts.formats) {
        const format = this.opts.formats[name2];
        if (format)
          this.addFormat(name2, format);
      }
    }
    function addInitialKeywords(defs) {
      if (Array.isArray(defs)) {
        this.addVocabulary(defs);
        return;
      }
      this.logger.warn("keywords option as map is deprecated, pass array");
      for (const keyword2 in defs) {
        const def = defs[keyword2];
        if (!def.keyword)
          def.keyword = keyword2;
        this.addKeyword(def);
      }
    }
    function getMetaSchemaOptions() {
      const metaOpts = { ...this.opts };
      for (const opt of META_IGNORE_OPTIONS)
        delete metaOpts[opt];
      return metaOpts;
    }
    var noLogs = { log() {
    }, warn() {
    }, error() {
    } };
    function getLogger(logger) {
      if (logger === false)
        return noLogs;
      if (logger === void 0)
        return console;
      if (logger.log && logger.warn && logger.error)
        return logger;
      throw new Error("logger must implement log, warn and error methods");
    }
    var KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
    function checkKeyword(keyword2, def) {
      const { RULES } = this;
      (0, util_1.eachItem)(keyword2, (kwd) => {
        if (RULES.keywords[kwd])
          throw new Error(`Keyword ${kwd} is already defined`);
        if (!KEYWORD_NAME.test(kwd))
          throw new Error(`Keyword ${kwd} has invalid name`);
      });
      if (!def)
        return;
      if (def.$data && !("code" in def || "validate" in def)) {
        throw new Error('$data keyword must have "code" or "validate" function');
      }
    }
    function addRule(keyword2, definition, dataType) {
      var _a4;
      const post = definition === null || definition === void 0 ? void 0 : definition.post;
      if (dataType && post)
        throw new Error('keyword with "post" flag cannot have "type"');
      const { RULES } = this;
      let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t3 }) => t3 === dataType);
      if (!ruleGroup) {
        ruleGroup = { type: dataType, rules: [] };
        RULES.rules.push(ruleGroup);
      }
      RULES.keywords[keyword2] = true;
      if (!definition)
        return;
      const rule = {
        keyword: keyword2,
        definition: {
          ...definition,
          type: (0, dataType_1.getJSONTypes)(definition.type),
          schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType)
        }
      };
      if (definition.before)
        addBeforeRule.call(this, ruleGroup, rule, definition.before);
      else
        ruleGroup.rules.push(rule);
      RULES.all[keyword2] = rule;
      (_a4 = definition.implements) === null || _a4 === void 0 ? void 0 : _a4.forEach((kwd) => this.addKeyword(kwd));
    }
    function addBeforeRule(ruleGroup, rule, before) {
      const i2 = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);
      if (i2 >= 0) {
        ruleGroup.rules.splice(i2, 0, rule);
      } else {
        ruleGroup.rules.push(rule);
        this.logger.warn(`rule ${before} is not defined`);
      }
    }
    function keywordMetaschema(def) {
      let { metaSchema } = def;
      if (metaSchema === void 0)
        return;
      if (def.$data && this.opts.$data)
        metaSchema = schemaOrData(metaSchema);
      def.validateSchema = this.compile(metaSchema, true);
    }
    var $dataRef = {
      $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
    };
    function schemaOrData(schema) {
      return { anyOf: [schema, $dataRef] };
    }
  }
});

// node_modules/vanilla-jsoneditor/node_modules/ajv/dist/vocabularies/core/id.js
var require_id = __commonJS({
  "node_modules/vanilla-jsoneditor/node_modules/ajv/dist/vocabularies/core/id.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var def = {
      keyword: "id",
      code() {
        throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
      }
    };
    exports2.default = def;
  }
});

// node_modules/vanilla-jsoneditor/node_modules/ajv/dist/vocabularies/core/ref.js
var require_ref = __commonJS({
  "node_modules/vanilla-jsoneditor/node_modules/ajv/dist/vocabularies/core/ref.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.callRef = exports2.getValidate = void 0;
    var ref_error_1 = require_ref_error();
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var compile_1 = require_compile();
    var util_1 = require_util();
    var def = {
      keyword: "$ref",
      schemaType: "string",
      code(cxt) {
        const { gen, schema: $ref, it: it2 } = cxt;
        const { baseId, schemaEnv: env, validateName, opts, self: self2 } = it2;
        const { root } = env;
        if (($ref === "#" || $ref === "#/") && baseId === root.baseId)
          return callRootRef();
        const schOrEnv = compile_1.resolveRef.call(self2, root, baseId, $ref);
        if (schOrEnv === void 0)
          throw new ref_error_1.default(it2.opts.uriResolver, baseId, $ref);
        if (schOrEnv instanceof compile_1.SchemaEnv)
          return callValidate(schOrEnv);
        return inlineRefSchema(schOrEnv);
        function callRootRef() {
          if (env === root)
            return callRef(cxt, validateName, env, env.$async);
          const rootName = gen.scopeValue("root", { ref: root });
          return callRef(cxt, (0, codegen_1._)`${rootName}.validate`, root, root.$async);
        }
        function callValidate(sch) {
          const v = getValidate(cxt, sch);
          callRef(cxt, v, sch, sch.$async);
        }
        function inlineRefSchema(sch) {
          const schName = gen.scopeValue("schema", opts.code.source === true ? { ref: sch, code: (0, codegen_1.stringify)(sch) } : { ref: sch });
          const valid = gen.name("valid");
          const schCxt = cxt.subschema({
            schema: sch,
            dataTypes: [],
            schemaPath: codegen_1.nil,
            topSchemaRef: schName,
            errSchemaPath: $ref
          }, valid);
          cxt.mergeEvaluated(schCxt);
          cxt.ok(valid);
        }
      }
    };
    function getValidate(cxt, sch) {
      const { gen } = cxt;
      return sch.validate ? gen.scopeValue("validate", { ref: sch.validate }) : (0, codegen_1._)`${gen.scopeValue("wrapper", { ref: sch })}.validate`;
    }
    exports2.getValidate = getValidate;
    function callRef(cxt, v, sch, $async) {
      const { gen, it: it2 } = cxt;
      const { allErrors, schemaEnv: env, opts } = it2;
      const passCxt = opts.passContext ? names_1.default.this : codegen_1.nil;
      if ($async)
        callAsyncRef();
      else
        callSyncRef();
      function callAsyncRef() {
        if (!env.$async)
          throw new Error("async schema referenced by sync schema");
        const valid = gen.let("valid");
        gen.try(() => {
          gen.code((0, codegen_1._)`await ${(0, code_1.callValidateCode)(cxt, v, passCxt)}`);
          addEvaluatedFrom(v);
          if (!allErrors)
            gen.assign(valid, true);
        }, (e2) => {
          gen.if((0, codegen_1._)`!(${e2} instanceof ${it2.ValidationError})`, () => gen.throw(e2));
          addErrorsFrom(e2);
          if (!allErrors)
            gen.assign(valid, false);
        });
        cxt.ok(valid);
      }
      function callSyncRef() {
        cxt.result((0, code_1.callValidateCode)(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));
      }
      function addErrorsFrom(source) {
        const errs = (0, codegen_1._)`${source}.errors`;
        gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`);
        gen.assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
      }
      function addEvaluatedFrom(source) {
        var _a4;
        if (!it2.opts.unevaluated)
          return;
        const schEvaluated = (_a4 = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a4 === void 0 ? void 0 : _a4.evaluated;
        if (it2.props !== true) {
          if (schEvaluated && !schEvaluated.dynamicProps) {
            if (schEvaluated.props !== void 0) {
              it2.props = util_1.mergeEvaluated.props(gen, schEvaluated.props, it2.props);
            }
          } else {
            const props = gen.var("props", (0, codegen_1._)`${source}.evaluated.props`);
            it2.props = util_1.mergeEvaluated.props(gen, props, it2.props, codegen_1.Name);
          }
        }
        if (it2.items !== true) {
          if (schEvaluated && !schEvaluated.dynamicItems) {
            if (schEvaluated.items !== void 0) {
              it2.items = util_1.mergeEvaluated.items(gen, schEvaluated.items, it2.items);
            }
          } else {
            const items = gen.var("items", (0, codegen_1._)`${source}.evaluated.items`);
            it2.items = util_1.mergeEvaluated.items(gen, items, it2.items, codegen_1.Name);
          }
        }
      }
    }
    exports2.callRef = callRef;
    exports2.default = def;
  }
});

// node_modules/vanilla-jsoneditor/node_modules/ajv/dist/vocabularies/core/index.js
var require_core2 = __commonJS({
  "node_modules/vanilla-jsoneditor/node_modules/ajv/dist/vocabularies/core/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var id_1 = require_id();
    var ref_1 = require_ref();
    var core = [
      "$schema",
      "$id",
      "$defs",
      "$vocabulary",
      { keyword: "$comment" },
      "definitions",
      id_1.default,
      ref_1.default
    ];
    exports2.default = core;
  }
});

// node_modules/vanilla-jsoneditor/node_modules/ajv/dist/vocabularies/validation/limitNumber.js
var require_limitNumber = __commonJS({
  "node_modules/vanilla-jsoneditor/node_modules/ajv/dist/vocabularies/validation/limitNumber.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var ops = codegen_1.operators;
    var KWDs = {
      maximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
      minimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
      exclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
      exclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
    };
    var error = {
      message: ({ keyword: keyword2, schemaCode }) => (0, codegen_1.str)`must be ${KWDs[keyword2].okStr} ${schemaCode}`,
      params: ({ keyword: keyword2, schemaCode }) => (0, codegen_1._)`{comparison: ${KWDs[keyword2].okStr}, limit: ${schemaCode}}`
    };
    var def = {
      keyword: Object.keys(KWDs),
      type: "number",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword: keyword2, data, schemaCode } = cxt;
        cxt.fail$data((0, codegen_1._)`${data} ${KWDs[keyword2].fail} ${schemaCode} || isNaN(${data})`);
      }
    };
    exports2.default = def;
  }
});

// node_modules/vanilla-jsoneditor/node_modules/ajv/dist/vocabularies/validation/multipleOf.js
var require_multipleOf = __commonJS({
  "node_modules/vanilla-jsoneditor/node_modules/ajv/dist/vocabularies/validation/multipleOf.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must be multiple of ${schemaCode}`,
      params: ({ schemaCode }) => (0, codegen_1._)`{multipleOf: ${schemaCode}}`
    };
    var def = {
      keyword: "multipleOf",
      type: "number",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, schemaCode, it: it2 } = cxt;
        const prec2 = it2.opts.multipleOfPrecision;
        const res = gen.let("res");
        const invalid = prec2 ? (0, codegen_1._)`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec2}` : (0, codegen_1._)`${res} !== parseInt(${res})`;
        cxt.fail$data((0, codegen_1._)`(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);
      }
    };
    exports2.default = def;
  }
});

// node_modules/vanilla-jsoneditor/node_modules/ajv/dist/runtime/ucs2length.js
var require_ucs2length = __commonJS({
  "node_modules/vanilla-jsoneditor/node_modules/ajv/dist/runtime/ucs2length.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function ucs2length(str) {
      const len = str.length;
      let length = 0;
      let pos = 0;
      let value;
      while (pos < len) {
        length++;
        value = str.charCodeAt(pos++);
        if (value >= 55296 && value <= 56319 && pos < len) {
          value = str.charCodeAt(pos);
          if ((value & 64512) === 56320)
            pos++;
        }
      }
      return length;
    }
    exports2.default = ucs2length;
    ucs2length.code = 'require("ajv/dist/runtime/ucs2length").default';
  }
});

// node_modules/vanilla-jsoneditor/node_modules/ajv/dist/vocabularies/validation/limitLength.js
var require_limitLength = __commonJS({
  "node_modules/vanilla-jsoneditor/node_modules/ajv/dist/vocabularies/validation/limitLength.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var ucs2length_1 = require_ucs2length();
    var error = {
      message({ keyword: keyword2, schemaCode }) {
        const comp = keyword2 === "maxLength" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} characters`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    };
    var def = {
      keyword: ["maxLength", "minLength"],
      type: "string",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword: keyword2, data, schemaCode, it: it2 } = cxt;
        const op2 = keyword2 === "maxLength" ? codegen_1.operators.GT : codegen_1.operators.LT;
        const len = it2.opts.unicode === false ? (0, codegen_1._)`${data}.length` : (0, codegen_1._)`${(0, util_1.useFunc)(cxt.gen, ucs2length_1.default)}(${data})`;
        cxt.fail$data((0, codegen_1._)`${len} ${op2} ${schemaCode}`);
      }
    };
    exports2.default = def;
  }
});

// node_modules/vanilla-jsoneditor/node_modules/ajv/dist/vocabularies/validation/pattern.js
var require_pattern = __commonJS({
  "node_modules/vanilla-jsoneditor/node_modules/ajv/dist/vocabularies/validation/pattern.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var error = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must match pattern "${schemaCode}"`,
      params: ({ schemaCode }) => (0, codegen_1._)`{pattern: ${schemaCode}}`
    };
    var def = {
      keyword: "pattern",
      type: "string",
      schemaType: "string",
      $data: true,
      error,
      code(cxt) {
        const { data, $data, schema, schemaCode, it: it2 } = cxt;
        const u = it2.opts.unicodeRegExp ? "u" : "";
        const regExp = $data ? (0, codegen_1._)`(new RegExp(${schemaCode}, ${u}))` : (0, code_1.usePattern)(cxt, schema);
        cxt.fail$data((0, codegen_1._)`!${regExp}.test(${data})`);
      }
    };
    exports2.default = def;
  }
});

// node_modules/vanilla-jsoneditor/node_modules/ajv/dist/vocabularies/validation/limitProperties.js
var require_limitProperties = __commonJS({
  "node_modules/vanilla-jsoneditor/node_modules/ajv/dist/vocabularies/validation/limitProperties.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message({ keyword: keyword2, schemaCode }) {
        const comp = keyword2 === "maxProperties" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} properties`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    };
    var def = {
      keyword: ["maxProperties", "minProperties"],
      type: "object",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword: keyword2, data, schemaCode } = cxt;
        const op2 = keyword2 === "maxProperties" ? codegen_1.operators.GT : codegen_1.operators.LT;
        cxt.fail$data((0, codegen_1._)`Object.keys(${data}).length ${op2} ${schemaCode}`);
      }
    };
    exports2.default = def;
  }
});

// node_modules/vanilla-jsoneditor/node_modules/ajv/dist/vocabularies/validation/required.js
var require_required = __commonJS({
  "node_modules/vanilla-jsoneditor/node_modules/ajv/dist/vocabularies/validation/required.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: ({ params: { missingProperty } }) => (0, codegen_1.str)`must have required property '${missingProperty}'`,
      params: ({ params: { missingProperty } }) => (0, codegen_1._)`{missingProperty: ${missingProperty}}`
    };
    var def = {
      keyword: "required",
      type: "object",
      schemaType: "array",
      $data: true,
      error,
      code(cxt) {
        const { gen, schema, schemaCode, data, $data, it: it2 } = cxt;
        const { opts } = it2;
        if (!$data && schema.length === 0)
          return;
        const useLoop = schema.length >= opts.loopRequired;
        if (it2.allErrors)
          allErrorsMode();
        else
          exitOnErrorMode();
        if (opts.strictRequired) {
          const props = cxt.parentSchema.properties;
          const { definedProperties } = cxt.it;
          for (const requiredKey of schema) {
            if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === void 0 && !definedProperties.has(requiredKey)) {
              const schemaPath = it2.schemaEnv.baseId + it2.errSchemaPath;
              const msg = `required property "${requiredKey}" is not defined at "${schemaPath}" (strictRequired)`;
              (0, util_1.checkStrictMode)(it2, msg, it2.opts.strictRequired);
            }
          }
        }
        function allErrorsMode() {
          if (useLoop || $data) {
            cxt.block$data(codegen_1.nil, loopAllRequired);
          } else {
            for (const prop of schema) {
              (0, code_1.checkReportMissingProp)(cxt, prop);
            }
          }
        }
        function exitOnErrorMode() {
          const missing = gen.let("missing");
          if (useLoop || $data) {
            const valid = gen.let("valid", true);
            cxt.block$data(valid, () => loopUntilMissing(missing, valid));
            cxt.ok(valid);
          } else {
            gen.if((0, code_1.checkMissingProp)(cxt, schema, missing));
            (0, code_1.reportMissingProp)(cxt, missing);
            gen.else();
          }
        }
        function loopAllRequired() {
          gen.forOf("prop", schemaCode, (prop) => {
            cxt.setParams({ missingProperty: prop });
            gen.if((0, code_1.noPropertyInData)(gen, data, prop, opts.ownProperties), () => cxt.error());
          });
        }
        function loopUntilMissing(missing, valid) {
          cxt.setParams({ missingProperty: missing });
          gen.forOf(missing, schemaCode, () => {
            gen.assign(valid, (0, code_1.propertyInData)(gen, data, missing, opts.ownProperties));
            gen.if((0, codegen_1.not)(valid), () => {
              cxt.error();
              gen.break();
            });
          }, codegen_1.nil);
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/vanilla-jsoneditor/node_modules/ajv/dist/vocabularies/validation/limitItems.js
var require_limitItems = __commonJS({
  "node_modules/vanilla-jsoneditor/node_modules/ajv/dist/vocabularies/validation/limitItems.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message({ keyword: keyword2, schemaCode }) {
        const comp = keyword2 === "maxItems" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} items`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    };
    var def = {
      keyword: ["maxItems", "minItems"],
      type: "array",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword: keyword2, data, schemaCode } = cxt;
        const op2 = keyword2 === "maxItems" ? codegen_1.operators.GT : codegen_1.operators.LT;
        cxt.fail$data((0, codegen_1._)`${data}.length ${op2} ${schemaCode}`);
      }
    };
    exports2.default = def;
  }
});

// node_modules/vanilla-jsoneditor/node_modules/ajv/dist/runtime/equal.js
var require_equal = __commonJS({
  "node_modules/vanilla-jsoneditor/node_modules/ajv/dist/runtime/equal.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var equal = require_fast_deep_equal();
    equal.code = 'require("ajv/dist/runtime/equal").default';
    exports2.default = equal;
  }
});

// node_modules/vanilla-jsoneditor/node_modules/ajv/dist/vocabularies/validation/uniqueItems.js
var require_uniqueItems = __commonJS({
  "node_modules/vanilla-jsoneditor/node_modules/ajv/dist/vocabularies/validation/uniqueItems.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var dataType_1 = require_dataType();
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var equal_1 = require_equal();
    var error = {
      message: ({ params: { i: i2, j } }) => (0, codegen_1.str)`must NOT have duplicate items (items ## ${j} and ${i2} are identical)`,
      params: ({ params: { i: i2, j } }) => (0, codegen_1._)`{i: ${i2}, j: ${j}}`
    };
    var def = {
      keyword: "uniqueItems",
      type: "array",
      schemaType: "boolean",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, $data, schema, parentSchema, schemaCode, it: it2 } = cxt;
        if (!$data && !schema)
          return;
        const valid = gen.let("valid");
        const itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];
        cxt.block$data(valid, validateUniqueItems, (0, codegen_1._)`${schemaCode} === false`);
        cxt.ok(valid);
        function validateUniqueItems() {
          const i2 = gen.let("i", (0, codegen_1._)`${data}.length`);
          const j = gen.let("j");
          cxt.setParams({ i: i2, j });
          gen.assign(valid, true);
          gen.if((0, codegen_1._)`${i2} > 1`, () => (canOptimize() ? loopN : loopN2)(i2, j));
        }
        function canOptimize() {
          return itemTypes.length > 0 && !itemTypes.some((t3) => t3 === "object" || t3 === "array");
        }
        function loopN(i2, j) {
          const item = gen.name("item");
          const wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it2.opts.strictNumbers, dataType_1.DataType.Wrong);
          const indices = gen.const("indices", (0, codegen_1._)`{}`);
          gen.for((0, codegen_1._)`;${i2}--;`, () => {
            gen.let(item, (0, codegen_1._)`${data}[${i2}]`);
            gen.if(wrongType, (0, codegen_1._)`continue`);
            if (itemTypes.length > 1)
              gen.if((0, codegen_1._)`typeof ${item} == "string"`, (0, codegen_1._)`${item} += "_"`);
            gen.if((0, codegen_1._)`typeof ${indices}[${item}] == "number"`, () => {
              gen.assign(j, (0, codegen_1._)`${indices}[${item}]`);
              cxt.error();
              gen.assign(valid, false).break();
            }).code((0, codegen_1._)`${indices}[${item}] = ${i2}`);
          });
        }
        function loopN2(i2, j) {
          const eql = (0, util_1.useFunc)(gen, equal_1.default);
          const outer = gen.name("outer");
          gen.label(outer).for((0, codegen_1._)`;${i2}--;`, () => gen.for((0, codegen_1._)`${j} = ${i2}; ${j}--;`, () => gen.if((0, codegen_1._)`${eql}(${data}[${i2}], ${data}[${j}])`, () => {
            cxt.error();
            gen.assign(valid, false).break(outer);
          })));
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/vanilla-jsoneditor/node_modules/ajv/dist/vocabularies/validation/const.js
var require_const = __commonJS({
  "node_modules/vanilla-jsoneditor/node_modules/ajv/dist/vocabularies/validation/const.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var equal_1 = require_equal();
    var error = {
      message: "must be equal to constant",
      params: ({ schemaCode }) => (0, codegen_1._)`{allowedValue: ${schemaCode}}`
    };
    var def = {
      keyword: "const",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, $data, schemaCode, schema } = cxt;
        if ($data || schema && typeof schema == "object") {
          cxt.fail$data((0, codegen_1._)`!${(0, util_1.useFunc)(gen, equal_1.default)}(${data}, ${schemaCode})`);
        } else {
          cxt.fail((0, codegen_1._)`${schema} !== ${data}`);
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/vanilla-jsoneditor/node_modules/ajv/dist/vocabularies/validation/enum.js
var require_enum = __commonJS({
  "node_modules/vanilla-jsoneditor/node_modules/ajv/dist/vocabularies/validation/enum.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var equal_1 = require_equal();
    var error = {
      message: "must be equal to one of the allowed values",
      params: ({ schemaCode }) => (0, codegen_1._)`{allowedValues: ${schemaCode}}`
    };
    var def = {
      keyword: "enum",
      schemaType: "array",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, $data, schema, schemaCode, it: it2 } = cxt;
        if (!$data && schema.length === 0)
          throw new Error("enum must have non-empty array");
        const useLoop = schema.length >= it2.opts.loopEnum;
        let eql;
        const getEql = () => eql !== null && eql !== void 0 ? eql : eql = (0, util_1.useFunc)(gen, equal_1.default);
        let valid;
        if (useLoop || $data) {
          valid = gen.let("valid");
          cxt.block$data(valid, loopEnum);
        } else {
          if (!Array.isArray(schema))
            throw new Error("ajv implementation error");
          const vSchema = gen.const("vSchema", schemaCode);
          valid = (0, codegen_1.or)(...schema.map((_x2, i2) => equalCode(vSchema, i2)));
        }
        cxt.pass(valid);
        function loopEnum() {
          gen.assign(valid, false);
          gen.forOf("v", schemaCode, (v) => gen.if((0, codegen_1._)`${getEql()}(${data}, ${v})`, () => gen.assign(valid, true).break()));
        }
        function equalCode(vSchema, i2) {
          const sch = schema[i2];
          return typeof sch === "object" && sch !== null ? (0, codegen_1._)`${getEql()}(${data}, ${vSchema}[${i2}])` : (0, codegen_1._)`${data} === ${sch}`;
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/vanilla-jsoneditor/node_modules/ajv/dist/vocabularies/validation/index.js
var require_validation = __commonJS({
  "node_modules/vanilla-jsoneditor/node_modules/ajv/dist/vocabularies/validation/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var limitNumber_1 = require_limitNumber();
    var multipleOf_1 = require_multipleOf();
    var limitLength_1 = require_limitLength();
    var pattern_1 = require_pattern();
    var limitProperties_1 = require_limitProperties();
    var required_1 = require_required();
    var limitItems_1 = require_limitItems();
    var uniqueItems_1 = require_uniqueItems();
    var const_1 = require_const();
    var enum_1 = require_enum();
    var validation = [
      // number
      limitNumber_1.default,
      multipleOf_1.default,
      // string
      limitLength_1.default,
      pattern_1.default,
      // object
      limitProperties_1.default,
      required_1.default,
      // array
      limitItems_1.default,
      uniqueItems_1.default,
      // any
      { keyword: "type", schemaType: ["string", "array"] },
      { keyword: "nullable", schemaType: "boolean" },
      const_1.default,
      enum_1.default
    ];
    exports2.default = validation;
  }
});

// node_modules/vanilla-jsoneditor/node_modules/ajv/dist/vocabularies/applicator/additionalItems.js
var require_additionalItems = __commonJS({
  "node_modules/vanilla-jsoneditor/node_modules/ajv/dist/vocabularies/applicator/additionalItems.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateAdditionalItems = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
      params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
    };
    var def = {
      keyword: "additionalItems",
      type: "array",
      schemaType: ["boolean", "object"],
      before: "uniqueItems",
      error,
      code(cxt) {
        const { parentSchema, it: it2 } = cxt;
        const { items } = parentSchema;
        if (!Array.isArray(items)) {
          (0, util_1.checkStrictMode)(it2, '"additionalItems" is ignored when "items" is not an array of schemas');
          return;
        }
        validateAdditionalItems(cxt, items);
      }
    };
    function validateAdditionalItems(cxt, items) {
      const { gen, schema, data, keyword: keyword2, it: it2 } = cxt;
      it2.items = true;
      const len = gen.const("len", (0, codegen_1._)`${data}.length`);
      if (schema === false) {
        cxt.setParams({ len: items.length });
        cxt.pass((0, codegen_1._)`${len} <= ${items.length}`);
      } else if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it2, schema)) {
        const valid = gen.var("valid", (0, codegen_1._)`${len} <= ${items.length}`);
        gen.if((0, codegen_1.not)(valid), () => validateItems(valid));
        cxt.ok(valid);
      }
      function validateItems(valid) {
        gen.forRange("i", items.length, len, (i2) => {
          cxt.subschema({ keyword: keyword2, dataProp: i2, dataPropType: util_1.Type.Num }, valid);
          if (!it2.allErrors)
            gen.if((0, codegen_1.not)(valid), () => gen.break());
        });
      }
    }
    exports2.validateAdditionalItems = validateAdditionalItems;
    exports2.default = def;
  }
});

// node_modules/vanilla-jsoneditor/node_modules/ajv/dist/vocabularies/applicator/items.js
var require_items = __commonJS({
  "node_modules/vanilla-jsoneditor/node_modules/ajv/dist/vocabularies/applicator/items.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateTuple = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var code_1 = require_code2();
    var def = {
      keyword: "items",
      type: "array",
      schemaType: ["object", "array", "boolean"],
      before: "uniqueItems",
      code(cxt) {
        const { schema, it: it2 } = cxt;
        if (Array.isArray(schema))
          return validateTuple(cxt, "additionalItems", schema);
        it2.items = true;
        if ((0, util_1.alwaysValidSchema)(it2, schema))
          return;
        cxt.ok((0, code_1.validateArray)(cxt));
      }
    };
    function validateTuple(cxt, extraItems, schArr = cxt.schema) {
      const { gen, parentSchema, data, keyword: keyword2, it: it2 } = cxt;
      checkStrictTuple(parentSchema);
      if (it2.opts.unevaluated && schArr.length && it2.items !== true) {
        it2.items = util_1.mergeEvaluated.items(gen, schArr.length, it2.items);
      }
      const valid = gen.name("valid");
      const len = gen.const("len", (0, codegen_1._)`${data}.length`);
      schArr.forEach((sch, i2) => {
        if ((0, util_1.alwaysValidSchema)(it2, sch))
          return;
        gen.if((0, codegen_1._)`${len} > ${i2}`, () => cxt.subschema({
          keyword: keyword2,
          schemaProp: i2,
          dataProp: i2
        }, valid));
        cxt.ok(valid);
      });
      function checkStrictTuple(sch) {
        const { opts, errSchemaPath } = it2;
        const l = schArr.length;
        const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);
        if (opts.strictTuples && !fullTuple) {
          const msg = `"${keyword2}" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path "${errSchemaPath}"`;
          (0, util_1.checkStrictMode)(it2, msg, opts.strictTuples);
        }
      }
    }
    exports2.validateTuple = validateTuple;
    exports2.default = def;
  }
});

// node_modules/vanilla-jsoneditor/node_modules/ajv/dist/vocabularies/applicator/prefixItems.js
var require_prefixItems = __commonJS({
  "node_modules/vanilla-jsoneditor/node_modules/ajv/dist/vocabularies/applicator/prefixItems.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var items_1 = require_items();
    var def = {
      keyword: "prefixItems",
      type: "array",
      schemaType: ["array"],
      before: "uniqueItems",
      code: (cxt) => (0, items_1.validateTuple)(cxt, "items")
    };
    exports2.default = def;
  }
});

// node_modules/vanilla-jsoneditor/node_modules/ajv/dist/vocabularies/applicator/items2020.js
var require_items2020 = __commonJS({
  "node_modules/vanilla-jsoneditor/node_modules/ajv/dist/vocabularies/applicator/items2020.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var code_1 = require_code2();
    var additionalItems_1 = require_additionalItems();
    var error = {
      message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
      params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
    };
    var def = {
      keyword: "items",
      type: "array",
      schemaType: ["object", "boolean"],
      before: "uniqueItems",
      error,
      code(cxt) {
        const { schema, parentSchema, it: it2 } = cxt;
        const { prefixItems } = parentSchema;
        it2.items = true;
        if ((0, util_1.alwaysValidSchema)(it2, schema))
          return;
        if (prefixItems)
          (0, additionalItems_1.validateAdditionalItems)(cxt, prefixItems);
        else
          cxt.ok((0, code_1.validateArray)(cxt));
      }
    };
    exports2.default = def;
  }
});

// node_modules/vanilla-jsoneditor/node_modules/ajv/dist/vocabularies/applicator/contains.js
var require_contains = __commonJS({
  "node_modules/vanilla-jsoneditor/node_modules/ajv/dist/vocabularies/applicator/contains.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1.str)`must contain at least ${min} valid item(s)` : (0, codegen_1.str)`must contain at least ${min} and no more than ${max} valid item(s)`,
      params: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1._)`{minContains: ${min}}` : (0, codegen_1._)`{minContains: ${min}, maxContains: ${max}}`
    };
    var def = {
      keyword: "contains",
      type: "array",
      schemaType: ["object", "boolean"],
      before: "uniqueItems",
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, schema, parentSchema, data, it: it2 } = cxt;
        let min;
        let max;
        const { minContains, maxContains } = parentSchema;
        if (it2.opts.next) {
          min = minContains === void 0 ? 1 : minContains;
          max = maxContains;
        } else {
          min = 1;
        }
        const len = gen.const("len", (0, codegen_1._)`${data}.length`);
        cxt.setParams({ min, max });
        if (max === void 0 && min === 0) {
          (0, util_1.checkStrictMode)(it2, `"minContains" == 0 without "maxContains": "contains" keyword ignored`);
          return;
        }
        if (max !== void 0 && min > max) {
          (0, util_1.checkStrictMode)(it2, `"minContains" > "maxContains" is always invalid`);
          cxt.fail();
          return;
        }
        if ((0, util_1.alwaysValidSchema)(it2, schema)) {
          let cond = (0, codegen_1._)`${len} >= ${min}`;
          if (max !== void 0)
            cond = (0, codegen_1._)`${cond} && ${len} <= ${max}`;
          cxt.pass(cond);
          return;
        }
        it2.items = true;
        const valid = gen.name("valid");
        if (max === void 0 && min === 1) {
          validateItems(valid, () => gen.if(valid, () => gen.break()));
        } else if (min === 0) {
          gen.let(valid, true);
          if (max !== void 0)
            gen.if((0, codegen_1._)`${data}.length > 0`, validateItemsWithCount);
        } else {
          gen.let(valid, false);
          validateItemsWithCount();
        }
        cxt.result(valid, () => cxt.reset());
        function validateItemsWithCount() {
          const schValid = gen.name("_valid");
          const count = gen.let("count", 0);
          validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));
        }
        function validateItems(_valid, block) {
          gen.forRange("i", 0, len, (i2) => {
            cxt.subschema({
              keyword: "contains",
              dataProp: i2,
              dataPropType: util_1.Type.Num,
              compositeRule: true
            }, _valid);
            block();
          });
        }
        function checkLimits(count) {
          gen.code((0, codegen_1._)`${count}++`);
          if (max === void 0) {
            gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, true).break());
          } else {
            gen.if((0, codegen_1._)`${count} > ${max}`, () => gen.assign(valid, false).break());
            if (min === 1)
              gen.assign(valid, true);
            else
              gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, true));
          }
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/vanilla-jsoneditor/node_modules/ajv/dist/vocabularies/applicator/dependencies.js
var require_dependencies = __commonJS({
  "node_modules/vanilla-jsoneditor/node_modules/ajv/dist/vocabularies/applicator/dependencies.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateSchemaDeps = exports2.validatePropertyDeps = exports2.error = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var code_1 = require_code2();
    exports2.error = {
      message: ({ params: { property, depsCount, deps } }) => {
        const property_ies = depsCount === 1 ? "property" : "properties";
        return (0, codegen_1.str)`must have ${property_ies} ${deps} when property ${property} is present`;
      },
      params: ({ params: { property, depsCount, deps, missingProperty } }) => (0, codegen_1._)`{property: ${property},
    missingProperty: ${missingProperty},
    depsCount: ${depsCount},
    deps: ${deps}}`
      // TODO change to reference
    };
    var def = {
      keyword: "dependencies",
      type: "object",
      schemaType: "object",
      error: exports2.error,
      code(cxt) {
        const [propDeps, schDeps] = splitDependencies(cxt);
        validatePropertyDeps(cxt, propDeps);
        validateSchemaDeps(cxt, schDeps);
      }
    };
    function splitDependencies({ schema }) {
      const propertyDeps = {};
      const schemaDeps = {};
      for (const key in schema) {
        if (key === "__proto__")
          continue;
        const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps;
        deps[key] = schema[key];
      }
      return [propertyDeps, schemaDeps];
    }
    function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {
      const { gen, data, it: it2 } = cxt;
      if (Object.keys(propertyDeps).length === 0)
        return;
      const missing = gen.let("missing");
      for (const prop in propertyDeps) {
        const deps = propertyDeps[prop];
        if (deps.length === 0)
          continue;
        const hasProperty = (0, code_1.propertyInData)(gen, data, prop, it2.opts.ownProperties);
        cxt.setParams({
          property: prop,
          depsCount: deps.length,
          deps: deps.join(", ")
        });
        if (it2.allErrors) {
          gen.if(hasProperty, () => {
            for (const depProp of deps) {
              (0, code_1.checkReportMissingProp)(cxt, depProp);
            }
          });
        } else {
          gen.if((0, codegen_1._)`${hasProperty} && (${(0, code_1.checkMissingProp)(cxt, deps, missing)})`);
          (0, code_1.reportMissingProp)(cxt, missing);
          gen.else();
        }
      }
    }
    exports2.validatePropertyDeps = validatePropertyDeps;
    function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {
      const { gen, data, keyword: keyword2, it: it2 } = cxt;
      const valid = gen.name("valid");
      for (const prop in schemaDeps) {
        if ((0, util_1.alwaysValidSchema)(it2, schemaDeps[prop]))
          continue;
        gen.if(
          (0, code_1.propertyInData)(gen, data, prop, it2.opts.ownProperties),
          () => {
            const schCxt = cxt.subschema({ keyword: keyword2, schemaProp: prop }, valid);
            cxt.mergeValidEvaluated(schCxt, valid);
          },
          () => gen.var(valid, true)
          // TODO var
        );
        cxt.ok(valid);
      }
    }
    exports2.validateSchemaDeps = validateSchemaDeps;
    exports2.default = def;
  }
});

// node_modules/vanilla-jsoneditor/node_modules/ajv/dist/vocabularies/applicator/propertyNames.js
var require_propertyNames = __commonJS({
  "node_modules/vanilla-jsoneditor/node_modules/ajv/dist/vocabularies/applicator/propertyNames.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: "property name must be valid",
      params: ({ params }) => (0, codegen_1._)`{propertyName: ${params.propertyName}}`
    };
    var def = {
      keyword: "propertyNames",
      type: "object",
      schemaType: ["object", "boolean"],
      error,
      code(cxt) {
        const { gen, schema, data, it: it2 } = cxt;
        if ((0, util_1.alwaysValidSchema)(it2, schema))
          return;
        const valid = gen.name("valid");
        gen.forIn("key", data, (key) => {
          cxt.setParams({ propertyName: key });
          cxt.subschema({
            keyword: "propertyNames",
            data: key,
            dataTypes: ["string"],
            propertyName: key,
            compositeRule: true
          }, valid);
          gen.if((0, codegen_1.not)(valid), () => {
            cxt.error(true);
            if (!it2.allErrors)
              gen.break();
          });
        });
        cxt.ok(valid);
      }
    };
    exports2.default = def;
  }
});

// node_modules/vanilla-jsoneditor/node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js
var require_additionalProperties = __commonJS({
  "node_modules/vanilla-jsoneditor/node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var util_1 = require_util();
    var error = {
      message: "must NOT have additional properties",
      params: ({ params }) => (0, codegen_1._)`{additionalProperty: ${params.additionalProperty}}`
    };
    var def = {
      keyword: "additionalProperties",
      type: ["object"],
      schemaType: ["boolean", "object"],
      allowUndefined: true,
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, schema, parentSchema, data, errsCount, it: it2 } = cxt;
        if (!errsCount)
          throw new Error("ajv implementation error");
        const { allErrors, opts } = it2;
        it2.props = true;
        if (opts.removeAdditional !== "all" && (0, util_1.alwaysValidSchema)(it2, schema))
          return;
        const props = (0, code_1.allSchemaProperties)(parentSchema.properties);
        const patProps = (0, code_1.allSchemaProperties)(parentSchema.patternProperties);
        checkAdditionalProperties();
        cxt.ok((0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
        function checkAdditionalProperties() {
          gen.forIn("key", data, (key) => {
            if (!props.length && !patProps.length)
              additionalPropertyCode(key);
            else
              gen.if(isAdditional(key), () => additionalPropertyCode(key));
          });
        }
        function isAdditional(key) {
          let definedProp;
          if (props.length > 8) {
            const propsSchema = (0, util_1.schemaRefOrVal)(it2, parentSchema.properties, "properties");
            definedProp = (0, code_1.isOwnProperty)(gen, propsSchema, key);
          } else if (props.length) {
            definedProp = (0, codegen_1.or)(...props.map((p) => (0, codegen_1._)`${key} === ${p}`));
          } else {
            definedProp = codegen_1.nil;
          }
          if (patProps.length) {
            definedProp = (0, codegen_1.or)(definedProp, ...patProps.map((p) => (0, codegen_1._)`${(0, code_1.usePattern)(cxt, p)}.test(${key})`));
          }
          return (0, codegen_1.not)(definedProp);
        }
        function deleteAdditional(key) {
          gen.code((0, codegen_1._)`delete ${data}[${key}]`);
        }
        function additionalPropertyCode(key) {
          if (opts.removeAdditional === "all" || opts.removeAdditional && schema === false) {
            deleteAdditional(key);
            return;
          }
          if (schema === false) {
            cxt.setParams({ additionalProperty: key });
            cxt.error();
            if (!allErrors)
              gen.break();
            return;
          }
          if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it2, schema)) {
            const valid = gen.name("valid");
            if (opts.removeAdditional === "failing") {
              applyAdditionalSchema(key, valid, false);
              gen.if((0, codegen_1.not)(valid), () => {
                cxt.reset();
                deleteAdditional(key);
              });
            } else {
              applyAdditionalSchema(key, valid);
              if (!allErrors)
                gen.if((0, codegen_1.not)(valid), () => gen.break());
            }
          }
        }
        function applyAdditionalSchema(key, valid, errors) {
          const subschema = {
            keyword: "additionalProperties",
            dataProp: key,
            dataPropType: util_1.Type.Str
          };
          if (errors === false) {
            Object.assign(subschema, {
              compositeRule: true,
              createErrors: false,
              allErrors: false
            });
          }
          cxt.subschema(subschema, valid);
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/vanilla-jsoneditor/node_modules/ajv/dist/vocabularies/applicator/properties.js
var require_properties = __commonJS({
  "node_modules/vanilla-jsoneditor/node_modules/ajv/dist/vocabularies/applicator/properties.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var validate_1 = require_validate();
    var code_1 = require_code2();
    var util_1 = require_util();
    var additionalProperties_1 = require_additionalProperties();
    var def = {
      keyword: "properties",
      type: "object",
      schemaType: "object",
      code(cxt) {
        const { gen, schema, parentSchema, data, it: it2 } = cxt;
        if (it2.opts.removeAdditional === "all" && parentSchema.additionalProperties === void 0) {
          additionalProperties_1.default.code(new validate_1.KeywordCxt(it2, additionalProperties_1.default, "additionalProperties"));
        }
        const allProps = (0, code_1.allSchemaProperties)(schema);
        for (const prop of allProps) {
          it2.definedProperties.add(prop);
        }
        if (it2.opts.unevaluated && allProps.length && it2.props !== true) {
          it2.props = util_1.mergeEvaluated.props(gen, (0, util_1.toHash)(allProps), it2.props);
        }
        const properties = allProps.filter((p) => !(0, util_1.alwaysValidSchema)(it2, schema[p]));
        if (properties.length === 0)
          return;
        const valid = gen.name("valid");
        for (const prop of properties) {
          if (hasDefault(prop)) {
            applyPropertySchema(prop);
          } else {
            gen.if((0, code_1.propertyInData)(gen, data, prop, it2.opts.ownProperties));
            applyPropertySchema(prop);
            if (!it2.allErrors)
              gen.else().var(valid, true);
            gen.endIf();
          }
          cxt.it.definedProperties.add(prop);
          cxt.ok(valid);
        }
        function hasDefault(prop) {
          return it2.opts.useDefaults && !it2.compositeRule && schema[prop].default !== void 0;
        }
        function applyPropertySchema(prop) {
          cxt.subschema({
            keyword: "properties",
            schemaProp: prop,
            dataProp: prop
          }, valid);
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/vanilla-jsoneditor/node_modules/ajv/dist/vocabularies/applicator/patternProperties.js
var require_patternProperties = __commonJS({
  "node_modules/vanilla-jsoneditor/node_modules/ajv/dist/vocabularies/applicator/patternProperties.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var util_2 = require_util();
    var def = {
      keyword: "patternProperties",
      type: "object",
      schemaType: "object",
      code(cxt) {
        const { gen, schema, data, parentSchema, it: it2 } = cxt;
        const { opts } = it2;
        const patterns = (0, code_1.allSchemaProperties)(schema);
        const alwaysValidPatterns = patterns.filter((p) => (0, util_1.alwaysValidSchema)(it2, schema[p]));
        if (patterns.length === 0 || alwaysValidPatterns.length === patterns.length && (!it2.opts.unevaluated || it2.props === true)) {
          return;
        }
        const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;
        const valid = gen.name("valid");
        if (it2.props !== true && !(it2.props instanceof codegen_1.Name)) {
          it2.props = (0, util_2.evaluatedPropsToName)(gen, it2.props);
        }
        const { props } = it2;
        validatePatternProperties();
        function validatePatternProperties() {
          for (const pat of patterns) {
            if (checkProperties)
              checkMatchingProperties(pat);
            if (it2.allErrors) {
              validateProperties(pat);
            } else {
              gen.var(valid, true);
              validateProperties(pat);
              gen.if(valid);
            }
          }
        }
        function checkMatchingProperties(pat) {
          for (const prop in checkProperties) {
            if (new RegExp(pat).test(prop)) {
              (0, util_1.checkStrictMode)(it2, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);
            }
          }
        }
        function validateProperties(pat) {
          gen.forIn("key", data, (key) => {
            gen.if((0, codegen_1._)`${(0, code_1.usePattern)(cxt, pat)}.test(${key})`, () => {
              const alwaysValid = alwaysValidPatterns.includes(pat);
              if (!alwaysValid) {
                cxt.subschema({
                  keyword: "patternProperties",
                  schemaProp: pat,
                  dataProp: key,
                  dataPropType: util_2.Type.Str
                }, valid);
              }
              if (it2.opts.unevaluated && props !== true) {
                gen.assign((0, codegen_1._)`${props}[${key}]`, true);
              } else if (!alwaysValid && !it2.allErrors) {
                gen.if((0, codegen_1.not)(valid), () => gen.break());
              }
            });
          });
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/vanilla-jsoneditor/node_modules/ajv/dist/vocabularies/applicator/not.js
var require_not = __commonJS({
  "node_modules/vanilla-jsoneditor/node_modules/ajv/dist/vocabularies/applicator/not.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var util_1 = require_util();
    var def = {
      keyword: "not",
      schemaType: ["object", "boolean"],
      trackErrors: true,
      code(cxt) {
        const { gen, schema, it: it2 } = cxt;
        if ((0, util_1.alwaysValidSchema)(it2, schema)) {
          cxt.fail();
          return;
        }
        const valid = gen.name("valid");
        cxt.subschema({
          keyword: "not",
          compositeRule: true,
          createErrors: false,
          allErrors: false
        }, valid);
        cxt.failResult(valid, () => cxt.reset(), () => cxt.error());
      },
      error: { message: "must NOT be valid" }
    };
    exports2.default = def;
  }
});

// node_modules/vanilla-jsoneditor/node_modules/ajv/dist/vocabularies/applicator/anyOf.js
var require_anyOf = __commonJS({
  "node_modules/vanilla-jsoneditor/node_modules/ajv/dist/vocabularies/applicator/anyOf.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var code_1 = require_code2();
    var def = {
      keyword: "anyOf",
      schemaType: "array",
      trackErrors: true,
      code: code_1.validateUnion,
      error: { message: "must match a schema in anyOf" }
    };
    exports2.default = def;
  }
});

// node_modules/vanilla-jsoneditor/node_modules/ajv/dist/vocabularies/applicator/oneOf.js
var require_oneOf = __commonJS({
  "node_modules/vanilla-jsoneditor/node_modules/ajv/dist/vocabularies/applicator/oneOf.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: "must match exactly one schema in oneOf",
      params: ({ params }) => (0, codegen_1._)`{passingSchemas: ${params.passing}}`
    };
    var def = {
      keyword: "oneOf",
      schemaType: "array",
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, schema, parentSchema, it: it2 } = cxt;
        if (!Array.isArray(schema))
          throw new Error("ajv implementation error");
        if (it2.opts.discriminator && parentSchema.discriminator)
          return;
        const schArr = schema;
        const valid = gen.let("valid", false);
        const passing = gen.let("passing", null);
        const schValid = gen.name("_valid");
        cxt.setParams({ passing });
        gen.block(validateOneOf);
        cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
        function validateOneOf() {
          schArr.forEach((sch, i2) => {
            let schCxt;
            if ((0, util_1.alwaysValidSchema)(it2, sch)) {
              gen.var(schValid, true);
            } else {
              schCxt = cxt.subschema({
                keyword: "oneOf",
                schemaProp: i2,
                compositeRule: true
              }, schValid);
            }
            if (i2 > 0) {
              gen.if((0, codegen_1._)`${schValid} && ${valid}`).assign(valid, false).assign(passing, (0, codegen_1._)`[${passing}, ${i2}]`).else();
            }
            gen.if(schValid, () => {
              gen.assign(valid, true);
              gen.assign(passing, i2);
              if (schCxt)
                cxt.mergeEvaluated(schCxt, codegen_1.Name);
            });
          });
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/vanilla-jsoneditor/node_modules/ajv/dist/vocabularies/applicator/allOf.js
var require_allOf = __commonJS({
  "node_modules/vanilla-jsoneditor/node_modules/ajv/dist/vocabularies/applicator/allOf.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var util_1 = require_util();
    var def = {
      keyword: "allOf",
      schemaType: "array",
      code(cxt) {
        const { gen, schema, it: it2 } = cxt;
        if (!Array.isArray(schema))
          throw new Error("ajv implementation error");
        const valid = gen.name("valid");
        schema.forEach((sch, i2) => {
          if ((0, util_1.alwaysValidSchema)(it2, sch))
            return;
          const schCxt = cxt.subschema({ keyword: "allOf", schemaProp: i2 }, valid);
          cxt.ok(valid);
          cxt.mergeEvaluated(schCxt);
        });
      }
    };
    exports2.default = def;
  }
});

// node_modules/vanilla-jsoneditor/node_modules/ajv/dist/vocabularies/applicator/if.js
var require_if = __commonJS({
  "node_modules/vanilla-jsoneditor/node_modules/ajv/dist/vocabularies/applicator/if.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: ({ params }) => (0, codegen_1.str)`must match "${params.ifClause}" schema`,
      params: ({ params }) => (0, codegen_1._)`{failingKeyword: ${params.ifClause}}`
    };
    var def = {
      keyword: "if",
      schemaType: ["object", "boolean"],
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, parentSchema, it: it2 } = cxt;
        if (parentSchema.then === void 0 && parentSchema.else === void 0) {
          (0, util_1.checkStrictMode)(it2, '"if" without "then" and "else" is ignored');
        }
        const hasThen = hasSchema(it2, "then");
        const hasElse = hasSchema(it2, "else");
        if (!hasThen && !hasElse)
          return;
        const valid = gen.let("valid", true);
        const schValid = gen.name("_valid");
        validateIf();
        cxt.reset();
        if (hasThen && hasElse) {
          const ifClause = gen.let("ifClause");
          cxt.setParams({ ifClause });
          gen.if(schValid, validateClause("then", ifClause), validateClause("else", ifClause));
        } else if (hasThen) {
          gen.if(schValid, validateClause("then"));
        } else {
          gen.if((0, codegen_1.not)(schValid), validateClause("else"));
        }
        cxt.pass(valid, () => cxt.error(true));
        function validateIf() {
          const schCxt = cxt.subschema({
            keyword: "if",
            compositeRule: true,
            createErrors: false,
            allErrors: false
          }, schValid);
          cxt.mergeEvaluated(schCxt);
        }
        function validateClause(keyword2, ifClause) {
          return () => {
            const schCxt = cxt.subschema({ keyword: keyword2 }, schValid);
            gen.assign(valid, schValid);
            cxt.mergeValidEvaluated(schCxt, valid);
            if (ifClause)
              gen.assign(ifClause, (0, codegen_1._)`${keyword2}`);
            else
              cxt.setParams({ ifClause: keyword2 });
          };
        }
      }
    };
    function hasSchema(it2, keyword2) {
      const schema = it2.schema[keyword2];
      return schema !== void 0 && !(0, util_1.alwaysValidSchema)(it2, schema);
    }
    exports2.default = def;
  }
});

// node_modules/vanilla-jsoneditor/node_modules/ajv/dist/vocabularies/applicator/thenElse.js
var require_thenElse = __commonJS({
  "node_modules/vanilla-jsoneditor/node_modules/ajv/dist/vocabularies/applicator/thenElse.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var util_1 = require_util();
    var def = {
      keyword: ["then", "else"],
      schemaType: ["object", "boolean"],
      code({ keyword: keyword2, parentSchema, it: it2 }) {
        if (parentSchema.if === void 0)
          (0, util_1.checkStrictMode)(it2, `"${keyword2}" without "if" is ignored`);
      }
    };
    exports2.default = def;
  }
});

// node_modules/vanilla-jsoneditor/node_modules/ajv/dist/vocabularies/applicator/index.js
var require_applicator = __commonJS({
  "node_modules/vanilla-jsoneditor/node_modules/ajv/dist/vocabularies/applicator/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var additionalItems_1 = require_additionalItems();
    var prefixItems_1 = require_prefixItems();
    var items_1 = require_items();
    var items2020_1 = require_items2020();
    var contains_1 = require_contains();
    var dependencies_1 = require_dependencies();
    var propertyNames_1 = require_propertyNames();
    var additionalProperties_1 = require_additionalProperties();
    var properties_1 = require_properties();
    var patternProperties_1 = require_patternProperties();
    var not_1 = require_not();
    var anyOf_1 = require_anyOf();
    var oneOf_1 = require_oneOf();
    var allOf_1 = require_allOf();
    var if_1 = require_if();
    var thenElse_1 = require_thenElse();
    function getApplicator(draft2020 = false) {
      const applicator = [
        // any
        not_1.default,
        anyOf_1.default,
        oneOf_1.default,
        allOf_1.default,
        if_1.default,
        thenElse_1.default,
        // object
        propertyNames_1.default,
        additionalProperties_1.default,
        dependencies_1.default,
        properties_1.default,
        patternProperties_1.default
      ];
      if (draft2020)
        applicator.push(prefixItems_1.default, items2020_1.default);
      else
        applicator.push(additionalItems_1.default, items_1.default);
      applicator.push(contains_1.default);
      return applicator;
    }
    exports2.default = getApplicator;
  }
});

// node_modules/vanilla-jsoneditor/node_modules/ajv/dist/vocabularies/format/format.js
var require_format = __commonJS({
  "node_modules/vanilla-jsoneditor/node_modules/ajv/dist/vocabularies/format/format.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must match format "${schemaCode}"`,
      params: ({ schemaCode }) => (0, codegen_1._)`{format: ${schemaCode}}`
    };
    var def = {
      keyword: "format",
      type: ["number", "string"],
      schemaType: "string",
      $data: true,
      error,
      code(cxt, ruleType) {
        const { gen, data, $data, schema, schemaCode, it: it2 } = cxt;
        const { opts, errSchemaPath, schemaEnv, self: self2 } = it2;
        if (!opts.validateFormats)
          return;
        if ($data)
          validate$DataFormat();
        else
          validateFormat();
        function validate$DataFormat() {
          const fmts = gen.scopeValue("formats", {
            ref: self2.formats,
            code: opts.code.formats
          });
          const fDef = gen.const("fDef", (0, codegen_1._)`${fmts}[${schemaCode}]`);
          const fType = gen.let("fType");
          const format = gen.let("format");
          gen.if((0, codegen_1._)`typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, (0, codegen_1._)`${fDef}.type || "string"`).assign(format, (0, codegen_1._)`${fDef}.validate`), () => gen.assign(fType, (0, codegen_1._)`"string"`).assign(format, fDef));
          cxt.fail$data((0, codegen_1.or)(unknownFmt(), invalidFmt()));
          function unknownFmt() {
            if (opts.strictSchema === false)
              return codegen_1.nil;
            return (0, codegen_1._)`${schemaCode} && !${format}`;
          }
          function invalidFmt() {
            const callFormat = schemaEnv.$async ? (0, codegen_1._)`(${fDef}.async ? await ${format}(${data}) : ${format}(${data}))` : (0, codegen_1._)`${format}(${data})`;
            const validData = (0, codegen_1._)`(typeof ${format} == "function" ? ${callFormat} : ${format}.test(${data}))`;
            return (0, codegen_1._)`${format} && ${format} !== true && ${fType} === ${ruleType} && !${validData}`;
          }
        }
        function validateFormat() {
          const formatDef = self2.formats[schema];
          if (!formatDef) {
            unknownFormat();
            return;
          }
          if (formatDef === true)
            return;
          const [fmtType, format, fmtRef] = getFormat(formatDef);
          if (fmtType === ruleType)
            cxt.pass(validCondition());
          function unknownFormat() {
            if (opts.strictSchema === false) {
              self2.logger.warn(unknownMsg());
              return;
            }
            throw new Error(unknownMsg());
            function unknownMsg() {
              return `unknown format "${schema}" ignored in schema at path "${errSchemaPath}"`;
            }
          }
          function getFormat(fmtDef) {
            const code = fmtDef instanceof RegExp ? (0, codegen_1.regexpCode)(fmtDef) : opts.code.formats ? (0, codegen_1._)`${opts.code.formats}${(0, codegen_1.getProperty)(schema)}` : void 0;
            const fmt = gen.scopeValue("formats", { key: schema, ref: fmtDef, code });
            if (typeof fmtDef == "object" && !(fmtDef instanceof RegExp)) {
              return [fmtDef.type || "string", fmtDef.validate, (0, codegen_1._)`${fmt}.validate`];
            }
            return ["string", fmtDef, fmt];
          }
          function validCondition() {
            if (typeof formatDef == "object" && !(formatDef instanceof RegExp) && formatDef.async) {
              if (!schemaEnv.$async)
                throw new Error("async format in sync schema");
              return (0, codegen_1._)`await ${fmtRef}(${data})`;
            }
            return typeof format == "function" ? (0, codegen_1._)`${fmtRef}(${data})` : (0, codegen_1._)`${fmtRef}.test(${data})`;
          }
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/vanilla-jsoneditor/node_modules/ajv/dist/vocabularies/format/index.js
var require_format2 = __commonJS({
  "node_modules/vanilla-jsoneditor/node_modules/ajv/dist/vocabularies/format/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var format_1 = require_format();
    var format = [format_1.default];
    exports2.default = format;
  }
});

// node_modules/vanilla-jsoneditor/node_modules/ajv/dist/vocabularies/metadata.js
var require_metadata = __commonJS({
  "node_modules/vanilla-jsoneditor/node_modules/ajv/dist/vocabularies/metadata.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.contentVocabulary = exports2.metadataVocabulary = void 0;
    exports2.metadataVocabulary = [
      "title",
      "description",
      "default",
      "deprecated",
      "readOnly",
      "writeOnly",
      "examples"
    ];
    exports2.contentVocabulary = [
      "contentMediaType",
      "contentEncoding",
      "contentSchema"
    ];
  }
});

// node_modules/vanilla-jsoneditor/node_modules/ajv/dist/vocabularies/draft7.js
var require_draft7 = __commonJS({
  "node_modules/vanilla-jsoneditor/node_modules/ajv/dist/vocabularies/draft7.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var core_1 = require_core2();
    var validation_1 = require_validation();
    var applicator_1 = require_applicator();
    var format_1 = require_format2();
    var metadata_1 = require_metadata();
    var draft7Vocabularies = [
      core_1.default,
      validation_1.default,
      (0, applicator_1.default)(),
      format_1.default,
      metadata_1.metadataVocabulary,
      metadata_1.contentVocabulary
    ];
    exports2.default = draft7Vocabularies;
  }
});

// node_modules/vanilla-jsoneditor/node_modules/ajv/dist/vocabularies/discriminator/types.js
var require_types = __commonJS({
  "node_modules/vanilla-jsoneditor/node_modules/ajv/dist/vocabularies/discriminator/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DiscrError = void 0;
    var DiscrError;
    (function(DiscrError2) {
      DiscrError2["Tag"] = "tag";
      DiscrError2["Mapping"] = "mapping";
    })(DiscrError || (exports2.DiscrError = DiscrError = {}));
  }
});

// node_modules/vanilla-jsoneditor/node_modules/ajv/dist/vocabularies/discriminator/index.js
var require_discriminator = __commonJS({
  "node_modules/vanilla-jsoneditor/node_modules/ajv/dist/vocabularies/discriminator/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var types_1 = require_types();
    var compile_1 = require_compile();
    var ref_error_1 = require_ref_error();
    var util_1 = require_util();
    var error = {
      message: ({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag ? `tag "${tagName}" must be string` : `value of tag "${tagName}" must be in oneOf`,
      params: ({ params: { discrError, tag, tagName } }) => (0, codegen_1._)`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`
    };
    var def = {
      keyword: "discriminator",
      type: "object",
      schemaType: "object",
      error,
      code(cxt) {
        const { gen, data, schema, parentSchema, it: it2 } = cxt;
        const { oneOf } = parentSchema;
        if (!it2.opts.discriminator) {
          throw new Error("discriminator: requires discriminator option");
        }
        const tagName = schema.propertyName;
        if (typeof tagName != "string")
          throw new Error("discriminator: requires propertyName");
        if (schema.mapping)
          throw new Error("discriminator: mapping is not supported");
        if (!oneOf)
          throw new Error("discriminator: requires oneOf keyword");
        const valid = gen.let("valid", false);
        const tag = gen.const("tag", (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(tagName)}`);
        gen.if((0, codegen_1._)`typeof ${tag} == "string"`, () => validateMapping(), () => cxt.error(false, { discrError: types_1.DiscrError.Tag, tag, tagName }));
        cxt.ok(valid);
        function validateMapping() {
          const mapping = getMapping();
          gen.if(false);
          for (const tagValue in mapping) {
            gen.elseIf((0, codegen_1._)`${tag} === ${tagValue}`);
            gen.assign(valid, applyTagSchema(mapping[tagValue]));
          }
          gen.else();
          cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag, tagName });
          gen.endIf();
        }
        function applyTagSchema(schemaProp) {
          const _valid = gen.name("valid");
          const schCxt = cxt.subschema({ keyword: "oneOf", schemaProp }, _valid);
          cxt.mergeEvaluated(schCxt, codegen_1.Name);
          return _valid;
        }
        function getMapping() {
          var _a4;
          const oneOfMapping = {};
          const topRequired = hasRequired(parentSchema);
          let tagRequired = true;
          for (let i2 = 0; i2 < oneOf.length; i2++) {
            let sch = oneOf[i2];
            if ((sch === null || sch === void 0 ? void 0 : sch.$ref) && !(0, util_1.schemaHasRulesButRef)(sch, it2.self.RULES)) {
              const ref2 = sch.$ref;
              sch = compile_1.resolveRef.call(it2.self, it2.schemaEnv.root, it2.baseId, ref2);
              if (sch instanceof compile_1.SchemaEnv)
                sch = sch.schema;
              if (sch === void 0)
                throw new ref_error_1.default(it2.opts.uriResolver, it2.baseId, ref2);
            }
            const propSch = (_a4 = sch === null || sch === void 0 ? void 0 : sch.properties) === null || _a4 === void 0 ? void 0 : _a4[tagName];
            if (typeof propSch != "object") {
              throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${tagName}"`);
            }
            tagRequired = tagRequired && (topRequired || hasRequired(sch));
            addMappings(propSch, i2);
          }
          if (!tagRequired)
            throw new Error(`discriminator: "${tagName}" must be required`);
          return oneOfMapping;
          function hasRequired({ required }) {
            return Array.isArray(required) && required.includes(tagName);
          }
          function addMappings(sch, i2) {
            if (sch.const) {
              addMapping(sch.const, i2);
            } else if (sch.enum) {
              for (const tagValue of sch.enum) {
                addMapping(tagValue, i2);
              }
            } else {
              throw new Error(`discriminator: "properties/${tagName}" must have "const" or "enum"`);
            }
          }
          function addMapping(tagValue, i2) {
            if (typeof tagValue != "string" || tagValue in oneOfMapping) {
              throw new Error(`discriminator: "${tagName}" values must be unique strings`);
            }
            oneOfMapping[tagValue] = i2;
          }
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/vanilla-jsoneditor/node_modules/ajv/dist/refs/json-schema-draft-07.json
var require_json_schema_draft_07 = __commonJS({
  "node_modules/vanilla-jsoneditor/node_modules/ajv/dist/refs/json-schema-draft-07.json"(exports2, module2) {
    module2.exports = {
      $schema: "http://json-schema.org/draft-07/schema#",
      $id: "http://json-schema.org/draft-07/schema#",
      title: "Core schema meta-schema",
      definitions: {
        schemaArray: {
          type: "array",
          minItems: 1,
          items: { $ref: "#" }
        },
        nonNegativeInteger: {
          type: "integer",
          minimum: 0
        },
        nonNegativeIntegerDefault0: {
          allOf: [{ $ref: "#/definitions/nonNegativeInteger" }, { default: 0 }]
        },
        simpleTypes: {
          enum: ["array", "boolean", "integer", "null", "number", "object", "string"]
        },
        stringArray: {
          type: "array",
          items: { type: "string" },
          uniqueItems: true,
          default: []
        }
      },
      type: ["object", "boolean"],
      properties: {
        $id: {
          type: "string",
          format: "uri-reference"
        },
        $schema: {
          type: "string",
          format: "uri"
        },
        $ref: {
          type: "string",
          format: "uri-reference"
        },
        $comment: {
          type: "string"
        },
        title: {
          type: "string"
        },
        description: {
          type: "string"
        },
        default: true,
        readOnly: {
          type: "boolean",
          default: false
        },
        examples: {
          type: "array",
          items: true
        },
        multipleOf: {
          type: "number",
          exclusiveMinimum: 0
        },
        maximum: {
          type: "number"
        },
        exclusiveMaximum: {
          type: "number"
        },
        minimum: {
          type: "number"
        },
        exclusiveMinimum: {
          type: "number"
        },
        maxLength: { $ref: "#/definitions/nonNegativeInteger" },
        minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        pattern: {
          type: "string",
          format: "regex"
        },
        additionalItems: { $ref: "#" },
        items: {
          anyOf: [{ $ref: "#" }, { $ref: "#/definitions/schemaArray" }],
          default: true
        },
        maxItems: { $ref: "#/definitions/nonNegativeInteger" },
        minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        uniqueItems: {
          type: "boolean",
          default: false
        },
        contains: { $ref: "#" },
        maxProperties: { $ref: "#/definitions/nonNegativeInteger" },
        minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        required: { $ref: "#/definitions/stringArray" },
        additionalProperties: { $ref: "#" },
        definitions: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        properties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        patternProperties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          propertyNames: { format: "regex" },
          default: {}
        },
        dependencies: {
          type: "object",
          additionalProperties: {
            anyOf: [{ $ref: "#" }, { $ref: "#/definitions/stringArray" }]
          }
        },
        propertyNames: { $ref: "#" },
        const: true,
        enum: {
          type: "array",
          items: true,
          minItems: 1,
          uniqueItems: true
        },
        type: {
          anyOf: [
            { $ref: "#/definitions/simpleTypes" },
            {
              type: "array",
              items: { $ref: "#/definitions/simpleTypes" },
              minItems: 1,
              uniqueItems: true
            }
          ]
        },
        format: { type: "string" },
        contentMediaType: { type: "string" },
        contentEncoding: { type: "string" },
        if: { $ref: "#" },
        then: { $ref: "#" },
        else: { $ref: "#" },
        allOf: { $ref: "#/definitions/schemaArray" },
        anyOf: { $ref: "#/definitions/schemaArray" },
        oneOf: { $ref: "#/definitions/schemaArray" },
        not: { $ref: "#" }
      },
      default: true
    };
  }
});

// node_modules/vanilla-jsoneditor/node_modules/ajv/dist/ajv.js
var require_ajv = __commonJS({
  "node_modules/vanilla-jsoneditor/node_modules/ajv/dist/ajv.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MissingRefError = exports2.ValidationError = exports2.CodeGen = exports2.Name = exports2.nil = exports2.stringify = exports2.str = exports2._ = exports2.KeywordCxt = exports2.Ajv = void 0;
    var core_1 = require_core();
    var draft7_1 = require_draft7();
    var discriminator_1 = require_discriminator();
    var draft7MetaSchema = require_json_schema_draft_07();
    var META_SUPPORT_DATA = ["/properties"];
    var META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
    var Ajv = class extends core_1.default {
      _addVocabularies() {
        super._addVocabularies();
        draft7_1.default.forEach((v) => this.addVocabulary(v));
        if (this.opts.discriminator)
          this.addKeyword(discriminator_1.default);
      }
      _addDefaultMetaSchema() {
        super._addDefaultMetaSchema();
        if (!this.opts.meta)
          return;
        const metaSchema = this.opts.$data ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA) : draft7MetaSchema;
        this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);
        this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
      }
      defaultMeta() {
        return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0);
      }
    };
    exports2.Ajv = Ajv;
    module2.exports = exports2 = Ajv;
    module2.exports.Ajv = Ajv;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = Ajv;
    var validate_1 = require_validate();
    Object.defineProperty(exports2, "KeywordCxt", { enumerable: true, get: function() {
      return validate_1.KeywordCxt;
    } });
    var codegen_1 = require_codegen();
    Object.defineProperty(exports2, "_", { enumerable: true, get: function() {
      return codegen_1._;
    } });
    Object.defineProperty(exports2, "str", { enumerable: true, get: function() {
      return codegen_1.str;
    } });
    Object.defineProperty(exports2, "stringify", { enumerable: true, get: function() {
      return codegen_1.stringify;
    } });
    Object.defineProperty(exports2, "nil", { enumerable: true, get: function() {
      return codegen_1.nil;
    } });
    Object.defineProperty(exports2, "Name", { enumerable: true, get: function() {
      return codegen_1.Name;
    } });
    Object.defineProperty(exports2, "CodeGen", { enumerable: true, get: function() {
      return codegen_1.CodeGen;
    } });
    var validation_error_1 = require_validation_error();
    Object.defineProperty(exports2, "ValidationError", { enumerable: true, get: function() {
      return validation_error_1.default;
    } });
    var ref_error_1 = require_ref_error();
    Object.defineProperty(exports2, "MissingRefError", { enumerable: true, get: function() {
      return ref_error_1.default;
    } });
  }
});

// node_modules/jmespath/jmespath.js
var require_jmespath = __commonJS({
  "node_modules/jmespath/jmespath.js"(exports2) {
    (function(exports3) {
      "use strict";
      function isArray(obj) {
        if (obj !== null) {
          return Object.prototype.toString.call(obj) === "[object Array]";
        } else {
          return false;
        }
      }
      function isObject(obj) {
        if (obj !== null) {
          return Object.prototype.toString.call(obj) === "[object Object]";
        } else {
          return false;
        }
      }
      function strictDeepEqual(first, second) {
        if (first === second) {
          return true;
        }
        var firstType = Object.prototype.toString.call(first);
        if (firstType !== Object.prototype.toString.call(second)) {
          return false;
        }
        if (isArray(first) === true) {
          if (first.length !== second.length) {
            return false;
          }
          for (var i2 = 0; i2 < first.length; i2++) {
            if (strictDeepEqual(first[i2], second[i2]) === false) {
              return false;
            }
          }
          return true;
        }
        if (isObject(first) === true) {
          var keysSeen = {};
          for (var key in first) {
            if (hasOwnProperty.call(first, key)) {
              if (strictDeepEqual(first[key], second[key]) === false) {
                return false;
              }
              keysSeen[key] = true;
            }
          }
          for (var key2 in second) {
            if (hasOwnProperty.call(second, key2)) {
              if (keysSeen[key2] !== true) {
                return false;
              }
            }
          }
          return true;
        }
        return false;
      }
      function isFalse(obj) {
        if (obj === "" || obj === false || obj === null) {
          return true;
        } else if (isArray(obj) && obj.length === 0) {
          return true;
        } else if (isObject(obj)) {
          for (var key in obj) {
            if (obj.hasOwnProperty(key)) {
              return false;
            }
          }
          return true;
        } else {
          return false;
        }
      }
      function objValues(obj) {
        var keys2 = Object.keys(obj);
        var values = [];
        for (var i2 = 0; i2 < keys2.length; i2++) {
          values.push(obj[keys2[i2]]);
        }
        return values;
      }
      function merge(a2, b2) {
        var merged = {};
        for (var key in a2) {
          merged[key] = a2[key];
        }
        for (var key2 in b2) {
          merged[key2] = b2[key2];
        }
        return merged;
      }
      var trimLeft;
      if (typeof String.prototype.trimLeft === "function") {
        trimLeft = function(str) {
          return str.trimLeft();
        };
      } else {
        trimLeft = function(str) {
          return str.match(/^\s*(.*)/)[1];
        };
      }
      var TYPE_NUMBER = 0;
      var TYPE_ANY = 1;
      var TYPE_STRING = 2;
      var TYPE_ARRAY = 3;
      var TYPE_OBJECT = 4;
      var TYPE_BOOLEAN = 5;
      var TYPE_EXPREF = 6;
      var TYPE_NULL = 7;
      var TYPE_ARRAY_NUMBER = 8;
      var TYPE_ARRAY_STRING = 9;
      var TYPE_NAME_TABLE = {
        0: "number",
        1: "any",
        2: "string",
        3: "array",
        4: "object",
        5: "boolean",
        6: "expression",
        7: "null",
        8: "Array<number>",
        9: "Array<string>"
      };
      var TOK_EOF = "EOF";
      var TOK_UNQUOTEDIDENTIFIER = "UnquotedIdentifier";
      var TOK_QUOTEDIDENTIFIER = "QuotedIdentifier";
      var TOK_RBRACKET = "Rbracket";
      var TOK_RPAREN = "Rparen";
      var TOK_COMMA = "Comma";
      var TOK_COLON = "Colon";
      var TOK_RBRACE = "Rbrace";
      var TOK_NUMBER = "Number";
      var TOK_CURRENT = "Current";
      var TOK_EXPREF = "Expref";
      var TOK_PIPE = "Pipe";
      var TOK_OR = "Or";
      var TOK_AND = "And";
      var TOK_EQ = "EQ";
      var TOK_GT = "GT";
      var TOK_LT = "LT";
      var TOK_GTE = "GTE";
      var TOK_LTE = "LTE";
      var TOK_NE = "NE";
      var TOK_FLATTEN = "Flatten";
      var TOK_STAR = "Star";
      var TOK_FILTER = "Filter";
      var TOK_DOT = "Dot";
      var TOK_NOT = "Not";
      var TOK_LBRACE = "Lbrace";
      var TOK_LBRACKET = "Lbracket";
      var TOK_LPAREN = "Lparen";
      var TOK_LITERAL = "Literal";
      var basicTokens = {
        ".": TOK_DOT,
        "*": TOK_STAR,
        ",": TOK_COMMA,
        ":": TOK_COLON,
        "{": TOK_LBRACE,
        "}": TOK_RBRACE,
        "]": TOK_RBRACKET,
        "(": TOK_LPAREN,
        ")": TOK_RPAREN,
        "@": TOK_CURRENT
      };
      var operatorStartToken = {
        "<": true,
        ">": true,
        "=": true,
        "!": true
      };
      var skipChars = {
        " ": true,
        "	": true,
        "\n": true
      };
      function isAlpha(ch2) {
        return ch2 >= "a" && ch2 <= "z" || ch2 >= "A" && ch2 <= "Z" || ch2 === "_";
      }
      function isNum(ch2) {
        return ch2 >= "0" && ch2 <= "9" || ch2 === "-";
      }
      function isAlphaNum(ch2) {
        return ch2 >= "a" && ch2 <= "z" || ch2 >= "A" && ch2 <= "Z" || ch2 >= "0" && ch2 <= "9" || ch2 === "_";
      }
      function Lexer() {
      }
      Lexer.prototype = {
        tokenize: function(stream) {
          var tokens = [];
          this._current = 0;
          var start;
          var identifier;
          var token;
          while (this._current < stream.length) {
            if (isAlpha(stream[this._current])) {
              start = this._current;
              identifier = this._consumeUnquotedIdentifier(stream);
              tokens.push({
                type: TOK_UNQUOTEDIDENTIFIER,
                value: identifier,
                start
              });
            } else if (basicTokens[stream[this._current]] !== void 0) {
              tokens.push({
                type: basicTokens[stream[this._current]],
                value: stream[this._current],
                start: this._current
              });
              this._current++;
            } else if (isNum(stream[this._current])) {
              token = this._consumeNumber(stream);
              tokens.push(token);
            } else if (stream[this._current] === "[") {
              token = this._consumeLBracket(stream);
              tokens.push(token);
            } else if (stream[this._current] === '"') {
              start = this._current;
              identifier = this._consumeQuotedIdentifier(stream);
              tokens.push({
                type: TOK_QUOTEDIDENTIFIER,
                value: identifier,
                start
              });
            } else if (stream[this._current] === "'") {
              start = this._current;
              identifier = this._consumeRawStringLiteral(stream);
              tokens.push({
                type: TOK_LITERAL,
                value: identifier,
                start
              });
            } else if (stream[this._current] === "`") {
              start = this._current;
              var literal2 = this._consumeLiteral(stream);
              tokens.push({
                type: TOK_LITERAL,
                value: literal2,
                start
              });
            } else if (operatorStartToken[stream[this._current]] !== void 0) {
              tokens.push(this._consumeOperator(stream));
            } else if (skipChars[stream[this._current]] !== void 0) {
              this._current++;
            } else if (stream[this._current] === "&") {
              start = this._current;
              this._current++;
              if (stream[this._current] === "&") {
                this._current++;
                tokens.push({ type: TOK_AND, value: "&&", start });
              } else {
                tokens.push({ type: TOK_EXPREF, value: "&", start });
              }
            } else if (stream[this._current] === "|") {
              start = this._current;
              this._current++;
              if (stream[this._current] === "|") {
                this._current++;
                tokens.push({ type: TOK_OR, value: "||", start });
              } else {
                tokens.push({ type: TOK_PIPE, value: "|", start });
              }
            } else {
              var error = new Error("Unknown character:" + stream[this._current]);
              error.name = "LexerError";
              throw error;
            }
          }
          return tokens;
        },
        _consumeUnquotedIdentifier: function(stream) {
          var start = this._current;
          this._current++;
          while (this._current < stream.length && isAlphaNum(stream[this._current])) {
            this._current++;
          }
          return stream.slice(start, this._current);
        },
        _consumeQuotedIdentifier: function(stream) {
          var start = this._current;
          this._current++;
          var maxLength = stream.length;
          while (stream[this._current] !== '"' && this._current < maxLength) {
            var current = this._current;
            if (stream[current] === "\\" && (stream[current + 1] === "\\" || stream[current + 1] === '"')) {
              current += 2;
            } else {
              current++;
            }
            this._current = current;
          }
          this._current++;
          return JSON.parse(stream.slice(start, this._current));
        },
        _consumeRawStringLiteral: function(stream) {
          var start = this._current;
          this._current++;
          var maxLength = stream.length;
          while (stream[this._current] !== "'" && this._current < maxLength) {
            var current = this._current;
            if (stream[current] === "\\" && (stream[current + 1] === "\\" || stream[current + 1] === "'")) {
              current += 2;
            } else {
              current++;
            }
            this._current = current;
          }
          this._current++;
          var literal2 = stream.slice(start + 1, this._current - 1);
          return literal2.replace("\\'", "'");
        },
        _consumeNumber: function(stream) {
          var start = this._current;
          this._current++;
          var maxLength = stream.length;
          while (isNum(stream[this._current]) && this._current < maxLength) {
            this._current++;
          }
          var value = parseInt(stream.slice(start, this._current));
          return { type: TOK_NUMBER, value, start };
        },
        _consumeLBracket: function(stream) {
          var start = this._current;
          this._current++;
          if (stream[this._current] === "?") {
            this._current++;
            return { type: TOK_FILTER, value: "[?", start };
          } else if (stream[this._current] === "]") {
            this._current++;
            return { type: TOK_FLATTEN, value: "[]", start };
          } else {
            return { type: TOK_LBRACKET, value: "[", start };
          }
        },
        _consumeOperator: function(stream) {
          var start = this._current;
          var startingChar = stream[start];
          this._current++;
          if (startingChar === "!") {
            if (stream[this._current] === "=") {
              this._current++;
              return { type: TOK_NE, value: "!=", start };
            } else {
              return { type: TOK_NOT, value: "!", start };
            }
          } else if (startingChar === "<") {
            if (stream[this._current] === "=") {
              this._current++;
              return { type: TOK_LTE, value: "<=", start };
            } else {
              return { type: TOK_LT, value: "<", start };
            }
          } else if (startingChar === ">") {
            if (stream[this._current] === "=") {
              this._current++;
              return { type: TOK_GTE, value: ">=", start };
            } else {
              return { type: TOK_GT, value: ">", start };
            }
          } else if (startingChar === "=") {
            if (stream[this._current] === "=") {
              this._current++;
              return { type: TOK_EQ, value: "==", start };
            }
          }
        },
        _consumeLiteral: function(stream) {
          this._current++;
          var start = this._current;
          var maxLength = stream.length;
          var literal2;
          while (stream[this._current] !== "`" && this._current < maxLength) {
            var current = this._current;
            if (stream[current] === "\\" && (stream[current + 1] === "\\" || stream[current + 1] === "`")) {
              current += 2;
            } else {
              current++;
            }
            this._current = current;
          }
          var literalString = trimLeft(stream.slice(start, this._current));
          literalString = literalString.replace("\\`", "`");
          if (this._looksLikeJSON(literalString)) {
            literal2 = JSON.parse(literalString);
          } else {
            literal2 = JSON.parse('"' + literalString + '"');
          }
          this._current++;
          return literal2;
        },
        _looksLikeJSON: function(literalString) {
          var startingChars = '[{"';
          var jsonLiterals = ["true", "false", "null"];
          var numberLooking = "-0123456789";
          if (literalString === "") {
            return false;
          } else if (startingChars.indexOf(literalString[0]) >= 0) {
            return true;
          } else if (jsonLiterals.indexOf(literalString) >= 0) {
            return true;
          } else if (numberLooking.indexOf(literalString[0]) >= 0) {
            try {
              JSON.parse(literalString);
              return true;
            } catch (ex2) {
              return false;
            }
          } else {
            return false;
          }
        }
      };
      var bindingPower = {};
      bindingPower[TOK_EOF] = 0;
      bindingPower[TOK_UNQUOTEDIDENTIFIER] = 0;
      bindingPower[TOK_QUOTEDIDENTIFIER] = 0;
      bindingPower[TOK_RBRACKET] = 0;
      bindingPower[TOK_RPAREN] = 0;
      bindingPower[TOK_COMMA] = 0;
      bindingPower[TOK_RBRACE] = 0;
      bindingPower[TOK_NUMBER] = 0;
      bindingPower[TOK_CURRENT] = 0;
      bindingPower[TOK_EXPREF] = 0;
      bindingPower[TOK_PIPE] = 1;
      bindingPower[TOK_OR] = 2;
      bindingPower[TOK_AND] = 3;
      bindingPower[TOK_EQ] = 5;
      bindingPower[TOK_GT] = 5;
      bindingPower[TOK_LT] = 5;
      bindingPower[TOK_GTE] = 5;
      bindingPower[TOK_LTE] = 5;
      bindingPower[TOK_NE] = 5;
      bindingPower[TOK_FLATTEN] = 9;
      bindingPower[TOK_STAR] = 20;
      bindingPower[TOK_FILTER] = 21;
      bindingPower[TOK_DOT] = 40;
      bindingPower[TOK_NOT] = 45;
      bindingPower[TOK_LBRACE] = 50;
      bindingPower[TOK_LBRACKET] = 55;
      bindingPower[TOK_LPAREN] = 60;
      function Parser2() {
      }
      Parser2.prototype = {
        parse: function(expression) {
          this._loadTokens(expression);
          this.index = 0;
          var ast = this.expression(0);
          if (this._lookahead(0) !== TOK_EOF) {
            var t3 = this._lookaheadToken(0);
            var error = new Error(
              "Unexpected token type: " + t3.type + ", value: " + t3.value
            );
            error.name = "ParserError";
            throw error;
          }
          return ast;
        },
        _loadTokens: function(expression) {
          var lexer = new Lexer();
          var tokens = lexer.tokenize(expression);
          tokens.push({ type: TOK_EOF, value: "", start: expression.length });
          this.tokens = tokens;
        },
        expression: function(rbp) {
          var leftToken = this._lookaheadToken(0);
          this._advance();
          var left = this.nud(leftToken);
          var currentToken = this._lookahead(0);
          while (rbp < bindingPower[currentToken]) {
            this._advance();
            left = this.led(currentToken, left);
            currentToken = this._lookahead(0);
          }
          return left;
        },
        _lookahead: function(number2) {
          return this.tokens[this.index + number2].type;
        },
        _lookaheadToken: function(number2) {
          return this.tokens[this.index + number2];
        },
        _advance: function() {
          this.index++;
        },
        nud: function(token) {
          var left;
          var right;
          var expression;
          switch (token.type) {
            case TOK_LITERAL:
              return { type: "Literal", value: token.value };
            case TOK_UNQUOTEDIDENTIFIER:
              return { type: "Field", name: token.value };
            case TOK_QUOTEDIDENTIFIER:
              var node = { type: "Field", name: token.value };
              if (this._lookahead(0) === TOK_LPAREN) {
                throw new Error("Quoted identifier not allowed for function names.");
              }
              return node;
            case TOK_NOT:
              right = this.expression(bindingPower.Not);
              return { type: "NotExpression", children: [right] };
            case TOK_STAR:
              left = { type: "Identity" };
              right = null;
              if (this._lookahead(0) === TOK_RBRACKET) {
                right = { type: "Identity" };
              } else {
                right = this._parseProjectionRHS(bindingPower.Star);
              }
              return { type: "ValueProjection", children: [left, right] };
            case TOK_FILTER:
              return this.led(token.type, { type: "Identity" });
            case TOK_LBRACE:
              return this._parseMultiselectHash();
            case TOK_FLATTEN:
              left = { type: TOK_FLATTEN, children: [{ type: "Identity" }] };
              right = this._parseProjectionRHS(bindingPower.Flatten);
              return { type: "Projection", children: [left, right] };
            case TOK_LBRACKET:
              if (this._lookahead(0) === TOK_NUMBER || this._lookahead(0) === TOK_COLON) {
                right = this._parseIndexExpression();
                return this._projectIfSlice({ type: "Identity" }, right);
              } else if (this._lookahead(0) === TOK_STAR && this._lookahead(1) === TOK_RBRACKET) {
                this._advance();
                this._advance();
                right = this._parseProjectionRHS(bindingPower.Star);
                return {
                  type: "Projection",
                  children: [{ type: "Identity" }, right]
                };
              }
              return this._parseMultiselectList();
            case TOK_CURRENT:
              return { type: TOK_CURRENT };
            case TOK_EXPREF:
              expression = this.expression(bindingPower.Expref);
              return { type: "ExpressionReference", children: [expression] };
            case TOK_LPAREN:
              var args = [];
              while (this._lookahead(0) !== TOK_RPAREN) {
                if (this._lookahead(0) === TOK_CURRENT) {
                  expression = { type: TOK_CURRENT };
                  this._advance();
                } else {
                  expression = this.expression(0);
                }
                args.push(expression);
              }
              this._match(TOK_RPAREN);
              return args[0];
            default:
              this._errorToken(token);
          }
        },
        led: function(tokenName, left) {
          var right;
          switch (tokenName) {
            case TOK_DOT:
              var rbp = bindingPower.Dot;
              if (this._lookahead(0) !== TOK_STAR) {
                right = this._parseDotRHS(rbp);
                return { type: "Subexpression", children: [left, right] };
              }
              this._advance();
              right = this._parseProjectionRHS(rbp);
              return { type: "ValueProjection", children: [left, right] };
            case TOK_PIPE:
              right = this.expression(bindingPower.Pipe);
              return { type: TOK_PIPE, children: [left, right] };
            case TOK_OR:
              right = this.expression(bindingPower.Or);
              return { type: "OrExpression", children: [left, right] };
            case TOK_AND:
              right = this.expression(bindingPower.And);
              return { type: "AndExpression", children: [left, right] };
            case TOK_LPAREN:
              var name2 = left.name;
              var args = [];
              var expression, node;
              while (this._lookahead(0) !== TOK_RPAREN) {
                if (this._lookahead(0) === TOK_CURRENT) {
                  expression = { type: TOK_CURRENT };
                  this._advance();
                } else {
                  expression = this.expression(0);
                }
                if (this._lookahead(0) === TOK_COMMA) {
                  this._match(TOK_COMMA);
                }
                args.push(expression);
              }
              this._match(TOK_RPAREN);
              node = { type: "Function", name: name2, children: args };
              return node;
            case TOK_FILTER:
              var condition = this.expression(0);
              this._match(TOK_RBRACKET);
              if (this._lookahead(0) === TOK_FLATTEN) {
                right = { type: "Identity" };
              } else {
                right = this._parseProjectionRHS(bindingPower.Filter);
              }
              return { type: "FilterProjection", children: [left, right, condition] };
            case TOK_FLATTEN:
              var leftNode = { type: TOK_FLATTEN, children: [left] };
              var rightNode = this._parseProjectionRHS(bindingPower.Flatten);
              return { type: "Projection", children: [leftNode, rightNode] };
            case TOK_EQ:
            case TOK_NE:
            case TOK_GT:
            case TOK_GTE:
            case TOK_LT:
            case TOK_LTE:
              return this._parseComparator(left, tokenName);
            case TOK_LBRACKET:
              var token = this._lookaheadToken(0);
              if (token.type === TOK_NUMBER || token.type === TOK_COLON) {
                right = this._parseIndexExpression();
                return this._projectIfSlice(left, right);
              }
              this._match(TOK_STAR);
              this._match(TOK_RBRACKET);
              right = this._parseProjectionRHS(bindingPower.Star);
              return { type: "Projection", children: [left, right] };
            default:
              this._errorToken(this._lookaheadToken(0));
          }
        },
        _match: function(tokenType) {
          if (this._lookahead(0) === tokenType) {
            this._advance();
          } else {
            var t3 = this._lookaheadToken(0);
            var error = new Error("Expected " + tokenType + ", got: " + t3.type);
            error.name = "ParserError";
            throw error;
          }
        },
        _errorToken: function(token) {
          var error = new Error("Invalid token (" + token.type + '): "' + token.value + '"');
          error.name = "ParserError";
          throw error;
        },
        _parseIndexExpression: function() {
          if (this._lookahead(0) === TOK_COLON || this._lookahead(1) === TOK_COLON) {
            return this._parseSliceExpression();
          } else {
            var node = {
              type: "Index",
              value: this._lookaheadToken(0).value
            };
            this._advance();
            this._match(TOK_RBRACKET);
            return node;
          }
        },
        _projectIfSlice: function(left, right) {
          var indexExpr = { type: "IndexExpression", children: [left, right] };
          if (right.type === "Slice") {
            return {
              type: "Projection",
              children: [indexExpr, this._parseProjectionRHS(bindingPower.Star)]
            };
          } else {
            return indexExpr;
          }
        },
        _parseSliceExpression: function() {
          var parts = [null, null, null];
          var index2 = 0;
          var currentToken = this._lookahead(0);
          while (currentToken !== TOK_RBRACKET && index2 < 3) {
            if (currentToken === TOK_COLON) {
              index2++;
              this._advance();
            } else if (currentToken === TOK_NUMBER) {
              parts[index2] = this._lookaheadToken(0).value;
              this._advance();
            } else {
              var t3 = this._lookahead(0);
              var error = new Error("Syntax error, unexpected token: " + t3.value + "(" + t3.type + ")");
              error.name = "Parsererror";
              throw error;
            }
            currentToken = this._lookahead(0);
          }
          this._match(TOK_RBRACKET);
          return {
            type: "Slice",
            children: parts
          };
        },
        _parseComparator: function(left, comparator) {
          var right = this.expression(bindingPower[comparator]);
          return { type: "Comparator", name: comparator, children: [left, right] };
        },
        _parseDotRHS: function(rbp) {
          var lookahead = this._lookahead(0);
          var exprTokens = [TOK_UNQUOTEDIDENTIFIER, TOK_QUOTEDIDENTIFIER, TOK_STAR];
          if (exprTokens.indexOf(lookahead) >= 0) {
            return this.expression(rbp);
          } else if (lookahead === TOK_LBRACKET) {
            this._match(TOK_LBRACKET);
            return this._parseMultiselectList();
          } else if (lookahead === TOK_LBRACE) {
            this._match(TOK_LBRACE);
            return this._parseMultiselectHash();
          }
        },
        _parseProjectionRHS: function(rbp) {
          var right;
          if (bindingPower[this._lookahead(0)] < 10) {
            right = { type: "Identity" };
          } else if (this._lookahead(0) === TOK_LBRACKET) {
            right = this.expression(rbp);
          } else if (this._lookahead(0) === TOK_FILTER) {
            right = this.expression(rbp);
          } else if (this._lookahead(0) === TOK_DOT) {
            this._match(TOK_DOT);
            right = this._parseDotRHS(rbp);
          } else {
            var t3 = this._lookaheadToken(0);
            var error = new Error("Sytanx error, unexpected token: " + t3.value + "(" + t3.type + ")");
            error.name = "ParserError";
            throw error;
          }
          return right;
        },
        _parseMultiselectList: function() {
          var expressions = [];
          while (this._lookahead(0) !== TOK_RBRACKET) {
            var expression = this.expression(0);
            expressions.push(expression);
            if (this._lookahead(0) === TOK_COMMA) {
              this._match(TOK_COMMA);
              if (this._lookahead(0) === TOK_RBRACKET) {
                throw new Error("Unexpected token Rbracket");
              }
            }
          }
          this._match(TOK_RBRACKET);
          return { type: "MultiSelectList", children: expressions };
        },
        _parseMultiselectHash: function() {
          var pairs = [];
          var identifierTypes = [TOK_UNQUOTEDIDENTIFIER, TOK_QUOTEDIDENTIFIER];
          var keyToken, keyName2, value, node;
          for (; ; ) {
            keyToken = this._lookaheadToken(0);
            if (identifierTypes.indexOf(keyToken.type) < 0) {
              throw new Error("Expecting an identifier token, got: " + keyToken.type);
            }
            keyName2 = keyToken.value;
            this._advance();
            this._match(TOK_COLON);
            value = this.expression(0);
            node = { type: "KeyValuePair", name: keyName2, value };
            pairs.push(node);
            if (this._lookahead(0) === TOK_COMMA) {
              this._match(TOK_COMMA);
            } else if (this._lookahead(0) === TOK_RBRACE) {
              this._match(TOK_RBRACE);
              break;
            }
          }
          return { type: "MultiSelectHash", children: pairs };
        }
      };
      function TreeInterpreter(runtime) {
        this.runtime = runtime;
      }
      TreeInterpreter.prototype = {
        search: function(node, value) {
          return this.visit(node, value);
        },
        visit: function(node, value) {
          var matched, current, result, first, second, field, left, right, collected, i2;
          switch (node.type) {
            case "Field":
              if (value !== null && isObject(value)) {
                field = value[node.name];
                if (field === void 0) {
                  return null;
                } else {
                  return field;
                }
              }
              return null;
            case "Subexpression":
              result = this.visit(node.children[0], value);
              for (i2 = 1; i2 < node.children.length; i2++) {
                result = this.visit(node.children[1], result);
                if (result === null) {
                  return null;
                }
              }
              return result;
            case "IndexExpression":
              left = this.visit(node.children[0], value);
              right = this.visit(node.children[1], left);
              return right;
            case "Index":
              if (!isArray(value)) {
                return null;
              }
              var index2 = node.value;
              if (index2 < 0) {
                index2 = value.length + index2;
              }
              result = value[index2];
              if (result === void 0) {
                result = null;
              }
              return result;
            case "Slice":
              if (!isArray(value)) {
                return null;
              }
              var sliceParams = node.children.slice(0);
              var computed2 = this.computeSliceParams(value.length, sliceParams);
              var start = computed2[0];
              var stop = computed2[1];
              var step = computed2[2];
              result = [];
              if (step > 0) {
                for (i2 = start; i2 < stop; i2 += step) {
                  result.push(value[i2]);
                }
              } else {
                for (i2 = start; i2 > stop; i2 += step) {
                  result.push(value[i2]);
                }
              }
              return result;
            case "Projection":
              var base2 = this.visit(node.children[0], value);
              if (!isArray(base2)) {
                return null;
              }
              collected = [];
              for (i2 = 0; i2 < base2.length; i2++) {
                current = this.visit(node.children[1], base2[i2]);
                if (current !== null) {
                  collected.push(current);
                }
              }
              return collected;
            case "ValueProjection":
              base2 = this.visit(node.children[0], value);
              if (!isObject(base2)) {
                return null;
              }
              collected = [];
              var values = objValues(base2);
              for (i2 = 0; i2 < values.length; i2++) {
                current = this.visit(node.children[1], values[i2]);
                if (current !== null) {
                  collected.push(current);
                }
              }
              return collected;
            case "FilterProjection":
              base2 = this.visit(node.children[0], value);
              if (!isArray(base2)) {
                return null;
              }
              var filtered = [];
              var finalResults = [];
              for (i2 = 0; i2 < base2.length; i2++) {
                matched = this.visit(node.children[2], base2[i2]);
                if (!isFalse(matched)) {
                  filtered.push(base2[i2]);
                }
              }
              for (var j = 0; j < filtered.length; j++) {
                current = this.visit(node.children[1], filtered[j]);
                if (current !== null) {
                  finalResults.push(current);
                }
              }
              return finalResults;
            case "Comparator":
              first = this.visit(node.children[0], value);
              second = this.visit(node.children[1], value);
              switch (node.name) {
                case TOK_EQ:
                  result = strictDeepEqual(first, second);
                  break;
                case TOK_NE:
                  result = !strictDeepEqual(first, second);
                  break;
                case TOK_GT:
                  result = first > second;
                  break;
                case TOK_GTE:
                  result = first >= second;
                  break;
                case TOK_LT:
                  result = first < second;
                  break;
                case TOK_LTE:
                  result = first <= second;
                  break;
                default:
                  throw new Error("Unknown comparator: " + node.name);
              }
              return result;
            case TOK_FLATTEN:
              var original = this.visit(node.children[0], value);
              if (!isArray(original)) {
                return null;
              }
              var merged = [];
              for (i2 = 0; i2 < original.length; i2++) {
                current = original[i2];
                if (isArray(current)) {
                  merged.push.apply(merged, current);
                } else {
                  merged.push(current);
                }
              }
              return merged;
            case "Identity":
              return value;
            case "MultiSelectList":
              if (value === null) {
                return null;
              }
              collected = [];
              for (i2 = 0; i2 < node.children.length; i2++) {
                collected.push(this.visit(node.children[i2], value));
              }
              return collected;
            case "MultiSelectHash":
              if (value === null) {
                return null;
              }
              collected = {};
              var child;
              for (i2 = 0; i2 < node.children.length; i2++) {
                child = node.children[i2];
                collected[child.name] = this.visit(child.value, value);
              }
              return collected;
            case "OrExpression":
              matched = this.visit(node.children[0], value);
              if (isFalse(matched)) {
                matched = this.visit(node.children[1], value);
              }
              return matched;
            case "AndExpression":
              first = this.visit(node.children[0], value);
              if (isFalse(first) === true) {
                return first;
              }
              return this.visit(node.children[1], value);
            case "NotExpression":
              first = this.visit(node.children[0], value);
              return isFalse(first);
            case "Literal":
              return node.value;
            case TOK_PIPE:
              left = this.visit(node.children[0], value);
              return this.visit(node.children[1], left);
            case TOK_CURRENT:
              return value;
            case "Function":
              var resolvedArgs = [];
              for (i2 = 0; i2 < node.children.length; i2++) {
                resolvedArgs.push(this.visit(node.children[i2], value));
              }
              return this.runtime.callFunction(node.name, resolvedArgs);
            case "ExpressionReference":
              var refNode = node.children[0];
              refNode.jmespathType = TOK_EXPREF;
              return refNode;
            default:
              throw new Error("Unknown node type: " + node.type);
          }
        },
        computeSliceParams: function(arrayLength, sliceParams) {
          var start = sliceParams[0];
          var stop = sliceParams[1];
          var step = sliceParams[2];
          var computed2 = [null, null, null];
          if (step === null) {
            step = 1;
          } else if (step === 0) {
            var error = new Error("Invalid slice, step cannot be 0");
            error.name = "RuntimeError";
            throw error;
          }
          var stepValueNegative = step < 0 ? true : false;
          if (start === null) {
            start = stepValueNegative ? arrayLength - 1 : 0;
          } else {
            start = this.capSliceRange(arrayLength, start, step);
          }
          if (stop === null) {
            stop = stepValueNegative ? -1 : arrayLength;
          } else {
            stop = this.capSliceRange(arrayLength, stop, step);
          }
          computed2[0] = start;
          computed2[1] = stop;
          computed2[2] = step;
          return computed2;
        },
        capSliceRange: function(arrayLength, actualValue, step) {
          if (actualValue < 0) {
            actualValue += arrayLength;
            if (actualValue < 0) {
              actualValue = step < 0 ? -1 : 0;
            }
          } else if (actualValue >= arrayLength) {
            actualValue = step < 0 ? arrayLength - 1 : arrayLength;
          }
          return actualValue;
        }
      };
      function Runtime(interpreter) {
        this._interpreter = interpreter;
        this.functionTable = {
          // name: [function, <signature>]
          // The <signature> can be:
          //
          // {
          //   args: [[type1, type2], [type1, type2]],
          //   variadic: true|false
          // }
          //
          // Each arg in the arg list is a list of valid types
          // (if the function is overloaded and supports multiple
          // types.  If the type is "any" then no type checking
          // occurs on the argument.  Variadic is optional
          // and if not provided is assumed to be false.
          abs: { _func: this._functionAbs, _signature: [{ types: [TYPE_NUMBER] }] },
          avg: { _func: this._functionAvg, _signature: [{ types: [TYPE_ARRAY_NUMBER] }] },
          ceil: { _func: this._functionCeil, _signature: [{ types: [TYPE_NUMBER] }] },
          contains: {
            _func: this._functionContains,
            _signature: [
              { types: [TYPE_STRING, TYPE_ARRAY] },
              { types: [TYPE_ANY] }
            ]
          },
          "ends_with": {
            _func: this._functionEndsWith,
            _signature: [{ types: [TYPE_STRING] }, { types: [TYPE_STRING] }]
          },
          floor: { _func: this._functionFloor, _signature: [{ types: [TYPE_NUMBER] }] },
          length: {
            _func: this._functionLength,
            _signature: [{ types: [TYPE_STRING, TYPE_ARRAY, TYPE_OBJECT] }]
          },
          map: {
            _func: this._functionMap,
            _signature: [{ types: [TYPE_EXPREF] }, { types: [TYPE_ARRAY] }]
          },
          max: {
            _func: this._functionMax,
            _signature: [{ types: [TYPE_ARRAY_NUMBER, TYPE_ARRAY_STRING] }]
          },
          "merge": {
            _func: this._functionMerge,
            _signature: [{ types: [TYPE_OBJECT], variadic: true }]
          },
          "max_by": {
            _func: this._functionMaxBy,
            _signature: [{ types: [TYPE_ARRAY] }, { types: [TYPE_EXPREF] }]
          },
          sum: { _func: this._functionSum, _signature: [{ types: [TYPE_ARRAY_NUMBER] }] },
          "starts_with": {
            _func: this._functionStartsWith,
            _signature: [{ types: [TYPE_STRING] }, { types: [TYPE_STRING] }]
          },
          min: {
            _func: this._functionMin,
            _signature: [{ types: [TYPE_ARRAY_NUMBER, TYPE_ARRAY_STRING] }]
          },
          "min_by": {
            _func: this._functionMinBy,
            _signature: [{ types: [TYPE_ARRAY] }, { types: [TYPE_EXPREF] }]
          },
          type: { _func: this._functionType, _signature: [{ types: [TYPE_ANY] }] },
          keys: { _func: this._functionKeys, _signature: [{ types: [TYPE_OBJECT] }] },
          values: { _func: this._functionValues, _signature: [{ types: [TYPE_OBJECT] }] },
          sort: { _func: this._functionSort, _signature: [{ types: [TYPE_ARRAY_STRING, TYPE_ARRAY_NUMBER] }] },
          "sort_by": {
            _func: this._functionSortBy,
            _signature: [{ types: [TYPE_ARRAY] }, { types: [TYPE_EXPREF] }]
          },
          join: {
            _func: this._functionJoin,
            _signature: [
              { types: [TYPE_STRING] },
              { types: [TYPE_ARRAY_STRING] }
            ]
          },
          reverse: {
            _func: this._functionReverse,
            _signature: [{ types: [TYPE_STRING, TYPE_ARRAY] }]
          },
          "to_array": { _func: this._functionToArray, _signature: [{ types: [TYPE_ANY] }] },
          "to_string": { _func: this._functionToString, _signature: [{ types: [TYPE_ANY] }] },
          "to_number": { _func: this._functionToNumber, _signature: [{ types: [TYPE_ANY] }] },
          "not_null": {
            _func: this._functionNotNull,
            _signature: [{ types: [TYPE_ANY], variadic: true }]
          }
        };
      }
      Runtime.prototype = {
        callFunction: function(name2, resolvedArgs) {
          var functionEntry = this.functionTable[name2];
          if (functionEntry === void 0) {
            throw new Error("Unknown function: " + name2 + "()");
          }
          this._validateArgs(name2, resolvedArgs, functionEntry._signature);
          return functionEntry._func.call(this, resolvedArgs);
        },
        _validateArgs: function(name2, args, signature) {
          var pluralized;
          if (signature[signature.length - 1].variadic) {
            if (args.length < signature.length) {
              pluralized = signature.length === 1 ? " argument" : " arguments";
              throw new Error("ArgumentError: " + name2 + "() takes at least" + signature.length + pluralized + " but received " + args.length);
            }
          } else if (args.length !== signature.length) {
            pluralized = signature.length === 1 ? " argument" : " arguments";
            throw new Error("ArgumentError: " + name2 + "() takes " + signature.length + pluralized + " but received " + args.length);
          }
          var currentSpec;
          var actualType;
          var typeMatched;
          for (var i2 = 0; i2 < signature.length; i2++) {
            typeMatched = false;
            currentSpec = signature[i2].types;
            actualType = this._getTypeName(args[i2]);
            for (var j = 0; j < currentSpec.length; j++) {
              if (this._typeMatches(actualType, currentSpec[j], args[i2])) {
                typeMatched = true;
                break;
              }
            }
            if (!typeMatched) {
              var expected = currentSpec.map(function(typeIdentifier) {
                return TYPE_NAME_TABLE[typeIdentifier];
              }).join(",");
              throw new Error("TypeError: " + name2 + "() expected argument " + (i2 + 1) + " to be type " + expected + " but received type " + TYPE_NAME_TABLE[actualType] + " instead.");
            }
          }
        },
        _typeMatches: function(actual, expected, argValue) {
          if (expected === TYPE_ANY) {
            return true;
          }
          if (expected === TYPE_ARRAY_STRING || expected === TYPE_ARRAY_NUMBER || expected === TYPE_ARRAY) {
            if (expected === TYPE_ARRAY) {
              return actual === TYPE_ARRAY;
            } else if (actual === TYPE_ARRAY) {
              var subtype;
              if (expected === TYPE_ARRAY_NUMBER) {
                subtype = TYPE_NUMBER;
              } else if (expected === TYPE_ARRAY_STRING) {
                subtype = TYPE_STRING;
              }
              for (var i2 = 0; i2 < argValue.length; i2++) {
                if (!this._typeMatches(
                  this._getTypeName(argValue[i2]),
                  subtype,
                  argValue[i2]
                )) {
                  return false;
                }
              }
              return true;
            }
          } else {
            return actual === expected;
          }
        },
        _getTypeName: function(obj) {
          switch (Object.prototype.toString.call(obj)) {
            case "[object String]":
              return TYPE_STRING;
            case "[object Number]":
              return TYPE_NUMBER;
            case "[object Array]":
              return TYPE_ARRAY;
            case "[object Boolean]":
              return TYPE_BOOLEAN;
            case "[object Null]":
              return TYPE_NULL;
            case "[object Object]":
              if (obj.jmespathType === TOK_EXPREF) {
                return TYPE_EXPREF;
              } else {
                return TYPE_OBJECT;
              }
          }
        },
        _functionStartsWith: function(resolvedArgs) {
          return resolvedArgs[0].lastIndexOf(resolvedArgs[1]) === 0;
        },
        _functionEndsWith: function(resolvedArgs) {
          var searchStr = resolvedArgs[0];
          var suffix = resolvedArgs[1];
          return searchStr.indexOf(suffix, searchStr.length - suffix.length) !== -1;
        },
        _functionReverse: function(resolvedArgs) {
          var typeName2 = this._getTypeName(resolvedArgs[0]);
          if (typeName2 === TYPE_STRING) {
            var originalStr = resolvedArgs[0];
            var reversedStr = "";
            for (var i2 = originalStr.length - 1; i2 >= 0; i2--) {
              reversedStr += originalStr[i2];
            }
            return reversedStr;
          } else {
            var reversedArray = resolvedArgs[0].slice(0);
            reversedArray.reverse();
            return reversedArray;
          }
        },
        _functionAbs: function(resolvedArgs) {
          return Math.abs(resolvedArgs[0]);
        },
        _functionCeil: function(resolvedArgs) {
          return Math.ceil(resolvedArgs[0]);
        },
        _functionAvg: function(resolvedArgs) {
          var sum = 0;
          var inputArray = resolvedArgs[0];
          for (var i2 = 0; i2 < inputArray.length; i2++) {
            sum += inputArray[i2];
          }
          return sum / inputArray.length;
        },
        _functionContains: function(resolvedArgs) {
          return resolvedArgs[0].indexOf(resolvedArgs[1]) >= 0;
        },
        _functionFloor: function(resolvedArgs) {
          return Math.floor(resolvedArgs[0]);
        },
        _functionLength: function(resolvedArgs) {
          if (!isObject(resolvedArgs[0])) {
            return resolvedArgs[0].length;
          } else {
            return Object.keys(resolvedArgs[0]).length;
          }
        },
        _functionMap: function(resolvedArgs) {
          var mapped = [];
          var interpreter = this._interpreter;
          var exprefNode = resolvedArgs[0];
          var elements = resolvedArgs[1];
          for (var i2 = 0; i2 < elements.length; i2++) {
            mapped.push(interpreter.visit(exprefNode, elements[i2]));
          }
          return mapped;
        },
        _functionMerge: function(resolvedArgs) {
          var merged = {};
          for (var i2 = 0; i2 < resolvedArgs.length; i2++) {
            var current = resolvedArgs[i2];
            for (var key in current) {
              merged[key] = current[key];
            }
          }
          return merged;
        },
        _functionMax: function(resolvedArgs) {
          if (resolvedArgs[0].length > 0) {
            var typeName2 = this._getTypeName(resolvedArgs[0][0]);
            if (typeName2 === TYPE_NUMBER) {
              return Math.max.apply(Math, resolvedArgs[0]);
            } else {
              var elements = resolvedArgs[0];
              var maxElement = elements[0];
              for (var i2 = 1; i2 < elements.length; i2++) {
                if (maxElement.localeCompare(elements[i2]) < 0) {
                  maxElement = elements[i2];
                }
              }
              return maxElement;
            }
          } else {
            return null;
          }
        },
        _functionMin: function(resolvedArgs) {
          if (resolvedArgs[0].length > 0) {
            var typeName2 = this._getTypeName(resolvedArgs[0][0]);
            if (typeName2 === TYPE_NUMBER) {
              return Math.min.apply(Math, resolvedArgs[0]);
            } else {
              var elements = resolvedArgs[0];
              var minElement = elements[0];
              for (var i2 = 1; i2 < elements.length; i2++) {
                if (elements[i2].localeCompare(minElement) < 0) {
                  minElement = elements[i2];
                }
              }
              return minElement;
            }
          } else {
            return null;
          }
        },
        _functionSum: function(resolvedArgs) {
          var sum = 0;
          var listToSum = resolvedArgs[0];
          for (var i2 = 0; i2 < listToSum.length; i2++) {
            sum += listToSum[i2];
          }
          return sum;
        },
        _functionType: function(resolvedArgs) {
          switch (this._getTypeName(resolvedArgs[0])) {
            case TYPE_NUMBER:
              return "number";
            case TYPE_STRING:
              return "string";
            case TYPE_ARRAY:
              return "array";
            case TYPE_OBJECT:
              return "object";
            case TYPE_BOOLEAN:
              return "boolean";
            case TYPE_EXPREF:
              return "expref";
            case TYPE_NULL:
              return "null";
          }
        },
        _functionKeys: function(resolvedArgs) {
          return Object.keys(resolvedArgs[0]);
        },
        _functionValues: function(resolvedArgs) {
          var obj = resolvedArgs[0];
          var keys2 = Object.keys(obj);
          var values = [];
          for (var i2 = 0; i2 < keys2.length; i2++) {
            values.push(obj[keys2[i2]]);
          }
          return values;
        },
        _functionJoin: function(resolvedArgs) {
          var joinChar = resolvedArgs[0];
          var listJoin = resolvedArgs[1];
          return listJoin.join(joinChar);
        },
        _functionToArray: function(resolvedArgs) {
          if (this._getTypeName(resolvedArgs[0]) === TYPE_ARRAY) {
            return resolvedArgs[0];
          } else {
            return [resolvedArgs[0]];
          }
        },
        _functionToString: function(resolvedArgs) {
          if (this._getTypeName(resolvedArgs[0]) === TYPE_STRING) {
            return resolvedArgs[0];
          } else {
            return JSON.stringify(resolvedArgs[0]);
          }
        },
        _functionToNumber: function(resolvedArgs) {
          var typeName2 = this._getTypeName(resolvedArgs[0]);
          var convertedValue;
          if (typeName2 === TYPE_NUMBER) {
            return resolvedArgs[0];
          } else if (typeName2 === TYPE_STRING) {
            convertedValue = +resolvedArgs[0];
            if (!isNaN(convertedValue)) {
              return convertedValue;
            }
          }
          return null;
        },
        _functionNotNull: function(resolvedArgs) {
          for (var i2 = 0; i2 < resolvedArgs.length; i2++) {
            if (this._getTypeName(resolvedArgs[i2]) !== TYPE_NULL) {
              return resolvedArgs[i2];
            }
          }
          return null;
        },
        _functionSort: function(resolvedArgs) {
          var sortedArray = resolvedArgs[0].slice(0);
          sortedArray.sort();
          return sortedArray;
        },
        _functionSortBy: function(resolvedArgs) {
          var sortedArray = resolvedArgs[0].slice(0);
          if (sortedArray.length === 0) {
            return sortedArray;
          }
          var interpreter = this._interpreter;
          var exprefNode = resolvedArgs[1];
          var requiredType = this._getTypeName(
            interpreter.visit(exprefNode, sortedArray[0])
          );
          if ([TYPE_NUMBER, TYPE_STRING].indexOf(requiredType) < 0) {
            throw new Error("TypeError");
          }
          var that = this;
          var decorated = [];
          for (var i2 = 0; i2 < sortedArray.length; i2++) {
            decorated.push([i2, sortedArray[i2]]);
          }
          decorated.sort(function(a2, b2) {
            var exprA = interpreter.visit(exprefNode, a2[1]);
            var exprB = interpreter.visit(exprefNode, b2[1]);
            if (that._getTypeName(exprA) !== requiredType) {
              throw new Error(
                "TypeError: expected " + requiredType + ", received " + that._getTypeName(exprA)
              );
            } else if (that._getTypeName(exprB) !== requiredType) {
              throw new Error(
                "TypeError: expected " + requiredType + ", received " + that._getTypeName(exprB)
              );
            }
            if (exprA > exprB) {
              return 1;
            } else if (exprA < exprB) {
              return -1;
            } else {
              return a2[0] - b2[0];
            }
          });
          for (var j = 0; j < decorated.length; j++) {
            sortedArray[j] = decorated[j][1];
          }
          return sortedArray;
        },
        _functionMaxBy: function(resolvedArgs) {
          var exprefNode = resolvedArgs[1];
          var resolvedArray = resolvedArgs[0];
          var keyFunction = this.createKeyFunction(exprefNode, [TYPE_NUMBER, TYPE_STRING]);
          var maxNumber = -Infinity;
          var maxRecord;
          var current;
          for (var i2 = 0; i2 < resolvedArray.length; i2++) {
            current = keyFunction(resolvedArray[i2]);
            if (current > maxNumber) {
              maxNumber = current;
              maxRecord = resolvedArray[i2];
            }
          }
          return maxRecord;
        },
        _functionMinBy: function(resolvedArgs) {
          var exprefNode = resolvedArgs[1];
          var resolvedArray = resolvedArgs[0];
          var keyFunction = this.createKeyFunction(exprefNode, [TYPE_NUMBER, TYPE_STRING]);
          var minNumber = Infinity;
          var minRecord;
          var current;
          for (var i2 = 0; i2 < resolvedArray.length; i2++) {
            current = keyFunction(resolvedArray[i2]);
            if (current < minNumber) {
              minNumber = current;
              minRecord = resolvedArray[i2];
            }
          }
          return minRecord;
        },
        createKeyFunction: function(exprefNode, allowedTypes) {
          var that = this;
          var interpreter = this._interpreter;
          var keyFunc = function(x) {
            var current = interpreter.visit(exprefNode, x);
            if (allowedTypes.indexOf(that._getTypeName(current)) < 0) {
              var msg = "TypeError: expected one of " + allowedTypes + ", received " + that._getTypeName(current);
              throw new Error(msg);
            }
            return current;
          };
          return keyFunc;
        }
      };
      function compile(stream) {
        var parser2 = new Parser2();
        var ast = parser2.parse(stream);
        return ast;
      }
      function tokenize(stream) {
        var lexer = new Lexer();
        return lexer.tokenize(stream);
      }
      function search2(data, expression) {
        var parser2 = new Parser2();
        var runtime = new Runtime();
        var interpreter = new TreeInterpreter(runtime);
        runtime._interpreter = interpreter;
        var node = parser2.parse(expression);
        return interpreter.search(node, data);
      }
      exports3.tokenize = tokenize;
      exports3.compile = compile;
      exports3.search = search2;
      exports3.strictDeepEqual = strictDeepEqual;
    })(typeof exports2 === "undefined" ? exports2.jmespath = {} : exports2);
  }
});

// node_modules/immutable-json-patch/lib/esm/typeguards.js
function isJSONArray(value) {
  return Array.isArray(value);
}
function isJSONObject(value) {
  return value !== null && typeof value === "object" && (value.constructor === void 0 || // for example Object.create(null)
  value.constructor.name === "Object");
}
function isJSONPatchAdd(value) {
  return value && typeof value === "object" ? value.op === "add" : false;
}
function isJSONPatchRemove(value) {
  return value && typeof value === "object" ? value.op === "remove" : false;
}
function isJSONPatchReplace(value) {
  return value && typeof value === "object" ? value.op === "replace" : false;
}
function isJSONPatchCopy(value) {
  return value && typeof value === "object" ? value.op === "copy" : false;
}
function isJSONPatchMove(value) {
  return value && typeof value === "object" ? value.op === "move" : false;
}

// node_modules/immutable-json-patch/lib/esm/utils.js
function isEqual(a2, b2) {
  return JSON.stringify(a2) === JSON.stringify(b2);
}
function strictEqual(a2, b2) {
  return a2 === b2;
}
function initial(array) {
  return array.slice(0, array.length - 1);
}
function last(array) {
  return array[array.length - 1];
}
function startsWith(array1, array2) {
  let isEqual2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : strictEqual;
  if (array1.length < array2.length) {
    return false;
  }
  for (let i2 = 0; i2 < array2.length; i2++) {
    if (!isEqual2(array1[i2], array2[i2])) {
      return false;
    }
  }
  return true;
}
function isObjectOrArray(value) {
  return typeof value === "object" && value !== null;
}

// node_modules/immutable-json-patch/lib/esm/immutabilityHelpers.js
function shallowClone(value) {
  if (isJSONArray(value)) {
    const copy2 = value.slice();
    Object.getOwnPropertySymbols(value).forEach((symbol) => {
      copy2[symbol] = value[symbol];
    });
    return copy2;
  } else if (isJSONObject(value)) {
    const copy2 = {
      ...value
    };
    Object.getOwnPropertySymbols(value).forEach((symbol) => {
      copy2[symbol] = value[symbol];
    });
    return copy2;
  } else {
    return value;
  }
}
function applyProp(object, key, value) {
  if (object[key] === value) {
    return object;
  } else {
    const updatedObject = shallowClone(object);
    updatedObject[key] = value;
    return updatedObject;
  }
}
function getIn(object, path) {
  let value = object;
  let i2 = 0;
  while (i2 < path.length) {
    if (isJSONObject(value)) {
      value = value[path[i2]];
    } else if (isJSONArray(value)) {
      value = value[parseInt(path[i2])];
    } else {
      value = void 0;
    }
    i2++;
  }
  return value;
}
function setIn(object, path, value) {
  let createPath = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
  if (path.length === 0) {
    return value;
  }
  const key = path[0];
  const updatedValue = setIn(object ? object[key] : void 0, path.slice(1), value, createPath);
  if (isJSONObject(object) || isJSONArray(object)) {
    return applyProp(object, key, updatedValue);
  } else {
    if (createPath) {
      const newObject = IS_INTEGER_REGEX.test(key) ? [] : {};
      newObject[key] = updatedValue;
      return newObject;
    } else {
      throw new Error("Path does not exist");
    }
  }
}
var IS_INTEGER_REGEX = /^\d+$/;
function updateIn(object, path, transform2) {
  if (path.length === 0) {
    return transform2(object);
  }
  if (!isObjectOrArray(object)) {
    throw new Error("Path doesn't exist");
  }
  const key = path[0];
  const updatedValue = updateIn(object[key], path.slice(1), transform2);
  return applyProp(object, key, updatedValue);
}
function deleteIn(object, path) {
  if (path.length === 0) {
    return object;
  }
  if (!isObjectOrArray(object)) {
    throw new Error("Path does not exist");
  }
  if (path.length === 1) {
    const key2 = path[0];
    if (!(key2 in object)) {
      return object;
    } else {
      const updatedObject = shallowClone(object);
      if (isJSONArray(updatedObject)) {
        updatedObject.splice(parseInt(key2), 1);
      }
      if (isJSONObject(updatedObject)) {
        delete updatedObject[key2];
      }
      return updatedObject;
    }
  }
  const key = path[0];
  const updatedValue = deleteIn(object[key], path.slice(1));
  return applyProp(object, key, updatedValue);
}
function insertAt(document2, path, value) {
  const parentPath = path.slice(0, path.length - 1);
  const index2 = path[path.length - 1];
  return updateIn(document2, parentPath, (items) => {
    if (!Array.isArray(items)) {
      throw new TypeError("Array expected at path " + JSON.stringify(parentPath));
    }
    const updatedItems = shallowClone(items);
    updatedItems.splice(parseInt(index2), 0, value);
    return updatedItems;
  });
}
function existsIn(document2, path) {
  if (document2 === void 0) {
    return false;
  }
  if (path.length === 0) {
    return true;
  }
  if (document2 === null) {
    return false;
  }
  return existsIn(document2[path[0]], path.slice(1));
}

// node_modules/immutable-json-patch/lib/esm/jsonPointer.js
function parseJSONPointer(pointer) {
  const path = pointer.split("/");
  path.shift();
  return path.map((p) => p.replace(/~1/g, "/").replace(/~0/g, "~"));
}
function compileJSONPointer(path) {
  return path.map(compileJSONPointerProp).join("");
}
function compileJSONPointerProp(pathProp) {
  return "/" + String(pathProp).replace(/~/g, "~0").replace(/\//g, "~1");
}
function appendToJSONPointer(pointer, pathProp) {
  return pointer + compileJSONPointerProp(pathProp);
}

// node_modules/immutable-json-patch/lib/esm/immutableJSONPatch.js
function immutableJSONPatch(document2, operations, options) {
  let updatedDocument = document2;
  for (let i2 = 0; i2 < operations.length; i2++) {
    validateJSONPatchOperation(operations[i2]);
    let operation = operations[i2];
    if (options && options.before) {
      const result = options.before(updatedDocument, operation);
      if (result !== void 0) {
        if (result.document !== void 0) {
          updatedDocument = result.document;
        }
        if (result.json !== void 0) {
          throw new Error('Deprecation warning: returned object property ".json" has been renamed to ".document"');
        }
        if (result.operation !== void 0) {
          operation = result.operation;
        }
      }
    }
    const previousDocument = updatedDocument;
    const path = parsePath(updatedDocument, operation.path);
    if (operation.op === "add") {
      updatedDocument = add(updatedDocument, path, operation.value);
    } else if (operation.op === "remove") {
      updatedDocument = remove(updatedDocument, path);
    } else if (operation.op === "replace") {
      updatedDocument = replace(updatedDocument, path, operation.value);
    } else if (operation.op === "copy") {
      updatedDocument = copy(updatedDocument, path, parseFrom(operation.from));
    } else if (operation.op === "move") {
      updatedDocument = move(updatedDocument, path, parseFrom(operation.from));
    } else if (operation.op === "test") {
      test(updatedDocument, path, operation.value);
    } else {
      throw new Error("Unknown JSONPatch operation " + JSON.stringify(operation));
    }
    if (options && options.after) {
      const result = options.after(updatedDocument, operation, previousDocument);
      if (result !== void 0) {
        updatedDocument = result;
      }
    }
  }
  return updatedDocument;
}
function replace(document2, path, value) {
  return setIn(document2, path, value);
}
function remove(document2, path) {
  return deleteIn(document2, path);
}
function add(document2, path, value) {
  if (isArrayItem(document2, path)) {
    return insertAt(document2, path, value);
  } else {
    return setIn(document2, path, value);
  }
}
function copy(document2, path, from) {
  const value = getIn(document2, from);
  if (isArrayItem(document2, path)) {
    return insertAt(document2, path, value);
  } else {
    const value2 = getIn(document2, from);
    return setIn(document2, path, value2);
  }
}
function move(document2, path, from) {
  const value = getIn(document2, from);
  const removedJson = deleteIn(document2, from);
  return isArrayItem(removedJson, path) ? insertAt(removedJson, path, value) : setIn(removedJson, path, value);
}
function test(document2, path, value) {
  if (value === void 0) {
    throw new Error(`Test failed: no value provided (path: "${compileJSONPointer(path)}")`);
  }
  if (!existsIn(document2, path)) {
    throw new Error(`Test failed: path not found (path: "${compileJSONPointer(path)}")`);
  }
  const actualValue = getIn(document2, path);
  if (!isEqual(actualValue, value)) {
    throw new Error(`Test failed, value differs (path: "${compileJSONPointer(path)}")`);
  }
}
function isArrayItem(document2, path) {
  if (path.length === 0) {
    return false;
  }
  const parent = getIn(document2, initial(path));
  return Array.isArray(parent);
}
function resolvePathIndex(document2, path) {
  if (last(path) !== "-") {
    return path;
  }
  const parentPath = initial(path);
  const parent = getIn(document2, parentPath);
  return parentPath.concat(parent.length);
}
function validateJSONPatchOperation(operation) {
  const ops = ["add", "remove", "replace", "copy", "move", "test"];
  if (!ops.includes(operation.op)) {
    throw new Error("Unknown JSONPatch op " + JSON.stringify(operation.op));
  }
  if (typeof operation.path !== "string") {
    throw new Error('Required property "path" missing or not a string in operation ' + JSON.stringify(operation));
  }
  if (operation.op === "copy" || operation.op === "move") {
    if (typeof operation.from !== "string") {
      throw new Error('Required property "from" missing or not a string in operation ' + JSON.stringify(operation));
    }
  }
}
function parsePath(document2, pointer) {
  return resolvePathIndex(document2, parseJSONPointer(pointer));
}
function parseFrom(fromPointer) {
  return parseJSONPointer(fromPointer);
}

// node_modules/immutable-json-patch/lib/esm/revertJSONPatch.js
function revertJSONPatch(document2, operations, options) {
  let allRevertOperations = [];
  const before = (document3, operation) => {
    let revertOperations;
    const path = parsePath(document3, operation.path);
    if (operation.op === "add") {
      revertOperations = revertAdd(document3, path);
    } else if (operation.op === "remove") {
      revertOperations = revertRemove(document3, path);
    } else if (operation.op === "replace") {
      revertOperations = revertReplace(document3, path);
    } else if (operation.op === "copy") {
      revertOperations = revertCopy(document3, path);
    } else if (operation.op === "move") {
      revertOperations = revertMove(document3, path, parseFrom(operation.from));
    } else if (operation.op === "test") {
      revertOperations = [];
    } else {
      throw new Error("Unknown JSONPatch operation " + JSON.stringify(operation));
    }
    let updatedJson;
    if (options && options.before) {
      const res = options.before(document3, operation, revertOperations);
      if (res && res.revertOperations) {
        revertOperations = res.revertOperations;
      }
      if (res && res.document) {
        updatedJson = res.document;
      }
      if (res && res.json) {
        throw new Error('Deprecation warning: returned object property ".json" has been renamed to ".document"');
      }
    }
    allRevertOperations = revertOperations.concat(allRevertOperations);
    if (updatedJson !== void 0) {
      return {
        document: updatedJson
      };
    }
  };
  immutableJSONPatch(document2, operations, {
    before
  });
  return allRevertOperations;
}
function revertReplace(document2, path) {
  return [{
    op: "replace",
    path: compileJSONPointer(path),
    value: getIn(document2, path)
  }];
}
function revertRemove(document2, path) {
  return [{
    op: "add",
    path: compileJSONPointer(path),
    value: getIn(document2, path)
  }];
}
function revertAdd(document2, path) {
  if (isArrayItem(document2, path) || !existsIn(document2, path)) {
    return [{
      op: "remove",
      path: compileJSONPointer(path)
    }];
  } else {
    return revertReplace(document2, path);
  }
}
function revertCopy(document2, path) {
  return revertAdd(document2, path);
}
function revertMove(document2, path, from) {
  if (path.length < from.length && startsWith(from, path)) {
    return [{
      op: "replace",
      path: compileJSONPointer(path),
      value: document2
    }];
  }
  const move2 = {
    op: "move",
    from: compileJSONPointer(path),
    path: compileJSONPointer(from)
  };
  if (!isArrayItem(document2, path) && existsIn(document2, path)) {
    return [move2, ...revertRemove(document2, path)];
  } else {
    return [move2];
  }
}

// node_modules/vanilla-jsoneditor/index.js
var import_json_source_map = __toESM(require_json_source_map());

// node_modules/jsonrepair/lib/esm/utils/JSONRepairError.js
var JSONRepairError = class extends Error {
  constructor(message, position) {
    super("".concat(message, " at position ").concat(position));
    this.position = position;
  }
};

// node_modules/jsonrepair/lib/esm/utils/stringUtils.js
var codeBackslash = 92;
var codeSlash = 47;
var codeAsterisk = 42;
var codeOpeningBrace = 123;
var codeClosingBrace = 125;
var codeOpeningBracket = 91;
var codeClosingBracket = 93;
var codeOpenParenthesis = 40;
var codeCloseParenthesis = 41;
var codeSpace = 32;
var codeNewline = 10;
var codeTab = 9;
var codeReturn = 13;
var codeBackspace = 8;
var codeFormFeed = 12;
var codeDoubleQuote = 34;
var codePlus = 43;
var codeMinus = 45;
var codeQuote = 39;
var codeZero = 48;
var codeNine = 57;
var codeComma = 44;
var codeDot = 46;
var codeColon = 58;
var codeSemicolon = 59;
var codeUppercaseA = 65;
var codeLowercaseA = 97;
var codeUppercaseE = 69;
var codeLowercaseE = 101;
var codeUppercaseF = 70;
var codeLowercaseF = 102;
var codeNonBreakingSpace = 160;
var codeEnQuad = 8192;
var codeHairSpace = 8202;
var codeNarrowNoBreakSpace = 8239;
var codeMediumMathematicalSpace = 8287;
var codeIdeographicSpace = 12288;
var codeDoubleQuoteLeft = 8220;
var codeDoubleQuoteRight = 8221;
var codeQuoteLeft = 8216;
var codeQuoteRight = 8217;
var codeGraveAccent = 96;
var codeAcuteAccent = 180;
function isHex(code) {
  return code >= codeZero && code <= codeNine || code >= codeUppercaseA && code <= codeUppercaseF || code >= codeLowercaseA && code <= codeLowercaseF;
}
function isDigit(code) {
  return code >= codeZero && code <= codeNine;
}
function isValidStringCharacter(code) {
  return code >= 32 && code <= 1114111;
}
function isDelimiter(char) {
  return regexDelimiter.test(char);
}
var regexDelimiter = /^[,:[\]/{}()\n+]$/;
function isDelimiterExceptSlash(char) {
  return isDelimiter(char) && char !== "/";
}
function isStartOfValue(char) {
  return regexStartOfValue.test(char) || char && isQuote(char.charCodeAt(0));
}
var regexStartOfValue = /^[[{\w-]$/;
function isControlCharacter(code) {
  return code === codeNewline || code === codeReturn || code === codeTab || code === codeBackspace || code === codeFormFeed;
}
function isWhitespace(code) {
  return code === codeSpace || code === codeNewline || code === codeTab || code === codeReturn;
}
function isSpecialWhitespace(code) {
  return code === codeNonBreakingSpace || code >= codeEnQuad && code <= codeHairSpace || code === codeNarrowNoBreakSpace || code === codeMediumMathematicalSpace || code === codeIdeographicSpace;
}
function isQuote(code) {
  return isDoubleQuoteLike(code) || isSingleQuoteLike(code);
}
function isDoubleQuoteLike(code) {
  return code === codeDoubleQuote || code === codeDoubleQuoteLeft || code === codeDoubleQuoteRight;
}
function isDoubleQuote(code) {
  return code === codeDoubleQuote;
}
function isSingleQuoteLike(code) {
  return code === codeQuote || code === codeQuoteLeft || code === codeQuoteRight || code === codeGraveAccent || code === codeAcuteAccent;
}
function isSingleQuote(code) {
  return code === codeQuote;
}
function stripLastOccurrence(text, textToStrip) {
  let stripRemainingText = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  const index2 = text.lastIndexOf(textToStrip);
  return index2 !== -1 ? text.substring(0, index2) + (stripRemainingText ? "" : text.substring(index2 + 1)) : text;
}
function insertBeforeLastWhitespace(text, textToInsert) {
  let index2 = text.length;
  if (!isWhitespace(text.charCodeAt(index2 - 1))) {
    return text + textToInsert;
  }
  while (isWhitespace(text.charCodeAt(index2 - 1))) {
    index2--;
  }
  return text.substring(0, index2) + textToInsert + text.substring(index2);
}
function removeAtIndex(text, start, count) {
  return text.substring(0, start) + text.substring(start + count);
}
function endsWithCommaOrNewline(text) {
  return /[,\n][ \t\r]*$/.test(text);
}
function isFunctionName(text) {
  return /^\w+$/.test(text);
}

// node_modules/jsonrepair/lib/esm/regular/jsonrepair.js
var controlCharacters = {
  "\b": "\\b",
  "\f": "\\f",
  "\n": "\\n",
  "\r": "\\r",
  "	": "\\t"
};
var escapeCharacters = {
  '"': '"',
  "\\": "\\",
  "/": "/",
  b: "\b",
  f: "\f",
  n: "\n",
  r: "\r",
  t: "	"
  // note that \u is handled separately in parseString()
};
function jsonrepair(text) {
  let i2 = 0;
  let output = "";
  const processed = parseValue();
  if (!processed) {
    throwUnexpectedEnd();
  }
  const processedComma = parseCharacter(codeComma);
  if (processedComma) {
    parseWhitespaceAndSkipComments();
  }
  if (isStartOfValue(text[i2]) && endsWithCommaOrNewline(output)) {
    if (!processedComma) {
      output = insertBeforeLastWhitespace(output, ",");
    }
    parseNewlineDelimitedJSON();
  } else if (processedComma) {
    output = stripLastOccurrence(output, ",");
  }
  while (text.charCodeAt(i2) === codeClosingBrace || text.charCodeAt(i2) === codeClosingBracket) {
    i2++;
    parseWhitespaceAndSkipComments();
  }
  if (i2 >= text.length) {
    return output;
  }
  throwUnexpectedCharacter();
  function parseValue() {
    parseWhitespaceAndSkipComments();
    const processed2 = parseObject() || parseArray() || parseString() || parseNumber() || parseKeywords() || parseUnquotedString();
    parseWhitespaceAndSkipComments();
    return processed2;
  }
  function parseWhitespaceAndSkipComments() {
    const start = i2;
    let changed = parseWhitespace();
    do {
      changed = parseComment();
      if (changed) {
        changed = parseWhitespace();
      }
    } while (changed);
    return i2 > start;
  }
  function parseWhitespace() {
    let whitespace = "";
    let normal;
    while ((normal = isWhitespace(text.charCodeAt(i2))) || isSpecialWhitespace(text.charCodeAt(i2))) {
      if (normal) {
        whitespace += text[i2];
      } else {
        whitespace += " ";
      }
      i2++;
    }
    if (whitespace.length > 0) {
      output += whitespace;
      return true;
    }
    return false;
  }
  function parseComment() {
    if (text.charCodeAt(i2) === codeSlash && text.charCodeAt(i2 + 1) === codeAsterisk) {
      while (i2 < text.length && !atEndOfBlockComment(text, i2)) {
        i2++;
      }
      i2 += 2;
      return true;
    }
    if (text.charCodeAt(i2) === codeSlash && text.charCodeAt(i2 + 1) === codeSlash) {
      while (i2 < text.length && text.charCodeAt(i2) !== codeNewline) {
        i2++;
      }
      return true;
    }
    return false;
  }
  function parseCharacter(code) {
    if (text.charCodeAt(i2) === code) {
      output += text[i2];
      i2++;
      return true;
    }
    return false;
  }
  function skipCharacter(code) {
    if (text.charCodeAt(i2) === code) {
      i2++;
      return true;
    }
    return false;
  }
  function skipEscapeCharacter() {
    return skipCharacter(codeBackslash);
  }
  function skipEllipsis() {
    parseWhitespaceAndSkipComments();
    if (text.charCodeAt(i2) === codeDot && text.charCodeAt(i2 + 1) === codeDot && text.charCodeAt(i2 + 2) === codeDot) {
      i2 += 3;
      parseWhitespaceAndSkipComments();
      skipCharacter(codeComma);
      return true;
    }
    return false;
  }
  function parseObject() {
    if (text.charCodeAt(i2) === codeOpeningBrace) {
      output += "{";
      i2++;
      parseWhitespaceAndSkipComments();
      if (skipCharacter(codeComma)) {
        parseWhitespaceAndSkipComments();
      }
      let initial2 = true;
      while (i2 < text.length && text.charCodeAt(i2) !== codeClosingBrace) {
        let processedComma2;
        if (!initial2) {
          processedComma2 = parseCharacter(codeComma);
          if (!processedComma2) {
            output = insertBeforeLastWhitespace(output, ",");
          }
          parseWhitespaceAndSkipComments();
        } else {
          processedComma2 = true;
          initial2 = false;
        }
        skipEllipsis();
        const processedKey = parseString() || parseUnquotedString();
        if (!processedKey) {
          if (text.charCodeAt(i2) === codeClosingBrace || text.charCodeAt(i2) === codeOpeningBrace || text.charCodeAt(i2) === codeClosingBracket || text.charCodeAt(i2) === codeOpeningBracket || text[i2] === void 0) {
            output = stripLastOccurrence(output, ",");
          } else {
            throwObjectKeyExpected();
          }
          break;
        }
        parseWhitespaceAndSkipComments();
        const processedColon = parseCharacter(codeColon);
        const truncatedText = i2 >= text.length;
        if (!processedColon) {
          if (isStartOfValue(text[i2]) || truncatedText) {
            output = insertBeforeLastWhitespace(output, ":");
          } else {
            throwColonExpected();
          }
        }
        const processedValue = parseValue();
        if (!processedValue) {
          if (processedColon || truncatedText) {
            output += "null";
          } else {
            throwColonExpected();
          }
        }
      }
      if (text.charCodeAt(i2) === codeClosingBrace) {
        output += "}";
        i2++;
      } else {
        output = insertBeforeLastWhitespace(output, "}");
      }
      return true;
    }
    return false;
  }
  function parseArray() {
    if (text.charCodeAt(i2) === codeOpeningBracket) {
      output += "[";
      i2++;
      parseWhitespaceAndSkipComments();
      if (skipCharacter(codeComma)) {
        parseWhitespaceAndSkipComments();
      }
      let initial2 = true;
      while (i2 < text.length && text.charCodeAt(i2) !== codeClosingBracket) {
        if (!initial2) {
          const processedComma2 = parseCharacter(codeComma);
          if (!processedComma2) {
            output = insertBeforeLastWhitespace(output, ",");
          }
        } else {
          initial2 = false;
        }
        skipEllipsis();
        const processedValue = parseValue();
        if (!processedValue) {
          output = stripLastOccurrence(output, ",");
          break;
        }
      }
      if (text.charCodeAt(i2) === codeClosingBracket) {
        output += "]";
        i2++;
      } else {
        output = insertBeforeLastWhitespace(output, "]");
      }
      return true;
    }
    return false;
  }
  function parseNewlineDelimitedJSON() {
    let initial2 = true;
    let processedValue = true;
    while (processedValue) {
      if (!initial2) {
        const processedComma2 = parseCharacter(codeComma);
        if (!processedComma2) {
          output = insertBeforeLastWhitespace(output, ",");
        }
      } else {
        initial2 = false;
      }
      processedValue = parseValue();
    }
    if (!processedValue) {
      output = stripLastOccurrence(output, ",");
    }
    output = "[\n".concat(output, "\n]");
  }
  function parseString() {
    let stopAtDelimiter = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    let skipEscapeChars = text.charCodeAt(i2) === codeBackslash;
    if (skipEscapeChars) {
      i2++;
      skipEscapeChars = true;
    }
    if (isQuote(text.charCodeAt(i2))) {
      const isEndQuote = isDoubleQuote(text.charCodeAt(i2)) ? isDoubleQuote : isSingleQuote(text.charCodeAt(i2)) ? isSingleQuote : isSingleQuoteLike(text.charCodeAt(i2)) ? isSingleQuoteLike : isDoubleQuoteLike;
      const iBefore = i2;
      const oBefore = output.length;
      let str = '"';
      i2++;
      while (true) {
        if (i2 >= text.length) {
          const iPrev = prevNonWhitespaceIndex(i2 - 1);
          if (!stopAtDelimiter && isDelimiter(text.charAt(iPrev))) {
            i2 = iBefore;
            output = output.substring(0, oBefore);
            return parseString(true);
          }
          str = insertBeforeLastWhitespace(str, '"');
          output += str;
          return true;
        } else if (isEndQuote(text.charCodeAt(i2))) {
          const iQuote = i2;
          const oQuote = str.length;
          str += '"';
          i2++;
          output += str;
          parseWhitespaceAndSkipComments();
          if (stopAtDelimiter || i2 >= text.length || isDelimiter(text.charAt(i2)) || isQuote(text.charCodeAt(i2)) || isDigit(text.charCodeAt(i2))) {
            parseConcatenatedString();
            return true;
          }
          if (isDelimiter(text.charAt(prevNonWhitespaceIndex(iQuote - 1)))) {
            i2 = iBefore;
            output = output.substring(0, oBefore);
            return parseString(true);
          }
          output = output.substring(0, oBefore);
          i2 = iQuote + 1;
          str = "".concat(str.substring(0, oQuote), "\\").concat(str.substring(oQuote));
        } else if (stopAtDelimiter && isDelimiter(text[i2])) {
          str = insertBeforeLastWhitespace(str, '"');
          output += str;
          parseConcatenatedString();
          return true;
        } else if (text.charCodeAt(i2) === codeBackslash) {
          const char = text.charAt(i2 + 1);
          const escapeChar = escapeCharacters[char];
          if (escapeChar !== void 0) {
            str += text.slice(i2, i2 + 2);
            i2 += 2;
          } else if (char === "u") {
            let j = 2;
            while (j < 6 && isHex(text.charCodeAt(i2 + j))) {
              j++;
            }
            if (j === 6) {
              str += text.slice(i2, i2 + 6);
              i2 += 6;
            } else if (i2 + j >= text.length) {
              i2 = text.length;
            } else {
              throwInvalidUnicodeCharacter();
            }
          } else {
            str += char;
            i2 += 2;
          }
        } else {
          const char = text.charAt(i2);
          const code = text.charCodeAt(i2);
          if (code === codeDoubleQuote && text.charCodeAt(i2 - 1) !== codeBackslash) {
            str += "\\".concat(char);
            i2++;
          } else if (isControlCharacter(code)) {
            str += controlCharacters[char];
            i2++;
          } else {
            if (!isValidStringCharacter(code)) {
              throwInvalidCharacter(char);
            }
            str += char;
            i2++;
          }
        }
        if (skipEscapeChars) {
          skipEscapeCharacter();
        }
      }
    }
    return false;
  }
  function parseConcatenatedString() {
    let processed2 = false;
    parseWhitespaceAndSkipComments();
    while (text.charCodeAt(i2) === codePlus) {
      processed2 = true;
      i2++;
      parseWhitespaceAndSkipComments();
      output = stripLastOccurrence(output, '"', true);
      const start = output.length;
      const parsedStr = parseString();
      if (parsedStr) {
        output = removeAtIndex(output, start, 1);
      } else {
        output = insertBeforeLastWhitespace(output, '"');
      }
    }
    return processed2;
  }
  function parseNumber() {
    const start = i2;
    if (text.charCodeAt(i2) === codeMinus) {
      i2++;
      if (atEndOfNumber()) {
        repairNumberEndingWithNumericSymbol(start);
        return true;
      }
      if (!isDigit(text.charCodeAt(i2))) {
        i2 = start;
        return false;
      }
    }
    while (isDigit(text.charCodeAt(i2))) {
      i2++;
    }
    if (text.charCodeAt(i2) === codeDot) {
      i2++;
      if (atEndOfNumber()) {
        repairNumberEndingWithNumericSymbol(start);
        return true;
      }
      if (!isDigit(text.charCodeAt(i2))) {
        i2 = start;
        return false;
      }
      while (isDigit(text.charCodeAt(i2))) {
        i2++;
      }
    }
    if (text.charCodeAt(i2) === codeLowercaseE || text.charCodeAt(i2) === codeUppercaseE) {
      i2++;
      if (text.charCodeAt(i2) === codeMinus || text.charCodeAt(i2) === codePlus) {
        i2++;
      }
      if (atEndOfNumber()) {
        repairNumberEndingWithNumericSymbol(start);
        return true;
      }
      if (!isDigit(text.charCodeAt(i2))) {
        i2 = start;
        return false;
      }
      while (isDigit(text.charCodeAt(i2))) {
        i2++;
      }
    }
    if (!atEndOfNumber()) {
      i2 = start;
      return false;
    }
    if (i2 > start) {
      const num = text.slice(start, i2);
      const hasInvalidLeadingZero = /^0\d/.test(num);
      output += hasInvalidLeadingZero ? '"'.concat(num, '"') : num;
      return true;
    }
    return false;
  }
  function parseKeywords() {
    return parseKeyword("true", "true") || parseKeyword("false", "false") || parseKeyword("null", "null") || // repair Python keywords True, False, None
    parseKeyword("True", "true") || parseKeyword("False", "false") || parseKeyword("None", "null");
  }
  function parseKeyword(name2, value) {
    if (text.slice(i2, i2 + name2.length) === name2) {
      output += value;
      i2 += name2.length;
      return true;
    }
    return false;
  }
  function parseUnquotedString() {
    const start = i2;
    while (i2 < text.length && !isDelimiterExceptSlash(text[i2]) && !isQuote(text.charCodeAt(i2))) {
      i2++;
    }
    if (i2 > start) {
      if (text.charCodeAt(i2) === codeOpenParenthesis && isFunctionName(text.slice(start, i2).trim())) {
        i2++;
        parseValue();
        if (text.charCodeAt(i2) === codeCloseParenthesis) {
          i2++;
          if (text.charCodeAt(i2) === codeSemicolon) {
            i2++;
          }
        }
        return true;
      } else {
        while (isWhitespace(text.charCodeAt(i2 - 1)) && i2 > 0) {
          i2--;
        }
        const symbol = text.slice(start, i2);
        output += symbol === "undefined" ? "null" : JSON.stringify(symbol);
        if (text.charCodeAt(i2) === codeDoubleQuote) {
          i2++;
        }
        return true;
      }
    }
  }
  function prevNonWhitespaceIndex(start) {
    let prev = start;
    while (prev > 0 && isWhitespace(text.charCodeAt(prev))) {
      prev--;
    }
    return prev;
  }
  function atEndOfNumber() {
    return i2 >= text.length || isDelimiter(text[i2]) || isWhitespace(text.charCodeAt(i2));
  }
  function repairNumberEndingWithNumericSymbol(start) {
    output += "".concat(text.slice(start, i2), "0");
  }
  function throwInvalidCharacter(char) {
    throw new JSONRepairError("Invalid character ".concat(JSON.stringify(char)), i2);
  }
  function throwUnexpectedCharacter() {
    throw new JSONRepairError("Unexpected character ".concat(JSON.stringify(text[i2])), i2);
  }
  function throwUnexpectedEnd() {
    throw new JSONRepairError("Unexpected end of json string", text.length);
  }
  function throwObjectKeyExpected() {
    throw new JSONRepairError("Object key expected", i2);
  }
  function throwColonExpected() {
    throw new JSONRepairError("Colon expected", i2);
  }
  function throwInvalidUnicodeCharacter() {
    const chars = text.slice(i2, i2 + 6);
    throw new JSONRepairError('Invalid unicode character "'.concat(chars, '"'), i2);
  }
}
function atEndOfBlockComment(text, i2) {
  return text[i2] === "*" && text[i2 + 1] === "/";
}

// node_modules/@jsonquerylang/jsonquery/lib/jsonquery.js
var E = (t3) => Array.isArray(t3);
var L = (t3) => typeof t3 == "string";
function m(t3) {
  return (...e2) => {
    const r2 = e2.map((i2) => b(i2)), n2 = r2[0], s2 = r2[1];
    return r2.length === 1 ? (i2) => t3(n2(i2)) : r2.length === 2 ? (i2) => t3(n2(i2), s2(i2)) : (i2) => t3(...r2.map((j) => j(i2)));
  };
}
var N = {
  pipe: (...t3) => {
    const e2 = t3.map((r2) => b(r2));
    return (r2) => e2.reduce((n2, s2) => s2(n2), r2);
  },
  object: (t3) => {
    const e2 = Object.keys(t3).map((r2) => [r2, b(t3[r2])]);
    return (r2) => {
      const n2 = {};
      for (const [s2, i2] of e2)
        n2[s2] = i2(r2);
      return n2;
    };
  },
  array: (...t3) => {
    const e2 = t3.map((r2) => b(r2));
    return (r2) => e2.map((n2) => n2(r2));
  },
  get: (...t3) => {
    if (t3.length === 0)
      return (e2) => e2;
    if (t3.length === 1) {
      const e2 = t3[0];
      return (r2) => r2 == null ? void 0 : r2[e2];
    }
    return (e2) => {
      let r2 = e2;
      for (const n2 of t3)
        r2 = r2 == null ? void 0 : r2[n2];
      return r2;
    };
  },
  map: (t3) => {
    const e2 = b(t3);
    return (r2) => r2.map(e2);
  },
  filter: (t3) => {
    const e2 = b(t3);
    return (r2) => r2.filter(e2);
  },
  sort: (t3 = ["get"], e2) => {
    const r2 = b(t3), n2 = e2 === "desc" ? -1 : 1;
    function s2(i2, j) {
      const w = r2(i2), y = r2(j);
      return w > y ? n2 : w < y ? -n2 : 0;
    }
    return (i2) => i2.slice().sort(s2);
  },
  pick: (...t3) => {
    const e2 = t3.map(
      ([n2, ...s2]) => [s2[s2.length - 1], N.get(...s2)]
    ), r2 = (n2, s2) => {
      const i2 = {};
      for (const [j, w] of s2)
        i2[j] = w(n2);
      return i2;
    };
    return (n2) => E(n2) ? n2.map((s2) => r2(s2, e2)) : r2(n2, e2);
  },
  groupBy: (t3) => {
    const e2 = b(t3);
    return (r2) => {
      const n2 = {};
      for (const s2 of r2) {
        const i2 = e2(s2);
        n2[i2] ? n2[i2].push(s2) : n2[i2] = [s2];
      }
      return n2;
    };
  },
  keyBy: (t3) => {
    const e2 = b(t3);
    return (r2) => {
      const n2 = {};
      for (const s2 of r2) {
        const i2 = e2(s2);
        n2[i2] = n2[i2] ?? s2;
      }
      return n2;
    };
  },
  flatten: () => (t3) => t3.flat(),
  uniq: () => (t3) => [...new Set(t3)],
  uniqBy: (t3) => (e2) => Object.values(N.groupBy(t3)(e2)).map((r2) => r2[0]),
  limit: (t3) => (e2) => e2.slice(0, t3),
  size: () => (t3) => t3.length,
  keys: () => Object.keys,
  values: () => Object.values,
  prod: () => (t3) => t3.reduce((e2, r2) => e2 * r2),
  sum: () => (t3) => t3.reduce((e2, r2) => e2 + r2),
  average: () => (t3) => N.sum()(t3) / t3.length,
  min: () => (t3) => Math.min(...t3),
  max: () => (t3) => Math.max(...t3),
  in: (t3, e2) => {
    const r2 = b(t3), n2 = b(e2);
    return (s2) => n2(s2).includes(r2(s2));
  },
  "not in": (t3, e2) => {
    const r2 = N.in(t3, e2);
    return (n2) => !r2(n2);
  },
  regex: (t3, e2, r2) => {
    const n2 = new RegExp(e2, r2), s2 = b(t3);
    return (i2) => n2.test(s2(i2));
  },
  and: m((t3, e2) => t3 && e2),
  or: m((t3, e2) => t3 || e2),
  not: m((t3) => !t3),
  exists: m((t3) => t3 !== void 0),
  eq: m((t3, e2) => t3 === e2),
  gt: m((t3, e2) => t3 > e2),
  gte: m((t3, e2) => t3 >= e2),
  lt: m((t3, e2) => t3 < e2),
  lte: m((t3, e2) => t3 <= e2),
  ne: m((t3, e2) => t3 !== e2),
  add: m((t3, e2) => t3 + e2),
  subtract: m((t3, e2) => t3 - e2),
  multiply: m((t3, e2) => t3 * e2),
  divide: m((t3, e2) => t3 / e2),
  pow: m((t3, e2) => t3 ** e2),
  mod: m((t3, e2) => t3 % e2),
  abs: m(Math.abs),
  round: m((t3, e2 = 0) => +`${Math.round(+`${t3}e${e2}`)}e${-e2}`)
};
var S = [];
function b(t3, e2) {
  S.unshift({ ...N, ...S[0], ...e2 == null ? void 0 : e2.functions });
  try {
    const r2 = E(t3) ? P(t3, S[0]) : () => t3;
    return (n2) => {
      try {
        return r2(n2);
      } catch (s2) {
        throw s2.jsonquery = [{ data: n2, query: t3 }, ...s2.jsonquery ?? []], s2;
      }
    };
  } finally {
    S.shift();
  }
}
function P(t3, e2) {
  const [r2, ...n2] = t3, s2 = e2[r2];
  if (!s2)
    throw new Error(`Unknown function '${r2}'`);
  return s2(...n2);
}
var R = {
  and: "and",
  or: "or",
  eq: "==",
  gt: ">",
  gte: ">=",
  lt: "<",
  lte: "<=",
  ne: "!=",
  add: "+",
  subtract: "-",
  multiply: "*",
  divide: "/",
  pow: "^",
  mod: "%",
  in: "in",
  "not in": "not in"
};
var W = /^[a-zA-Z_$][a-zA-Z\d_$]*$/;
var I = /^[a-zA-Z_$][a-zA-Z\d_$]*/;
var U = /^"(?:[^"\\]|\\.)*"/;
var F = /^-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?/;
var J = /^(0|[1-9][0-9]*)/;
var z = /^(true|false|null)/;
var B = /^[ \n\t\r]+/;
function M(t3, e2) {
  const r2 = () => {
    h2();
    const o2 = n2();
    if (h2(), t3[c] === "|") {
      const g = [o2];
      for (; t3[c] === "|"; )
        c++, h2(), g.push(n2());
      return ["pipe", ...g];
    }
    return o2;
  }, n2 = () => {
    const o2 = { ...R, ...e2 == null ? void 0 : e2.operators }, g = s2();
    h2();
    for (const x of Object.keys(o2).sort((k2, v) => v.length - k2.length)) {
      const k2 = o2[x];
      if (t3.substring(c, c + k2.length) === k2) {
        c += k2.length, h2();
        const v = s2();
        return [x, g, v];
      }
    }
    return g;
  }, s2 = () => {
    if (t3[c] === "(") {
      c++;
      const o2 = r2();
      return p(")"), o2;
    }
    return i2();
  }, i2 = () => {
    const o2 = [];
    if (t3[c] === ".") {
      for (; t3[c] === "."; )
        c++, o2.push(
          a2() ?? u() ?? f() ?? $2("Property expected")
        );
      return ["get", ...o2];
    }
    return j();
  }, j = () => {
    const o2 = c, g = u();
    if (h2(), !g || t3[c] !== "(")
      return c = o2, w();
    c++, !(e2 != null && e2.functions[g]) && !N[g] && $2(`Unknown function '${g}'`), h2();
    const x = t3[c] !== ")" ? [r2()] : [];
    for (; c < t3.length && t3[c] !== ")"; )
      h2(), p(","), x.push(r2());
    return p(")"), [g, ...x];
  }, w = () => {
    if (t3[c] === "{") {
      c++, h2();
      const o2 = {};
      let g = true;
      for (; c < t3.length && t3[c] !== "}"; ) {
        g ? g = false : (p(","), h2());
        const x = a2() ?? u() ?? f() ?? $2("Key expected");
        h2(), p(":"), o2[x] = r2();
      }
      return p("}"), ["object", o2];
    }
    return y();
  }, y = () => {
    if (t3[c] === "[") {
      c++, h2();
      const o2 = [];
      let g = true;
      for (; c < t3.length && t3[c] !== "]"; )
        g ? g = false : (p(","), h2()), o2.push(r2());
      return p("]"), ["array", ...o2];
    }
    return a2() ?? l() ?? _2();
  }, a2 = () => d(U, JSON.parse), u = () => d(I, (o2) => o2), l = () => d(F, JSON.parse), f = () => d(J, JSON.parse), _2 = () => {
    const o2 = d(z, JSON.parse);
    if (o2 !== void 0)
      return o2;
    $2("Value expected");
  }, O = () => {
    h2(), c < t3.length && $2(`Unexpected part '${t3.substring(c)}'`);
  }, d = (o2, g) => {
    const x = t3.substring(c).match(o2);
    if (x)
      return c += x[0].length, g(x[0]);
  }, h2 = () => d(B, (o2) => o2), p = (o2) => {
    t3[c] !== o2 && $2(`Character '${o2}' expected`), c++;
  }, $2 = (o2, g = c) => {
    throw new SyntaxError(`${o2} (pos: ${g})`);
  };
  let c = 0;
  const A = r2();
  return O(), A;
}
var T = 40;
var Z = "  ";
var D = (t3, e2) => {
  const r2 = (e2 == null ? void 0 : e2.indentation) ?? Z, n2 = (a2, u) => E(a2) ? s2(a2, u) : JSON.stringify(a2), s2 = (a2, u) => {
    var h2;
    const [l, ...f] = a2;
    if (l === "get" && f.length > 0)
      return j(f);
    if (l === "pipe") {
      const p = f.map(($2) => n2($2, u + r2));
      return y(p, ["", " | ", ""], ["", `
${u + r2}| `, ""]);
    }
    if (l === "object")
      return i2(f[0], u);
    if (l === "array") {
      const p = f.map(($2) => n2($2, u));
      return y(
        p,
        ["[", ", ", "]"],
        [`[
${u + r2}`, `,
${u + r2}`, `
${u}]`]
      );
    }
    const _2 = ((h2 = e2 == null ? void 0 : e2.operators) == null ? void 0 : h2[l]) ?? R[l];
    if (_2 && f.length === 2) {
      const [p, $2] = f, c = n2(p, u), A = n2($2, u);
      return `(${c} ${_2} ${A})`;
    }
    const O = f.length === 1 ? u : u + r2, d = f.map((p) => n2(p, O));
    return f.length === 1 && d[0][0] === "(" ? `${l}${d}` : y(
      d,
      [`${l}(`, ", ", ")"],
      f.length === 1 ? [`${l}(`, `,
${u}`, ")"] : [`${l}(
${O}`, `,
${O}`, `
${u})`]
    );
  }, i2 = (a2, u) => {
    const l = u + r2, f = Object.entries(a2).map(([_2, O]) => `${w(_2)}: ${n2(O, l)}`);
    return y(
      f,
      ["{ ", ", ", " }"],
      [`{
${l}`, `,
${l}`, `
${u}}`]
    );
  }, j = (a2) => a2.map((u) => `.${w(u)}`).join(""), w = (a2) => W.test(a2) ? a2 : JSON.stringify(a2), y = (a2, [u, l, f], [_2, O, d]) => u.length + a2.reduce((p, $2) => p + $2.length + l.length, 0) - l.length + f.length <= ((e2 == null ? void 0 : e2.maxLineLength) ?? T) ? u + a2.join(l) + f : _2 + a2.join(O) + d;
  return n2(t3, "");
};
function K(t3, e2, r2) {
  return b(L(e2) ? M(e2, r2) : e2, r2)(t3);
}

// node_modules/@fortawesome/free-regular-svg-icons/index.mjs
var faLightbulb = {
  prefix: "far",
  iconName: "lightbulb",
  icon: [384, 512, [128161], "f0eb", "M297.2 248.9C311.6 228.3 320 203.2 320 176c0-70.7-57.3-128-128-128S64 105.3 64 176c0 27.2 8.4 52.3 22.8 72.9c3.7 5.3 8.1 11.3 12.8 17.7c0 0 0 0 0 0c12.9 17.7 28.3 38.9 39.8 59.8c10.4 19 15.7 38.8 18.3 57.5L109 384c-2.2-12-5.9-23.7-11.8-34.5c-9.9-18-22.2-34.9-34.5-51.8c0 0 0 0 0 0s0 0 0 0c-5.2-7.1-10.4-14.2-15.4-21.4C27.6 247.9 16 213.3 16 176C16 78.8 94.8 0 192 0s176 78.8 176 176c0 37.3-11.6 71.9-31.4 100.3c-5 7.2-10.2 14.3-15.4 21.4c0 0 0 0 0 0s0 0 0 0c-12.3 16.8-24.6 33.7-34.5 51.8c-5.9 10.8-9.6 22.5-11.8 34.5l-48.6 0c2.6-18.7 7.9-38.6 18.3-57.5c11.5-20.9 26.9-42.1 39.8-59.8c0 0 0 0 0 0s0 0 0 0s0 0 0 0c4.7-6.4 9-12.4 12.7-17.7zM192 128c-26.5 0-48 21.5-48 48c0 8.8-7.2 16-16 16s-16-7.2-16-16c0-44.2 35.8-80 80-80c8.8 0 16 7.2 16 16s-7.2 16-16 16zm0 384c-44.2 0-80-35.8-80-80l0-16 160 0 0 16c0 44.2-35.8 80-80 80z"]
};
var faSquareCheck = {
  prefix: "far",
  iconName: "square-check",
  icon: [448, 512, [9745, 9989, 61510, "check-square"], "f14a", "M64 80c-8.8 0-16 7.2-16 16l0 320c0 8.8 7.2 16 16 16l320 0c8.8 0 16-7.2 16-16l0-320c0-8.8-7.2-16-16-16L64 80zM0 96C0 60.7 28.7 32 64 32l320 0c35.3 0 64 28.7 64 64l0 320c0 35.3-28.7 64-64 64L64 480c-35.3 0-64-28.7-64-64L0 96zM337 209L209 337c-9.4 9.4-24.6 9.4-33.9 0l-64-64c-9.4-9.4-9.4-24.6 0-33.9s24.6-9.4 33.9 0l47 47L303 175c9.4-9.4 24.6-9.4 33.9 0s9.4 24.6 0 33.9z"]
};
var faCheckSquare = faSquareCheck;
var faSquare = {
  prefix: "far",
  iconName: "square",
  icon: [448, 512, [9632, 9723, 9724, 61590], "f0c8", "M384 80c8.8 0 16 7.2 16 16l0 320c0 8.8-7.2 16-16 16L64 432c-8.8 0-16-7.2-16-16L48 96c0-8.8 7.2-16 16-16l320 0zM64 32C28.7 32 0 60.7 0 96L0 416c0 35.3 28.7 64 64 64l320 0c35.3 0 64-28.7 64-64l0-320c0-35.3-28.7-64-64-64L64 32z"]
};
var faClock = {
  prefix: "far",
  iconName: "clock",
  icon: [512, 512, [128339, "clock-four"], "f017", "M464 256A208 208 0 1 1 48 256a208 208 0 1 1 416 0zM0 256a256 256 0 1 0 512 0A256 256 0 1 0 0 256zM232 120l0 136c0 8 4 15.5 10.7 20l96 64c11 7.4 25.9 4.4 33.3-6.7s4.4-25.9-6.7-33.3L280 243.2 280 120c0-13.3-10.7-24-24-24s-24 10.7-24 24z"]
};

// node_modules/@fortawesome/free-solid-svg-icons/index.mjs
var faTrashCan = {
  prefix: "fas",
  iconName: "trash-can",
  icon: [448, 512, [61460, "trash-alt"], "f2ed", "M135.2 17.7C140.6 6.8 151.7 0 163.8 0L284.2 0c12.1 0 23.2 6.8 28.6 17.7L320 32l96 0c17.7 0 32 14.3 32 32s-14.3 32-32 32L32 96C14.3 96 0 81.7 0 64S14.3 32 32 32l96 0 7.2-14.3zM32 128l384 0 0 320c0 35.3-28.7 64-64 64L96 512c-35.3 0-64-28.7-64-64l0-320zm96 64c-8.8 0-16 7.2-16 16l0 224c0 8.8 7.2 16 16 16s16-7.2 16-16l0-224c0-8.8-7.2-16-16-16zm96 0c-8.8 0-16 7.2-16 16l0 224c0 8.8 7.2 16 16 16s16-7.2 16-16l0-224c0-8.8-7.2-16-16-16zm96 0c-8.8 0-16 7.2-16 16l0 224c0 8.8 7.2 16 16 16s16-7.2 16-16l0-224c0-8.8-7.2-16-16-16z"]
};
var faDownLeftAndUpRightToCenter = {
  prefix: "fas",
  iconName: "down-left-and-up-right-to-center",
  icon: [512, 512, ["compress-alt"], "f422", "M439 7c9.4-9.4 24.6-9.4 33.9 0l32 32c9.4 9.4 9.4 24.6 0 33.9l-87 87 39 39c6.9 6.9 8.9 17.2 5.2 26.2s-12.5 14.8-22.2 14.8l-144 0c-13.3 0-24-10.7-24-24l0-144c0-9.7 5.8-18.5 14.8-22.2s19.3-1.7 26.2 5.2l39 39L439 7zM72 272l144 0c13.3 0 24 10.7 24 24l0 144c0 9.7-5.8 18.5-14.8 22.2s-19.3 1.7-26.2-5.2l-39-39L73 505c-9.4 9.4-24.6 9.4-33.9 0L7 473c-9.4-9.4-9.4-24.6 0-33.9l87-87L55 313c-6.9-6.9-8.9-17.2-5.2-26.2s12.5-14.8 22.2-14.8z"]
};
var faCaretRight = {
  prefix: "fas",
  iconName: "caret-right",
  icon: [256, 512, [], "f0da", "M246.6 278.6c12.5-12.5 12.5-32.8 0-45.3l-128-128c-9.2-9.2-22.9-11.9-34.9-6.9s-19.8 16.6-19.8 29.6l0 256c0 12.9 7.8 24.6 19.8 29.6s25.7 2.2 34.9-6.9l128-128z"]
};
var faPaste = {
  prefix: "fas",
  iconName: "paste",
  icon: [512, 512, ["file-clipboard"], "f0ea", "M160 0c-23.7 0-44.4 12.9-55.4 32L48 32C21.5 32 0 53.5 0 80L0 400c0 26.5 21.5 48 48 48l144 0 0-272c0-44.2 35.8-80 80-80l48 0 0-16c0-26.5-21.5-48-48-48l-56.6 0C204.4 12.9 183.7 0 160 0zM272 128c-26.5 0-48 21.5-48 48l0 272 0 16c0 26.5 21.5 48 48 48l192 0c26.5 0 48-21.5 48-48l0-220.1c0-12.7-5.1-24.9-14.1-33.9l-67.9-67.9c-9-9-21.2-14.1-33.9-14.1L320 128l-48 0zM160 40a24 24 0 1 1 0 48 24 24 0 1 1 0-48z"]
};
var faCircleNotch = {
  prefix: "fas",
  iconName: "circle-notch",
  icon: [512, 512, [], "f1ce", "M222.7 32.1c5 16.9-4.6 34.8-21.5 39.8C121.8 95.6 64 169.1 64 256c0 106 86 192 192 192s192-86 192-192c0-86.9-57.8-160.4-137.1-184.1c-16.9-5-26.6-22.9-21.5-39.8s22.9-26.6 39.8-21.5C434.9 42.1 512 140 512 256c0 141.4-114.6 256-256 256S0 397.4 0 256C0 140 77.1 42.1 182.9 10.6c16.9-5 34.8 4.6 39.8 21.5z"]
};
var faScissors = {
  prefix: "fas",
  iconName: "scissors",
  icon: [512, 512, [9984, 9986, 9988, "cut"], "f0c4", "M256 192l-39.5-39.5c4.9-12.6 7.5-26.2 7.5-40.5C224 50.1 173.9 0 112 0S0 50.1 0 112s50.1 112 112 112c14.3 0 27.9-2.7 40.5-7.5L192 256l-39.5 39.5c-12.6-4.9-26.2-7.5-40.5-7.5C50.1 288 0 338.1 0 400s50.1 112 112 112s112-50.1 112-112c0-14.3-2.7-27.9-7.5-40.5L499.2 76.8c7.1-7.1 7.1-18.5 0-25.6c-28.3-28.3-74.1-28.3-102.4 0L256 192zm22.6 150.6L396.8 460.8c28.3 28.3 74.1 28.3 102.4 0c7.1-7.1 7.1-18.5 0-25.6L342.6 278.6l-64 64zM64 112a48 48 0 1 1 96 0 48 48 0 1 1 -96 0zm48 240a48 48 0 1 1 0 96 48 48 0 1 1 0-96z"]
};
var faCut = faScissors;
var faSquareCaretDown = {
  prefix: "fas",
  iconName: "square-caret-down",
  icon: [448, 512, ["caret-square-down"], "f150", "M384 480c35.3 0 64-28.7 64-64l0-320c0-35.3-28.7-64-64-64L64 32C28.7 32 0 60.7 0 96L0 416c0 35.3 28.7 64 64 64l320 0zM224 352c-6.7 0-13-2.8-17.6-7.7l-104-112c-6.5-7-8.2-17.2-4.4-25.9s12.5-14.4 22-14.4l208 0c9.5 0 18.2 5.7 22 14.4s2.1 18.9-4.4 25.9l-104 112c-4.5 4.9-10.9 7.7-17.6 7.7z"]
};
var faCaretSquareDown = faSquareCaretDown;
var faCaretLeft = {
  prefix: "fas",
  iconName: "caret-left",
  icon: [256, 512, [], "f0d9", "M9.4 278.6c-12.5-12.5-12.5-32.8 0-45.3l128-128c9.2-9.2 22.9-11.9 34.9-6.9s19.8 16.6 19.8 29.6l0 256c0 12.9-7.8 24.6-19.8 29.6s-25.7 2.2-34.9-6.9l-128-128z"]
};
var faSquareCheck2 = {
  prefix: "fas",
  iconName: "square-check",
  icon: [448, 512, [9745, 9989, 61510, "check-square"], "f14a", "M64 32C28.7 32 0 60.7 0 96L0 416c0 35.3 28.7 64 64 64l320 0c35.3 0 64-28.7 64-64l0-320c0-35.3-28.7-64-64-64L64 32zM337 209L209 337c-9.4 9.4-24.6 9.4-33.9 0l-64-64c-9.4-9.4-9.4-24.6 0-33.9s24.6-9.4 33.9 0l47 47L303 175c9.4-9.4 24.6-9.4 33.9 0s9.4 24.6 0 33.9z"]
};
var faCheckSquare2 = faSquareCheck2;
var faPenToSquare = {
  prefix: "fas",
  iconName: "pen-to-square",
  icon: [512, 512, ["edit"], "f044", "M471.6 21.7c-21.9-21.9-57.3-21.9-79.2 0L362.3 51.7l97.9 97.9 30.1-30.1c21.9-21.9 21.9-57.3 0-79.2L471.6 21.7zm-299.2 220c-6.1 6.1-10.8 13.6-13.5 21.9l-29.6 88.8c-2.9 8.6-.6 18.1 5.8 24.6s15.9 8.7 24.6 5.8l88.8-29.6c8.2-2.7 15.7-7.4 21.9-13.5L437.7 172.3 339.7 74.3 172.4 241.7zM96 64C43 64 0 107 0 160L0 416c0 53 43 96 96 96l256 0c53 0 96-43 96-96l0-96c0-17.7-14.3-32-32-32s-32 14.3-32 32l0 96c0 17.7-14.3 32-32 32L96 448c-17.7 0-32-14.3-32-32l0-256c0-17.7 14.3-32 32-32l96 0c17.7 0 32-14.3 32-32s-14.3-32-32-32L96 64z"]
};
var faEdit = faPenToSquare;
var faChevronUp = {
  prefix: "fas",
  iconName: "chevron-up",
  icon: [512, 512, [], "f077", "M233.4 105.4c12.5-12.5 32.8-12.5 45.3 0l192 192c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L256 173.3 86.6 342.6c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3l192-192z"]
};
var faAngleRight = {
  prefix: "fas",
  iconName: "angle-right",
  icon: [320, 512, [8250], "f105", "M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"]
};
var faSquareCaretUp = {
  prefix: "fas",
  iconName: "square-caret-up",
  icon: [448, 512, ["caret-square-up"], "f151", "M64 32C28.7 32 0 60.7 0 96L0 416c0 35.3 28.7 64 64 64l320 0c35.3 0 64-28.7 64-64l0-320c0-35.3-28.7-64-64-64L64 32zM224 160c6.7 0 13 2.8 17.6 7.7l104 112c6.5 7 8.2 17.2 4.4 25.9s-12.5 14.4-22 14.4l-208 0c-9.5 0-18.2-5.7-22-14.4s-2.1-18.9 4.4-25.9l104-112c4.5-4.9 10.9-7.7 17.6-7.7z"]
};
var faCaretSquareUp = faSquareCaretUp;
var faCaretUp = {
  prefix: "fas",
  iconName: "caret-up",
  icon: [320, 512, [], "f0d8", "M182.6 137.4c-12.5-12.5-32.8-12.5-45.3 0l-128 128c-9.2 9.2-11.9 22.9-6.9 34.9s16.6 19.8 29.6 19.8l256 0c12.9 0 24.6-7.8 29.6-19.8s2.2-25.7-6.9-34.9l-128-128z"]
};
var faSquare2 = {
  prefix: "fas",
  iconName: "square",
  icon: [448, 512, [9632, 9723, 9724, 61590], "f0c8", "M0 96C0 60.7 28.7 32 64 32H384c35.3 0 64 28.7 64 64V416c0 35.3-28.7 64-64 64H64c-35.3 0-64-28.7-64-64V96z"]
};
var faFilter = {
  prefix: "fas",
  iconName: "filter",
  icon: [512, 512, [], "f0b0", "M3.9 54.9C10.5 40.9 24.5 32 40 32l432 0c15.5 0 29.5 8.9 36.1 22.9s4.6 30.5-5.2 42.5L320 320.9 320 448c0 12.1-6.8 23.2-17.7 28.6s-23.8 4.3-33.5-3l-64-48c-8.1-6-12.8-15.5-12.8-25.6l0-79.1L9 97.3C-.7 85.4-2.8 68.8 3.9 54.9z"]
};
var faCode = {
  prefix: "fas",
  iconName: "code",
  icon: [640, 512, [], "f121", "M392.8 1.2c-17-4.9-34.7 5-39.6 22l-128 448c-4.9 17 5 34.7 22 39.6s34.7-5 39.6-22l128-448c4.9-17-5-34.7-22-39.6zm80.6 120.1c-12.5 12.5-12.5 32.8 0 45.3L562.7 256l-89.4 89.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0l112-112c12.5-12.5 12.5-32.8 0-45.3l-112-112c-12.5-12.5-32.8-12.5-45.3 0zm-306.7 0c-12.5-12.5-32.8-12.5-45.3 0l-112 112c-12.5 12.5-12.5 32.8 0 45.3l112 112c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L77.3 256l89.4-89.4c12.5-12.5 12.5-32.8 0-45.3z"]
};
var faWrench = {
  prefix: "fas",
  iconName: "wrench",
  icon: [512, 512, [128295], "f0ad", "M352 320c88.4 0 160-71.6 160-160c0-15.3-2.2-30.1-6.2-44.2c-3.1-10.8-16.4-13.2-24.3-5.3l-76.8 76.8c-3 3-7.1 4.7-11.3 4.7L336 192c-8.8 0-16-7.2-16-16l0-57.4c0-4.2 1.7-8.3 4.7-11.3l76.8-76.8c7.9-7.9 5.4-21.2-5.3-24.3C382.1 2.2 367.3 0 352 0C263.6 0 192 71.6 192 160c0 19.1 3.4 37.5 9.5 54.5L19.9 396.1C7.2 408.8 0 426.1 0 444.1C0 481.6 30.4 512 67.9 512c18 0 35.3-7.2 48-19.9L297.5 310.5c17 6.2 35.4 9.5 54.5 9.5zM80 408a24 24 0 1 1 0 48 24 24 0 1 1 0-48z"]
};
var faEye = {
  prefix: "fas",
  iconName: "eye",
  icon: [576, 512, [128065], "f06e", "M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM144 256a144 144 0 1 1 288 0 144 144 0 1 1 -288 0zm144-64c0 35.3-28.7 64-64 64c-7.1 0-13.9-1.2-20.3-3.3c-5.5-1.8-11.9 1.6-11.7 7.4c.3 6.9 1.3 13.8 3.2 20.7c13.7 51.2 66.4 81.6 117.6 67.9s81.6-66.4 67.9-117.6c-11.1-41.5-47.8-69.4-88.6-71.1c-5.8-.2-9.2 6.1-7.4 11.7c2.1 6.4 3.3 13.2 3.3 20.3z"]
};
var faPen = {
  prefix: "fas",
  iconName: "pen",
  icon: [512, 512, [128394], "f304", "M362.7 19.3L314.3 67.7 444.3 197.7l48.4-48.4c25-25 25-65.5 0-90.5L453.3 19.3c-25-25-65.5-25-90.5 0zm-71 71L58.6 323.5c-10.4 10.4-18 23.3-22.2 37.4L1 481.2C-1.5 489.7 .8 498.8 7 505s15.3 8.5 23.7 6.1l120.3-35.4c14.1-4.2 27-11.8 37.4-22.2L421.7 220.3 291.7 90.3z"]
};
var faArrowRotateRight = {
  prefix: "fas",
  iconName: "arrow-rotate-right",
  icon: [512, 512, [8635, "arrow-right-rotate", "arrow-rotate-forward", "redo"], "f01e", "M386.3 160L336 160c-17.7 0-32 14.3-32 32s14.3 32 32 32l128 0c17.7 0 32-14.3 32-32l0-128c0-17.7-14.3-32-32-32s-32 14.3-32 32l0 51.2L414.4 97.6c-87.5-87.5-229.3-87.5-316.8 0s-87.5 229.3 0 316.8s229.3 87.5 316.8 0c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0c-62.5 62.5-163.8 62.5-226.3 0s-62.5-163.8 0-226.3s163.8-62.5 226.3 0L386.3 160z"]
};
var faRedo = faArrowRotateRight;
var faArrowRotateLeft = {
  prefix: "fas",
  iconName: "arrow-rotate-left",
  icon: [512, 512, [8634, "arrow-left-rotate", "arrow-rotate-back", "arrow-rotate-backward", "undo"], "f0e2", "M125.7 160l50.3 0c17.7 0 32 14.3 32 32s-14.3 32-32 32L48 224c-17.7 0-32-14.3-32-32L16 64c0-17.7 14.3-32 32-32s32 14.3 32 32l0 51.2L97.6 97.6c87.5-87.5 229.3-87.5 316.8 0s87.5 229.3 0 316.8s-229.3 87.5-316.8 0c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0c62.5 62.5 163.8 62.5 226.3 0s62.5-163.8 0-226.3s-163.8-62.5-226.3 0L125.7 160z"]
};
var faUndo = faArrowRotateLeft;
var faCropSimple = {
  prefix: "fas",
  iconName: "crop-simple",
  icon: [512, 512, ["crop-alt"], "f565", "M128 32c0-17.7-14.3-32-32-32S64 14.3 64 32l0 32L32 64C14.3 64 0 78.3 0 96s14.3 32 32 32l32 0 0 256c0 35.3 28.7 64 64 64l224 0 0-64-224 0 0-352zM384 480c0 17.7 14.3 32 32 32s32-14.3 32-32l0-32 32 0c17.7 0 32-14.3 32-32s-14.3-32-32-32l-32 0 0-256c0-35.3-28.7-64-64-64L160 64l0 64 224 0 0 352z"]
};
var faCropAlt = faCropSimple;
var faGear = {
  prefix: "fas",
  iconName: "gear",
  icon: [512, 512, [9881, "cog"], "f013", "M495.9 166.6c3.2 8.7 .5 18.4-6.4 24.6l-43.3 39.4c1.1 8.3 1.7 16.8 1.7 25.4s-.6 17.1-1.7 25.4l43.3 39.4c6.9 6.2 9.6 15.9 6.4 24.6c-4.4 11.9-9.7 23.3-15.8 34.3l-4.7 8.1c-6.6 11-14 21.4-22.1 31.2c-5.9 7.2-15.7 9.6-24.5 6.8l-55.7-17.7c-13.4 10.3-28.2 18.9-44 25.4l-12.5 57.1c-2 9.1-9 16.3-18.2 17.8c-13.8 2.3-28 3.5-42.5 3.5s-28.7-1.2-42.5-3.5c-9.2-1.5-16.2-8.7-18.2-17.8l-12.5-57.1c-15.8-6.5-30.6-15.1-44-25.4L83.1 425.9c-8.8 2.8-18.6 .3-24.5-6.8c-8.1-9.8-15.5-20.2-22.1-31.2l-4.7-8.1c-6.1-11-11.4-22.4-15.8-34.3c-3.2-8.7-.5-18.4 6.4-24.6l43.3-39.4C64.6 273.1 64 264.6 64 256s.6-17.1 1.7-25.4L22.4 191.2c-6.9-6.2-9.6-15.9-6.4-24.6c4.4-11.9 9.7-23.3 15.8-34.3l4.7-8.1c6.6-11 14-21.4 22.1-31.2c5.9-7.2 15.7-9.6 24.5-6.8l55.7 17.7c13.4-10.3 28.2-18.9 44-25.4l12.5-57.1c2-9.1 9-16.3 18.2-17.8C227.3 1.2 241.5 0 256 0s28.7 1.2 42.5 3.5c9.2 1.5 16.2 8.7 18.2 17.8l12.5 57.1c15.8 6.5 30.6 15.1 44 25.4l55.7-17.7c8.8-2.8 18.6-.3 24.5 6.8c8.1 9.8 15.5 20.2 22.1 31.2l4.7 8.1c6.1 11 11.4 22.4 15.8 34.3zM256 336a80 80 0 1 0 0-160 80 80 0 1 0 0 160z"]
};
var faCog = faGear;
var faCaretDown = {
  prefix: "fas",
  iconName: "caret-down",
  icon: [320, 512, [], "f0d7", "M137.4 374.6c12.5 12.5 32.8 12.5 45.3 0l128-128c9.2-9.2 11.9-22.9 6.9-34.9s-16.6-19.8-29.6-19.8L32 192c-12.9 0-24.6 7.8-29.6 19.8s-2.2 25.7 6.9 34.9l128 128z"]
};
var faEllipsisVertical = {
  prefix: "fas",
  iconName: "ellipsis-vertical",
  icon: [128, 512, ["ellipsis-v"], "f142", "M64 360a56 56 0 1 0 0 112 56 56 0 1 0 0-112zm0-160a56 56 0 1 0 0 112 56 56 0 1 0 0-112zM120 96A56 56 0 1 0 8 96a56 56 0 1 0 112 0z"]
};
var faEllipsisV = faEllipsisVertical;
var faArrowRightArrowLeft = {
  prefix: "fas",
  iconName: "arrow-right-arrow-left",
  icon: [448, 512, [8644, "exchange"], "f0ec", "M438.6 150.6c12.5-12.5 12.5-32.8 0-45.3l-96-96c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3L338.7 96 32 96C14.3 96 0 110.3 0 128s14.3 32 32 32l306.7 0-41.4 41.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0l96-96zm-333.3 352c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 416 416 416c17.7 0 32-14.3 32-32s-14.3-32-32-32l-306.7 0 41.4-41.4c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-96 96c-12.5 12.5-12.5 32.8 0 45.3l96 96z"]
};
var faArrowDownShortWide = {
  prefix: "fas",
  iconName: "arrow-down-short-wide",
  icon: [576, 512, ["sort-amount-desc", "sort-amount-down-alt"], "f884", "M151.6 469.6C145.5 476.2 137 480 128 480s-17.5-3.8-23.6-10.4l-88-96c-11.9-13-11.1-33.3 2-45.2s33.3-11.1 45.2 2L96 365.7 96 64c0-17.7 14.3-32 32-32s32 14.3 32 32l0 301.7 32.4-35.4c11.9-13 32.2-13.9 45.2-2s13.9 32.2 2 45.2l-88 96zM320 32l32 0c17.7 0 32 14.3 32 32s-14.3 32-32 32l-32 0c-17.7 0-32-14.3-32-32s14.3-32 32-32zm0 128l96 0c17.7 0 32 14.3 32 32s-14.3 32-32 32l-96 0c-17.7 0-32-14.3-32-32s14.3-32 32-32zm0 128l160 0c17.7 0 32 14.3 32 32s-14.3 32-32 32l-160 0c-17.7 0-32-14.3-32-32s14.3-32 32-32zm0 128l224 0c17.7 0 32 14.3 32 32s-14.3 32-32 32l-224 0c-17.7 0-32-14.3-32-32s14.3-32 32-32z"]
};
var faSortAmountDownAlt = faArrowDownShortWide;
var faAngleDown = {
  prefix: "fas",
  iconName: "angle-down",
  icon: [448, 512, [8964], "f107", "M201.4 374.6c12.5 12.5 32.8 12.5 45.3 0l160-160c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L224 306.7 86.6 169.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l160 160z"]
};
var faArrowDown = {
  prefix: "fas",
  iconName: "arrow-down",
  icon: [384, 512, [8595], "f063", "M169.4 470.6c12.5 12.5 32.8 12.5 45.3 0l160-160c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L224 370.8 224 64c0-17.7-14.3-32-32-32s-32 14.3-32 32l0 306.7L54.6 265.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l160 160z"]
};
var faMagnifyingGlass = {
  prefix: "fas",
  iconName: "magnifying-glass",
  icon: [512, 512, [128269, "search"], "f002", "M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352a144 144 0 1 0 0-288 144 144 0 1 0 0 288z"]
};
var faSearch = faMagnifyingGlass;
var faChevronDown = {
  prefix: "fas",
  iconName: "chevron-down",
  icon: [512, 512, [], "f078", "M233.4 406.6c12.5 12.5 32.8 12.5 45.3 0l192-192c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L256 338.7 86.6 169.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l192 192z"]
};
var faCopy = {
  prefix: "fas",
  iconName: "copy",
  icon: [448, 512, [], "f0c5", "M208 0L332.1 0c12.7 0 24.9 5.1 33.9 14.1l67.9 67.9c9 9 14.1 21.2 14.1 33.9L448 336c0 26.5-21.5 48-48 48l-192 0c-26.5 0-48-21.5-48-48l0-288c0-26.5 21.5-48 48-48zM48 128l80 0 0 64-64 0 0 256 192 0 0-32 64 0 0 48c0 26.5-21.5 48-48 48L48 512c-26.5 0-48-21.5-48-48L0 176c0-26.5 21.5-48 48-48z"]
};
var faPlus = {
  prefix: "fas",
  iconName: "plus",
  icon: [448, 512, [10133, 61543, "add"], "2b", "M256 80c0-17.7-14.3-32-32-32s-32 14.3-32 32l0 144L48 224c-17.7 0-32 14.3-32 32s14.3 32 32 32l144 0 0 144c0 17.7 14.3 32 32 32s32-14.3 32-32l0-144 144 0c17.7 0 32-14.3 32-32s-14.3-32-32-32l-144 0 0-144z"]
};
var faXmark = {
  prefix: "fas",
  iconName: "xmark",
  icon: [384, 512, [128473, 10005, 10006, 10060, 215, "close", "multiply", "remove", "times"], "f00d", "M342.6 150.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L192 210.7 86.6 105.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3L146.7 256 41.4 361.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0L192 301.3 297.4 406.6c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L237.3 256 342.6 150.6z"]
};
var faClose = faXmark;
var faTimes = faXmark;
var faRotate = {
  prefix: "fas",
  iconName: "rotate",
  icon: [512, 512, [128260, "sync-alt"], "f2f1", "M142.9 142.9c-17.5 17.5-30.1 38-37.8 59.8c-5.9 16.7-24.2 25.4-40.8 19.5s-25.4-24.2-19.5-40.8C55.6 150.7 73.2 122 97.6 97.6c87.2-87.2 228.3-87.5 315.8-1L455 55c6.9-6.9 17.2-8.9 26.2-5.2s14.8 12.5 14.8 22.2l0 128c0 13.3-10.7 24-24 24l-8.4 0c0 0 0 0 0 0L344 224c-9.7 0-18.5-5.8-22.2-14.8s-1.7-19.3 5.2-26.2l41.1-41.1c-62.6-61.5-163.1-61.2-225.3 1zM16 312c0-13.3 10.7-24 24-24l7.6 0 .7 0L168 288c9.7 0 18.5 5.8 22.2 14.8s1.7 19.3-5.2 26.2l-41.1 41.1c62.6 61.5 163.1 61.2 225.3-1c17.5-17.5 30.1-38 37.8-59.8c5.9-16.7 24.2-25.4 40.8-19.5s25.4 24.2 19.5 40.8c-10.8 30.6-28.4 59.3-52.9 83.8c-87.2 87.2-228.3 87.5-315.8 1L57 457c-6.9 6.9-17.2 8.9-26.2 5.2S16 449.7 16 440l0-119.6 0-.7 0-7.6z"]
};
var faUpRightAndDownLeftFromCenter = {
  prefix: "fas",
  iconName: "up-right-and-down-left-from-center",
  icon: [512, 512, ["expand-alt"], "f424", "M344 0L488 0c13.3 0 24 10.7 24 24l0 144c0 9.7-5.8 18.5-14.8 22.2s-19.3 1.7-26.2-5.2l-39-39-87 87c-9.4 9.4-24.6 9.4-33.9 0l-32-32c-9.4-9.4-9.4-24.6 0-33.9l87-87L327 41c-6.9-6.9-8.9-17.2-5.2-26.2S334.3 0 344 0zM168 512L24 512c-13.3 0-24-10.7-24-24L0 344c0-9.7 5.8-18.5 14.8-22.2s19.3-1.7 26.2 5.2l39 39 87-87c9.4-9.4 24.6-9.4 33.9 0l32 32c9.4 9.4 9.4 24.6 0 33.9l-87 87 39 39c6.9 6.9 8.9 17.2 5.2 26.2s-12.5 14.8-22.2 14.8z"]
};
var faClone = {
  prefix: "fas",
  iconName: "clone",
  icon: [512, 512, [], "f24d", "M288 448L64 448l0-224 64 0 0-64-64 0c-35.3 0-64 28.7-64 64L0 448c0 35.3 28.7 64 64 64l224 0c35.3 0 64-28.7 64-64l0-64-64 0 0 64zm-64-96l224 0c35.3 0 64-28.7 64-64l0-224c0-35.3-28.7-64-64-64L224 0c-35.3 0-64 28.7-64 64l0 224c0 35.3 28.7 64 64 64z"]
};
var faCheck = {
  prefix: "fas",
  iconName: "check",
  icon: [448, 512, [10003, 10004], "f00c", "M438.6 105.4c12.5 12.5 12.5 32.8 0 45.3l-256 256c-12.5 12.5-32.8 12.5-45.3 0l-128-128c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0L160 338.7 393.4 105.4c12.5-12.5 32.8-12.5 45.3 0z"]
};
var faTriangleExclamation = {
  prefix: "fas",
  iconName: "triangle-exclamation",
  icon: [512, 512, [9888, "exclamation-triangle", "warning"], "f071", "M256 32c14.2 0 27.3 7.5 34.5 19.8l216 368c7.3 12.4 7.3 27.7 .2 40.1S486.3 480 472 480L40 480c-14.3 0-27.6-7.7-34.7-20.1s-7-27.8 .2-40.1l216-368C228.7 39.5 241.8 32 256 32zm0 128c-13.3 0-24 10.7-24 24l0 112c0 13.3 10.7 24 24 24s24-10.7 24-24l0-112c0-13.3-10.7-24-24-24zm32 224a32 32 0 1 0 -64 0 32 32 0 1 0 64 0z"]
};
var faExclamationTriangle = faTriangleExclamation;

// node_modules/vanilla-jsoneditor/index.js
var import_natural_compare_lite = __toESM(require_natural_compare_lite());

// node_modules/@codemirror/state/dist/index.js
var Text = class _Text {
  /**
  Get the line description around the given position.
  */
  lineAt(pos) {
    if (pos < 0 || pos > this.length)
      throw new RangeError(`Invalid position ${pos} in document of length ${this.length}`);
    return this.lineInner(pos, false, 1, 0);
  }
  /**
  Get the description for the given (1-based) line number.
  */
  line(n2) {
    if (n2 < 1 || n2 > this.lines)
      throw new RangeError(`Invalid line number ${n2} in ${this.lines}-line document`);
    return this.lineInner(n2, true, 1, 0);
  }
  /**
  Replace a range of the text with the given content.
  */
  replace(from, to3, text) {
    [from, to3] = clip(this, from, to3);
    let parts = [];
    this.decompose(
      0,
      from,
      parts,
      2
      /* Open.To */
    );
    if (text.length)
      text.decompose(
        0,
        text.length,
        parts,
        1 | 2
        /* Open.To */
      );
    this.decompose(
      to3,
      this.length,
      parts,
      1
      /* Open.From */
    );
    return TextNode.from(parts, this.length - (to3 - from) + text.length);
  }
  /**
  Append another document to this one.
  */
  append(other) {
    return this.replace(this.length, this.length, other);
  }
  /**
  Retrieve the text between the given points.
  */
  slice(from, to3 = this.length) {
    [from, to3] = clip(this, from, to3);
    let parts = [];
    this.decompose(from, to3, parts, 0);
    return TextNode.from(parts, to3 - from);
  }
  /**
  Test whether this text is equal to another instance.
  */
  eq(other) {
    if (other == this)
      return true;
    if (other.length != this.length || other.lines != this.lines)
      return false;
    let start = this.scanIdentical(other, 1), end = this.length - this.scanIdentical(other, -1);
    let a2 = new RawTextCursor(this), b2 = new RawTextCursor(other);
    for (let skip = start, pos = start; ; ) {
      a2.next(skip);
      b2.next(skip);
      skip = 0;
      if (a2.lineBreak != b2.lineBreak || a2.done != b2.done || a2.value != b2.value)
        return false;
      pos += a2.value.length;
      if (a2.done || pos >= end)
        return true;
    }
  }
  /**
  Iterate over the text. When `dir` is `-1`, iteration happens
  from end to start. This will return lines and the breaks between
  them as separate strings.
  */
  iter(dir = 1) {
    return new RawTextCursor(this, dir);
  }
  /**
  Iterate over a range of the text. When `from` > `to`, the
  iterator will run in reverse.
  */
  iterRange(from, to3 = this.length) {
    return new PartialTextCursor(this, from, to3);
  }
  /**
  Return a cursor that iterates over the given range of lines,
  _without_ returning the line breaks between, and yielding empty
  strings for empty lines.
  
  When `from` and `to` are given, they should be 1-based line numbers.
  */
  iterLines(from, to3) {
    let inner;
    if (from == null) {
      inner = this.iter();
    } else {
      if (to3 == null)
        to3 = this.lines + 1;
      let start = this.line(from).from;
      inner = this.iterRange(start, Math.max(start, to3 == this.lines + 1 ? this.length : to3 <= 1 ? 0 : this.line(to3 - 1).to));
    }
    return new LineCursor(inner);
  }
  /**
  Return the document as a string, using newline characters to
  separate lines.
  */
  toString() {
    return this.sliceString(0);
  }
  /**
  Convert the document to an array of lines (which can be
  deserialized again via [`Text.of`](https://codemirror.net/6/docs/ref/#state.Text^of)).
  */
  toJSON() {
    let lines = [];
    this.flatten(lines);
    return lines;
  }
  /**
  @internal
  */
  constructor() {
  }
  /**
  Create a `Text` instance for the given array of lines.
  */
  static of(text) {
    if (text.length == 0)
      throw new RangeError("A document must have at least one line");
    if (text.length == 1 && !text[0])
      return _Text.empty;
    return text.length <= 32 ? new TextLeaf(text) : TextNode.from(TextLeaf.split(text, []));
  }
};
var TextLeaf = class _TextLeaf extends Text {
  constructor(text, length = textLength(text)) {
    super();
    this.text = text;
    this.length = length;
  }
  get lines() {
    return this.text.length;
  }
  get children() {
    return null;
  }
  lineInner(target, isLine, line, offset) {
    for (let i2 = 0; ; i2++) {
      let string2 = this.text[i2], end = offset + string2.length;
      if ((isLine ? line : end) >= target)
        return new Line(offset, end, line, string2);
      offset = end + 1;
      line++;
    }
  }
  decompose(from, to3, target, open) {
    let text = from <= 0 && to3 >= this.length ? this : new _TextLeaf(sliceText(this.text, from, to3), Math.min(to3, this.length) - Math.max(0, from));
    if (open & 1) {
      let prev = target.pop();
      let joined = appendText(text.text, prev.text.slice(), 0, text.length);
      if (joined.length <= 32) {
        target.push(new _TextLeaf(joined, prev.length + text.length));
      } else {
        let mid = joined.length >> 1;
        target.push(new _TextLeaf(joined.slice(0, mid)), new _TextLeaf(joined.slice(mid)));
      }
    } else {
      target.push(text);
    }
  }
  replace(from, to3, text) {
    if (!(text instanceof _TextLeaf))
      return super.replace(from, to3, text);
    [from, to3] = clip(this, from, to3);
    let lines = appendText(this.text, appendText(text.text, sliceText(this.text, 0, from)), to3);
    let newLen = this.length + text.length - (to3 - from);
    if (lines.length <= 32)
      return new _TextLeaf(lines, newLen);
    return TextNode.from(_TextLeaf.split(lines, []), newLen);
  }
  sliceString(from, to3 = this.length, lineSep = "\n") {
    [from, to3] = clip(this, from, to3);
    let result = "";
    for (let pos = 0, i2 = 0; pos <= to3 && i2 < this.text.length; i2++) {
      let line = this.text[i2], end = pos + line.length;
      if (pos > from && i2)
        result += lineSep;
      if (from < end && to3 > pos)
        result += line.slice(Math.max(0, from - pos), to3 - pos);
      pos = end + 1;
    }
    return result;
  }
  flatten(target) {
    for (let line of this.text)
      target.push(line);
  }
  scanIdentical() {
    return 0;
  }
  static split(text, target) {
    let part = [], len = -1;
    for (let line of text) {
      part.push(line);
      len += line.length + 1;
      if (part.length == 32) {
        target.push(new _TextLeaf(part, len));
        part = [];
        len = -1;
      }
    }
    if (len > -1)
      target.push(new _TextLeaf(part, len));
    return target;
  }
};
var TextNode = class _TextNode extends Text {
  constructor(children, length) {
    super();
    this.children = children;
    this.length = length;
    this.lines = 0;
    for (let child of children)
      this.lines += child.lines;
  }
  lineInner(target, isLine, line, offset) {
    for (let i2 = 0; ; i2++) {
      let child = this.children[i2], end = offset + child.length, endLine = line + child.lines - 1;
      if ((isLine ? endLine : end) >= target)
        return child.lineInner(target, isLine, line, offset);
      offset = end + 1;
      line = endLine + 1;
    }
  }
  decompose(from, to3, target, open) {
    for (let i2 = 0, pos = 0; pos <= to3 && i2 < this.children.length; i2++) {
      let child = this.children[i2], end = pos + child.length;
      if (from <= end && to3 >= pos) {
        let childOpen = open & ((pos <= from ? 1 : 0) | (end >= to3 ? 2 : 0));
        if (pos >= from && end <= to3 && !childOpen)
          target.push(child);
        else
          child.decompose(from - pos, to3 - pos, target, childOpen);
      }
      pos = end + 1;
    }
  }
  replace(from, to3, text) {
    [from, to3] = clip(this, from, to3);
    if (text.lines < this.lines)
      for (let i2 = 0, pos = 0; i2 < this.children.length; i2++) {
        let child = this.children[i2], end = pos + child.length;
        if (from >= pos && to3 <= end) {
          let updated = child.replace(from - pos, to3 - pos, text);
          let totalLines = this.lines - child.lines + updated.lines;
          if (updated.lines < totalLines >> 5 - 1 && updated.lines > totalLines >> 5 + 1) {
            let copy2 = this.children.slice();
            copy2[i2] = updated;
            return new _TextNode(copy2, this.length - (to3 - from) + text.length);
          }
          return super.replace(pos, end, updated);
        }
        pos = end + 1;
      }
    return super.replace(from, to3, text);
  }
  sliceString(from, to3 = this.length, lineSep = "\n") {
    [from, to3] = clip(this, from, to3);
    let result = "";
    for (let i2 = 0, pos = 0; i2 < this.children.length && pos <= to3; i2++) {
      let child = this.children[i2], end = pos + child.length;
      if (pos > from && i2)
        result += lineSep;
      if (from < end && to3 > pos)
        result += child.sliceString(from - pos, to3 - pos, lineSep);
      pos = end + 1;
    }
    return result;
  }
  flatten(target) {
    for (let child of this.children)
      child.flatten(target);
  }
  scanIdentical(other, dir) {
    if (!(other instanceof _TextNode))
      return 0;
    let length = 0;
    let [iA, iB, eA, eB] = dir > 0 ? [0, 0, this.children.length, other.children.length] : [this.children.length - 1, other.children.length - 1, -1, -1];
    for (; ; iA += dir, iB += dir) {
      if (iA == eA || iB == eB)
        return length;
      let chA = this.children[iA], chB = other.children[iB];
      if (chA != chB)
        return length + chA.scanIdentical(chB, dir);
      length += chA.length + 1;
    }
  }
  static from(children, length = children.reduce((l, ch2) => l + ch2.length + 1, -1)) {
    let lines = 0;
    for (let ch2 of children)
      lines += ch2.lines;
    if (lines < 32) {
      let flat = [];
      for (let ch2 of children)
        ch2.flatten(flat);
      return new TextLeaf(flat, length);
    }
    let chunk = Math.max(
      32,
      lines >> 5
      /* Tree.BranchShift */
    ), maxChunk = chunk << 1, minChunk = chunk >> 1;
    let chunked = [], currentLines = 0, currentLen = -1, currentChunk = [];
    function add3(child) {
      let last2;
      if (child.lines > maxChunk && child instanceof _TextNode) {
        for (let node of child.children)
          add3(node);
      } else if (child.lines > minChunk && (currentLines > minChunk || !currentLines)) {
        flush();
        chunked.push(child);
      } else if (child instanceof TextLeaf && currentLines && (last2 = currentChunk[currentChunk.length - 1]) instanceof TextLeaf && child.lines + last2.lines <= 32) {
        currentLines += child.lines;
        currentLen += child.length + 1;
        currentChunk[currentChunk.length - 1] = new TextLeaf(last2.text.concat(child.text), last2.length + 1 + child.length);
      } else {
        if (currentLines + child.lines > chunk)
          flush();
        currentLines += child.lines;
        currentLen += child.length + 1;
        currentChunk.push(child);
      }
    }
    function flush() {
      if (currentLines == 0)
        return;
      chunked.push(currentChunk.length == 1 ? currentChunk[0] : _TextNode.from(currentChunk, currentLen));
      currentLen = -1;
      currentLines = currentChunk.length = 0;
    }
    for (let child of children)
      add3(child);
    flush();
    return chunked.length == 1 ? chunked[0] : new _TextNode(chunked, length);
  }
};
Text.empty = new TextLeaf([""], 0);
function textLength(text) {
  let length = -1;
  for (let line of text)
    length += line.length + 1;
  return length;
}
function appendText(text, target, from = 0, to3 = 1e9) {
  for (let pos = 0, i2 = 0, first = true; i2 < text.length && pos <= to3; i2++) {
    let line = text[i2], end = pos + line.length;
    if (end >= from) {
      if (end > to3)
        line = line.slice(0, to3 - pos);
      if (pos < from)
        line = line.slice(from - pos);
      if (first) {
        target[target.length - 1] += line;
        first = false;
      } else
        target.push(line);
    }
    pos = end + 1;
  }
  return target;
}
function sliceText(text, from, to3) {
  return appendText(text, [""], from, to3);
}
var RawTextCursor = class {
  constructor(text, dir = 1) {
    this.dir = dir;
    this.done = false;
    this.lineBreak = false;
    this.value = "";
    this.nodes = [text];
    this.offsets = [dir > 0 ? 1 : (text instanceof TextLeaf ? text.text.length : text.children.length) << 1];
  }
  nextInner(skip, dir) {
    this.done = this.lineBreak = false;
    for (; ; ) {
      let last2 = this.nodes.length - 1;
      let top2 = this.nodes[last2], offsetValue = this.offsets[last2], offset = offsetValue >> 1;
      let size = top2 instanceof TextLeaf ? top2.text.length : top2.children.length;
      if (offset == (dir > 0 ? size : 0)) {
        if (last2 == 0) {
          this.done = true;
          this.value = "";
          return this;
        }
        if (dir > 0)
          this.offsets[last2 - 1]++;
        this.nodes.pop();
        this.offsets.pop();
      } else if ((offsetValue & 1) == (dir > 0 ? 0 : 1)) {
        this.offsets[last2] += dir;
        if (skip == 0) {
          this.lineBreak = true;
          this.value = "\n";
          return this;
        }
        skip--;
      } else if (top2 instanceof TextLeaf) {
        let next = top2.text[offset + (dir < 0 ? -1 : 0)];
        this.offsets[last2] += dir;
        if (next.length > Math.max(0, skip)) {
          this.value = skip == 0 ? next : dir > 0 ? next.slice(skip) : next.slice(0, next.length - skip);
          return this;
        }
        skip -= next.length;
      } else {
        let next = top2.children[offset + (dir < 0 ? -1 : 0)];
        if (skip > next.length) {
          skip -= next.length;
          this.offsets[last2] += dir;
        } else {
          if (dir < 0)
            this.offsets[last2]--;
          this.nodes.push(next);
          this.offsets.push(dir > 0 ? 1 : (next instanceof TextLeaf ? next.text.length : next.children.length) << 1);
        }
      }
    }
  }
  next(skip = 0) {
    if (skip < 0) {
      this.nextInner(-skip, -this.dir);
      skip = this.value.length;
    }
    return this.nextInner(skip, this.dir);
  }
};
var PartialTextCursor = class {
  constructor(text, start, end) {
    this.value = "";
    this.done = false;
    this.cursor = new RawTextCursor(text, start > end ? -1 : 1);
    this.pos = start > end ? text.length : 0;
    this.from = Math.min(start, end);
    this.to = Math.max(start, end);
  }
  nextInner(skip, dir) {
    if (dir < 0 ? this.pos <= this.from : this.pos >= this.to) {
      this.value = "";
      this.done = true;
      return this;
    }
    skip += Math.max(0, dir < 0 ? this.pos - this.to : this.from - this.pos);
    let limit = dir < 0 ? this.pos - this.from : this.to - this.pos;
    if (skip > limit)
      skip = limit;
    limit -= skip;
    let { value } = this.cursor.next(skip);
    this.pos += (value.length + skip) * dir;
    this.value = value.length <= limit ? value : dir < 0 ? value.slice(value.length - limit) : value.slice(0, limit);
    this.done = !this.value;
    return this;
  }
  next(skip = 0) {
    if (skip < 0)
      skip = Math.max(skip, this.from - this.pos);
    else if (skip > 0)
      skip = Math.min(skip, this.to - this.pos);
    return this.nextInner(skip, this.cursor.dir);
  }
  get lineBreak() {
    return this.cursor.lineBreak && this.value != "";
  }
};
var LineCursor = class {
  constructor(inner) {
    this.inner = inner;
    this.afterBreak = true;
    this.value = "";
    this.done = false;
  }
  next(skip = 0) {
    let { done, lineBreak, value } = this.inner.next(skip);
    if (done && this.afterBreak) {
      this.value = "";
      this.afterBreak = false;
    } else if (done) {
      this.done = true;
      this.value = "";
    } else if (lineBreak) {
      if (this.afterBreak) {
        this.value = "";
      } else {
        this.afterBreak = true;
        this.next();
      }
    } else {
      this.value = value;
      this.afterBreak = false;
    }
    return this;
  }
  get lineBreak() {
    return false;
  }
};
if (typeof Symbol != "undefined") {
  Text.prototype[Symbol.iterator] = function() {
    return this.iter();
  };
  RawTextCursor.prototype[Symbol.iterator] = PartialTextCursor.prototype[Symbol.iterator] = LineCursor.prototype[Symbol.iterator] = function() {
    return this;
  };
}
var Line = class {
  /**
  @internal
  */
  constructor(from, to3, number2, text) {
    this.from = from;
    this.to = to3;
    this.number = number2;
    this.text = text;
  }
  /**
  The length of the line (not including any line break after it).
  */
  get length() {
    return this.to - this.from;
  }
};
function clip(text, from, to3) {
  from = Math.max(0, Math.min(text.length, from));
  return [from, Math.max(from, Math.min(text.length, to3))];
}
var extend = "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map((s2) => s2 ? parseInt(s2, 36) : 1);
for (let i2 = 1; i2 < extend.length; i2++)
  extend[i2] += extend[i2 - 1];
function isExtendingChar(code) {
  for (let i2 = 1; i2 < extend.length; i2 += 2)
    if (extend[i2] > code)
      return extend[i2 - 1] <= code;
  return false;
}
function isRegionalIndicator(code) {
  return code >= 127462 && code <= 127487;
}
var ZWJ = 8205;
function findClusterBreak(str, pos, forward = true, includeExtending = true) {
  return (forward ? nextClusterBreak : prevClusterBreak)(str, pos, includeExtending);
}
function nextClusterBreak(str, pos, includeExtending) {
  if (pos == str.length)
    return pos;
  if (pos && surrogateLow(str.charCodeAt(pos)) && surrogateHigh(str.charCodeAt(pos - 1)))
    pos--;
  let prev = codePointAt(str, pos);
  pos += codePointSize(prev);
  while (pos < str.length) {
    let next = codePointAt(str, pos);
    if (prev == ZWJ || next == ZWJ || includeExtending && isExtendingChar(next)) {
      pos += codePointSize(next);
      prev = next;
    } else if (isRegionalIndicator(next)) {
      let countBefore = 0, i2 = pos - 2;
      while (i2 >= 0 && isRegionalIndicator(codePointAt(str, i2))) {
        countBefore++;
        i2 -= 2;
      }
      if (countBefore % 2 == 0)
        break;
      else
        pos += 2;
    } else {
      break;
    }
  }
  return pos;
}
function prevClusterBreak(str, pos, includeExtending) {
  while (pos > 0) {
    let found = nextClusterBreak(str, pos - 2, includeExtending);
    if (found < pos)
      return found;
    pos--;
  }
  return 0;
}
function surrogateLow(ch2) {
  return ch2 >= 56320 && ch2 < 57344;
}
function surrogateHigh(ch2) {
  return ch2 >= 55296 && ch2 < 56320;
}
function codePointAt(str, pos) {
  let code0 = str.charCodeAt(pos);
  if (!surrogateHigh(code0) || pos + 1 == str.length)
    return code0;
  let code1 = str.charCodeAt(pos + 1);
  if (!surrogateLow(code1))
    return code0;
  return (code0 - 55296 << 10) + (code1 - 56320) + 65536;
}
function fromCodePoint(code) {
  if (code <= 65535)
    return String.fromCharCode(code);
  code -= 65536;
  return String.fromCharCode((code >> 10) + 55296, (code & 1023) + 56320);
}
function codePointSize(code) {
  return code < 65536 ? 1 : 2;
}
var DefaultSplit = /\r\n?|\n/;
var MapMode = function(MapMode2) {
  MapMode2[MapMode2["Simple"] = 0] = "Simple";
  MapMode2[MapMode2["TrackDel"] = 1] = "TrackDel";
  MapMode2[MapMode2["TrackBefore"] = 2] = "TrackBefore";
  MapMode2[MapMode2["TrackAfter"] = 3] = "TrackAfter";
  return MapMode2;
}(MapMode || (MapMode = {}));
var ChangeDesc = class _ChangeDesc {
  // Sections are encoded as pairs of integers. The first is the
  // length in the current document, and the second is -1 for
  // unaffected sections, and the length of the replacement content
  // otherwise. So an insertion would be (0, n>0), a deletion (n>0,
  // 0), and a replacement two positive numbers.
  /**
  @internal
  */
  constructor(sections) {
    this.sections = sections;
  }
  /**
  The length of the document before the change.
  */
  get length() {
    let result = 0;
    for (let i2 = 0; i2 < this.sections.length; i2 += 2)
      result += this.sections[i2];
    return result;
  }
  /**
  The length of the document after the change.
  */
  get newLength() {
    let result = 0;
    for (let i2 = 0; i2 < this.sections.length; i2 += 2) {
      let ins = this.sections[i2 + 1];
      result += ins < 0 ? this.sections[i2] : ins;
    }
    return result;
  }
  /**
  False when there are actual changes in this set.
  */
  get empty() {
    return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0;
  }
  /**
  Iterate over the unchanged parts left by these changes. `posA`
  provides the position of the range in the old document, `posB`
  the new position in the changed document.
  */
  iterGaps(f) {
    for (let i2 = 0, posA = 0, posB = 0; i2 < this.sections.length; ) {
      let len = this.sections[i2++], ins = this.sections[i2++];
      if (ins < 0) {
        f(posA, posB, len);
        posB += len;
      } else {
        posB += ins;
      }
      posA += len;
    }
  }
  /**
  Iterate over the ranges changed by these changes. (See
  [`ChangeSet.iterChanges`](https://codemirror.net/6/docs/ref/#state.ChangeSet.iterChanges) for a
  variant that also provides you with the inserted text.)
  `fromA`/`toA` provides the extent of the change in the starting
  document, `fromB`/`toB` the extent of the replacement in the
  changed document.
  
  When `individual` is true, adjacent changes (which are kept
  separate for [position mapping](https://codemirror.net/6/docs/ref/#state.ChangeDesc.mapPos)) are
  reported separately.
  */
  iterChangedRanges(f, individual = false) {
    iterChanges(this, f, individual);
  }
  /**
  Get a description of the inverted form of these changes.
  */
  get invertedDesc() {
    let sections = [];
    for (let i2 = 0; i2 < this.sections.length; ) {
      let len = this.sections[i2++], ins = this.sections[i2++];
      if (ins < 0)
        sections.push(len, ins);
      else
        sections.push(ins, len);
    }
    return new _ChangeDesc(sections);
  }
  /**
  Compute the combined effect of applying another set of changes
  after this one. The length of the document after this set should
  match the length before `other`.
  */
  composeDesc(other) {
    return this.empty ? other : other.empty ? this : composeSets(this, other);
  }
  /**
  Map this description, which should start with the same document
  as `other`, over another set of changes, so that it can be
  applied after it. When `before` is true, map as if the changes
  in `other` happened before the ones in `this`.
  */
  mapDesc(other, before = false) {
    return other.empty ? this : mapSet(this, other, before);
  }
  mapPos(pos, assoc = -1, mode = MapMode.Simple) {
    let posA = 0, posB = 0;
    for (let i2 = 0; i2 < this.sections.length; ) {
      let len = this.sections[i2++], ins = this.sections[i2++], endA = posA + len;
      if (ins < 0) {
        if (endA > pos)
          return posB + (pos - posA);
        posB += len;
      } else {
        if (mode != MapMode.Simple && endA >= pos && (mode == MapMode.TrackDel && posA < pos && endA > pos || mode == MapMode.TrackBefore && posA < pos || mode == MapMode.TrackAfter && endA > pos))
          return null;
        if (endA > pos || endA == pos && assoc < 0 && !len)
          return pos == posA || assoc < 0 ? posB : posB + ins;
        posB += ins;
      }
      posA = endA;
    }
    if (pos > posA)
      throw new RangeError(`Position ${pos} is out of range for changeset of length ${posA}`);
    return posB;
  }
  /**
  Check whether these changes touch a given range. When one of the
  changes entirely covers the range, the string `"cover"` is
  returned.
  */
  touchesRange(from, to3 = from) {
    for (let i2 = 0, pos = 0; i2 < this.sections.length && pos <= to3; ) {
      let len = this.sections[i2++], ins = this.sections[i2++], end = pos + len;
      if (ins >= 0 && pos <= to3 && end >= from)
        return pos < from && end > to3 ? "cover" : true;
      pos = end;
    }
    return false;
  }
  /**
  @internal
  */
  toString() {
    let result = "";
    for (let i2 = 0; i2 < this.sections.length; ) {
      let len = this.sections[i2++], ins = this.sections[i2++];
      result += (result ? " " : "") + len + (ins >= 0 ? ":" + ins : "");
    }
    return result;
  }
  /**
  Serialize this change desc to a JSON-representable value.
  */
  toJSON() {
    return this.sections;
  }
  /**
  Create a change desc from its JSON representation (as produced
  by [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeDesc.toJSON).
  */
  static fromJSON(json2) {
    if (!Array.isArray(json2) || json2.length % 2 || json2.some((a2) => typeof a2 != "number"))
      throw new RangeError("Invalid JSON representation of ChangeDesc");
    return new _ChangeDesc(json2);
  }
  /**
  @internal
  */
  static create(sections) {
    return new _ChangeDesc(sections);
  }
};
var ChangeSet = class _ChangeSet extends ChangeDesc {
  constructor(sections, inserted) {
    super(sections);
    this.inserted = inserted;
  }
  /**
  Apply the changes to a document, returning the modified
  document.
  */
  apply(doc2) {
    if (this.length != doc2.length)
      throw new RangeError("Applying change set to a document with the wrong length");
    iterChanges(this, (fromA, toA, fromB, _toB, text) => doc2 = doc2.replace(fromB, fromB + (toA - fromA), text), false);
    return doc2;
  }
  mapDesc(other, before = false) {
    return mapSet(this, other, before, true);
  }
  /**
  Given the document as it existed _before_ the changes, return a
  change set that represents the inverse of this set, which could
  be used to go from the document created by the changes back to
  the document as it existed before the changes.
  */
  invert(doc2) {
    let sections = this.sections.slice(), inserted = [];
    for (let i2 = 0, pos = 0; i2 < sections.length; i2 += 2) {
      let len = sections[i2], ins = sections[i2 + 1];
      if (ins >= 0) {
        sections[i2] = ins;
        sections[i2 + 1] = len;
        let index2 = i2 >> 1;
        while (inserted.length < index2)
          inserted.push(Text.empty);
        inserted.push(len ? doc2.slice(pos, pos + len) : Text.empty);
      }
      pos += len;
    }
    return new _ChangeSet(sections, inserted);
  }
  /**
  Combine two subsequent change sets into a single set. `other`
  must start in the document produced by `this`. If `this` goes
  `docA` → `docB` and `other` represents `docB` → `docC`, the
  returned value will represent the change `docA` → `docC`.
  */
  compose(other) {
    return this.empty ? other : other.empty ? this : composeSets(this, other, true);
  }
  /**
  Given another change set starting in the same document, maps this
  change set over the other, producing a new change set that can be
  applied to the document produced by applying `other`. When
  `before` is `true`, order changes as if `this` comes before
  `other`, otherwise (the default) treat `other` as coming first.
  
  Given two changes `A` and `B`, `A.compose(B.map(A))` and
  `B.compose(A.map(B, true))` will produce the same document. This
  provides a basic form of [operational
  transformation](https://en.wikipedia.org/wiki/Operational_transformation),
  and can be used for collaborative editing.
  */
  map(other, before = false) {
    return other.empty ? this : mapSet(this, other, before, true);
  }
  /**
  Iterate over the changed ranges in the document, calling `f` for
  each, with the range in the original document (`fromA`-`toA`)
  and the range that replaces it in the new document
  (`fromB`-`toB`).
  
  When `individual` is true, adjacent changes are reported
  separately.
  */
  iterChanges(f, individual = false) {
    iterChanges(this, f, individual);
  }
  /**
  Get a [change description](https://codemirror.net/6/docs/ref/#state.ChangeDesc) for this change
  set.
  */
  get desc() {
    return ChangeDesc.create(this.sections);
  }
  /**
  @internal
  */
  filter(ranges) {
    let resultSections = [], resultInserted = [], filteredSections = [];
    let iter = new SectionIter(this);
    done: for (let i2 = 0, pos = 0; ; ) {
      let next = i2 == ranges.length ? 1e9 : ranges[i2++];
      while (pos < next || pos == next && iter.len == 0) {
        if (iter.done)
          break done;
        let len = Math.min(iter.len, next - pos);
        addSection(filteredSections, len, -1);
        let ins = iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0;
        addSection(resultSections, len, ins);
        if (ins > 0)
          addInsert(resultInserted, resultSections, iter.text);
        iter.forward(len);
        pos += len;
      }
      let end = ranges[i2++];
      while (pos < end) {
        if (iter.done)
          break done;
        let len = Math.min(iter.len, end - pos);
        addSection(resultSections, len, -1);
        addSection(filteredSections, len, iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0);
        iter.forward(len);
        pos += len;
      }
    }
    return {
      changes: new _ChangeSet(resultSections, resultInserted),
      filtered: ChangeDesc.create(filteredSections)
    };
  }
  /**
  Serialize this change set to a JSON-representable value.
  */
  toJSON() {
    let parts = [];
    for (let i2 = 0; i2 < this.sections.length; i2 += 2) {
      let len = this.sections[i2], ins = this.sections[i2 + 1];
      if (ins < 0)
        parts.push(len);
      else if (ins == 0)
        parts.push([len]);
      else
        parts.push([len].concat(this.inserted[i2 >> 1].toJSON()));
    }
    return parts;
  }
  /**
  Create a change set for the given changes, for a document of the
  given length, using `lineSep` as line separator.
  */
  static of(changes, length, lineSep) {
    let sections = [], inserted = [], pos = 0;
    let total = null;
    function flush(force = false) {
      if (!force && !sections.length)
        return;
      if (pos < length)
        addSection(sections, length - pos, -1);
      let set = new _ChangeSet(sections, inserted);
      total = total ? total.compose(set.map(total)) : set;
      sections = [];
      inserted = [];
      pos = 0;
    }
    function process2(spec) {
      if (Array.isArray(spec)) {
        for (let sub of spec)
          process2(sub);
      } else if (spec instanceof _ChangeSet) {
        if (spec.length != length)
          throw new RangeError(`Mismatched change set length (got ${spec.length}, expected ${length})`);
        flush();
        total = total ? total.compose(spec.map(total)) : spec;
      } else {
        let { from, to: to3 = from, insert: insert2 } = spec;
        if (from > to3 || from < 0 || to3 > length)
          throw new RangeError(`Invalid change range ${from} to ${to3} (in doc of length ${length})`);
        let insText = !insert2 ? Text.empty : typeof insert2 == "string" ? Text.of(insert2.split(lineSep || DefaultSplit)) : insert2;
        let insLen = insText.length;
        if (from == to3 && insLen == 0)
          return;
        if (from < pos)
          flush();
        if (from > pos)
          addSection(sections, from - pos, -1);
        addSection(sections, to3 - from, insLen);
        addInsert(inserted, sections, insText);
        pos = to3;
      }
    }
    process2(changes);
    flush(!total);
    return total;
  }
  /**
  Create an empty changeset of the given length.
  */
  static empty(length) {
    return new _ChangeSet(length ? [length, -1] : [], []);
  }
  /**
  Create a changeset from its JSON representation (as produced by
  [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeSet.toJSON).
  */
  static fromJSON(json2) {
    if (!Array.isArray(json2))
      throw new RangeError("Invalid JSON representation of ChangeSet");
    let sections = [], inserted = [];
    for (let i2 = 0; i2 < json2.length; i2++) {
      let part = json2[i2];
      if (typeof part == "number") {
        sections.push(part, -1);
      } else if (!Array.isArray(part) || typeof part[0] != "number" || part.some((e2, i3) => i3 && typeof e2 != "string")) {
        throw new RangeError("Invalid JSON representation of ChangeSet");
      } else if (part.length == 1) {
        sections.push(part[0], 0);
      } else {
        while (inserted.length < i2)
          inserted.push(Text.empty);
        inserted[i2] = Text.of(part.slice(1));
        sections.push(part[0], inserted[i2].length);
      }
    }
    return new _ChangeSet(sections, inserted);
  }
  /**
  @internal
  */
  static createSet(sections, inserted) {
    return new _ChangeSet(sections, inserted);
  }
};
function addSection(sections, len, ins, forceJoin = false) {
  if (len == 0 && ins <= 0)
    return;
  let last2 = sections.length - 2;
  if (last2 >= 0 && ins <= 0 && ins == sections[last2 + 1])
    sections[last2] += len;
  else if (len == 0 && sections[last2] == 0)
    sections[last2 + 1] += ins;
  else if (forceJoin) {
    sections[last2] += len;
    sections[last2 + 1] += ins;
  } else
    sections.push(len, ins);
}
function addInsert(values, sections, value) {
  if (value.length == 0)
    return;
  let index2 = sections.length - 2 >> 1;
  if (index2 < values.length) {
    values[values.length - 1] = values[values.length - 1].append(value);
  } else {
    while (values.length < index2)
      values.push(Text.empty);
    values.push(value);
  }
}
function iterChanges(desc, f, individual) {
  let inserted = desc.inserted;
  for (let posA = 0, posB = 0, i2 = 0; i2 < desc.sections.length; ) {
    let len = desc.sections[i2++], ins = desc.sections[i2++];
    if (ins < 0) {
      posA += len;
      posB += len;
    } else {
      let endA = posA, endB = posB, text = Text.empty;
      for (; ; ) {
        endA += len;
        endB += ins;
        if (ins && inserted)
          text = text.append(inserted[i2 - 2 >> 1]);
        if (individual || i2 == desc.sections.length || desc.sections[i2 + 1] < 0)
          break;
        len = desc.sections[i2++];
        ins = desc.sections[i2++];
      }
      f(posA, endA, posB, endB, text);
      posA = endA;
      posB = endB;
    }
  }
}
function mapSet(setA, setB, before, mkSet = false) {
  let sections = [], insert2 = mkSet ? [] : null;
  let a2 = new SectionIter(setA), b2 = new SectionIter(setB);
  for (let inserted = -1; ; ) {
    if (a2.ins == -1 && b2.ins == -1) {
      let len = Math.min(a2.len, b2.len);
      addSection(sections, len, -1);
      a2.forward(len);
      b2.forward(len);
    } else if (b2.ins >= 0 && (a2.ins < 0 || inserted == a2.i || a2.off == 0 && (b2.len < a2.len || b2.len == a2.len && !before))) {
      let len = b2.len;
      addSection(sections, b2.ins, -1);
      while (len) {
        let piece = Math.min(a2.len, len);
        if (a2.ins >= 0 && inserted < a2.i && a2.len <= piece) {
          addSection(sections, 0, a2.ins);
          if (insert2)
            addInsert(insert2, sections, a2.text);
          inserted = a2.i;
        }
        a2.forward(piece);
        len -= piece;
      }
      b2.next();
    } else if (a2.ins >= 0) {
      let len = 0, left = a2.len;
      while (left) {
        if (b2.ins == -1) {
          let piece = Math.min(left, b2.len);
          len += piece;
          left -= piece;
          b2.forward(piece);
        } else if (b2.ins == 0 && b2.len < left) {
          left -= b2.len;
          b2.next();
        } else {
          break;
        }
      }
      addSection(sections, len, inserted < a2.i ? a2.ins : 0);
      if (insert2 && inserted < a2.i)
        addInsert(insert2, sections, a2.text);
      inserted = a2.i;
      a2.forward(a2.len - left);
    } else if (a2.done && b2.done) {
      return insert2 ? ChangeSet.createSet(sections, insert2) : ChangeDesc.create(sections);
    } else {
      throw new Error("Mismatched change set lengths");
    }
  }
}
function composeSets(setA, setB, mkSet = false) {
  let sections = [];
  let insert2 = mkSet ? [] : null;
  let a2 = new SectionIter(setA), b2 = new SectionIter(setB);
  for (let open = false; ; ) {
    if (a2.done && b2.done) {
      return insert2 ? ChangeSet.createSet(sections, insert2) : ChangeDesc.create(sections);
    } else if (a2.ins == 0) {
      addSection(sections, a2.len, 0, open);
      a2.next();
    } else if (b2.len == 0 && !b2.done) {
      addSection(sections, 0, b2.ins, open);
      if (insert2)
        addInsert(insert2, sections, b2.text);
      b2.next();
    } else if (a2.done || b2.done) {
      throw new Error("Mismatched change set lengths");
    } else {
      let len = Math.min(a2.len2, b2.len), sectionLen = sections.length;
      if (a2.ins == -1) {
        let insB = b2.ins == -1 ? -1 : b2.off ? 0 : b2.ins;
        addSection(sections, len, insB, open);
        if (insert2 && insB)
          addInsert(insert2, sections, b2.text);
      } else if (b2.ins == -1) {
        addSection(sections, a2.off ? 0 : a2.len, len, open);
        if (insert2)
          addInsert(insert2, sections, a2.textBit(len));
      } else {
        addSection(sections, a2.off ? 0 : a2.len, b2.off ? 0 : b2.ins, open);
        if (insert2 && !b2.off)
          addInsert(insert2, sections, b2.text);
      }
      open = (a2.ins > len || b2.ins >= 0 && b2.len > len) && (open || sections.length > sectionLen);
      a2.forward2(len);
      b2.forward(len);
    }
  }
}
var SectionIter = class {
  constructor(set) {
    this.set = set;
    this.i = 0;
    this.next();
  }
  next() {
    let { sections } = this.set;
    if (this.i < sections.length) {
      this.len = sections[this.i++];
      this.ins = sections[this.i++];
    } else {
      this.len = 0;
      this.ins = -2;
    }
    this.off = 0;
  }
  get done() {
    return this.ins == -2;
  }
  get len2() {
    return this.ins < 0 ? this.len : this.ins;
  }
  get text() {
    let { inserted } = this.set, index2 = this.i - 2 >> 1;
    return index2 >= inserted.length ? Text.empty : inserted[index2];
  }
  textBit(len) {
    let { inserted } = this.set, index2 = this.i - 2 >> 1;
    return index2 >= inserted.length && !len ? Text.empty : inserted[index2].slice(this.off, len == null ? void 0 : this.off + len);
  }
  forward(len) {
    if (len == this.len)
      this.next();
    else {
      this.len -= len;
      this.off += len;
    }
  }
  forward2(len) {
    if (this.ins == -1)
      this.forward(len);
    else if (len == this.ins)
      this.next();
    else {
      this.ins -= len;
      this.off += len;
    }
  }
};
var SelectionRange = class _SelectionRange {
  constructor(from, to3, flags) {
    this.from = from;
    this.to = to3;
    this.flags = flags;
  }
  /**
  The anchor of the range—the side that doesn't move when you
  extend it.
  */
  get anchor() {
    return this.flags & 32 ? this.to : this.from;
  }
  /**
  The head of the range, which is moved when the range is
  [extended](https://codemirror.net/6/docs/ref/#state.SelectionRange.extend).
  */
  get head() {
    return this.flags & 32 ? this.from : this.to;
  }
  /**
  True when `anchor` and `head` are at the same position.
  */
  get empty() {
    return this.from == this.to;
  }
  /**
  If this is a cursor that is explicitly associated with the
  character on one of its sides, this returns the side. -1 means
  the character before its position, 1 the character after, and 0
  means no association.
  */
  get assoc() {
    return this.flags & 8 ? -1 : this.flags & 16 ? 1 : 0;
  }
  /**
  The bidirectional text level associated with this cursor, if
  any.
  */
  get bidiLevel() {
    let level = this.flags & 7;
    return level == 7 ? null : level;
  }
  /**
  The goal column (stored vertical offset) associated with a
  cursor. This is used to preserve the vertical position when
  [moving](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) across
  lines of different length.
  */
  get goalColumn() {
    let value = this.flags >> 6;
    return value == 16777215 ? void 0 : value;
  }
  /**
  Map this range through a change, producing a valid range in the
  updated document.
  */
  map(change, assoc = -1) {
    let from, to3;
    if (this.empty) {
      from = to3 = change.mapPos(this.from, assoc);
    } else {
      from = change.mapPos(this.from, 1);
      to3 = change.mapPos(this.to, -1);
    }
    return from == this.from && to3 == this.to ? this : new _SelectionRange(from, to3, this.flags);
  }
  /**
  Extend this range to cover at least `from` to `to`.
  */
  extend(from, to3 = from) {
    if (from <= this.anchor && to3 >= this.anchor)
      return EditorSelection.range(from, to3);
    let head = Math.abs(from - this.anchor) > Math.abs(to3 - this.anchor) ? from : to3;
    return EditorSelection.range(this.anchor, head);
  }
  /**
  Compare this range to another range.
  */
  eq(other, includeAssoc = false) {
    return this.anchor == other.anchor && this.head == other.head && (!includeAssoc || !this.empty || this.assoc == other.assoc);
  }
  /**
  Return a JSON-serializable object representing the range.
  */
  toJSON() {
    return { anchor: this.anchor, head: this.head };
  }
  /**
  Convert a JSON representation of a range to a `SelectionRange`
  instance.
  */
  static fromJSON(json2) {
    if (!json2 || typeof json2.anchor != "number" || typeof json2.head != "number")
      throw new RangeError("Invalid JSON representation for SelectionRange");
    return EditorSelection.range(json2.anchor, json2.head);
  }
  /**
  @internal
  */
  static create(from, to3, flags) {
    return new _SelectionRange(from, to3, flags);
  }
};
var EditorSelection = class _EditorSelection {
  constructor(ranges, mainIndex) {
    this.ranges = ranges;
    this.mainIndex = mainIndex;
  }
  /**
  Map a selection through a change. Used to adjust the selection
  position for changes.
  */
  map(change, assoc = -1) {
    if (change.empty)
      return this;
    return _EditorSelection.create(this.ranges.map((r2) => r2.map(change, assoc)), this.mainIndex);
  }
  /**
  Compare this selection to another selection. By default, ranges
  are compared only by position. When `includeAssoc` is true,
  cursor ranges must also have the same
  [`assoc`](https://codemirror.net/6/docs/ref/#state.SelectionRange.assoc) value.
  */
  eq(other, includeAssoc = false) {
    if (this.ranges.length != other.ranges.length || this.mainIndex != other.mainIndex)
      return false;
    for (let i2 = 0; i2 < this.ranges.length; i2++)
      if (!this.ranges[i2].eq(other.ranges[i2], includeAssoc))
        return false;
    return true;
  }
  /**
  Get the primary selection range. Usually, you should make sure
  your code applies to _all_ ranges, by using methods like
  [`changeByRange`](https://codemirror.net/6/docs/ref/#state.EditorState.changeByRange).
  */
  get main() {
    return this.ranges[this.mainIndex];
  }
  /**
  Make sure the selection only has one range. Returns a selection
  holding only the main range from this selection.
  */
  asSingle() {
    return this.ranges.length == 1 ? this : new _EditorSelection([this.main], 0);
  }
  /**
  Extend this selection with an extra range.
  */
  addRange(range, main = true) {
    return _EditorSelection.create([range].concat(this.ranges), main ? 0 : this.mainIndex + 1);
  }
  /**
  Replace a given range with another range, and then normalize the
  selection to merge and sort ranges if necessary.
  */
  replaceRange(range, which = this.mainIndex) {
    let ranges = this.ranges.slice();
    ranges[which] = range;
    return _EditorSelection.create(ranges, this.mainIndex);
  }
  /**
  Convert this selection to an object that can be serialized to
  JSON.
  */
  toJSON() {
    return { ranges: this.ranges.map((r2) => r2.toJSON()), main: this.mainIndex };
  }
  /**
  Create a selection from a JSON representation.
  */
  static fromJSON(json2) {
    if (!json2 || !Array.isArray(json2.ranges) || typeof json2.main != "number" || json2.main >= json2.ranges.length)
      throw new RangeError("Invalid JSON representation for EditorSelection");
    return new _EditorSelection(json2.ranges.map((r2) => SelectionRange.fromJSON(r2)), json2.main);
  }
  /**
  Create a selection holding a single range.
  */
  static single(anchor, head = anchor) {
    return new _EditorSelection([_EditorSelection.range(anchor, head)], 0);
  }
  /**
  Sort and merge the given set of ranges, creating a valid
  selection.
  */
  static create(ranges, mainIndex = 0) {
    if (ranges.length == 0)
      throw new RangeError("A selection needs at least one range");
    for (let pos = 0, i2 = 0; i2 < ranges.length; i2++) {
      let range = ranges[i2];
      if (range.empty ? range.from <= pos : range.from < pos)
        return _EditorSelection.normalized(ranges.slice(), mainIndex);
      pos = range.to;
    }
    return new _EditorSelection(ranges, mainIndex);
  }
  /**
  Create a cursor selection range at the given position. You can
  safely ignore the optional arguments in most situations.
  */
  static cursor(pos, assoc = 0, bidiLevel, goalColumn) {
    return SelectionRange.create(pos, pos, (assoc == 0 ? 0 : assoc < 0 ? 8 : 16) | (bidiLevel == null ? 7 : Math.min(6, bidiLevel)) | (goalColumn !== null && goalColumn !== void 0 ? goalColumn : 16777215) << 6);
  }
  /**
  Create a selection range.
  */
  static range(anchor, head, goalColumn, bidiLevel) {
    let flags = (goalColumn !== null && goalColumn !== void 0 ? goalColumn : 16777215) << 6 | (bidiLevel == null ? 7 : Math.min(6, bidiLevel));
    return head < anchor ? SelectionRange.create(head, anchor, 32 | 16 | flags) : SelectionRange.create(anchor, head, (head > anchor ? 8 : 0) | flags);
  }
  /**
  @internal
  */
  static normalized(ranges, mainIndex = 0) {
    let main = ranges[mainIndex];
    ranges.sort((a2, b2) => a2.from - b2.from);
    mainIndex = ranges.indexOf(main);
    for (let i2 = 1; i2 < ranges.length; i2++) {
      let range = ranges[i2], prev = ranges[i2 - 1];
      if (range.empty ? range.from <= prev.to : range.from < prev.to) {
        let from = prev.from, to3 = Math.max(range.to, prev.to);
        if (i2 <= mainIndex)
          mainIndex--;
        ranges.splice(--i2, 2, range.anchor > range.head ? _EditorSelection.range(to3, from) : _EditorSelection.range(from, to3));
      }
    }
    return new _EditorSelection(ranges, mainIndex);
  }
};
function checkSelection(selection, docLength) {
  for (let range of selection.ranges)
    if (range.to > docLength)
      throw new RangeError("Selection points outside of document");
}
var nextID = 0;
var Facet = class _Facet {
  constructor(combine, compareInput, compare2, isStatic, enables) {
    this.combine = combine;
    this.compareInput = compareInput;
    this.compare = compare2;
    this.isStatic = isStatic;
    this.id = nextID++;
    this.default = combine([]);
    this.extensions = typeof enables == "function" ? enables(this) : enables;
  }
  /**
  Returns a facet reader for this facet, which can be used to
  [read](https://codemirror.net/6/docs/ref/#state.EditorState.facet) it but not to define values for it.
  */
  get reader() {
    return this;
  }
  /**
  Define a new facet.
  */
  static define(config2 = {}) {
    return new _Facet(config2.combine || ((a2) => a2), config2.compareInput || ((a2, b2) => a2 === b2), config2.compare || (!config2.combine ? sameArray : (a2, b2) => a2 === b2), !!config2.static, config2.enables);
  }
  /**
  Returns an extension that adds the given value to this facet.
  */
  of(value) {
    return new FacetProvider([], this, 0, value);
  }
  /**
  Create an extension that computes a value for the facet from a
  state. You must take care to declare the parts of the state that
  this value depends on, since your function is only called again
  for a new state when one of those parts changed.
  
  In cases where your value depends only on a single field, you'll
  want to use the [`from`](https://codemirror.net/6/docs/ref/#state.Facet.from) method instead.
  */
  compute(deps, get) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new FacetProvider(deps, this, 1, get);
  }
  /**
  Create an extension that computes zero or more values for this
  facet from a state.
  */
  computeN(deps, get) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new FacetProvider(deps, this, 2, get);
  }
  from(field, get) {
    if (!get)
      get = (x) => x;
    return this.compute([field], (state) => get(state.field(field)));
  }
};
function sameArray(a2, b2) {
  return a2 == b2 || a2.length == b2.length && a2.every((e2, i2) => e2 === b2[i2]);
}
var FacetProvider = class {
  constructor(dependencies, facet, type, value) {
    this.dependencies = dependencies;
    this.facet = facet;
    this.type = type;
    this.value = value;
    this.id = nextID++;
  }
  dynamicSlot(addresses) {
    var _a4;
    let getter = this.value;
    let compare2 = this.facet.compareInput;
    let id2 = this.id, idx = addresses[id2] >> 1, multi = this.type == 2;
    let depDoc = false, depSel = false, depAddrs = [];
    for (let dep of this.dependencies) {
      if (dep == "doc")
        depDoc = true;
      else if (dep == "selection")
        depSel = true;
      else if ((((_a4 = addresses[dep.id]) !== null && _a4 !== void 0 ? _a4 : 1) & 1) == 0)
        depAddrs.push(addresses[dep.id]);
    }
    return {
      create(state) {
        state.values[idx] = getter(state);
        return 1;
      },
      update(state, tr3) {
        if (depDoc && tr3.docChanged || depSel && (tr3.docChanged || tr3.selection) || ensureAll(state, depAddrs)) {
          let newVal = getter(state);
          if (multi ? !compareArray(newVal, state.values[idx], compare2) : !compare2(newVal, state.values[idx])) {
            state.values[idx] = newVal;
            return 1;
          }
        }
        return 0;
      },
      reconfigure: (state, oldState) => {
        let newVal, oldAddr = oldState.config.address[id2];
        if (oldAddr != null) {
          let oldVal = getAddr(oldState, oldAddr);
          if (this.dependencies.every((dep) => {
            return dep instanceof Facet ? oldState.facet(dep) === state.facet(dep) : dep instanceof StateField ? oldState.field(dep, false) == state.field(dep, false) : true;
          }) || (multi ? compareArray(newVal = getter(state), oldVal, compare2) : compare2(newVal = getter(state), oldVal))) {
            state.values[idx] = oldVal;
            return 0;
          }
        } else {
          newVal = getter(state);
        }
        state.values[idx] = newVal;
        return 1;
      }
    };
  }
};
function compareArray(a2, b2, compare2) {
  if (a2.length != b2.length)
    return false;
  for (let i2 = 0; i2 < a2.length; i2++)
    if (!compare2(a2[i2], b2[i2]))
      return false;
  return true;
}
function ensureAll(state, addrs) {
  let changed = false;
  for (let addr of addrs)
    if (ensureAddr(state, addr) & 1)
      changed = true;
  return changed;
}
function dynamicFacetSlot(addresses, facet, providers) {
  let providerAddrs = providers.map((p) => addresses[p.id]);
  let providerTypes = providers.map((p) => p.type);
  let dynamic = providerAddrs.filter((p) => !(p & 1));
  let idx = addresses[facet.id] >> 1;
  function get(state) {
    let values = [];
    for (let i2 = 0; i2 < providerAddrs.length; i2++) {
      let value = getAddr(state, providerAddrs[i2]);
      if (providerTypes[i2] == 2)
        for (let val of value)
          values.push(val);
      else
        values.push(value);
    }
    return facet.combine(values);
  }
  return {
    create(state) {
      for (let addr of providerAddrs)
        ensureAddr(state, addr);
      state.values[idx] = get(state);
      return 1;
    },
    update(state, tr3) {
      if (!ensureAll(state, dynamic))
        return 0;
      let value = get(state);
      if (facet.compare(value, state.values[idx]))
        return 0;
      state.values[idx] = value;
      return 1;
    },
    reconfigure(state, oldState) {
      let depChanged = ensureAll(state, providerAddrs);
      let oldProviders = oldState.config.facets[facet.id], oldValue = oldState.facet(facet);
      if (oldProviders && !depChanged && sameArray(providers, oldProviders)) {
        state.values[idx] = oldValue;
        return 0;
      }
      let value = get(state);
      if (facet.compare(value, oldValue)) {
        state.values[idx] = oldValue;
        return 0;
      }
      state.values[idx] = value;
      return 1;
    }
  };
}
var initField = Facet.define({ static: true });
var StateField = class _StateField {
  constructor(id2, createF, updateF, compareF, spec) {
    this.id = id2;
    this.createF = createF;
    this.updateF = updateF;
    this.compareF = compareF;
    this.spec = spec;
    this.provides = void 0;
  }
  /**
  Define a state field.
  */
  static define(config2) {
    let field = new _StateField(nextID++, config2.create, config2.update, config2.compare || ((a2, b2) => a2 === b2), config2);
    if (config2.provide)
      field.provides = config2.provide(field);
    return field;
  }
  create(state) {
    let init = state.facet(initField).find((i2) => i2.field == this);
    return ((init === null || init === void 0 ? void 0 : init.create) || this.createF)(state);
  }
  /**
  @internal
  */
  slot(addresses) {
    let idx = addresses[this.id] >> 1;
    return {
      create: (state) => {
        state.values[idx] = this.create(state);
        return 1;
      },
      update: (state, tr3) => {
        let oldVal = state.values[idx];
        let value = this.updateF(oldVal, tr3);
        if (this.compareF(oldVal, value))
          return 0;
        state.values[idx] = value;
        return 1;
      },
      reconfigure: (state, oldState) => {
        if (oldState.config.address[this.id] != null) {
          state.values[idx] = oldState.field(this);
          return 0;
        }
        state.values[idx] = this.create(state);
        return 1;
      }
    };
  }
  /**
  Returns an extension that enables this field and overrides the
  way it is initialized. Can be useful when you need to provide a
  non-default starting value for the field.
  */
  init(create) {
    return [this, initField.of({ field: this, create })];
  }
  /**
  State field instances can be used as
  [`Extension`](https://codemirror.net/6/docs/ref/#state.Extension) values to enable the field in a
  given state.
  */
  get extension() {
    return this;
  }
};
var Prec_ = { lowest: 4, low: 3, default: 2, high: 1, highest: 0 };
function prec(value) {
  return (ext) => new PrecExtension(ext, value);
}
var Prec = {
  /**
  The highest precedence level, for extensions that should end up
  near the start of the precedence ordering.
  */
  highest: prec(Prec_.highest),
  /**
  A higher-than-default precedence, for extensions that should
  come before those with default precedence.
  */
  high: prec(Prec_.high),
  /**
  The default precedence, which is also used for extensions
  without an explicit precedence.
  */
  default: prec(Prec_.default),
  /**
  A lower-than-default precedence.
  */
  low: prec(Prec_.low),
  /**
  The lowest precedence level. Meant for things that should end up
  near the end of the extension order.
  */
  lowest: prec(Prec_.lowest)
};
var PrecExtension = class {
  constructor(inner, prec2) {
    this.inner = inner;
    this.prec = prec2;
  }
};
var Compartment = class _Compartment {
  /**
  Create an instance of this compartment to add to your [state
  configuration](https://codemirror.net/6/docs/ref/#state.EditorStateConfig.extensions).
  */
  of(ext) {
    return new CompartmentInstance(this, ext);
  }
  /**
  Create an [effect](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) that
  reconfigures this compartment.
  */
  reconfigure(content2) {
    return _Compartment.reconfigure.of({ compartment: this, extension: content2 });
  }
  /**
  Get the current content of the compartment in the state, or
  `undefined` if it isn't present.
  */
  get(state) {
    return state.config.compartments.get(this);
  }
};
var CompartmentInstance = class {
  constructor(compartment, inner) {
    this.compartment = compartment;
    this.inner = inner;
  }
};
var Configuration = class _Configuration {
  constructor(base2, compartments, dynamicSlots, address, staticValues, facets) {
    this.base = base2;
    this.compartments = compartments;
    this.dynamicSlots = dynamicSlots;
    this.address = address;
    this.staticValues = staticValues;
    this.facets = facets;
    this.statusTemplate = [];
    while (this.statusTemplate.length < dynamicSlots.length)
      this.statusTemplate.push(
        0
        /* SlotStatus.Unresolved */
      );
  }
  staticFacet(facet) {
    let addr = this.address[facet.id];
    return addr == null ? facet.default : this.staticValues[addr >> 1];
  }
  static resolve(base2, compartments, oldState) {
    let fields = [];
    let facets = /* @__PURE__ */ Object.create(null);
    let newCompartments = /* @__PURE__ */ new Map();
    for (let ext of flatten(base2, compartments, newCompartments)) {
      if (ext instanceof StateField)
        fields.push(ext);
      else
        (facets[ext.facet.id] || (facets[ext.facet.id] = [])).push(ext);
    }
    let address = /* @__PURE__ */ Object.create(null);
    let staticValues = [];
    let dynamicSlots = [];
    for (let field of fields) {
      address[field.id] = dynamicSlots.length << 1;
      dynamicSlots.push((a2) => field.slot(a2));
    }
    let oldFacets = oldState === null || oldState === void 0 ? void 0 : oldState.config.facets;
    for (let id2 in facets) {
      let providers = facets[id2], facet = providers[0].facet;
      let oldProviders = oldFacets && oldFacets[id2] || [];
      if (providers.every(
        (p) => p.type == 0
        /* Provider.Static */
      )) {
        address[facet.id] = staticValues.length << 1 | 1;
        if (sameArray(oldProviders, providers)) {
          staticValues.push(oldState.facet(facet));
        } else {
          let value = facet.combine(providers.map((p) => p.value));
          staticValues.push(oldState && facet.compare(value, oldState.facet(facet)) ? oldState.facet(facet) : value);
        }
      } else {
        for (let p of providers) {
          if (p.type == 0) {
            address[p.id] = staticValues.length << 1 | 1;
            staticValues.push(p.value);
          } else {
            address[p.id] = dynamicSlots.length << 1;
            dynamicSlots.push((a2) => p.dynamicSlot(a2));
          }
        }
        address[facet.id] = dynamicSlots.length << 1;
        dynamicSlots.push((a2) => dynamicFacetSlot(a2, facet, providers));
      }
    }
    let dynamic = dynamicSlots.map((f) => f(address));
    return new _Configuration(base2, newCompartments, dynamic, address, staticValues, facets);
  }
};
function flatten(extension, compartments, newCompartments) {
  let result = [[], [], [], [], []];
  let seen = /* @__PURE__ */ new Map();
  function inner(ext, prec2) {
    let known = seen.get(ext);
    if (known != null) {
      if (known <= prec2)
        return;
      let found = result[known].indexOf(ext);
      if (found > -1)
        result[known].splice(found, 1);
      if (ext instanceof CompartmentInstance)
        newCompartments.delete(ext.compartment);
    }
    seen.set(ext, prec2);
    if (Array.isArray(ext)) {
      for (let e2 of ext)
        inner(e2, prec2);
    } else if (ext instanceof CompartmentInstance) {
      if (newCompartments.has(ext.compartment))
        throw new RangeError(`Duplicate use of compartment in extensions`);
      let content2 = compartments.get(ext.compartment) || ext.inner;
      newCompartments.set(ext.compartment, content2);
      inner(content2, prec2);
    } else if (ext instanceof PrecExtension) {
      inner(ext.inner, ext.prec);
    } else if (ext instanceof StateField) {
      result[prec2].push(ext);
      if (ext.provides)
        inner(ext.provides, prec2);
    } else if (ext instanceof FacetProvider) {
      result[prec2].push(ext);
      if (ext.facet.extensions)
        inner(ext.facet.extensions, Prec_.default);
    } else {
      let content2 = ext.extension;
      if (!content2)
        throw new Error(`Unrecognized extension value in extension set (${ext}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
      inner(content2, prec2);
    }
  }
  inner(extension, Prec_.default);
  return result.reduce((a2, b2) => a2.concat(b2));
}
function ensureAddr(state, addr) {
  if (addr & 1)
    return 2;
  let idx = addr >> 1;
  let status = state.status[idx];
  if (status == 4)
    throw new Error("Cyclic dependency between fields and/or facets");
  if (status & 2)
    return status;
  state.status[idx] = 4;
  let changed = state.computeSlot(state, state.config.dynamicSlots[idx]);
  return state.status[idx] = 2 | changed;
}
function getAddr(state, addr) {
  return addr & 1 ? state.config.staticValues[addr >> 1] : state.values[addr >> 1];
}
var languageData = Facet.define();
var allowMultipleSelections = Facet.define({
  combine: (values) => values.some((v) => v),
  static: true
});
var lineSeparator = Facet.define({
  combine: (values) => values.length ? values[0] : void 0,
  static: true
});
var changeFilter = Facet.define();
var transactionFilter = Facet.define();
var transactionExtender = Facet.define();
var readOnly = Facet.define({
  combine: (values) => values.length ? values[0] : false
});
var Annotation = class {
  /**
  @internal
  */
  constructor(type, value) {
    this.type = type;
    this.value = value;
  }
  /**
  Define a new type of annotation.
  */
  static define() {
    return new AnnotationType();
  }
};
var AnnotationType = class {
  /**
  Create an instance of this annotation.
  */
  of(value) {
    return new Annotation(this, value);
  }
};
var StateEffectType = class {
  /**
  @internal
  */
  constructor(map) {
    this.map = map;
  }
  /**
  Create a [state effect](https://codemirror.net/6/docs/ref/#state.StateEffect) instance of this
  type.
  */
  of(value) {
    return new StateEffect(this, value);
  }
};
var StateEffect = class _StateEffect {
  /**
  @internal
  */
  constructor(type, value) {
    this.type = type;
    this.value = value;
  }
  /**
  Map this effect through a position mapping. Will return
  `undefined` when that ends up deleting the effect.
  */
  map(mapping) {
    let mapped = this.type.map(this.value, mapping);
    return mapped === void 0 ? void 0 : mapped == this.value ? this : new _StateEffect(this.type, mapped);
  }
  /**
  Tells you whether this effect object is of a given
  [type](https://codemirror.net/6/docs/ref/#state.StateEffectType).
  */
  is(type) {
    return this.type == type;
  }
  /**
  Define a new effect type. The type parameter indicates the type
  of values that his effect holds. It should be a type that
  doesn't include `undefined`, since that is used in
  [mapping](https://codemirror.net/6/docs/ref/#state.StateEffect.map) to indicate that an effect is
  removed.
  */
  static define(spec = {}) {
    return new StateEffectType(spec.map || ((v) => v));
  }
  /**
  Map an array of effects through a change set.
  */
  static mapEffects(effects, mapping) {
    if (!effects.length)
      return effects;
    let result = [];
    for (let effect of effects) {
      let mapped = effect.map(mapping);
      if (mapped)
        result.push(mapped);
    }
    return result;
  }
};
StateEffect.reconfigure = StateEffect.define();
StateEffect.appendConfig = StateEffect.define();
var Transaction = class _Transaction {
  constructor(startState, changes, selection, effects, annotations, scrollIntoView3) {
    this.startState = startState;
    this.changes = changes;
    this.selection = selection;
    this.effects = effects;
    this.annotations = annotations;
    this.scrollIntoView = scrollIntoView3;
    this._doc = null;
    this._state = null;
    if (selection)
      checkSelection(selection, changes.newLength);
    if (!annotations.some((a2) => a2.type == _Transaction.time))
      this.annotations = annotations.concat(_Transaction.time.of(Date.now()));
  }
  /**
  @internal
  */
  static create(startState, changes, selection, effects, annotations, scrollIntoView3) {
    return new _Transaction(startState, changes, selection, effects, annotations, scrollIntoView3);
  }
  /**
  The new document produced by the transaction. Contrary to
  [`.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state)`.doc`, accessing this won't
  force the entire new state to be computed right away, so it is
  recommended that [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) use this getter
  when they need to look at the new document.
  */
  get newDoc() {
    return this._doc || (this._doc = this.changes.apply(this.startState.doc));
  }
  /**
  The new selection produced by the transaction. If
  [`this.selection`](https://codemirror.net/6/docs/ref/#state.Transaction.selection) is undefined,
  this will [map](https://codemirror.net/6/docs/ref/#state.EditorSelection.map) the start state's
  current selection through the changes made by the transaction.
  */
  get newSelection() {
    return this.selection || this.startState.selection.map(this.changes);
  }
  /**
  The new state created by the transaction. Computed on demand
  (but retained for subsequent access), so it is recommended not to
  access it in [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) when possible.
  */
  get state() {
    if (!this._state)
      this.startState.applyTransaction(this);
    return this._state;
  }
  /**
  Get the value of the given annotation type, if any.
  */
  annotation(type) {
    for (let ann of this.annotations)
      if (ann.type == type)
        return ann.value;
    return void 0;
  }
  /**
  Indicates whether the transaction changed the document.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Indicates whether this transaction reconfigures the state
  (through a [configuration compartment](https://codemirror.net/6/docs/ref/#state.Compartment) or
  with a top-level configuration
  [effect](https://codemirror.net/6/docs/ref/#state.StateEffect^reconfigure).
  */
  get reconfigured() {
    return this.startState.config != this.state.config;
  }
  /**
  Returns true if the transaction has a [user
  event](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent) annotation that is equal to
  or more specific than `event`. For example, if the transaction
  has `"select.pointer"` as user event, `"select"` and
  `"select.pointer"` will match it.
  */
  isUserEvent(event) {
    let e2 = this.annotation(_Transaction.userEvent);
    return !!(e2 && (e2 == event || e2.length > event.length && e2.slice(0, event.length) == event && e2[event.length] == "."));
  }
};
Transaction.time = Annotation.define();
Transaction.userEvent = Annotation.define();
Transaction.addToHistory = Annotation.define();
Transaction.remote = Annotation.define();
function joinRanges(a2, b2) {
  let result = [];
  for (let iA = 0, iB = 0; ; ) {
    let from, to3;
    if (iA < a2.length && (iB == b2.length || b2[iB] >= a2[iA])) {
      from = a2[iA++];
      to3 = a2[iA++];
    } else if (iB < b2.length) {
      from = b2[iB++];
      to3 = b2[iB++];
    } else
      return result;
    if (!result.length || result[result.length - 1] < from)
      result.push(from, to3);
    else if (result[result.length - 1] < to3)
      result[result.length - 1] = to3;
  }
}
function mergeTransaction(a2, b2, sequential) {
  var _a4;
  let mapForA, mapForB, changes;
  if (sequential) {
    mapForA = b2.changes;
    mapForB = ChangeSet.empty(b2.changes.length);
    changes = a2.changes.compose(b2.changes);
  } else {
    mapForA = b2.changes.map(a2.changes);
    mapForB = a2.changes.mapDesc(b2.changes, true);
    changes = a2.changes.compose(mapForA);
  }
  return {
    changes,
    selection: b2.selection ? b2.selection.map(mapForB) : (_a4 = a2.selection) === null || _a4 === void 0 ? void 0 : _a4.map(mapForA),
    effects: StateEffect.mapEffects(a2.effects, mapForA).concat(StateEffect.mapEffects(b2.effects, mapForB)),
    annotations: a2.annotations.length ? a2.annotations.concat(b2.annotations) : b2.annotations,
    scrollIntoView: a2.scrollIntoView || b2.scrollIntoView
  };
}
function resolveTransactionInner(state, spec, docSize) {
  let sel = spec.selection, annotations = asArray(spec.annotations);
  if (spec.userEvent)
    annotations = annotations.concat(Transaction.userEvent.of(spec.userEvent));
  return {
    changes: spec.changes instanceof ChangeSet ? spec.changes : ChangeSet.of(spec.changes || [], docSize, state.facet(lineSeparator)),
    selection: sel && (sel instanceof EditorSelection ? sel : EditorSelection.single(sel.anchor, sel.head)),
    effects: asArray(spec.effects),
    annotations,
    scrollIntoView: !!spec.scrollIntoView
  };
}
function resolveTransaction(state, specs, filter) {
  let s2 = resolveTransactionInner(state, specs.length ? specs[0] : {}, state.doc.length);
  if (specs.length && specs[0].filter === false)
    filter = false;
  for (let i2 = 1; i2 < specs.length; i2++) {
    if (specs[i2].filter === false)
      filter = false;
    let seq = !!specs[i2].sequential;
    s2 = mergeTransaction(s2, resolveTransactionInner(state, specs[i2], seq ? s2.changes.newLength : state.doc.length), seq);
  }
  let tr3 = Transaction.create(state, s2.changes, s2.selection, s2.effects, s2.annotations, s2.scrollIntoView);
  return extendTransaction(filter ? filterTransaction(tr3) : tr3);
}
function filterTransaction(tr3) {
  let state = tr3.startState;
  let result = true;
  for (let filter of state.facet(changeFilter)) {
    let value = filter(tr3);
    if (value === false) {
      result = false;
      break;
    }
    if (Array.isArray(value))
      result = result === true ? value : joinRanges(result, value);
  }
  if (result !== true) {
    let changes, back;
    if (result === false) {
      back = tr3.changes.invertedDesc;
      changes = ChangeSet.empty(state.doc.length);
    } else {
      let filtered = tr3.changes.filter(result);
      changes = filtered.changes;
      back = filtered.filtered.mapDesc(filtered.changes).invertedDesc;
    }
    tr3 = Transaction.create(state, changes, tr3.selection && tr3.selection.map(back), StateEffect.mapEffects(tr3.effects, back), tr3.annotations, tr3.scrollIntoView);
  }
  let filters = state.facet(transactionFilter);
  for (let i2 = filters.length - 1; i2 >= 0; i2--) {
    let filtered = filters[i2](tr3);
    if (filtered instanceof Transaction)
      tr3 = filtered;
    else if (Array.isArray(filtered) && filtered.length == 1 && filtered[0] instanceof Transaction)
      tr3 = filtered[0];
    else
      tr3 = resolveTransaction(state, asArray(filtered), false);
  }
  return tr3;
}
function extendTransaction(tr3) {
  let state = tr3.startState, extenders = state.facet(transactionExtender), spec = tr3;
  for (let i2 = extenders.length - 1; i2 >= 0; i2--) {
    let extension = extenders[i2](tr3);
    if (extension && Object.keys(extension).length)
      spec = mergeTransaction(spec, resolveTransactionInner(state, extension, tr3.changes.newLength), true);
  }
  return spec == tr3 ? tr3 : Transaction.create(state, tr3.changes, tr3.selection, spec.effects, spec.annotations, spec.scrollIntoView);
}
var none = [];
function asArray(value) {
  return value == null ? none : Array.isArray(value) ? value : [value];
}
var CharCategory = function(CharCategory2) {
  CharCategory2[CharCategory2["Word"] = 0] = "Word";
  CharCategory2[CharCategory2["Space"] = 1] = "Space";
  CharCategory2[CharCategory2["Other"] = 2] = "Other";
  return CharCategory2;
}(CharCategory || (CharCategory = {}));
var nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
var wordChar;
try {
  wordChar = new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
} catch (_2) {
}
function hasWordChar(str) {
  if (wordChar)
    return wordChar.test(str);
  for (let i2 = 0; i2 < str.length; i2++) {
    let ch2 = str[i2];
    if (/\w/.test(ch2) || ch2 > "" && (ch2.toUpperCase() != ch2.toLowerCase() || nonASCIISingleCaseWordChar.test(ch2)))
      return true;
  }
  return false;
}
function makeCategorizer(wordChars) {
  return (char) => {
    if (!/\S/.test(char))
      return CharCategory.Space;
    if (hasWordChar(char))
      return CharCategory.Word;
    for (let i2 = 0; i2 < wordChars.length; i2++)
      if (char.indexOf(wordChars[i2]) > -1)
        return CharCategory.Word;
    return CharCategory.Other;
  };
}
var EditorState = class _EditorState {
  constructor(config2, doc2, selection, values, computeSlot, tr3) {
    this.config = config2;
    this.doc = doc2;
    this.selection = selection;
    this.values = values;
    this.status = config2.statusTemplate.slice();
    this.computeSlot = computeSlot;
    if (tr3)
      tr3._state = this;
    for (let i2 = 0; i2 < this.config.dynamicSlots.length; i2++)
      ensureAddr(this, i2 << 1);
    this.computeSlot = null;
  }
  field(field, require2 = true) {
    let addr = this.config.address[field.id];
    if (addr == null) {
      if (require2)
        throw new RangeError("Field is not present in this state");
      return void 0;
    }
    ensureAddr(this, addr);
    return getAddr(this, addr);
  }
  /**
  Create a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction) that updates this
  state. Any number of [transaction specs](https://codemirror.net/6/docs/ref/#state.TransactionSpec)
  can be passed. Unless
  [`sequential`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.sequential) is set, the
  [changes](https://codemirror.net/6/docs/ref/#state.TransactionSpec.changes) (if any) of each spec
  are assumed to start in the _current_ document (not the document
  produced by previous specs), and its
  [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) and
  [effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) are assumed to refer
  to the document created by its _own_ changes. The resulting
  transaction contains the combined effect of all the different
  specs. For [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection), later
  specs take precedence over earlier ones.
  */
  update(...specs) {
    return resolveTransaction(this, specs, true);
  }
  /**
  @internal
  */
  applyTransaction(tr3) {
    let conf = this.config, { base: base2, compartments } = conf;
    for (let effect of tr3.effects) {
      if (effect.is(Compartment.reconfigure)) {
        if (conf) {
          compartments = /* @__PURE__ */ new Map();
          conf.compartments.forEach((val, key) => compartments.set(key, val));
          conf = null;
        }
        compartments.set(effect.value.compartment, effect.value.extension);
      } else if (effect.is(StateEffect.reconfigure)) {
        conf = null;
        base2 = effect.value;
      } else if (effect.is(StateEffect.appendConfig)) {
        conf = null;
        base2 = asArray(base2).concat(effect.value);
      }
    }
    let startValues;
    if (!conf) {
      conf = Configuration.resolve(base2, compartments, this);
      let intermediateState = new _EditorState(conf, this.doc, this.selection, conf.dynamicSlots.map(() => null), (state, slot) => slot.reconfigure(state, this), null);
      startValues = intermediateState.values;
    } else {
      startValues = tr3.startState.values.slice();
    }
    let selection = tr3.startState.facet(allowMultipleSelections) ? tr3.newSelection : tr3.newSelection.asSingle();
    new _EditorState(conf, tr3.newDoc, selection, startValues, (state, slot) => slot.update(state, tr3), tr3);
  }
  /**
  Create a [transaction spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec) that
  replaces every selection range with the given content.
  */
  replaceSelection(text) {
    if (typeof text == "string")
      text = this.toText(text);
    return this.changeByRange((range) => ({
      changes: { from: range.from, to: range.to, insert: text },
      range: EditorSelection.cursor(range.from + text.length)
    }));
  }
  /**
  Create a set of changes and a new selection by running the given
  function for each range in the active selection. The function
  can return an optional set of changes (in the coordinate space
  of the start document), plus an updated range (in the coordinate
  space of the document produced by the call's own changes). This
  method will merge all the changes and ranges into a single
  changeset and selection, and return it as a [transaction
  spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec), which can be passed to
  [`update`](https://codemirror.net/6/docs/ref/#state.EditorState.update).
  */
  changeByRange(f) {
    let sel = this.selection;
    let result1 = f(sel.ranges[0]);
    let changes = this.changes(result1.changes), ranges = [result1.range];
    let effects = asArray(result1.effects);
    for (let i2 = 1; i2 < sel.ranges.length; i2++) {
      let result = f(sel.ranges[i2]);
      let newChanges = this.changes(result.changes), newMapped = newChanges.map(changes);
      for (let j = 0; j < i2; j++)
        ranges[j] = ranges[j].map(newMapped);
      let mapBy = changes.mapDesc(newChanges, true);
      ranges.push(result.range.map(mapBy));
      changes = changes.compose(newMapped);
      effects = StateEffect.mapEffects(effects, newMapped).concat(StateEffect.mapEffects(asArray(result.effects), mapBy));
    }
    return {
      changes,
      selection: EditorSelection.create(ranges, sel.mainIndex),
      effects
    };
  }
  /**
  Create a [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet) from the given change
  description, taking the state's document length and line
  separator into account.
  */
  changes(spec = []) {
    if (spec instanceof ChangeSet)
      return spec;
    return ChangeSet.of(spec, this.doc.length, this.facet(_EditorState.lineSeparator));
  }
  /**
  Using the state's [line
  separator](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator), create a
  [`Text`](https://codemirror.net/6/docs/ref/#state.Text) instance from the given string.
  */
  toText(string2) {
    return Text.of(string2.split(this.facet(_EditorState.lineSeparator) || DefaultSplit));
  }
  /**
  Return the given range of the document as a string.
  */
  sliceDoc(from = 0, to3 = this.doc.length) {
    return this.doc.sliceString(from, to3, this.lineBreak);
  }
  /**
  Get the value of a state [facet](https://codemirror.net/6/docs/ref/#state.Facet).
  */
  facet(facet) {
    let addr = this.config.address[facet.id];
    if (addr == null)
      return facet.default;
    ensureAddr(this, addr);
    return getAddr(this, addr);
  }
  /**
  Convert this state to a JSON-serializable object. When custom
  fields should be serialized, you can pass them in as an object
  mapping property names (in the resulting object, which should
  not use `doc` or `selection`) to fields.
  */
  toJSON(fields) {
    let result = {
      doc: this.sliceDoc(),
      selection: this.selection.toJSON()
    };
    if (fields)
      for (let prop in fields) {
        let value = fields[prop];
        if (value instanceof StateField && this.config.address[value.id] != null)
          result[prop] = value.spec.toJSON(this.field(fields[prop]), this);
      }
    return result;
  }
  /**
  Deserialize a state from its JSON representation. When custom
  fields should be deserialized, pass the same object you passed
  to [`toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) when serializing as
  third argument.
  */
  static fromJSON(json2, config2 = {}, fields) {
    if (!json2 || typeof json2.doc != "string")
      throw new RangeError("Invalid JSON representation for EditorState");
    let fieldInit = [];
    if (fields)
      for (let prop in fields) {
        if (Object.prototype.hasOwnProperty.call(json2, prop)) {
          let field = fields[prop], value = json2[prop];
          fieldInit.push(field.init((state) => field.spec.fromJSON(value, state)));
        }
      }
    return _EditorState.create({
      doc: json2.doc,
      selection: EditorSelection.fromJSON(json2.selection),
      extensions: config2.extensions ? fieldInit.concat([config2.extensions]) : fieldInit
    });
  }
  /**
  Create a new state. You'll usually only need this when
  initializing an editor—updated states are created by applying
  transactions.
  */
  static create(config2 = {}) {
    let configuration = Configuration.resolve(config2.extensions || [], /* @__PURE__ */ new Map());
    let doc2 = config2.doc instanceof Text ? config2.doc : Text.of((config2.doc || "").split(configuration.staticFacet(_EditorState.lineSeparator) || DefaultSplit));
    let selection = !config2.selection ? EditorSelection.single(0) : config2.selection instanceof EditorSelection ? config2.selection : EditorSelection.single(config2.selection.anchor, config2.selection.head);
    checkSelection(selection, doc2.length);
    if (!configuration.staticFacet(allowMultipleSelections))
      selection = selection.asSingle();
    return new _EditorState(configuration, doc2, selection, configuration.dynamicSlots.map(() => null), (state, slot) => slot.create(state), null);
  }
  /**
  The size (in columns) of a tab in the document, determined by
  the [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) facet.
  */
  get tabSize() {
    return this.facet(_EditorState.tabSize);
  }
  /**
  Get the proper [line-break](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator)
  string for this state.
  */
  get lineBreak() {
    return this.facet(_EditorState.lineSeparator) || "\n";
  }
  /**
  Returns true when the editor is
  [configured](https://codemirror.net/6/docs/ref/#state.EditorState^readOnly) to be read-only.
  */
  get readOnly() {
    return this.facet(readOnly);
  }
  /**
  Look up a translation for the given phrase (via the
  [`phrases`](https://codemirror.net/6/docs/ref/#state.EditorState^phrases) facet), or return the
  original string if no translation is found.
  
  If additional arguments are passed, they will be inserted in
  place of markers like `$1` (for the first value) and `$2`, etc.
  A single `$` is equivalent to `$1`, and `$$` will produce a
  literal dollar sign.
  */
  phrase(phrase2, ...insert2) {
    for (let map of this.facet(_EditorState.phrases))
      if (Object.prototype.hasOwnProperty.call(map, phrase2)) {
        phrase2 = map[phrase2];
        break;
      }
    if (insert2.length)
      phrase2 = phrase2.replace(/\$(\$|\d*)/g, (m3, i2) => {
        if (i2 == "$")
          return "$";
        let n2 = +(i2 || 1);
        return !n2 || n2 > insert2.length ? m3 : insert2[n2 - 1];
      });
    return phrase2;
  }
  /**
  Find the values for a given language data field, provided by the
  the [`languageData`](https://codemirror.net/6/docs/ref/#state.EditorState^languageData) facet.
  
  Examples of language data fields are...
  
  - [`"commentTokens"`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) for specifying
    comment syntax.
  - [`"autocomplete"`](https://codemirror.net/6/docs/ref/#autocomplete.autocompletion^config.override)
    for providing language-specific completion sources.
  - [`"wordChars"`](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) for adding
    characters that should be considered part of words in this
    language.
  - [`"closeBrackets"`](https://codemirror.net/6/docs/ref/#autocomplete.CloseBracketConfig) controls
    bracket closing behavior.
  */
  languageDataAt(name2, pos, side = -1) {
    let values = [];
    for (let provider of this.facet(languageData)) {
      for (let result of provider(this, pos, side)) {
        if (Object.prototype.hasOwnProperty.call(result, name2))
          values.push(result[name2]);
      }
    }
    return values;
  }
  /**
  Return a function that can categorize strings (expected to
  represent a single [grapheme cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak))
  into one of:
  
   - Word (contains an alphanumeric character or a character
     explicitly listed in the local language's `"wordChars"`
     language data, which should be a string)
   - Space (contains only whitespace)
   - Other (anything else)
  */
  charCategorizer(at2) {
    return makeCategorizer(this.languageDataAt("wordChars", at2).join(""));
  }
  /**
  Find the word at the given position, meaning the range
  containing all [word](https://codemirror.net/6/docs/ref/#state.CharCategory.Word) characters
  around it. If no word characters are adjacent to the position,
  this returns null.
  */
  wordAt(pos) {
    let { text, from, length } = this.doc.lineAt(pos);
    let cat = this.charCategorizer(pos);
    let start = pos - from, end = pos - from;
    while (start > 0) {
      let prev = findClusterBreak(text, start, false);
      if (cat(text.slice(prev, start)) != CharCategory.Word)
        break;
      start = prev;
    }
    while (end < length) {
      let next = findClusterBreak(text, end);
      if (cat(text.slice(end, next)) != CharCategory.Word)
        break;
      end = next;
    }
    return start == end ? null : EditorSelection.range(start + from, end + from);
  }
};
EditorState.allowMultipleSelections = allowMultipleSelections;
EditorState.tabSize = Facet.define({
  combine: (values) => values.length ? values[0] : 4
});
EditorState.lineSeparator = lineSeparator;
EditorState.readOnly = readOnly;
EditorState.phrases = Facet.define({
  compare(a2, b2) {
    let kA = Object.keys(a2), kB = Object.keys(b2);
    return kA.length == kB.length && kA.every((k2) => a2[k2] == b2[k2]);
  }
});
EditorState.languageData = languageData;
EditorState.changeFilter = changeFilter;
EditorState.transactionFilter = transactionFilter;
EditorState.transactionExtender = transactionExtender;
Compartment.reconfigure = StateEffect.define();
function combineConfig(configs, defaults3, combine = {}) {
  let result = {};
  for (let config2 of configs)
    for (let key of Object.keys(config2)) {
      let value = config2[key], current = result[key];
      if (current === void 0)
        result[key] = value;
      else if (current === value || value === void 0) ;
      else if (Object.hasOwnProperty.call(combine, key))
        result[key] = combine[key](current, value);
      else
        throw new Error("Config merge conflict for field " + key);
    }
  for (let key in defaults3)
    if (result[key] === void 0)
      result[key] = defaults3[key];
  return result;
}
var RangeValue = class {
  /**
  Compare this value with another value. Used when comparing
  rangesets. The default implementation compares by identity.
  Unless you are only creating a fixed number of unique instances
  of your value type, it is a good idea to implement this
  properly.
  */
  eq(other) {
    return this == other;
  }
  /**
  Create a [range](https://codemirror.net/6/docs/ref/#state.Range) with this value.
  */
  range(from, to3 = from) {
    return Range.create(from, to3, this);
  }
};
RangeValue.prototype.startSide = RangeValue.prototype.endSide = 0;
RangeValue.prototype.point = false;
RangeValue.prototype.mapMode = MapMode.TrackDel;
var Range = class _Range {
  constructor(from, to3, value) {
    this.from = from;
    this.to = to3;
    this.value = value;
  }
  /**
  @internal
  */
  static create(from, to3, value) {
    return new _Range(from, to3, value);
  }
};
function cmpRange(a2, b2) {
  return a2.from - b2.from || a2.value.startSide - b2.value.startSide;
}
var Chunk = class _Chunk {
  constructor(from, to3, value, maxPoint) {
    this.from = from;
    this.to = to3;
    this.value = value;
    this.maxPoint = maxPoint;
  }
  get length() {
    return this.to[this.to.length - 1];
  }
  // Find the index of the given position and side. Use the ranges'
  // `from` pos when `end == false`, `to` when `end == true`.
  findIndex(pos, side, end, startAt = 0) {
    let arr = end ? this.to : this.from;
    for (let lo3 = startAt, hi3 = arr.length; ; ) {
      if (lo3 == hi3)
        return lo3;
      let mid = lo3 + hi3 >> 1;
      let diff = arr[mid] - pos || (end ? this.value[mid].endSide : this.value[mid].startSide) - side;
      if (mid == lo3)
        return diff >= 0 ? lo3 : hi3;
      if (diff >= 0)
        hi3 = mid;
      else
        lo3 = mid + 1;
    }
  }
  between(offset, from, to3, f) {
    for (let i2 = this.findIndex(from, -1e9, true), e2 = this.findIndex(to3, 1e9, false, i2); i2 < e2; i2++)
      if (f(this.from[i2] + offset, this.to[i2] + offset, this.value[i2]) === false)
        return false;
  }
  map(offset, changes) {
    let value = [], from = [], to3 = [], newPos = -1, maxPoint = -1;
    for (let i2 = 0; i2 < this.value.length; i2++) {
      let val = this.value[i2], curFrom = this.from[i2] + offset, curTo = this.to[i2] + offset, newFrom, newTo;
      if (curFrom == curTo) {
        let mapped = changes.mapPos(curFrom, val.startSide, val.mapMode);
        if (mapped == null)
          continue;
        newFrom = newTo = mapped;
        if (val.startSide != val.endSide) {
          newTo = changes.mapPos(curFrom, val.endSide);
          if (newTo < newFrom)
            continue;
        }
      } else {
        newFrom = changes.mapPos(curFrom, val.startSide);
        newTo = changes.mapPos(curTo, val.endSide);
        if (newFrom > newTo || newFrom == newTo && val.startSide > 0 && val.endSide <= 0)
          continue;
      }
      if ((newTo - newFrom || val.endSide - val.startSide) < 0)
        continue;
      if (newPos < 0)
        newPos = newFrom;
      if (val.point)
        maxPoint = Math.max(maxPoint, newTo - newFrom);
      value.push(val);
      from.push(newFrom - newPos);
      to3.push(newTo - newPos);
    }
    return { mapped: value.length ? new _Chunk(from, to3, value, maxPoint) : null, pos: newPos };
  }
};
var RangeSet = class _RangeSet {
  constructor(chunkPos, chunk, nextLayer, maxPoint) {
    this.chunkPos = chunkPos;
    this.chunk = chunk;
    this.nextLayer = nextLayer;
    this.maxPoint = maxPoint;
  }
  /**
  @internal
  */
  static create(chunkPos, chunk, nextLayer, maxPoint) {
    return new _RangeSet(chunkPos, chunk, nextLayer, maxPoint);
  }
  /**
  @internal
  */
  get length() {
    let last2 = this.chunk.length - 1;
    return last2 < 0 ? 0 : Math.max(this.chunkEnd(last2), this.nextLayer.length);
  }
  /**
  The number of ranges in the set.
  */
  get size() {
    if (this.isEmpty)
      return 0;
    let size = this.nextLayer.size;
    for (let chunk of this.chunk)
      size += chunk.value.length;
    return size;
  }
  /**
  @internal
  */
  chunkEnd(index2) {
    return this.chunkPos[index2] + this.chunk[index2].length;
  }
  /**
  Update the range set, optionally adding new ranges or filtering
  out existing ones.
  
  (Note: The type parameter is just there as a kludge to work
  around TypeScript variance issues that prevented `RangeSet<X>`
  from being a subtype of `RangeSet<Y>` when `X` is a subtype of
  `Y`.)
  */
  update(updateSpec) {
    let { add: add3 = [], sort = false, filterFrom = 0, filterTo = this.length } = updateSpec;
    let filter = updateSpec.filter;
    if (add3.length == 0 && !filter)
      return this;
    if (sort)
      add3 = add3.slice().sort(cmpRange);
    if (this.isEmpty)
      return add3.length ? _RangeSet.of(add3) : this;
    let cur2 = new LayerCursor(this, null, -1).goto(0), i2 = 0, spill = [];
    let builder = new RangeSetBuilder();
    while (cur2.value || i2 < add3.length) {
      if (i2 < add3.length && (cur2.from - add3[i2].from || cur2.startSide - add3[i2].value.startSide) >= 0) {
        let range = add3[i2++];
        if (!builder.addInner(range.from, range.to, range.value))
          spill.push(range);
      } else if (cur2.rangeIndex == 1 && cur2.chunkIndex < this.chunk.length && (i2 == add3.length || this.chunkEnd(cur2.chunkIndex) < add3[i2].from) && (!filter || filterFrom > this.chunkEnd(cur2.chunkIndex) || filterTo < this.chunkPos[cur2.chunkIndex]) && builder.addChunk(this.chunkPos[cur2.chunkIndex], this.chunk[cur2.chunkIndex])) {
        cur2.nextChunk();
      } else {
        if (!filter || filterFrom > cur2.to || filterTo < cur2.from || filter(cur2.from, cur2.to, cur2.value)) {
          if (!builder.addInner(cur2.from, cur2.to, cur2.value))
            spill.push(Range.create(cur2.from, cur2.to, cur2.value));
        }
        cur2.next();
      }
    }
    return builder.finishInner(this.nextLayer.isEmpty && !spill.length ? _RangeSet.empty : this.nextLayer.update({ add: spill, filter, filterFrom, filterTo }));
  }
  /**
  Map this range set through a set of changes, return the new set.
  */
  map(changes) {
    if (changes.empty || this.isEmpty)
      return this;
    let chunks = [], chunkPos = [], maxPoint = -1;
    for (let i2 = 0; i2 < this.chunk.length; i2++) {
      let start = this.chunkPos[i2], chunk = this.chunk[i2];
      let touch = changes.touchesRange(start, start + chunk.length);
      if (touch === false) {
        maxPoint = Math.max(maxPoint, chunk.maxPoint);
        chunks.push(chunk);
        chunkPos.push(changes.mapPos(start));
      } else if (touch === true) {
        let { mapped, pos } = chunk.map(start, changes);
        if (mapped) {
          maxPoint = Math.max(maxPoint, mapped.maxPoint);
          chunks.push(mapped);
          chunkPos.push(pos);
        }
      }
    }
    let next = this.nextLayer.map(changes);
    return chunks.length == 0 ? next : new _RangeSet(chunkPos, chunks, next || _RangeSet.empty, maxPoint);
  }
  /**
  Iterate over the ranges that touch the region `from` to `to`,
  calling `f` for each. There is no guarantee that the ranges will
  be reported in any specific order. When the callback returns
  `false`, iteration stops.
  */
  between(from, to3, f) {
    if (this.isEmpty)
      return;
    for (let i2 = 0; i2 < this.chunk.length; i2++) {
      let start = this.chunkPos[i2], chunk = this.chunk[i2];
      if (to3 >= start && from <= start + chunk.length && chunk.between(start, from - start, to3 - start, f) === false)
        return;
    }
    this.nextLayer.between(from, to3, f);
  }
  /**
  Iterate over the ranges in this set, in order, including all
  ranges that end at or after `from`.
  */
  iter(from = 0) {
    return HeapCursor.from([this]).goto(from);
  }
  /**
  @internal
  */
  get isEmpty() {
    return this.nextLayer == this;
  }
  /**
  Iterate over the ranges in a collection of sets, in order,
  starting from `from`.
  */
  static iter(sets, from = 0) {
    return HeapCursor.from(sets).goto(from);
  }
  /**
  Iterate over two groups of sets, calling methods on `comparator`
  to notify it of possible differences.
  */
  static compare(oldSets, newSets, textDiff, comparator, minPointSize = -1) {
    let a2 = oldSets.filter((set) => set.maxPoint > 0 || !set.isEmpty && set.maxPoint >= minPointSize);
    let b2 = newSets.filter((set) => set.maxPoint > 0 || !set.isEmpty && set.maxPoint >= minPointSize);
    let sharedChunks = findSharedChunks(a2, b2, textDiff);
    let sideA = new SpanCursor(a2, sharedChunks, minPointSize);
    let sideB = new SpanCursor(b2, sharedChunks, minPointSize);
    textDiff.iterGaps((fromA, fromB, length) => compare(sideA, fromA, sideB, fromB, length, comparator));
    if (textDiff.empty && textDiff.length == 0)
      compare(sideA, 0, sideB, 0, 0, comparator);
  }
  /**
  Compare the contents of two groups of range sets, returning true
  if they are equivalent in the given range.
  */
  static eq(oldSets, newSets, from = 0, to3) {
    if (to3 == null)
      to3 = 1e9 - 1;
    let a2 = oldSets.filter((set) => !set.isEmpty && newSets.indexOf(set) < 0);
    let b2 = newSets.filter((set) => !set.isEmpty && oldSets.indexOf(set) < 0);
    if (a2.length != b2.length)
      return false;
    if (!a2.length)
      return true;
    let sharedChunks = findSharedChunks(a2, b2);
    let sideA = new SpanCursor(a2, sharedChunks, 0).goto(from), sideB = new SpanCursor(b2, sharedChunks, 0).goto(from);
    for (; ; ) {
      if (sideA.to != sideB.to || !sameValues(sideA.active, sideB.active) || sideA.point && (!sideB.point || !sideA.point.eq(sideB.point)))
        return false;
      if (sideA.to > to3)
        return true;
      sideA.next();
      sideB.next();
    }
  }
  /**
  Iterate over a group of range sets at the same time, notifying
  the iterator about the ranges covering every given piece of
  content. Returns the open count (see
  [`SpanIterator.span`](https://codemirror.net/6/docs/ref/#state.SpanIterator.span)) at the end
  of the iteration.
  */
  static spans(sets, from, to3, iterator, minPointSize = -1) {
    let cursor = new SpanCursor(sets, null, minPointSize).goto(from), pos = from;
    let openRanges = cursor.openStart;
    for (; ; ) {
      let curTo = Math.min(cursor.to, to3);
      if (cursor.point) {
        let active = cursor.activeForPoint(cursor.to);
        let openCount = cursor.pointFrom < from ? active.length + 1 : cursor.point.startSide < 0 ? active.length : Math.min(active.length, openRanges);
        iterator.point(pos, curTo, cursor.point, active, openCount, cursor.pointRank);
        openRanges = Math.min(cursor.openEnd(curTo), active.length);
      } else if (curTo > pos) {
        iterator.span(pos, curTo, cursor.active, openRanges);
        openRanges = cursor.openEnd(curTo);
      }
      if (cursor.to > to3)
        return openRanges + (cursor.point && cursor.to > to3 ? 1 : 0);
      pos = cursor.to;
      cursor.next();
    }
  }
  /**
  Create a range set for the given range or array of ranges. By
  default, this expects the ranges to be _sorted_ (by start
  position and, if two start at the same position,
  `value.startSide`). You can pass `true` as second argument to
  cause the method to sort them.
  */
  static of(ranges, sort = false) {
    let build = new RangeSetBuilder();
    for (let range of ranges instanceof Range ? [ranges] : sort ? lazySort(ranges) : ranges)
      build.add(range.from, range.to, range.value);
    return build.finish();
  }
  /**
  Join an array of range sets into a single set.
  */
  static join(sets) {
    if (!sets.length)
      return _RangeSet.empty;
    let result = sets[sets.length - 1];
    for (let i2 = sets.length - 2; i2 >= 0; i2--) {
      for (let layer2 = sets[i2]; layer2 != _RangeSet.empty; layer2 = layer2.nextLayer)
        result = new _RangeSet(layer2.chunkPos, layer2.chunk, result, Math.max(layer2.maxPoint, result.maxPoint));
    }
    return result;
  }
};
RangeSet.empty = new RangeSet([], [], null, -1);
function lazySort(ranges) {
  if (ranges.length > 1)
    for (let prev = ranges[0], i2 = 1; i2 < ranges.length; i2++) {
      let cur2 = ranges[i2];
      if (cmpRange(prev, cur2) > 0)
        return ranges.slice().sort(cmpRange);
      prev = cur2;
    }
  return ranges;
}
RangeSet.empty.nextLayer = RangeSet.empty;
var RangeSetBuilder = class _RangeSetBuilder {
  finishChunk(newArrays) {
    this.chunks.push(new Chunk(this.from, this.to, this.value, this.maxPoint));
    this.chunkPos.push(this.chunkStart);
    this.chunkStart = -1;
    this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint);
    this.maxPoint = -1;
    if (newArrays) {
      this.from = [];
      this.to = [];
      this.value = [];
    }
  }
  /**
  Create an empty builder.
  */
  constructor() {
    this.chunks = [];
    this.chunkPos = [];
    this.chunkStart = -1;
    this.last = null;
    this.lastFrom = -1e9;
    this.lastTo = -1e9;
    this.from = [];
    this.to = [];
    this.value = [];
    this.maxPoint = -1;
    this.setMaxPoint = -1;
    this.nextLayer = null;
  }
  /**
  Add a range. Ranges should be added in sorted (by `from` and
  `value.startSide`) order.
  */
  add(from, to3, value) {
    if (!this.addInner(from, to3, value))
      (this.nextLayer || (this.nextLayer = new _RangeSetBuilder())).add(from, to3, value);
  }
  /**
  @internal
  */
  addInner(from, to3, value) {
    let diff = from - this.lastTo || value.startSide - this.last.endSide;
    if (diff <= 0 && (from - this.lastFrom || value.startSide - this.last.startSide) < 0)
      throw new Error("Ranges must be added sorted by `from` position and `startSide`");
    if (diff < 0)
      return false;
    if (this.from.length == 250)
      this.finishChunk(true);
    if (this.chunkStart < 0)
      this.chunkStart = from;
    this.from.push(from - this.chunkStart);
    this.to.push(to3 - this.chunkStart);
    this.last = value;
    this.lastFrom = from;
    this.lastTo = to3;
    this.value.push(value);
    if (value.point)
      this.maxPoint = Math.max(this.maxPoint, to3 - from);
    return true;
  }
  /**
  @internal
  */
  addChunk(from, chunk) {
    if ((from - this.lastTo || chunk.value[0].startSide - this.last.endSide) < 0)
      return false;
    if (this.from.length)
      this.finishChunk(true);
    this.setMaxPoint = Math.max(this.setMaxPoint, chunk.maxPoint);
    this.chunks.push(chunk);
    this.chunkPos.push(from);
    let last2 = chunk.value.length - 1;
    this.last = chunk.value[last2];
    this.lastFrom = chunk.from[last2] + from;
    this.lastTo = chunk.to[last2] + from;
    return true;
  }
  /**
  Finish the range set. Returns the new set. The builder can't be
  used anymore after this has been called.
  */
  finish() {
    return this.finishInner(RangeSet.empty);
  }
  /**
  @internal
  */
  finishInner(next) {
    if (this.from.length)
      this.finishChunk(false);
    if (this.chunks.length == 0)
      return next;
    let result = RangeSet.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(next) : next, this.setMaxPoint);
    this.from = null;
    return result;
  }
};
function findSharedChunks(a2, b2, textDiff) {
  let inA = /* @__PURE__ */ new Map();
  for (let set of a2)
    for (let i2 = 0; i2 < set.chunk.length; i2++)
      if (set.chunk[i2].maxPoint <= 0)
        inA.set(set.chunk[i2], set.chunkPos[i2]);
  let shared = /* @__PURE__ */ new Set();
  for (let set of b2)
    for (let i2 = 0; i2 < set.chunk.length; i2++) {
      let known = inA.get(set.chunk[i2]);
      if (known != null && (textDiff ? textDiff.mapPos(known) : known) == set.chunkPos[i2] && !(textDiff === null || textDiff === void 0 ? void 0 : textDiff.touchesRange(known, known + set.chunk[i2].length)))
        shared.add(set.chunk[i2]);
    }
  return shared;
}
var LayerCursor = class {
  constructor(layer2, skip, minPoint, rank = 0) {
    this.layer = layer2;
    this.skip = skip;
    this.minPoint = minPoint;
    this.rank = rank;
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  get endSide() {
    return this.value ? this.value.endSide : 0;
  }
  goto(pos, side = -1e9) {
    this.chunkIndex = this.rangeIndex = 0;
    this.gotoInner(pos, side, false);
    return this;
  }
  gotoInner(pos, side, forward) {
    while (this.chunkIndex < this.layer.chunk.length) {
      let next = this.layer.chunk[this.chunkIndex];
      if (!(this.skip && this.skip.has(next) || this.layer.chunkEnd(this.chunkIndex) < pos || next.maxPoint < this.minPoint))
        break;
      this.chunkIndex++;
      forward = false;
    }
    if (this.chunkIndex < this.layer.chunk.length) {
      let rangeIndex = this.layer.chunk[this.chunkIndex].findIndex(pos - this.layer.chunkPos[this.chunkIndex], side, true);
      if (!forward || this.rangeIndex < rangeIndex)
        this.setRangeIndex(rangeIndex);
    }
    this.next();
  }
  forward(pos, side) {
    if ((this.to - pos || this.endSide - side) < 0)
      this.gotoInner(pos, side, true);
  }
  next() {
    for (; ; ) {
      if (this.chunkIndex == this.layer.chunk.length) {
        this.from = this.to = 1e9;
        this.value = null;
        break;
      } else {
        let chunkPos = this.layer.chunkPos[this.chunkIndex], chunk = this.layer.chunk[this.chunkIndex];
        let from = chunkPos + chunk.from[this.rangeIndex];
        this.from = from;
        this.to = chunkPos + chunk.to[this.rangeIndex];
        this.value = chunk.value[this.rangeIndex];
        this.setRangeIndex(this.rangeIndex + 1);
        if (this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)
          break;
      }
    }
  }
  setRangeIndex(index2) {
    if (index2 == this.layer.chunk[this.chunkIndex].value.length) {
      this.chunkIndex++;
      if (this.skip) {
        while (this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]))
          this.chunkIndex++;
      }
      this.rangeIndex = 0;
    } else {
      this.rangeIndex = index2;
    }
  }
  nextChunk() {
    this.chunkIndex++;
    this.rangeIndex = 0;
    this.next();
  }
  compare(other) {
    return this.from - other.from || this.startSide - other.startSide || this.rank - other.rank || this.to - other.to || this.endSide - other.endSide;
  }
};
var HeapCursor = class _HeapCursor {
  constructor(heap) {
    this.heap = heap;
  }
  static from(sets, skip = null, minPoint = -1) {
    let heap = [];
    for (let i2 = 0; i2 < sets.length; i2++) {
      for (let cur2 = sets[i2]; !cur2.isEmpty; cur2 = cur2.nextLayer) {
        if (cur2.maxPoint >= minPoint)
          heap.push(new LayerCursor(cur2, skip, minPoint, i2));
      }
    }
    return heap.length == 1 ? heap[0] : new _HeapCursor(heap);
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  goto(pos, side = -1e9) {
    for (let cur2 of this.heap)
      cur2.goto(pos, side);
    for (let i2 = this.heap.length >> 1; i2 >= 0; i2--)
      heapBubble(this.heap, i2);
    this.next();
    return this;
  }
  forward(pos, side) {
    for (let cur2 of this.heap)
      cur2.forward(pos, side);
    for (let i2 = this.heap.length >> 1; i2 >= 0; i2--)
      heapBubble(this.heap, i2);
    if ((this.to - pos || this.value.endSide - side) < 0)
      this.next();
  }
  next() {
    if (this.heap.length == 0) {
      this.from = this.to = 1e9;
      this.value = null;
      this.rank = -1;
    } else {
      let top2 = this.heap[0];
      this.from = top2.from;
      this.to = top2.to;
      this.value = top2.value;
      this.rank = top2.rank;
      if (top2.value)
        top2.next();
      heapBubble(this.heap, 0);
    }
  }
};
function heapBubble(heap, index2) {
  for (let cur2 = heap[index2]; ; ) {
    let childIndex = (index2 << 1) + 1;
    if (childIndex >= heap.length)
      break;
    let child = heap[childIndex];
    if (childIndex + 1 < heap.length && child.compare(heap[childIndex + 1]) >= 0) {
      child = heap[childIndex + 1];
      childIndex++;
    }
    if (cur2.compare(child) < 0)
      break;
    heap[childIndex] = cur2;
    heap[index2] = child;
    index2 = childIndex;
  }
}
var SpanCursor = class {
  constructor(sets, skip, minPoint) {
    this.minPoint = minPoint;
    this.active = [];
    this.activeTo = [];
    this.activeRank = [];
    this.minActive = -1;
    this.point = null;
    this.pointFrom = 0;
    this.pointRank = 0;
    this.to = -1e9;
    this.endSide = 0;
    this.openStart = -1;
    this.cursor = HeapCursor.from(sets, skip, minPoint);
  }
  goto(pos, side = -1e9) {
    this.cursor.goto(pos, side);
    this.active.length = this.activeTo.length = this.activeRank.length = 0;
    this.minActive = -1;
    this.to = pos;
    this.endSide = side;
    this.openStart = -1;
    this.next();
    return this;
  }
  forward(pos, side) {
    while (this.minActive > -1 && (this.activeTo[this.minActive] - pos || this.active[this.minActive].endSide - side) < 0)
      this.removeActive(this.minActive);
    this.cursor.forward(pos, side);
  }
  removeActive(index2) {
    remove2(this.active, index2);
    remove2(this.activeTo, index2);
    remove2(this.activeRank, index2);
    this.minActive = findMinIndex(this.active, this.activeTo);
  }
  addActive(trackOpen) {
    let i2 = 0, { value, to: to3, rank } = this.cursor;
    while (i2 < this.activeRank.length && (rank - this.activeRank[i2] || to3 - this.activeTo[i2]) > 0)
      i2++;
    insert(this.active, i2, value);
    insert(this.activeTo, i2, to3);
    insert(this.activeRank, i2, rank);
    if (trackOpen)
      insert(trackOpen, i2, this.cursor.from);
    this.minActive = findMinIndex(this.active, this.activeTo);
  }
  // After calling this, if `this.point` != null, the next range is a
  // point. Otherwise, it's a regular range, covered by `this.active`.
  next() {
    let from = this.to, wasPoint = this.point;
    this.point = null;
    let trackOpen = this.openStart < 0 ? [] : null;
    for (; ; ) {
      let a2 = this.minActive;
      if (a2 > -1 && (this.activeTo[a2] - this.cursor.from || this.active[a2].endSide - this.cursor.startSide) < 0) {
        if (this.activeTo[a2] > from) {
          this.to = this.activeTo[a2];
          this.endSide = this.active[a2].endSide;
          break;
        }
        this.removeActive(a2);
        if (trackOpen)
          remove2(trackOpen, a2);
      } else if (!this.cursor.value) {
        this.to = this.endSide = 1e9;
        break;
      } else if (this.cursor.from > from) {
        this.to = this.cursor.from;
        this.endSide = this.cursor.startSide;
        break;
      } else {
        let nextVal = this.cursor.value;
        if (!nextVal.point) {
          this.addActive(trackOpen);
          this.cursor.next();
        } else if (wasPoint && this.cursor.to == this.to && this.cursor.from < this.cursor.to) {
          this.cursor.next();
        } else {
          this.point = nextVal;
          this.pointFrom = this.cursor.from;
          this.pointRank = this.cursor.rank;
          this.to = this.cursor.to;
          this.endSide = nextVal.endSide;
          this.cursor.next();
          this.forward(this.to, this.endSide);
          break;
        }
      }
    }
    if (trackOpen) {
      this.openStart = 0;
      for (let i2 = trackOpen.length - 1; i2 >= 0 && trackOpen[i2] < from; i2--)
        this.openStart++;
    }
  }
  activeForPoint(to3) {
    if (!this.active.length)
      return this.active;
    let active = [];
    for (let i2 = this.active.length - 1; i2 >= 0; i2--) {
      if (this.activeRank[i2] < this.pointRank)
        break;
      if (this.activeTo[i2] > to3 || this.activeTo[i2] == to3 && this.active[i2].endSide >= this.point.endSide)
        active.push(this.active[i2]);
    }
    return active.reverse();
  }
  openEnd(to3) {
    let open = 0;
    for (let i2 = this.activeTo.length - 1; i2 >= 0 && this.activeTo[i2] > to3; i2--)
      open++;
    return open;
  }
};
function compare(a2, startA, b2, startB, length, comparator) {
  a2.goto(startA);
  b2.goto(startB);
  let endB = startB + length;
  let pos = startB, dPos = startB - startA;
  for (; ; ) {
    let diff = a2.to + dPos - b2.to || a2.endSide - b2.endSide;
    let end = diff < 0 ? a2.to + dPos : b2.to, clipEnd = Math.min(end, endB);
    if (a2.point || b2.point) {
      if (!(a2.point && b2.point && (a2.point == b2.point || a2.point.eq(b2.point)) && sameValues(a2.activeForPoint(a2.to), b2.activeForPoint(b2.to))))
        comparator.comparePoint(pos, clipEnd, a2.point, b2.point);
    } else {
      if (clipEnd > pos && !sameValues(a2.active, b2.active))
        comparator.compareRange(pos, clipEnd, a2.active, b2.active);
    }
    if (end > endB)
      break;
    pos = end;
    if (diff <= 0)
      a2.next();
    if (diff >= 0)
      b2.next();
  }
}
function sameValues(a2, b2) {
  if (a2.length != b2.length)
    return false;
  for (let i2 = 0; i2 < a2.length; i2++)
    if (a2[i2] != b2[i2] && !a2[i2].eq(b2[i2]))
      return false;
  return true;
}
function remove2(array, index2) {
  for (let i2 = index2, e2 = array.length - 1; i2 < e2; i2++)
    array[i2] = array[i2 + 1];
  array.pop();
}
function insert(array, index2, value) {
  for (let i2 = array.length - 1; i2 >= index2; i2--)
    array[i2 + 1] = array[i2];
  array[index2] = value;
}
function findMinIndex(value, array) {
  let found = -1, foundPos = 1e9;
  for (let i2 = 0; i2 < array.length; i2++)
    if ((array[i2] - foundPos || value[i2].endSide - value[found].endSide) < 0) {
      found = i2;
      foundPos = array[i2];
    }
  return found;
}
function countColumn(string2, tabSize, to3 = string2.length) {
  let n2 = 0;
  for (let i2 = 0; i2 < to3; ) {
    if (string2.charCodeAt(i2) == 9) {
      n2 += tabSize - n2 % tabSize;
      i2++;
    } else {
      n2++;
      i2 = findClusterBreak(string2, i2);
    }
  }
  return n2;
}
function findColumn(string2, col, tabSize, strict) {
  for (let i2 = 0, n2 = 0; ; ) {
    if (n2 >= col)
      return i2;
    if (i2 == string2.length)
      break;
    n2 += string2.charCodeAt(i2) == 9 ? tabSize - n2 % tabSize : 1;
    i2 = findClusterBreak(string2, i2);
  }
  return strict === true ? -1 : string2.length;
}

// node_modules/style-mod/src/style-mod.js
var C = "ͼ";
var COUNT = typeof Symbol == "undefined" ? "__" + C : Symbol.for(C);
var SET = typeof Symbol == "undefined" ? "__styleSet" + Math.floor(Math.random() * 1e8) : Symbol("styleSet");
var top = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : {};
var StyleModule = class {
  // :: (Object<Style>, ?{finish: ?(string) → string})
  // Create a style module from the given spec.
  //
  // When `finish` is given, it is called on regular (non-`@`)
  // selectors (after `&` expansion) to compute the final selector.
  constructor(spec, options) {
    this.rules = [];
    let { finish } = options || {};
    function splitSelector(selector) {
      return /^@/.test(selector) ? [selector] : selector.split(/,\s*/);
    }
    function render(selectors, spec2, target, isKeyframes) {
      let local = [], isAt = /^@(\w+)\b/.exec(selectors[0]), keyframes = isAt && isAt[1] == "keyframes";
      if (isAt && spec2 == null) return target.push(selectors[0] + ";");
      for (let prop in spec2) {
        let value = spec2[prop];
        if (/&/.test(prop)) {
          render(
            prop.split(/,\s*/).map((part) => selectors.map((sel) => part.replace(/&/, sel))).reduce((a2, b2) => a2.concat(b2)),
            value,
            target
          );
        } else if (value && typeof value == "object") {
          if (!isAt) throw new RangeError("The value of a property (" + prop + ") should be a primitive value.");
          render(splitSelector(prop), value, local, keyframes);
        } else if (value != null) {
          local.push(prop.replace(/_.*/, "").replace(/[A-Z]/g, (l) => "-" + l.toLowerCase()) + ": " + value + ";");
        }
      }
      if (local.length || keyframes) {
        target.push((finish && !isAt && !isKeyframes ? selectors.map(finish) : selectors).join(", ") + " {" + local.join(" ") + "}");
      }
    }
    for (let prop in spec) render(splitSelector(prop), spec[prop], this.rules);
  }
  // :: () → string
  // Returns a string containing the module's CSS rules.
  getRules() {
    return this.rules.join("\n");
  }
  // :: () → string
  // Generate a new unique CSS class name.
  static newName() {
    let id2 = top[COUNT] || 1;
    top[COUNT] = id2 + 1;
    return C + id2.toString(36);
  }
  // :: (union<Document, ShadowRoot>, union<[StyleModule], StyleModule>, ?{nonce: ?string})
  //
  // Mount the given set of modules in the given DOM root, which ensures
  // that the CSS rules defined by the module are available in that
  // context.
  //
  // Rules are only added to the document once per root.
  //
  // Rule order will follow the order of the modules, so that rules from
  // modules later in the array take precedence of those from earlier
  // modules. If you call this function multiple times for the same root
  // in a way that changes the order of already mounted modules, the old
  // order will be changed.
  //
  // If a Content Security Policy nonce is provided, it is added to
  // the `<style>` tag generated by the library.
  static mount(root, modules, options) {
    let set = root[SET], nonce = options && options.nonce;
    if (!set) set = new StyleSet(root, nonce);
    else if (nonce) set.setNonce(nonce);
    set.mount(Array.isArray(modules) ? modules : [modules], root);
  }
};
var adoptedSet = /* @__PURE__ */ new Map();
var StyleSet = class {
  constructor(root, nonce) {
    let doc2 = root.ownerDocument || root, win = doc2.defaultView;
    if (!root.head && root.adoptedStyleSheets && win.CSSStyleSheet) {
      let adopted = adoptedSet.get(doc2);
      if (adopted) return root[SET] = adopted;
      this.sheet = new win.CSSStyleSheet();
      adoptedSet.set(doc2, this);
    } else {
      this.styleTag = doc2.createElement("style");
      if (nonce) this.styleTag.setAttribute("nonce", nonce);
    }
    this.modules = [];
    root[SET] = this;
  }
  mount(modules, root) {
    let sheet = this.sheet;
    let pos = 0, j = 0;
    for (let i2 = 0; i2 < modules.length; i2++) {
      let mod = modules[i2], index2 = this.modules.indexOf(mod);
      if (index2 < j && index2 > -1) {
        this.modules.splice(index2, 1);
        j--;
        index2 = -1;
      }
      if (index2 == -1) {
        this.modules.splice(j++, 0, mod);
        if (sheet) for (let k2 = 0; k2 < mod.rules.length; k2++)
          sheet.insertRule(mod.rules[k2], pos++);
      } else {
        while (j < index2) pos += this.modules[j++].rules.length;
        pos += mod.rules.length;
        j++;
      }
    }
    if (sheet) {
      if (root.adoptedStyleSheets.indexOf(this.sheet) < 0)
        root.adoptedStyleSheets = [this.sheet, ...root.adoptedStyleSheets];
    } else {
      let text = "";
      for (let i2 = 0; i2 < this.modules.length; i2++)
        text += this.modules[i2].getRules() + "\n";
      this.styleTag.textContent = text;
      let target = root.head || root;
      if (this.styleTag.parentNode != target)
        target.insertBefore(this.styleTag, target.firstChild);
    }
  }
  setNonce(nonce) {
    if (this.styleTag && this.styleTag.getAttribute("nonce") != nonce)
      this.styleTag.setAttribute("nonce", nonce);
  }
};

// node_modules/w3c-keyname/index.js
var base = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
};
var shift = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
};
var mac = typeof navigator != "undefined" && /Mac/.test(navigator.platform);
var ie = typeof navigator != "undefined" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (i2 = 0; i2 < 10; i2++) base[48 + i2] = base[96 + i2] = String(i2);
var i2;
for (i2 = 1; i2 <= 24; i2++) base[i2 + 111] = "F" + i2;
var i2;
for (i2 = 65; i2 <= 90; i2++) {
  base[i2] = String.fromCharCode(i2 + 32);
  shift[i2] = String.fromCharCode(i2);
}
var i2;
for (code in base) if (!shift.hasOwnProperty(code)) shift[code] = base[code];
var code;
function keyName(event) {
  var ignoreKey = mac && event.metaKey && event.shiftKey && !event.ctrlKey && !event.altKey || ie && event.shiftKey && event.key && event.key.length == 1 || event.key == "Unidentified";
  var name2 = !ignoreKey && event.key || (event.shiftKey ? shift : base)[event.keyCode] || event.key || "Unidentified";
  if (name2 == "Esc") name2 = "Escape";
  if (name2 == "Del") name2 = "Delete";
  if (name2 == "Left") name2 = "ArrowLeft";
  if (name2 == "Up") name2 = "ArrowUp";
  if (name2 == "Right") name2 = "ArrowRight";
  if (name2 == "Down") name2 = "ArrowDown";
  return name2;
}

// node_modules/@codemirror/view/dist/index.js
function getSelection(root) {
  let target;
  if (root.nodeType == 11) {
    target = root.getSelection ? root : root.ownerDocument;
  } else {
    target = root;
  }
  return target.getSelection();
}
function contains(dom, node) {
  return node ? dom == node || dom.contains(node.nodeType != 1 ? node.parentNode : node) : false;
}
function hasSelection(dom, selection) {
  if (!selection.anchorNode)
    return false;
  try {
    return contains(dom, selection.anchorNode);
  } catch (_2) {
    return false;
  }
}
function clientRectsFor(dom) {
  if (dom.nodeType == 3)
    return textRange(dom, 0, dom.nodeValue.length).getClientRects();
  else if (dom.nodeType == 1)
    return dom.getClientRects();
  else
    return [];
}
function isEquivalentPosition(node, off, targetNode, targetOff) {
  return targetNode ? scanFor(node, off, targetNode, targetOff, -1) || scanFor(node, off, targetNode, targetOff, 1) : false;
}
function domIndex(node) {
  for (var index2 = 0; ; index2++) {
    node = node.previousSibling;
    if (!node)
      return index2;
  }
}
function isBlockElement(node) {
  return node.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(node.nodeName);
}
function scanFor(node, off, targetNode, targetOff, dir) {
  for (; ; ) {
    if (node == targetNode && off == targetOff)
      return true;
    if (off == (dir < 0 ? 0 : maxOffset(node))) {
      if (node.nodeName == "DIV")
        return false;
      let parent = node.parentNode;
      if (!parent || parent.nodeType != 1)
        return false;
      off = domIndex(node) + (dir < 0 ? 0 : 1);
      node = parent;
    } else if (node.nodeType == 1) {
      node = node.childNodes[off + (dir < 0 ? -1 : 0)];
      if (node.nodeType == 1 && node.contentEditable == "false")
        return false;
      off = dir < 0 ? maxOffset(node) : 0;
    } else {
      return false;
    }
  }
}
function maxOffset(node) {
  return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
}
function flattenRect(rect, left) {
  let x = left ? rect.left : rect.right;
  return { left: x, right: x, top: rect.top, bottom: rect.bottom };
}
function windowRect(win) {
  let vp2 = win.visualViewport;
  if (vp2)
    return {
      left: 0,
      right: vp2.width,
      top: 0,
      bottom: vp2.height
    };
  return {
    left: 0,
    right: win.innerWidth,
    top: 0,
    bottom: win.innerHeight
  };
}
function getScale(elt, rect) {
  let scaleX = rect.width / elt.offsetWidth;
  let scaleY = rect.height / elt.offsetHeight;
  if (scaleX > 0.995 && scaleX < 1.005 || !isFinite(scaleX) || Math.abs(rect.width - elt.offsetWidth) < 1)
    scaleX = 1;
  if (scaleY > 0.995 && scaleY < 1.005 || !isFinite(scaleY) || Math.abs(rect.height - elt.offsetHeight) < 1)
    scaleY = 1;
  return { scaleX, scaleY };
}
function scrollRectIntoView(dom, rect, side, x, y, xMargin, yMargin, ltr) {
  let doc2 = dom.ownerDocument, win = doc2.defaultView || window;
  for (let cur2 = dom, stop = false; cur2 && !stop; ) {
    if (cur2.nodeType == 1) {
      let bounding, top2 = cur2 == doc2.body;
      let scaleX = 1, scaleY = 1;
      if (top2) {
        bounding = windowRect(win);
      } else {
        if (/^(fixed|sticky)$/.test(getComputedStyle(cur2).position))
          stop = true;
        if (cur2.scrollHeight <= cur2.clientHeight && cur2.scrollWidth <= cur2.clientWidth) {
          cur2 = cur2.assignedSlot || cur2.parentNode;
          continue;
        }
        let rect2 = cur2.getBoundingClientRect();
        ({ scaleX, scaleY } = getScale(cur2, rect2));
        bounding = {
          left: rect2.left,
          right: rect2.left + cur2.clientWidth * scaleX,
          top: rect2.top,
          bottom: rect2.top + cur2.clientHeight * scaleY
        };
      }
      let moveX = 0, moveY = 0;
      if (y == "nearest") {
        if (rect.top < bounding.top) {
          moveY = -(bounding.top - rect.top + yMargin);
          if (side > 0 && rect.bottom > bounding.bottom + moveY)
            moveY = rect.bottom - bounding.bottom + moveY + yMargin;
        } else if (rect.bottom > bounding.bottom) {
          moveY = rect.bottom - bounding.bottom + yMargin;
          if (side < 0 && rect.top - moveY < bounding.top)
            moveY = -(bounding.top + moveY - rect.top + yMargin);
        }
      } else {
        let rectHeight = rect.bottom - rect.top, boundingHeight = bounding.bottom - bounding.top;
        let targetTop = y == "center" && rectHeight <= boundingHeight ? rect.top + rectHeight / 2 - boundingHeight / 2 : y == "start" || y == "center" && side < 0 ? rect.top - yMargin : rect.bottom - boundingHeight + yMargin;
        moveY = targetTop - bounding.top;
      }
      if (x == "nearest") {
        if (rect.left < bounding.left) {
          moveX = -(bounding.left - rect.left + xMargin);
          if (side > 0 && rect.right > bounding.right + moveX)
            moveX = rect.right - bounding.right + moveX + xMargin;
        } else if (rect.right > bounding.right) {
          moveX = rect.right - bounding.right + xMargin;
          if (side < 0 && rect.left < bounding.left + moveX)
            moveX = -(bounding.left + moveX - rect.left + xMargin);
        }
      } else {
        let targetLeft = x == "center" ? rect.left + (rect.right - rect.left) / 2 - (bounding.right - bounding.left) / 2 : x == "start" == ltr ? rect.left - xMargin : rect.right - (bounding.right - bounding.left) + xMargin;
        moveX = targetLeft - bounding.left;
      }
      if (moveX || moveY) {
        if (top2) {
          win.scrollBy(moveX, moveY);
        } else {
          let movedX = 0, movedY = 0;
          if (moveY) {
            let start = cur2.scrollTop;
            cur2.scrollTop += moveY / scaleY;
            movedY = (cur2.scrollTop - start) * scaleY;
          }
          if (moveX) {
            let start = cur2.scrollLeft;
            cur2.scrollLeft += moveX / scaleX;
            movedX = (cur2.scrollLeft - start) * scaleX;
          }
          rect = {
            left: rect.left - movedX,
            top: rect.top - movedY,
            right: rect.right - movedX,
            bottom: rect.bottom - movedY
          };
          if (movedX && Math.abs(movedX - moveX) < 1)
            x = "nearest";
          if (movedY && Math.abs(movedY - moveY) < 1)
            y = "nearest";
        }
      }
      if (top2)
        break;
      cur2 = cur2.assignedSlot || cur2.parentNode;
    } else if (cur2.nodeType == 11) {
      cur2 = cur2.host;
    } else {
      break;
    }
  }
}
function scrollableParents(dom) {
  let doc2 = dom.ownerDocument, x, y;
  for (let cur2 = dom.parentNode; cur2; ) {
    if (cur2 == doc2.body || x && y) {
      break;
    } else if (cur2.nodeType == 1) {
      if (!y && cur2.scrollHeight > cur2.clientHeight)
        y = cur2;
      if (!x && cur2.scrollWidth > cur2.clientWidth)
        x = cur2;
      cur2 = cur2.assignedSlot || cur2.parentNode;
    } else if (cur2.nodeType == 11) {
      cur2 = cur2.host;
    } else {
      break;
    }
  }
  return { x, y };
}
var DOMSelectionState = class {
  constructor() {
    this.anchorNode = null;
    this.anchorOffset = 0;
    this.focusNode = null;
    this.focusOffset = 0;
  }
  eq(domSel) {
    return this.anchorNode == domSel.anchorNode && this.anchorOffset == domSel.anchorOffset && this.focusNode == domSel.focusNode && this.focusOffset == domSel.focusOffset;
  }
  setRange(range) {
    let { anchorNode, focusNode } = range;
    this.set(anchorNode, Math.min(range.anchorOffset, anchorNode ? maxOffset(anchorNode) : 0), focusNode, Math.min(range.focusOffset, focusNode ? maxOffset(focusNode) : 0));
  }
  set(anchorNode, anchorOffset, focusNode, focusOffset) {
    this.anchorNode = anchorNode;
    this.anchorOffset = anchorOffset;
    this.focusNode = focusNode;
    this.focusOffset = focusOffset;
  }
};
var preventScrollSupported = null;
function focusPreventScroll(dom) {
  if (dom.setActive)
    return dom.setActive();
  if (preventScrollSupported)
    return dom.focus(preventScrollSupported);
  let stack = [];
  for (let cur2 = dom; cur2; cur2 = cur2.parentNode) {
    stack.push(cur2, cur2.scrollTop, cur2.scrollLeft);
    if (cur2 == cur2.ownerDocument)
      break;
  }
  dom.focus(preventScrollSupported == null ? {
    get preventScroll() {
      preventScrollSupported = { preventScroll: true };
      return true;
    }
  } : void 0);
  if (!preventScrollSupported) {
    preventScrollSupported = false;
    for (let i2 = 0; i2 < stack.length; ) {
      let elt = stack[i2++], top2 = stack[i2++], left = stack[i2++];
      if (elt.scrollTop != top2)
        elt.scrollTop = top2;
      if (elt.scrollLeft != left)
        elt.scrollLeft = left;
    }
  }
}
var scratchRange;
function textRange(node, from, to3 = from) {
  let range = scratchRange || (scratchRange = document.createRange());
  range.setEnd(node, to3);
  range.setStart(node, from);
  return range;
}
function dispatchKey(elt, name2, code, mods) {
  let options = { key: name2, code: name2, keyCode: code, which: code, cancelable: true };
  if (mods)
    ({ altKey: options.altKey, ctrlKey: options.ctrlKey, shiftKey: options.shiftKey, metaKey: options.metaKey } = mods);
  let down = new KeyboardEvent("keydown", options);
  down.synthetic = true;
  elt.dispatchEvent(down);
  let up2 = new KeyboardEvent("keyup", options);
  up2.synthetic = true;
  elt.dispatchEvent(up2);
  return down.defaultPrevented || up2.defaultPrevented;
}
function getRoot(node) {
  while (node) {
    if (node && (node.nodeType == 9 || node.nodeType == 11 && node.host))
      return node;
    node = node.assignedSlot || node.parentNode;
  }
  return null;
}
function clearAttributes(node) {
  while (node.attributes.length)
    node.removeAttributeNode(node.attributes[0]);
}
function atElementStart(doc2, selection) {
  let node = selection.focusNode, offset = selection.focusOffset;
  if (!node || selection.anchorNode != node || selection.anchorOffset != offset)
    return false;
  offset = Math.min(offset, maxOffset(node));
  for (; ; ) {
    if (offset) {
      if (node.nodeType != 1)
        return false;
      let prev = node.childNodes[offset - 1];
      if (prev.contentEditable == "false")
        offset--;
      else {
        node = prev;
        offset = maxOffset(node);
      }
    } else if (node == doc2) {
      return true;
    } else {
      offset = domIndex(node);
      node = node.parentNode;
    }
  }
}
function isScrolledToBottom(elt) {
  return elt.scrollTop > Math.max(1, elt.scrollHeight - elt.clientHeight - 4);
}
function textNodeBefore(startNode, startOffset) {
  for (let node = startNode, offset = startOffset; ; ) {
    if (node.nodeType == 3 && offset > 0) {
      return { node, offset };
    } else if (node.nodeType == 1 && offset > 0) {
      if (node.contentEditable == "false")
        return null;
      node = node.childNodes[offset - 1];
      offset = maxOffset(node);
    } else if (node.parentNode && !isBlockElement(node)) {
      offset = domIndex(node);
      node = node.parentNode;
    } else {
      return null;
    }
  }
}
function textNodeAfter(startNode, startOffset) {
  for (let node = startNode, offset = startOffset; ; ) {
    if (node.nodeType == 3 && offset < node.nodeValue.length) {
      return { node, offset };
    } else if (node.nodeType == 1 && offset < node.childNodes.length) {
      if (node.contentEditable == "false")
        return null;
      node = node.childNodes[offset];
      offset = 0;
    } else if (node.parentNode && !isBlockElement(node)) {
      offset = domIndex(node) + 1;
      node = node.parentNode;
    } else {
      return null;
    }
  }
}
var DOMPos = class _DOMPos {
  constructor(node, offset, precise = true) {
    this.node = node;
    this.offset = offset;
    this.precise = precise;
  }
  static before(dom, precise) {
    return new _DOMPos(dom.parentNode, domIndex(dom), precise);
  }
  static after(dom, precise) {
    return new _DOMPos(dom.parentNode, domIndex(dom) + 1, precise);
  }
};
var noChildren = [];
var ContentView = class _ContentView {
  constructor() {
    this.parent = null;
    this.dom = null;
    this.flags = 2;
  }
  get overrideDOMText() {
    return null;
  }
  get posAtStart() {
    return this.parent ? this.parent.posBefore(this) : 0;
  }
  get posAtEnd() {
    return this.posAtStart + this.length;
  }
  posBefore(view) {
    let pos = this.posAtStart;
    for (let child of this.children) {
      if (child == view)
        return pos;
      pos += child.length + child.breakAfter;
    }
    throw new RangeError("Invalid child in posBefore");
  }
  posAfter(view) {
    return this.posBefore(view) + view.length;
  }
  sync(view, track) {
    if (this.flags & 2) {
      let parent = this.dom;
      let prev = null, next;
      for (let child of this.children) {
        if (child.flags & 7) {
          if (!child.dom && (next = prev ? prev.nextSibling : parent.firstChild)) {
            let contentView = _ContentView.get(next);
            if (!contentView || !contentView.parent && contentView.canReuseDOM(child))
              child.reuseDOM(next);
          }
          child.sync(view, track);
          child.flags &= ~7;
        }
        next = prev ? prev.nextSibling : parent.firstChild;
        if (track && !track.written && track.node == parent && next != child.dom)
          track.written = true;
        if (child.dom.parentNode == parent) {
          while (next && next != child.dom)
            next = rm$1(next);
        } else {
          parent.insertBefore(child.dom, next);
        }
        prev = child.dom;
      }
      next = prev ? prev.nextSibling : parent.firstChild;
      if (next && track && track.node == parent)
        track.written = true;
      while (next)
        next = rm$1(next);
    } else if (this.flags & 1) {
      for (let child of this.children)
        if (child.flags & 7) {
          child.sync(view, track);
          child.flags &= ~7;
        }
    }
  }
  reuseDOM(_dom) {
  }
  localPosFromDOM(node, offset) {
    let after;
    if (node == this.dom) {
      after = this.dom.childNodes[offset];
    } else {
      let bias = maxOffset(node) == 0 ? 0 : offset == 0 ? -1 : 1;
      for (; ; ) {
        let parent = node.parentNode;
        if (parent == this.dom)
          break;
        if (bias == 0 && parent.firstChild != parent.lastChild) {
          if (node == parent.firstChild)
            bias = -1;
          else
            bias = 1;
        }
        node = parent;
      }
      if (bias < 0)
        after = node;
      else
        after = node.nextSibling;
    }
    if (after == this.dom.firstChild)
      return 0;
    while (after && !_ContentView.get(after))
      after = after.nextSibling;
    if (!after)
      return this.length;
    for (let i2 = 0, pos = 0; ; i2++) {
      let child = this.children[i2];
      if (child.dom == after)
        return pos;
      pos += child.length + child.breakAfter;
    }
  }
  domBoundsAround(from, to3, offset = 0) {
    let fromI = -1, fromStart = -1, toI = -1, toEnd = -1;
    for (let i2 = 0, pos = offset, prevEnd = offset; i2 < this.children.length; i2++) {
      let child = this.children[i2], end = pos + child.length;
      if (pos < from && end > to3)
        return child.domBoundsAround(from, to3, pos);
      if (end >= from && fromI == -1) {
        fromI = i2;
        fromStart = pos;
      }
      if (pos > to3 && child.dom.parentNode == this.dom) {
        toI = i2;
        toEnd = prevEnd;
        break;
      }
      prevEnd = end;
      pos = end + child.breakAfter;
    }
    return {
      from: fromStart,
      to: toEnd < 0 ? offset + this.length : toEnd,
      startDOM: (fromI ? this.children[fromI - 1].dom.nextSibling : null) || this.dom.firstChild,
      endDOM: toI < this.children.length && toI >= 0 ? this.children[toI].dom : null
    };
  }
  markDirty(andParent = false) {
    this.flags |= 2;
    this.markParentsDirty(andParent);
  }
  markParentsDirty(childList) {
    for (let parent = this.parent; parent; parent = parent.parent) {
      if (childList)
        parent.flags |= 2;
      if (parent.flags & 1)
        return;
      parent.flags |= 1;
      childList = false;
    }
  }
  setParent(parent) {
    if (this.parent != parent) {
      this.parent = parent;
      if (this.flags & 7)
        this.markParentsDirty(true);
    }
  }
  setDOM(dom) {
    if (this.dom == dom)
      return;
    if (this.dom)
      this.dom.cmView = null;
    this.dom = dom;
    dom.cmView = this;
  }
  get rootView() {
    for (let v = this; ; ) {
      let parent = v.parent;
      if (!parent)
        return v;
      v = parent;
    }
  }
  replaceChildren(from, to3, children = noChildren) {
    this.markDirty();
    for (let i2 = from; i2 < to3; i2++) {
      let child = this.children[i2];
      if (child.parent == this && children.indexOf(child) < 0)
        child.destroy();
    }
    if (children.length < 250)
      this.children.splice(from, to3 - from, ...children);
    else
      this.children = [].concat(this.children.slice(0, from), children, this.children.slice(to3));
    for (let i2 = 0; i2 < children.length; i2++)
      children[i2].setParent(this);
  }
  ignoreMutation(_rec) {
    return false;
  }
  ignoreEvent(_event) {
    return false;
  }
  childCursor(pos = this.length) {
    return new ChildCursor(this.children, pos, this.children.length);
  }
  childPos(pos, bias = 1) {
    return this.childCursor().findPos(pos, bias);
  }
  toString() {
    let name2 = this.constructor.name.replace("View", "");
    return name2 + (this.children.length ? "(" + this.children.join() + ")" : this.length ? "[" + (name2 == "Text" ? this.text : this.length) + "]" : "") + (this.breakAfter ? "#" : "");
  }
  static get(node) {
    return node.cmView;
  }
  get isEditable() {
    return true;
  }
  get isWidget() {
    return false;
  }
  get isHidden() {
    return false;
  }
  merge(from, to3, source, hasStart, openStart, openEnd) {
    return false;
  }
  become(other) {
    return false;
  }
  canReuseDOM(other) {
    return other.constructor == this.constructor && !((this.flags | other.flags) & 8);
  }
  // When this is a zero-length view with a side, this should return a
  // number <= 0 to indicate it is before its position, or a
  // number > 0 when after its position.
  getSide() {
    return 0;
  }
  destroy() {
    for (let child of this.children)
      if (child.parent == this)
        child.destroy();
    this.parent = null;
  }
};
ContentView.prototype.breakAfter = 0;
function rm$1(dom) {
  let next = dom.nextSibling;
  dom.parentNode.removeChild(dom);
  return next;
}
var ChildCursor = class {
  constructor(children, pos, i2) {
    this.children = children;
    this.pos = pos;
    this.i = i2;
    this.off = 0;
  }
  findPos(pos, bias = 1) {
    for (; ; ) {
      if (pos > this.pos || pos == this.pos && (bias > 0 || this.i == 0 || this.children[this.i - 1].breakAfter)) {
        this.off = pos - this.pos;
        return this;
      }
      let next = this.children[--this.i];
      this.pos -= next.length + next.breakAfter;
    }
  }
};
function replaceRange(parent, fromI, fromOff, toI, toOff, insert2, breakAtStart, openStart, openEnd) {
  let { children } = parent;
  let before = children.length ? children[fromI] : null;
  let last2 = insert2.length ? insert2[insert2.length - 1] : null;
  let breakAtEnd = last2 ? last2.breakAfter : breakAtStart;
  if (fromI == toI && before && !breakAtStart && !breakAtEnd && insert2.length < 2 && before.merge(fromOff, toOff, insert2.length ? last2 : null, fromOff == 0, openStart, openEnd))
    return;
  if (toI < children.length) {
    let after = children[toI];
    if (after && (toOff < after.length || after.breakAfter && (last2 === null || last2 === void 0 ? void 0 : last2.breakAfter))) {
      if (fromI == toI) {
        after = after.split(toOff);
        toOff = 0;
      }
      if (!breakAtEnd && last2 && after.merge(0, toOff, last2, true, 0, openEnd)) {
        insert2[insert2.length - 1] = after;
      } else {
        if (toOff || after.children.length && !after.children[0].length)
          after.merge(0, toOff, null, false, 0, openEnd);
        insert2.push(after);
      }
    } else if (after === null || after === void 0 ? void 0 : after.breakAfter) {
      if (last2)
        last2.breakAfter = 1;
      else
        breakAtStart = 1;
    }
    toI++;
  }
  if (before) {
    before.breakAfter = breakAtStart;
    if (fromOff > 0) {
      if (!breakAtStart && insert2.length && before.merge(fromOff, before.length, insert2[0], false, openStart, 0)) {
        before.breakAfter = insert2.shift().breakAfter;
      } else if (fromOff < before.length || before.children.length && before.children[before.children.length - 1].length == 0) {
        before.merge(fromOff, before.length, null, false, openStart, 0);
      }
      fromI++;
    }
  }
  while (fromI < toI && insert2.length) {
    if (children[toI - 1].become(insert2[insert2.length - 1])) {
      toI--;
      insert2.pop();
      openEnd = insert2.length ? 0 : openStart;
    } else if (children[fromI].become(insert2[0])) {
      fromI++;
      insert2.shift();
      openStart = insert2.length ? 0 : openEnd;
    } else {
      break;
    }
  }
  if (!insert2.length && fromI && toI < children.length && !children[fromI - 1].breakAfter && children[toI].merge(0, 0, children[fromI - 1], false, openStart, openEnd))
    fromI--;
  if (fromI < toI || insert2.length)
    parent.replaceChildren(fromI, toI, insert2);
}
function mergeChildrenInto(parent, from, to3, insert2, openStart, openEnd) {
  let cur2 = parent.childCursor();
  let { i: toI, off: toOff } = cur2.findPos(to3, 1);
  let { i: fromI, off: fromOff } = cur2.findPos(from, -1);
  let dLen = from - to3;
  for (let view of insert2)
    dLen += view.length;
  parent.length += dLen;
  replaceRange(parent, fromI, fromOff, toI, toOff, insert2, 0, openStart, openEnd);
}
var nav = typeof navigator != "undefined" ? navigator : { userAgent: "", vendor: "", platform: "" };
var doc = typeof document != "undefined" ? document : { documentElement: { style: {} } };
var ie_edge = /Edge\/(\d+)/.exec(nav.userAgent);
var ie_upto10 = /MSIE \d/.test(nav.userAgent);
var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(nav.userAgent);
var ie2 = !!(ie_upto10 || ie_11up || ie_edge);
var gecko = !ie2 && /gecko\/(\d+)/i.test(nav.userAgent);
var chrome = !ie2 && /Chrome\/(\d+)/.exec(nav.userAgent);
var webkit = "webkitFontSmoothing" in doc.documentElement.style;
var safari = !ie2 && /Apple Computer/.test(nav.vendor);
var ios = safari && (/Mobile\/\w+/.test(nav.userAgent) || nav.maxTouchPoints > 2);
var browser = {
  mac: ios || /Mac/.test(nav.platform),
  windows: /Win/.test(nav.platform),
  linux: /Linux|X11/.test(nav.platform),
  ie: ie2,
  ie_version: ie_upto10 ? doc.documentMode || 6 : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0,
  gecko,
  gecko_version: gecko ? +(/Firefox\/(\d+)/.exec(nav.userAgent) || [0, 0])[1] : 0,
  chrome: !!chrome,
  chrome_version: chrome ? +chrome[1] : 0,
  ios,
  android: /Android\b/.test(nav.userAgent),
  webkit,
  safari,
  webkit_version: webkit ? +(/\bAppleWebKit\/(\d+)/.exec(nav.userAgent) || [0, 0])[1] : 0,
  tabSize: doc.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size"
};
var MaxJoinLen = 256;
var TextView = class _TextView extends ContentView {
  constructor(text) {
    super();
    this.text = text;
  }
  get length() {
    return this.text.length;
  }
  createDOM(textDOM) {
    this.setDOM(textDOM || document.createTextNode(this.text));
  }
  sync(view, track) {
    if (!this.dom)
      this.createDOM();
    if (this.dom.nodeValue != this.text) {
      if (track && track.node == this.dom)
        track.written = true;
      this.dom.nodeValue = this.text;
    }
  }
  reuseDOM(dom) {
    if (dom.nodeType == 3)
      this.createDOM(dom);
  }
  merge(from, to3, source) {
    if (this.flags & 8 || source && (!(source instanceof _TextView) || this.length - (to3 - from) + source.length > MaxJoinLen || source.flags & 8))
      return false;
    this.text = this.text.slice(0, from) + (source ? source.text : "") + this.text.slice(to3);
    this.markDirty();
    return true;
  }
  split(from) {
    let result = new _TextView(this.text.slice(from));
    this.text = this.text.slice(0, from);
    this.markDirty();
    result.flags |= this.flags & 8;
    return result;
  }
  localPosFromDOM(node, offset) {
    return node == this.dom ? offset : offset ? this.text.length : 0;
  }
  domAtPos(pos) {
    return new DOMPos(this.dom, pos);
  }
  domBoundsAround(_from, _to, offset) {
    return { from: offset, to: offset + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling };
  }
  coordsAt(pos, side) {
    return textCoords(this.dom, pos, side);
  }
};
var MarkView = class _MarkView extends ContentView {
  constructor(mark, children = [], length = 0) {
    super();
    this.mark = mark;
    this.children = children;
    this.length = length;
    for (let ch2 of children)
      ch2.setParent(this);
  }
  setAttrs(dom) {
    clearAttributes(dom);
    if (this.mark.class)
      dom.className = this.mark.class;
    if (this.mark.attrs)
      for (let name2 in this.mark.attrs)
        dom.setAttribute(name2, this.mark.attrs[name2]);
    return dom;
  }
  canReuseDOM(other) {
    return super.canReuseDOM(other) && !((this.flags | other.flags) & 8);
  }
  reuseDOM(node) {
    if (node.nodeName == this.mark.tagName.toUpperCase()) {
      this.setDOM(node);
      this.flags |= 4 | 2;
    }
  }
  sync(view, track) {
    if (!this.dom)
      this.setDOM(this.setAttrs(document.createElement(this.mark.tagName)));
    else if (this.flags & 4)
      this.setAttrs(this.dom);
    super.sync(view, track);
  }
  merge(from, to3, source, _hasStart, openStart, openEnd) {
    if (source && (!(source instanceof _MarkView && source.mark.eq(this.mark)) || from && openStart <= 0 || to3 < this.length && openEnd <= 0))
      return false;
    mergeChildrenInto(this, from, to3, source ? source.children.slice() : [], openStart - 1, openEnd - 1);
    this.markDirty();
    return true;
  }
  split(from) {
    let result = [], off = 0, detachFrom = -1, i2 = 0;
    for (let elt of this.children) {
      let end = off + elt.length;
      if (end > from)
        result.push(off < from ? elt.split(from - off) : elt);
      if (detachFrom < 0 && off >= from)
        detachFrom = i2;
      off = end;
      i2++;
    }
    let length = this.length - from;
    this.length = from;
    if (detachFrom > -1) {
      this.children.length = detachFrom;
      this.markDirty();
    }
    return new _MarkView(this.mark, result, length);
  }
  domAtPos(pos) {
    return inlineDOMAtPos(this, pos);
  }
  coordsAt(pos, side) {
    return coordsInChildren(this, pos, side);
  }
};
function textCoords(text, pos, side) {
  let length = text.nodeValue.length;
  if (pos > length)
    pos = length;
  let from = pos, to3 = pos, flatten2 = 0;
  if (pos == 0 && side < 0 || pos == length && side >= 0) {
    if (!(browser.chrome || browser.gecko)) {
      if (pos) {
        from--;
        flatten2 = 1;
      } else if (to3 < length) {
        to3++;
        flatten2 = -1;
      }
    }
  } else {
    if (side < 0)
      from--;
    else if (to3 < length)
      to3++;
  }
  let rects = textRange(text, from, to3).getClientRects();
  if (!rects.length)
    return null;
  let rect = rects[(flatten2 ? flatten2 < 0 : side >= 0) ? 0 : rects.length - 1];
  if (browser.safari && !flatten2 && rect.width == 0)
    rect = Array.prototype.find.call(rects, (r2) => r2.width) || rect;
  return flatten2 ? flattenRect(rect, flatten2 < 0) : rect || null;
}
var WidgetView = class _WidgetView extends ContentView {
  static create(widget, length, side) {
    return new _WidgetView(widget, length, side);
  }
  constructor(widget, length, side) {
    super();
    this.widget = widget;
    this.length = length;
    this.side = side;
    this.prevWidget = null;
  }
  split(from) {
    let result = _WidgetView.create(this.widget, this.length - from, this.side);
    this.length -= from;
    return result;
  }
  sync(view) {
    if (!this.dom || !this.widget.updateDOM(this.dom, view)) {
      if (this.dom && this.prevWidget)
        this.prevWidget.destroy(this.dom);
      this.prevWidget = null;
      this.setDOM(this.widget.toDOM(view));
      if (!this.widget.editable)
        this.dom.contentEditable = "false";
    }
  }
  getSide() {
    return this.side;
  }
  merge(from, to3, source, hasStart, openStart, openEnd) {
    if (source && (!(source instanceof _WidgetView) || !this.widget.compare(source.widget) || from > 0 && openStart <= 0 || to3 < this.length && openEnd <= 0))
      return false;
    this.length = from + (source ? source.length : 0) + (this.length - to3);
    return true;
  }
  become(other) {
    if (other instanceof _WidgetView && other.side == this.side && this.widget.constructor == other.widget.constructor) {
      if (!this.widget.compare(other.widget))
        this.markDirty(true);
      if (this.dom && !this.prevWidget)
        this.prevWidget = this.widget;
      this.widget = other.widget;
      this.length = other.length;
      return true;
    }
    return false;
  }
  ignoreMutation() {
    return true;
  }
  ignoreEvent(event) {
    return this.widget.ignoreEvent(event);
  }
  get overrideDOMText() {
    if (this.length == 0)
      return Text.empty;
    let top2 = this;
    while (top2.parent)
      top2 = top2.parent;
    let { view } = top2, text = view && view.state.doc, start = this.posAtStart;
    return text ? text.slice(start, start + this.length) : Text.empty;
  }
  domAtPos(pos) {
    return (this.length ? pos == 0 : this.side > 0) ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(pos, side) {
    let custom = this.widget.coordsAt(this.dom, pos, side);
    if (custom)
      return custom;
    let rects = this.dom.getClientRects(), rect = null;
    if (!rects.length)
      return null;
    let fromBack = this.side ? this.side < 0 : pos > 0;
    for (let i2 = fromBack ? rects.length - 1 : 0; ; i2 += fromBack ? -1 : 1) {
      rect = rects[i2];
      if (pos > 0 ? i2 == 0 : i2 == rects.length - 1 || rect.top < rect.bottom)
        break;
    }
    return flattenRect(rect, !fromBack);
  }
  get isEditable() {
    return false;
  }
  get isWidget() {
    return true;
  }
  get isHidden() {
    return this.widget.isHidden;
  }
  destroy() {
    super.destroy();
    if (this.dom)
      this.widget.destroy(this.dom);
  }
};
var WidgetBufferView = class _WidgetBufferView extends ContentView {
  constructor(side) {
    super();
    this.side = side;
  }
  get length() {
    return 0;
  }
  merge() {
    return false;
  }
  become(other) {
    return other instanceof _WidgetBufferView && other.side == this.side;
  }
  split() {
    return new _WidgetBufferView(this.side);
  }
  sync() {
    if (!this.dom) {
      let dom = document.createElement("img");
      dom.className = "cm-widgetBuffer";
      dom.setAttribute("aria-hidden", "true");
      this.setDOM(dom);
    }
  }
  getSide() {
    return this.side;
  }
  domAtPos(pos) {
    return this.side > 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom);
  }
  localPosFromDOM() {
    return 0;
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(pos) {
    return this.dom.getBoundingClientRect();
  }
  get overrideDOMText() {
    return Text.empty;
  }
  get isHidden() {
    return true;
  }
};
TextView.prototype.children = WidgetView.prototype.children = WidgetBufferView.prototype.children = noChildren;
function inlineDOMAtPos(parent, pos) {
  let dom = parent.dom, { children } = parent, i2 = 0;
  for (let off = 0; i2 < children.length; i2++) {
    let child = children[i2], end = off + child.length;
    if (end == off && child.getSide() <= 0)
      continue;
    if (pos > off && pos < end && child.dom.parentNode == dom)
      return child.domAtPos(pos - off);
    if (pos <= off)
      break;
    off = end;
  }
  for (let j = i2; j > 0; j--) {
    let prev = children[j - 1];
    if (prev.dom.parentNode == dom)
      return prev.domAtPos(prev.length);
  }
  for (let j = i2; j < children.length; j++) {
    let next = children[j];
    if (next.dom.parentNode == dom)
      return next.domAtPos(0);
  }
  return new DOMPos(dom, 0);
}
function joinInlineInto(parent, view, open) {
  let last2, { children } = parent;
  if (open > 0 && view instanceof MarkView && children.length && (last2 = children[children.length - 1]) instanceof MarkView && last2.mark.eq(view.mark)) {
    joinInlineInto(last2, view.children[0], open - 1);
  } else {
    children.push(view);
    view.setParent(parent);
  }
  parent.length += view.length;
}
function coordsInChildren(view, pos, side) {
  let before = null, beforePos = -1, after = null, afterPos = -1;
  function scan(view2, pos2) {
    for (let i2 = 0, off = 0; i2 < view2.children.length && off <= pos2; i2++) {
      let child = view2.children[i2], end = off + child.length;
      if (end >= pos2) {
        if (child.children.length) {
          scan(child, pos2 - off);
        } else if ((!after || after.isHidden && side > 0) && (end > pos2 || off == end && child.getSide() > 0)) {
          after = child;
          afterPos = pos2 - off;
        } else if (off < pos2 || off == end && child.getSide() < 0 && !child.isHidden) {
          before = child;
          beforePos = pos2 - off;
        }
      }
      off = end;
    }
  }
  scan(view, pos);
  let target = (side < 0 ? before : after) || before || after;
  if (target)
    return target.coordsAt(Math.max(0, target == before ? beforePos : afterPos), side);
  return fallbackRect(view);
}
function fallbackRect(view) {
  let last2 = view.dom.lastChild;
  if (!last2)
    return view.dom.getBoundingClientRect();
  let rects = clientRectsFor(last2);
  return rects[rects.length - 1] || null;
}
function combineAttrs(source, target) {
  for (let name2 in source) {
    if (name2 == "class" && target.class)
      target.class += " " + source.class;
    else if (name2 == "style" && target.style)
      target.style += ";" + source.style;
    else
      target[name2] = source[name2];
  }
  return target;
}
var noAttrs = /* @__PURE__ */ Object.create(null);
function attrsEq(a2, b2, ignore) {
  if (a2 == b2)
    return true;
  if (!a2)
    a2 = noAttrs;
  if (!b2)
    b2 = noAttrs;
  let keysA = Object.keys(a2), keysB = Object.keys(b2);
  if (keysA.length - (ignore && keysA.indexOf(ignore) > -1 ? 1 : 0) != keysB.length - (ignore && keysB.indexOf(ignore) > -1 ? 1 : 0))
    return false;
  for (let key of keysA) {
    if (key != ignore && (keysB.indexOf(key) == -1 || a2[key] !== b2[key]))
      return false;
  }
  return true;
}
function updateAttrs(dom, prev, attrs) {
  let changed = false;
  if (prev) {
    for (let name2 in prev)
      if (!(attrs && name2 in attrs)) {
        changed = true;
        if (name2 == "style")
          dom.style.cssText = "";
        else
          dom.removeAttribute(name2);
      }
  }
  if (attrs) {
    for (let name2 in attrs)
      if (!(prev && prev[name2] == attrs[name2])) {
        changed = true;
        if (name2 == "style")
          dom.style.cssText = attrs[name2];
        else
          dom.setAttribute(name2, attrs[name2]);
      }
  }
  return changed;
}
function getAttrs(dom) {
  let attrs = /* @__PURE__ */ Object.create(null);
  for (let i2 = 0; i2 < dom.attributes.length; i2++) {
    let attr = dom.attributes[i2];
    attrs[attr.name] = attr.value;
  }
  return attrs;
}
var WidgetType = class {
  /**
  Compare this instance to another instance of the same type.
  (TypeScript can't express this, but only instances of the same
  specific class will be passed to this method.) This is used to
  avoid redrawing widgets when they are replaced by a new
  decoration of the same type. The default implementation just
  returns `false`, which will cause new instances of the widget to
  always be redrawn.
  */
  eq(widget) {
    return false;
  }
  /**
  Update a DOM element created by a widget of the same type (but
  different, non-`eq` content) to reflect this widget. May return
  true to indicate that it could update, false to indicate it
  couldn't (in which case the widget will be redrawn). The default
  implementation just returns false.
  */
  updateDOM(dom, view) {
    return false;
  }
  /**
  @internal
  */
  compare(other) {
    return this == other || this.constructor == other.constructor && this.eq(other);
  }
  /**
  The estimated height this widget will have, to be used when
  estimating the height of content that hasn't been drawn. May
  return -1 to indicate you don't know. The default implementation
  returns -1.
  */
  get estimatedHeight() {
    return -1;
  }
  /**
  For inline widgets that are displayed inline (as opposed to
  `inline-block`) and introduce line breaks (through `<br>` tags
  or textual newlines), this must indicate the amount of line
  breaks they introduce. Defaults to 0.
  */
  get lineBreaks() {
    return 0;
  }
  /**
  Can be used to configure which kinds of events inside the widget
  should be ignored by the editor. The default is to ignore all
  events.
  */
  ignoreEvent(event) {
    return true;
  }
  /**
  Override the way screen coordinates for positions at/in the
  widget are found. `pos` will be the offset into the widget, and
  `side` the side of the position that is being queried—less than
  zero for before, greater than zero for after, and zero for
  directly at that position.
  */
  coordsAt(dom, pos, side) {
    return null;
  }
  /**
  @internal
  */
  get isHidden() {
    return false;
  }
  /**
  @internal
  */
  get editable() {
    return false;
  }
  /**
  This is called when the an instance of the widget is removed
  from the editor view.
  */
  destroy(dom) {
  }
};
var BlockType = function(BlockType2) {
  BlockType2[BlockType2["Text"] = 0] = "Text";
  BlockType2[BlockType2["WidgetBefore"] = 1] = "WidgetBefore";
  BlockType2[BlockType2["WidgetAfter"] = 2] = "WidgetAfter";
  BlockType2[BlockType2["WidgetRange"] = 3] = "WidgetRange";
  return BlockType2;
}(BlockType || (BlockType = {}));
var Decoration = class extends RangeValue {
  constructor(startSide, endSide, widget, spec) {
    super();
    this.startSide = startSide;
    this.endSide = endSide;
    this.widget = widget;
    this.spec = spec;
  }
  /**
  @internal
  */
  get heightRelevant() {
    return false;
  }
  /**
  Create a mark decoration, which influences the styling of the
  content in its range. Nested mark decorations will cause nested
  DOM elements to be created. Nesting order is determined by
  precedence of the [facet](https://codemirror.net/6/docs/ref/#view.EditorView^decorations), with
  the higher-precedence decorations creating the inner DOM nodes.
  Such elements are split on line boundaries and on the boundaries
  of lower-precedence decorations.
  */
  static mark(spec) {
    return new MarkDecoration(spec);
  }
  /**
  Create a widget decoration, which displays a DOM element at the
  given position.
  */
  static widget(spec) {
    let side = Math.max(-1e4, Math.min(1e4, spec.side || 0)), block = !!spec.block;
    side += block && !spec.inlineOrder ? side > 0 ? 3e8 : -4e8 : side > 0 ? 1e8 : -1e8;
    return new PointDecoration(spec, side, side, block, spec.widget || null, false);
  }
  /**
  Create a replace decoration which replaces the given range with
  a widget, or simply hides it.
  */
  static replace(spec) {
    let block = !!spec.block, startSide, endSide;
    if (spec.isBlockGap) {
      startSide = -5e8;
      endSide = 4e8;
    } else {
      let { start, end } = getInclusive(spec, block);
      startSide = (start ? block ? -3e8 : -1 : 5e8) - 1;
      endSide = (end ? block ? 2e8 : 1 : -6e8) + 1;
    }
    return new PointDecoration(spec, startSide, endSide, block, spec.widget || null, true);
  }
  /**
  Create a line decoration, which can add DOM attributes to the
  line starting at the given position.
  */
  static line(spec) {
    return new LineDecoration(spec);
  }
  /**
  Build a [`DecorationSet`](https://codemirror.net/6/docs/ref/#view.DecorationSet) from the given
  decorated range or ranges. If the ranges aren't already sorted,
  pass `true` for `sort` to make the library sort them for you.
  */
  static set(of2, sort = false) {
    return RangeSet.of(of2, sort);
  }
  /**
  @internal
  */
  hasHeight() {
    return this.widget ? this.widget.estimatedHeight > -1 : false;
  }
};
Decoration.none = RangeSet.empty;
var MarkDecoration = class _MarkDecoration extends Decoration {
  constructor(spec) {
    let { start, end } = getInclusive(spec);
    super(start ? -1 : 5e8, end ? 1 : -6e8, null, spec);
    this.tagName = spec.tagName || "span";
    this.class = spec.class || "";
    this.attrs = spec.attributes || null;
  }
  eq(other) {
    var _a4, _b;
    return this == other || other instanceof _MarkDecoration && this.tagName == other.tagName && (this.class || ((_a4 = this.attrs) === null || _a4 === void 0 ? void 0 : _a4.class)) == (other.class || ((_b = other.attrs) === null || _b === void 0 ? void 0 : _b.class)) && attrsEq(this.attrs, other.attrs, "class");
  }
  range(from, to3 = from) {
    if (from >= to3)
      throw new RangeError("Mark decorations may not be empty");
    return super.range(from, to3);
  }
};
MarkDecoration.prototype.point = false;
var LineDecoration = class _LineDecoration extends Decoration {
  constructor(spec) {
    super(-2e8, -2e8, null, spec);
  }
  eq(other) {
    return other instanceof _LineDecoration && this.spec.class == other.spec.class && attrsEq(this.spec.attributes, other.spec.attributes);
  }
  range(from, to3 = from) {
    if (to3 != from)
      throw new RangeError("Line decoration ranges must be zero-length");
    return super.range(from, to3);
  }
};
LineDecoration.prototype.mapMode = MapMode.TrackBefore;
LineDecoration.prototype.point = true;
var PointDecoration = class _PointDecoration extends Decoration {
  constructor(spec, startSide, endSide, block, widget, isReplace) {
    super(startSide, endSide, widget, spec);
    this.block = block;
    this.isReplace = isReplace;
    this.mapMode = !block ? MapMode.TrackDel : startSide <= 0 ? MapMode.TrackBefore : MapMode.TrackAfter;
  }
  // Only relevant when this.block == true
  get type() {
    return this.startSide != this.endSide ? BlockType.WidgetRange : this.startSide <= 0 ? BlockType.WidgetBefore : BlockType.WidgetAfter;
  }
  get heightRelevant() {
    return this.block || !!this.widget && (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0);
  }
  eq(other) {
    return other instanceof _PointDecoration && widgetsEq(this.widget, other.widget) && this.block == other.block && this.startSide == other.startSide && this.endSide == other.endSide;
  }
  range(from, to3 = from) {
    if (this.isReplace && (from > to3 || from == to3 && this.startSide > 0 && this.endSide <= 0))
      throw new RangeError("Invalid range for replacement decoration");
    if (!this.isReplace && to3 != from)
      throw new RangeError("Widget decorations can only have zero-length ranges");
    return super.range(from, to3);
  }
};
PointDecoration.prototype.point = true;
function getInclusive(spec, block = false) {
  let { inclusiveStart: start, inclusiveEnd: end } = spec;
  if (start == null)
    start = spec.inclusive;
  if (end == null)
    end = spec.inclusive;
  return { start: start !== null && start !== void 0 ? start : block, end: end !== null && end !== void 0 ? end : block };
}
function widgetsEq(a2, b2) {
  return a2 == b2 || !!(a2 && b2 && a2.compare(b2));
}
function addRange(from, to3, ranges, margin = 0) {
  let last2 = ranges.length - 1;
  if (last2 >= 0 && ranges[last2] + margin >= from)
    ranges[last2] = Math.max(ranges[last2], to3);
  else
    ranges.push(from, to3);
}
var LineView = class _LineView extends ContentView {
  constructor() {
    super(...arguments);
    this.children = [];
    this.length = 0;
    this.prevAttrs = void 0;
    this.attrs = null;
    this.breakAfter = 0;
  }
  // Consumes source
  merge(from, to3, source, hasStart, openStart, openEnd) {
    if (source) {
      if (!(source instanceof _LineView))
        return false;
      if (!this.dom)
        source.transferDOM(this);
    }
    if (hasStart)
      this.setDeco(source ? source.attrs : null);
    mergeChildrenInto(this, from, to3, source ? source.children.slice() : [], openStart, openEnd);
    return true;
  }
  split(at2) {
    let end = new _LineView();
    end.breakAfter = this.breakAfter;
    if (this.length == 0)
      return end;
    let { i: i2, off } = this.childPos(at2);
    if (off) {
      end.append(this.children[i2].split(off), 0);
      this.children[i2].merge(off, this.children[i2].length, null, false, 0, 0);
      i2++;
    }
    for (let j = i2; j < this.children.length; j++)
      end.append(this.children[j], 0);
    while (i2 > 0 && this.children[i2 - 1].length == 0)
      this.children[--i2].destroy();
    this.children.length = i2;
    this.markDirty();
    this.length = at2;
    return end;
  }
  transferDOM(other) {
    if (!this.dom)
      return;
    this.markDirty();
    other.setDOM(this.dom);
    other.prevAttrs = this.prevAttrs === void 0 ? this.attrs : this.prevAttrs;
    this.prevAttrs = void 0;
    this.dom = null;
  }
  setDeco(attrs) {
    if (!attrsEq(this.attrs, attrs)) {
      if (this.dom) {
        this.prevAttrs = this.attrs;
        this.markDirty();
      }
      this.attrs = attrs;
    }
  }
  append(child, openStart) {
    joinInlineInto(this, child, openStart);
  }
  // Only called when building a line view in ContentBuilder
  addLineDeco(deco) {
    let attrs = deco.spec.attributes, cls = deco.spec.class;
    if (attrs)
      this.attrs = combineAttrs(attrs, this.attrs || {});
    if (cls)
      this.attrs = combineAttrs({ class: cls }, this.attrs || {});
  }
  domAtPos(pos) {
    return inlineDOMAtPos(this, pos);
  }
  reuseDOM(node) {
    if (node.nodeName == "DIV") {
      this.setDOM(node);
      this.flags |= 4 | 2;
    }
  }
  sync(view, track) {
    var _a4;
    if (!this.dom) {
      this.setDOM(document.createElement("div"));
      this.dom.className = "cm-line";
      this.prevAttrs = this.attrs ? null : void 0;
    } else if (this.flags & 4) {
      clearAttributes(this.dom);
      this.dom.className = "cm-line";
      this.prevAttrs = this.attrs ? null : void 0;
    }
    if (this.prevAttrs !== void 0) {
      updateAttrs(this.dom, this.prevAttrs, this.attrs);
      this.dom.classList.add("cm-line");
      this.prevAttrs = void 0;
    }
    super.sync(view, track);
    let last2 = this.dom.lastChild;
    while (last2 && ContentView.get(last2) instanceof MarkView)
      last2 = last2.lastChild;
    if (!last2 || !this.length || last2.nodeName != "BR" && ((_a4 = ContentView.get(last2)) === null || _a4 === void 0 ? void 0 : _a4.isEditable) == false && (!browser.ios || !this.children.some((ch2) => ch2 instanceof TextView))) {
      let hack = document.createElement("BR");
      hack.cmIgnore = true;
      this.dom.appendChild(hack);
    }
  }
  measureTextSize() {
    if (this.children.length == 0 || this.length > 20)
      return null;
    let totalWidth = 0, textHeight;
    for (let child of this.children) {
      if (!(child instanceof TextView) || /[^ -~]/.test(child.text))
        return null;
      let rects = clientRectsFor(child.dom);
      if (rects.length != 1)
        return null;
      totalWidth += rects[0].width;
      textHeight = rects[0].height;
    }
    return !totalWidth ? null : {
      lineHeight: this.dom.getBoundingClientRect().height,
      charWidth: totalWidth / this.length,
      textHeight
    };
  }
  coordsAt(pos, side) {
    let rect = coordsInChildren(this, pos, side);
    if (!this.children.length && rect && this.parent) {
      let { heightOracle } = this.parent.view.viewState, height = rect.bottom - rect.top;
      if (Math.abs(height - heightOracle.lineHeight) < 2 && heightOracle.textHeight < height) {
        let dist2 = (height - heightOracle.textHeight) / 2;
        return { top: rect.top + dist2, bottom: rect.bottom - dist2, left: rect.left, right: rect.left };
      }
    }
    return rect;
  }
  become(other) {
    return other instanceof _LineView && this.children.length == 0 && other.children.length == 0 && attrsEq(this.attrs, other.attrs) && this.breakAfter == other.breakAfter;
  }
  covers() {
    return true;
  }
  static find(docView, pos) {
    for (let i2 = 0, off = 0; i2 < docView.children.length; i2++) {
      let block = docView.children[i2], end = off + block.length;
      if (end >= pos) {
        if (block instanceof _LineView)
          return block;
        if (end > pos)
          break;
      }
      off = end + block.breakAfter;
    }
    return null;
  }
};
var BlockWidgetView = class _BlockWidgetView extends ContentView {
  constructor(widget, length, deco) {
    super();
    this.widget = widget;
    this.length = length;
    this.deco = deco;
    this.breakAfter = 0;
    this.prevWidget = null;
  }
  merge(from, to3, source, _takeDeco, openStart, openEnd) {
    if (source && (!(source instanceof _BlockWidgetView) || !this.widget.compare(source.widget) || from > 0 && openStart <= 0 || to3 < this.length && openEnd <= 0))
      return false;
    this.length = from + (source ? source.length : 0) + (this.length - to3);
    return true;
  }
  domAtPos(pos) {
    return pos == 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);
  }
  split(at2) {
    let len = this.length - at2;
    this.length = at2;
    let end = new _BlockWidgetView(this.widget, len, this.deco);
    end.breakAfter = this.breakAfter;
    return end;
  }
  get children() {
    return noChildren;
  }
  sync(view) {
    if (!this.dom || !this.widget.updateDOM(this.dom, view)) {
      if (this.dom && this.prevWidget)
        this.prevWidget.destroy(this.dom);
      this.prevWidget = null;
      this.setDOM(this.widget.toDOM(view));
      if (!this.widget.editable)
        this.dom.contentEditable = "false";
    }
  }
  get overrideDOMText() {
    return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : Text.empty;
  }
  domBoundsAround() {
    return null;
  }
  become(other) {
    if (other instanceof _BlockWidgetView && other.widget.constructor == this.widget.constructor) {
      if (!other.widget.compare(this.widget))
        this.markDirty(true);
      if (this.dom && !this.prevWidget)
        this.prevWidget = this.widget;
      this.widget = other.widget;
      this.length = other.length;
      this.deco = other.deco;
      this.breakAfter = other.breakAfter;
      return true;
    }
    return false;
  }
  ignoreMutation() {
    return true;
  }
  ignoreEvent(event) {
    return this.widget.ignoreEvent(event);
  }
  get isEditable() {
    return false;
  }
  get isWidget() {
    return true;
  }
  coordsAt(pos, side) {
    let custom = this.widget.coordsAt(this.dom, pos, side);
    if (custom)
      return custom;
    if (this.widget instanceof BlockGapWidget)
      return null;
    return flattenRect(this.dom.getBoundingClientRect(), this.length ? pos == 0 : side <= 0);
  }
  destroy() {
    super.destroy();
    if (this.dom)
      this.widget.destroy(this.dom);
  }
  covers(side) {
    let { startSide, endSide } = this.deco;
    return startSide == endSide ? false : side < 0 ? startSide < 0 : endSide > 0;
  }
};
var BlockGapWidget = class extends WidgetType {
  constructor(height) {
    super();
    this.height = height;
  }
  toDOM() {
    let elt = document.createElement("div");
    elt.className = "cm-gap";
    this.updateDOM(elt);
    return elt;
  }
  eq(other) {
    return other.height == this.height;
  }
  updateDOM(elt) {
    elt.style.height = this.height + "px";
    return true;
  }
  get editable() {
    return true;
  }
  get estimatedHeight() {
    return this.height;
  }
  ignoreEvent() {
    return false;
  }
};
var ContentBuilder = class _ContentBuilder {
  constructor(doc2, pos, end, disallowBlockEffectsFor) {
    this.doc = doc2;
    this.pos = pos;
    this.end = end;
    this.disallowBlockEffectsFor = disallowBlockEffectsFor;
    this.content = [];
    this.curLine = null;
    this.breakAtStart = 0;
    this.pendingBuffer = 0;
    this.bufferMarks = [];
    this.atCursorPos = true;
    this.openStart = -1;
    this.openEnd = -1;
    this.text = "";
    this.textOff = 0;
    this.cursor = doc2.iter();
    this.skip = pos;
  }
  posCovered() {
    if (this.content.length == 0)
      return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
    let last2 = this.content[this.content.length - 1];
    return !(last2.breakAfter || last2 instanceof BlockWidgetView && last2.deco.endSide < 0);
  }
  getLine() {
    if (!this.curLine) {
      this.content.push(this.curLine = new LineView());
      this.atCursorPos = true;
    }
    return this.curLine;
  }
  flushBuffer(active = this.bufferMarks) {
    if (this.pendingBuffer) {
      this.curLine.append(wrapMarks(new WidgetBufferView(-1), active), active.length);
      this.pendingBuffer = 0;
    }
  }
  addBlockWidget(view) {
    this.flushBuffer();
    this.curLine = null;
    this.content.push(view);
  }
  finish(openEnd) {
    if (this.pendingBuffer && openEnd <= this.bufferMarks.length)
      this.flushBuffer();
    else
      this.pendingBuffer = 0;
    if (!this.posCovered() && !(openEnd && this.content.length && this.content[this.content.length - 1] instanceof BlockWidgetView))
      this.getLine();
  }
  buildText(length, active, openStart) {
    while (length > 0) {
      if (this.textOff == this.text.length) {
        let { value, lineBreak, done } = this.cursor.next(this.skip);
        this.skip = 0;
        if (done)
          throw new Error("Ran out of text content when drawing inline views");
        if (lineBreak) {
          if (!this.posCovered())
            this.getLine();
          if (this.content.length)
            this.content[this.content.length - 1].breakAfter = 1;
          else
            this.breakAtStart = 1;
          this.flushBuffer();
          this.curLine = null;
          this.atCursorPos = true;
          length--;
          continue;
        } else {
          this.text = value;
          this.textOff = 0;
        }
      }
      let take = Math.min(
        this.text.length - this.textOff,
        length,
        512
        /* T.Chunk */
      );
      this.flushBuffer(active.slice(active.length - openStart));
      this.getLine().append(wrapMarks(new TextView(this.text.slice(this.textOff, this.textOff + take)), active), openStart);
      this.atCursorPos = true;
      this.textOff += take;
      length -= take;
      openStart = 0;
    }
  }
  span(from, to3, active, openStart) {
    this.buildText(to3 - from, active, openStart);
    this.pos = to3;
    if (this.openStart < 0)
      this.openStart = openStart;
  }
  point(from, to3, deco, active, openStart, index2) {
    if (this.disallowBlockEffectsFor[index2] && deco instanceof PointDecoration) {
      if (deco.block)
        throw new RangeError("Block decorations may not be specified via plugins");
      if (to3 > this.doc.lineAt(this.pos).to)
        throw new RangeError("Decorations that replace line breaks may not be specified via plugins");
    }
    let len = to3 - from;
    if (deco instanceof PointDecoration) {
      if (deco.block) {
        if (deco.startSide > 0 && !this.posCovered())
          this.getLine();
        this.addBlockWidget(new BlockWidgetView(deco.widget || NullWidget.block, len, deco));
      } else {
        let view = WidgetView.create(deco.widget || NullWidget.inline, len, len ? 0 : deco.startSide);
        let cursorBefore = this.atCursorPos && !view.isEditable && openStart <= active.length && (from < to3 || deco.startSide > 0);
        let cursorAfter = !view.isEditable && (from < to3 || openStart > active.length || deco.startSide <= 0);
        let line = this.getLine();
        if (this.pendingBuffer == 2 && !cursorBefore && !view.isEditable)
          this.pendingBuffer = 0;
        this.flushBuffer(active);
        if (cursorBefore) {
          line.append(wrapMarks(new WidgetBufferView(1), active), openStart);
          openStart = active.length + Math.max(0, openStart - active.length);
        }
        line.append(wrapMarks(view, active), openStart);
        this.atCursorPos = cursorAfter;
        this.pendingBuffer = !cursorAfter ? 0 : from < to3 || openStart > active.length ? 1 : 2;
        if (this.pendingBuffer)
          this.bufferMarks = active.slice();
      }
    } else if (this.doc.lineAt(this.pos).from == this.pos) {
      this.getLine().addLineDeco(deco);
    }
    if (len) {
      if (this.textOff + len <= this.text.length) {
        this.textOff += len;
      } else {
        this.skip += len - (this.text.length - this.textOff);
        this.text = "";
        this.textOff = 0;
      }
      this.pos = to3;
    }
    if (this.openStart < 0)
      this.openStart = openStart;
  }
  static build(text, from, to3, decorations2, dynamicDecorationMap) {
    let builder = new _ContentBuilder(text, from, to3, dynamicDecorationMap);
    builder.openEnd = RangeSet.spans(decorations2, from, to3, builder);
    if (builder.openStart < 0)
      builder.openStart = builder.openEnd;
    builder.finish(builder.openEnd);
    return builder;
  }
};
function wrapMarks(view, active) {
  for (let mark of active)
    view = new MarkView(mark, [view], view.length);
  return view;
}
var NullWidget = class extends WidgetType {
  constructor(tag) {
    super();
    this.tag = tag;
  }
  eq(other) {
    return other.tag == this.tag;
  }
  toDOM() {
    return document.createElement(this.tag);
  }
  updateDOM(elt) {
    return elt.nodeName.toLowerCase() == this.tag;
  }
  get isHidden() {
    return true;
  }
};
NullWidget.inline = new NullWidget("span");
NullWidget.block = new NullWidget("div");
var Direction = function(Direction2) {
  Direction2[Direction2["LTR"] = 0] = "LTR";
  Direction2[Direction2["RTL"] = 1] = "RTL";
  return Direction2;
}(Direction || (Direction = {}));
var LTR = Direction.LTR;
var RTL = Direction.RTL;
function dec(str) {
  let result = [];
  for (let i2 = 0; i2 < str.length; i2++)
    result.push(1 << +str[i2]);
  return result;
}
var LowTypes = dec("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008");
var ArabicTypes = dec("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333");
var Brackets = /* @__PURE__ */ Object.create(null);
var BracketStack = [];
for (let p of ["()", "[]", "{}"]) {
  let l = p.charCodeAt(0), r2 = p.charCodeAt(1);
  Brackets[l] = r2;
  Brackets[r2] = -l;
}
function charType(ch2) {
  return ch2 <= 247 ? LowTypes[ch2] : 1424 <= ch2 && ch2 <= 1524 ? 2 : 1536 <= ch2 && ch2 <= 1785 ? ArabicTypes[ch2 - 1536] : 1774 <= ch2 && ch2 <= 2220 ? 4 : 8192 <= ch2 && ch2 <= 8204 ? 256 : 64336 <= ch2 && ch2 <= 65023 ? 4 : 1;
}
var BidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;
var BidiSpan = class {
  /**
  The direction of this span.
  */
  get dir() {
    return this.level % 2 ? RTL : LTR;
  }
  /**
  @internal
  */
  constructor(from, to3, level) {
    this.from = from;
    this.to = to3;
    this.level = level;
  }
  /**
  @internal
  */
  side(end, dir) {
    return this.dir == dir == end ? this.to : this.from;
  }
  /**
  @internal
  */
  forward(forward, dir) {
    return forward == (this.dir == dir);
  }
  /**
  @internal
  */
  static find(order, index2, level, assoc) {
    let maybe = -1;
    for (let i2 = 0; i2 < order.length; i2++) {
      let span = order[i2];
      if (span.from <= index2 && span.to >= index2) {
        if (span.level == level)
          return i2;
        if (maybe < 0 || (assoc != 0 ? assoc < 0 ? span.from < index2 : span.to > index2 : order[maybe].level > span.level))
          maybe = i2;
      }
    }
    if (maybe < 0)
      throw new RangeError("Index out of range");
    return maybe;
  }
};
function isolatesEq(a2, b2) {
  if (a2.length != b2.length)
    return false;
  for (let i2 = 0; i2 < a2.length; i2++) {
    let iA = a2[i2], iB = b2[i2];
    if (iA.from != iB.from || iA.to != iB.to || iA.direction != iB.direction || !isolatesEq(iA.inner, iB.inner))
      return false;
  }
  return true;
}
var types = [];
function computeCharTypes(line, rFrom, rTo, isolates, outerType) {
  for (let iI = 0; iI <= isolates.length; iI++) {
    let from = iI ? isolates[iI - 1].to : rFrom, to3 = iI < isolates.length ? isolates[iI].from : rTo;
    let prevType = iI ? 256 : outerType;
    for (let i2 = from, prev = prevType, prevStrong = prevType; i2 < to3; i2++) {
      let type = charType(line.charCodeAt(i2));
      if (type == 512)
        type = prev;
      else if (type == 8 && prevStrong == 4)
        type = 16;
      types[i2] = type == 4 ? 2 : type;
      if (type & 7)
        prevStrong = type;
      prev = type;
    }
    for (let i2 = from, prev = prevType, prevStrong = prevType; i2 < to3; i2++) {
      let type = types[i2];
      if (type == 128) {
        if (i2 < to3 - 1 && prev == types[i2 + 1] && prev & 24)
          type = types[i2] = prev;
        else
          types[i2] = 256;
      } else if (type == 64) {
        let end = i2 + 1;
        while (end < to3 && types[end] == 64)
          end++;
        let replace3 = i2 && prev == 8 || end < rTo && types[end] == 8 ? prevStrong == 1 ? 1 : 8 : 256;
        for (let j = i2; j < end; j++)
          types[j] = replace3;
        i2 = end - 1;
      } else if (type == 8 && prevStrong == 1) {
        types[i2] = 1;
      }
      prev = type;
      if (type & 7)
        prevStrong = type;
    }
  }
}
function processBracketPairs(line, rFrom, rTo, isolates, outerType) {
  let oppositeType = outerType == 1 ? 2 : 1;
  for (let iI = 0, sI = 0, context = 0; iI <= isolates.length; iI++) {
    let from = iI ? isolates[iI - 1].to : rFrom, to3 = iI < isolates.length ? isolates[iI].from : rTo;
    for (let i2 = from, ch2, br3, type; i2 < to3; i2++) {
      if (br3 = Brackets[ch2 = line.charCodeAt(i2)]) {
        if (br3 < 0) {
          for (let sJ = sI - 3; sJ >= 0; sJ -= 3) {
            if (BracketStack[sJ + 1] == -br3) {
              let flags = BracketStack[sJ + 2];
              let type2 = flags & 2 ? outerType : !(flags & 4) ? 0 : flags & 1 ? oppositeType : outerType;
              if (type2)
                types[i2] = types[BracketStack[sJ]] = type2;
              sI = sJ;
              break;
            }
          }
        } else if (BracketStack.length == 189) {
          break;
        } else {
          BracketStack[sI++] = i2;
          BracketStack[sI++] = ch2;
          BracketStack[sI++] = context;
        }
      } else if ((type = types[i2]) == 2 || type == 1) {
        let embed = type == outerType;
        context = embed ? 0 : 1;
        for (let sJ = sI - 3; sJ >= 0; sJ -= 3) {
          let cur2 = BracketStack[sJ + 2];
          if (cur2 & 2)
            break;
          if (embed) {
            BracketStack[sJ + 2] |= 2;
          } else {
            if (cur2 & 4)
              break;
            BracketStack[sJ + 2] |= 4;
          }
        }
      }
    }
  }
}
function processNeutrals(rFrom, rTo, isolates, outerType) {
  for (let iI = 0, prev = outerType; iI <= isolates.length; iI++) {
    let from = iI ? isolates[iI - 1].to : rFrom, to3 = iI < isolates.length ? isolates[iI].from : rTo;
    for (let i2 = from; i2 < to3; ) {
      let type = types[i2];
      if (type == 256) {
        let end = i2 + 1;
        for (; ; ) {
          if (end == to3) {
            if (iI == isolates.length)
              break;
            end = isolates[iI++].to;
            to3 = iI < isolates.length ? isolates[iI].from : rTo;
          } else if (types[end] == 256) {
            end++;
          } else {
            break;
          }
        }
        let beforeL = prev == 1;
        let afterL = (end < rTo ? types[end] : outerType) == 1;
        let replace3 = beforeL == afterL ? beforeL ? 1 : 2 : outerType;
        for (let j = end, jI = iI, fromJ = jI ? isolates[jI - 1].to : rFrom; j > i2; ) {
          if (j == fromJ) {
            j = isolates[--jI].from;
            fromJ = jI ? isolates[jI - 1].to : rFrom;
          }
          types[--j] = replace3;
        }
        i2 = end;
      } else {
        prev = type;
        i2++;
      }
    }
  }
}
function emitSpans(line, from, to3, level, baseLevel, isolates, order) {
  let ourType = level % 2 ? 2 : 1;
  if (level % 2 == baseLevel % 2) {
    for (let iCh = from, iI = 0; iCh < to3; ) {
      let sameDir = true, isNum = false;
      if (iI == isolates.length || iCh < isolates[iI].from) {
        let next = types[iCh];
        if (next != ourType) {
          sameDir = false;
          isNum = next == 16;
        }
      }
      let recurse = !sameDir && ourType == 1 ? [] : null;
      let localLevel = sameDir ? level : level + 1;
      let iScan = iCh;
      run: for (; ; ) {
        if (iI < isolates.length && iScan == isolates[iI].from) {
          if (isNum)
            break run;
          let iso = isolates[iI];
          if (!sameDir)
            for (let upto = iso.to, jI = iI + 1; ; ) {
              if (upto == to3)
                break run;
              if (jI < isolates.length && isolates[jI].from == upto)
                upto = isolates[jI++].to;
              else if (types[upto] == ourType)
                break run;
              else
                break;
            }
          iI++;
          if (recurse) {
            recurse.push(iso);
          } else {
            if (iso.from > iCh)
              order.push(new BidiSpan(iCh, iso.from, localLevel));
            let dirSwap = iso.direction == LTR != !(localLevel % 2);
            computeSectionOrder(line, dirSwap ? level + 1 : level, baseLevel, iso.inner, iso.from, iso.to, order);
            iCh = iso.to;
          }
          iScan = iso.to;
        } else if (iScan == to3 || (sameDir ? types[iScan] != ourType : types[iScan] == ourType)) {
          break;
        } else {
          iScan++;
        }
      }
      if (recurse)
        emitSpans(line, iCh, iScan, level + 1, baseLevel, recurse, order);
      else if (iCh < iScan)
        order.push(new BidiSpan(iCh, iScan, localLevel));
      iCh = iScan;
    }
  } else {
    for (let iCh = to3, iI = isolates.length; iCh > from; ) {
      let sameDir = true, isNum = false;
      if (!iI || iCh > isolates[iI - 1].to) {
        let next = types[iCh - 1];
        if (next != ourType) {
          sameDir = false;
          isNum = next == 16;
        }
      }
      let recurse = !sameDir && ourType == 1 ? [] : null;
      let localLevel = sameDir ? level : level + 1;
      let iScan = iCh;
      run: for (; ; ) {
        if (iI && iScan == isolates[iI - 1].to) {
          if (isNum)
            break run;
          let iso = isolates[--iI];
          if (!sameDir)
            for (let upto = iso.from, jI = iI; ; ) {
              if (upto == from)
                break run;
              if (jI && isolates[jI - 1].to == upto)
                upto = isolates[--jI].from;
              else if (types[upto - 1] == ourType)
                break run;
              else
                break;
            }
          if (recurse) {
            recurse.push(iso);
          } else {
            if (iso.to < iCh)
              order.push(new BidiSpan(iso.to, iCh, localLevel));
            let dirSwap = iso.direction == LTR != !(localLevel % 2);
            computeSectionOrder(line, dirSwap ? level + 1 : level, baseLevel, iso.inner, iso.from, iso.to, order);
            iCh = iso.from;
          }
          iScan = iso.from;
        } else if (iScan == from || (sameDir ? types[iScan - 1] != ourType : types[iScan - 1] == ourType)) {
          break;
        } else {
          iScan--;
        }
      }
      if (recurse)
        emitSpans(line, iScan, iCh, level + 1, baseLevel, recurse, order);
      else if (iScan < iCh)
        order.push(new BidiSpan(iScan, iCh, localLevel));
      iCh = iScan;
    }
  }
}
function computeSectionOrder(line, level, baseLevel, isolates, from, to3, order) {
  let outerType = level % 2 ? 2 : 1;
  computeCharTypes(line, from, to3, isolates, outerType);
  processBracketPairs(line, from, to3, isolates, outerType);
  processNeutrals(from, to3, isolates, outerType);
  emitSpans(line, from, to3, level, baseLevel, isolates, order);
}
function computeOrder(line, direction, isolates) {
  if (!line)
    return [new BidiSpan(0, 0, direction == RTL ? 1 : 0)];
  if (direction == LTR && !isolates.length && !BidiRE.test(line))
    return trivialOrder(line.length);
  if (isolates.length)
    while (line.length > types.length)
      types[types.length] = 256;
  let order = [], level = direction == LTR ? 0 : 1;
  computeSectionOrder(line, level, level, isolates, 0, line.length, order);
  return order;
}
function trivialOrder(length) {
  return [new BidiSpan(0, length, 0)];
}
var movedOver = "";
function moveVisually(line, order, dir, start, forward) {
  var _a4;
  let startIndex = start.head - line.from;
  let spanI = BidiSpan.find(order, startIndex, (_a4 = start.bidiLevel) !== null && _a4 !== void 0 ? _a4 : -1, start.assoc);
  let span = order[spanI], spanEnd = span.side(forward, dir);
  if (startIndex == spanEnd) {
    let nextI = spanI += forward ? 1 : -1;
    if (nextI < 0 || nextI >= order.length)
      return null;
    span = order[spanI = nextI];
    startIndex = span.side(!forward, dir);
    spanEnd = span.side(forward, dir);
  }
  let nextIndex = findClusterBreak(line.text, startIndex, span.forward(forward, dir));
  if (nextIndex < span.from || nextIndex > span.to)
    nextIndex = spanEnd;
  movedOver = line.text.slice(Math.min(startIndex, nextIndex), Math.max(startIndex, nextIndex));
  let nextSpan = spanI == (forward ? order.length - 1 : 0) ? null : order[spanI + (forward ? 1 : -1)];
  if (nextSpan && nextIndex == spanEnd && nextSpan.level + (forward ? 0 : 1) < span.level)
    return EditorSelection.cursor(nextSpan.side(!forward, dir) + line.from, nextSpan.forward(forward, dir) ? 1 : -1, nextSpan.level);
  return EditorSelection.cursor(nextIndex + line.from, span.forward(forward, dir) ? -1 : 1, span.level);
}
function autoDirection(text, from, to3) {
  for (let i2 = from; i2 < to3; i2++) {
    let type = charType(text.charCodeAt(i2));
    if (type == 1)
      return LTR;
    if (type == 2 || type == 4)
      return RTL;
  }
  return LTR;
}
var clickAddsSelectionRange = Facet.define();
var dragMovesSelection$1 = Facet.define();
var mouseSelectionStyle = Facet.define();
var exceptionSink = Facet.define();
var updateListener = Facet.define();
var inputHandler = Facet.define();
var focusChangeEffect = Facet.define();
var clipboardInputFilter = Facet.define();
var clipboardOutputFilter = Facet.define();
var perLineTextDirection = Facet.define({
  combine: (values) => values.some((x) => x)
});
var nativeSelectionHidden = Facet.define({
  combine: (values) => values.some((x) => x)
});
var scrollHandler = Facet.define();
var ScrollTarget = class _ScrollTarget {
  constructor(range, y = "nearest", x = "nearest", yMargin = 5, xMargin = 5, isSnapshot = false) {
    this.range = range;
    this.y = y;
    this.x = x;
    this.yMargin = yMargin;
    this.xMargin = xMargin;
    this.isSnapshot = isSnapshot;
  }
  map(changes) {
    return changes.empty ? this : new _ScrollTarget(this.range.map(changes), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
  clip(state) {
    return this.range.to <= state.doc.length ? this : new _ScrollTarget(EditorSelection.cursor(state.doc.length), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
};
var scrollIntoView = StateEffect.define({ map: (t3, ch2) => t3.map(ch2) });
var setEditContextFormatting = StateEffect.define();
function logException(state, exception, context) {
  let handler = state.facet(exceptionSink);
  if (handler.length)
    handler[0](exception);
  else if (window.onerror)
    window.onerror(String(exception), context, void 0, void 0, exception);
  else if (context)
    console.error(context + ":", exception);
  else
    console.error(exception);
}
var editable = Facet.define({ combine: (values) => values.length ? values[0] : true });
var nextPluginID = 0;
var viewPlugin = Facet.define();
var ViewPlugin = class _ViewPlugin {
  constructor(id2, create, domEventHandlers, domEventObservers, buildExtensions) {
    this.id = id2;
    this.create = create;
    this.domEventHandlers = domEventHandlers;
    this.domEventObservers = domEventObservers;
    this.extension = buildExtensions(this);
  }
  /**
  Define a plugin from a constructor function that creates the
  plugin's value, given an editor view.
  */
  static define(create, spec) {
    const { eventHandlers, eventObservers, provide, decorations: deco } = spec || {};
    return new _ViewPlugin(nextPluginID++, create, eventHandlers, eventObservers, (plugin3) => {
      let ext = [viewPlugin.of(plugin3)];
      if (deco)
        ext.push(decorations.of((view) => {
          let pluginInst = view.plugin(plugin3);
          return pluginInst ? deco(pluginInst) : Decoration.none;
        }));
      if (provide)
        ext.push(provide(plugin3));
      return ext;
    });
  }
  /**
  Create a plugin for a class whose constructor takes a single
  editor view as argument.
  */
  static fromClass(cls, spec) {
    return _ViewPlugin.define((view) => new cls(view), spec);
  }
};
var PluginInstance = class {
  constructor(spec) {
    this.spec = spec;
    this.mustUpdate = null;
    this.value = null;
  }
  update(view) {
    if (!this.value) {
      if (this.spec) {
        try {
          this.value = this.spec.create(view);
        } catch (e2) {
          logException(view.state, e2, "CodeMirror plugin crashed");
          this.deactivate();
        }
      }
    } else if (this.mustUpdate) {
      let update = this.mustUpdate;
      this.mustUpdate = null;
      if (this.value.update) {
        try {
          this.value.update(update);
        } catch (e2) {
          logException(update.state, e2, "CodeMirror plugin crashed");
          if (this.value.destroy)
            try {
              this.value.destroy();
            } catch (_2) {
            }
          this.deactivate();
        }
      }
    }
    return this;
  }
  destroy(view) {
    var _a4;
    if ((_a4 = this.value) === null || _a4 === void 0 ? void 0 : _a4.destroy) {
      try {
        this.value.destroy();
      } catch (e2) {
        logException(view.state, e2, "CodeMirror plugin crashed");
      }
    }
  }
  deactivate() {
    this.spec = this.value = null;
  }
};
var editorAttributes = Facet.define();
var contentAttributes = Facet.define();
var decorations = Facet.define();
var outerDecorations = Facet.define();
var atomicRanges = Facet.define();
var bidiIsolatedRanges = Facet.define();
function getIsolatedRanges(view, line) {
  let isolates = view.state.facet(bidiIsolatedRanges);
  if (!isolates.length)
    return isolates;
  let sets = isolates.map((i2) => i2 instanceof Function ? i2(view) : i2);
  let result = [];
  RangeSet.spans(sets, line.from, line.to, {
    point() {
    },
    span(fromDoc, toDoc, active, open) {
      let from = fromDoc - line.from, to3 = toDoc - line.from;
      let level = result;
      for (let i2 = active.length - 1; i2 >= 0; i2--, open--) {
        let direction = active[i2].spec.bidiIsolate, update;
        if (direction == null)
          direction = autoDirection(line.text, from, to3);
        if (open > 0 && level.length && (update = level[level.length - 1]).to == from && update.direction == direction) {
          update.to = to3;
          level = update.inner;
        } else {
          let add3 = { from, to: to3, direction, inner: [] };
          level.push(add3);
          level = add3.inner;
        }
      }
    }
  });
  return result;
}
var scrollMargins = Facet.define();
function getScrollMargins(view) {
  let left = 0, right = 0, top2 = 0, bottom = 0;
  for (let source of view.state.facet(scrollMargins)) {
    let m3 = source(view);
    if (m3) {
      if (m3.left != null)
        left = Math.max(left, m3.left);
      if (m3.right != null)
        right = Math.max(right, m3.right);
      if (m3.top != null)
        top2 = Math.max(top2, m3.top);
      if (m3.bottom != null)
        bottom = Math.max(bottom, m3.bottom);
    }
  }
  return { left, right, top: top2, bottom };
}
var styleModule = Facet.define();
var ChangedRange = class _ChangedRange {
  constructor(fromA, toA, fromB, toB) {
    this.fromA = fromA;
    this.toA = toA;
    this.fromB = fromB;
    this.toB = toB;
  }
  join(other) {
    return new _ChangedRange(Math.min(this.fromA, other.fromA), Math.max(this.toA, other.toA), Math.min(this.fromB, other.fromB), Math.max(this.toB, other.toB));
  }
  addToSet(set) {
    let i2 = set.length, me2 = this;
    for (; i2 > 0; i2--) {
      let range = set[i2 - 1];
      if (range.fromA > me2.toA)
        continue;
      if (range.toA < me2.fromA)
        break;
      me2 = me2.join(range);
      set.splice(i2 - 1, 1);
    }
    set.splice(i2, 0, me2);
    return set;
  }
  static extendWithRanges(diff, ranges) {
    if (ranges.length == 0)
      return diff;
    let result = [];
    for (let dI = 0, rI = 0, posA = 0, posB = 0; ; dI++) {
      let next = dI == diff.length ? null : diff[dI], off = posA - posB;
      let end = next ? next.fromB : 1e9;
      while (rI < ranges.length && ranges[rI] < end) {
        let from = ranges[rI], to3 = ranges[rI + 1];
        let fromB = Math.max(posB, from), toB = Math.min(end, to3);
        if (fromB <= toB)
          new _ChangedRange(fromB + off, toB + off, fromB, toB).addToSet(result);
        if (to3 > end)
          break;
        else
          rI += 2;
      }
      if (!next)
        return result;
      new _ChangedRange(next.fromA, next.toA, next.fromB, next.toB).addToSet(result);
      posA = next.toA;
      posB = next.toB;
    }
  }
};
var ViewUpdate = class _ViewUpdate {
  constructor(view, state, transactions) {
    this.view = view;
    this.state = state;
    this.transactions = transactions;
    this.flags = 0;
    this.startState = view.state;
    this.changes = ChangeSet.empty(this.startState.doc.length);
    for (let tr3 of transactions)
      this.changes = this.changes.compose(tr3.changes);
    let changedRanges = [];
    this.changes.iterChangedRanges((fromA, toA, fromB, toB) => changedRanges.push(new ChangedRange(fromA, toA, fromB, toB)));
    this.changedRanges = changedRanges;
  }
  /**
  @internal
  */
  static create(view, state, transactions) {
    return new _ViewUpdate(view, state, transactions);
  }
  /**
  Tells you whether the [viewport](https://codemirror.net/6/docs/ref/#view.EditorView.viewport) or
  [visible ranges](https://codemirror.net/6/docs/ref/#view.EditorView.visibleRanges) changed in this
  update.
  */
  get viewportChanged() {
    return (this.flags & 4) > 0;
  }
  /**
  Indicates whether the height of a block element in the editor
  changed in this update.
  */
  get heightChanged() {
    return (this.flags & 2) > 0;
  }
  /**
  Returns true when the document was modified or the size of the
  editor, or elements within the editor, changed.
  */
  get geometryChanged() {
    return this.docChanged || (this.flags & (8 | 2)) > 0;
  }
  /**
  True when this update indicates a focus change.
  */
  get focusChanged() {
    return (this.flags & 1) > 0;
  }
  /**
  Whether the document changed in this update.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Whether the selection was explicitly set in this update.
  */
  get selectionSet() {
    return this.transactions.some((tr3) => tr3.selection);
  }
  /**
  @internal
  */
  get empty() {
    return this.flags == 0 && this.transactions.length == 0;
  }
};
var DocView = class extends ContentView {
  get length() {
    return this.view.state.doc.length;
  }
  constructor(view) {
    super();
    this.view = view;
    this.decorations = [];
    this.dynamicDecorationMap = [false];
    this.domChanged = null;
    this.hasComposition = null;
    this.markedForComposition = /* @__PURE__ */ new Set();
    this.editContextFormatting = Decoration.none;
    this.lastCompositionAfterCursor = false;
    this.minWidth = 0;
    this.minWidthFrom = 0;
    this.minWidthTo = 0;
    this.impreciseAnchor = null;
    this.impreciseHead = null;
    this.forceSelection = false;
    this.lastUpdate = Date.now();
    this.setDOM(view.contentDOM);
    this.children = [new LineView()];
    this.children[0].setParent(this);
    this.updateDeco();
    this.updateInner([new ChangedRange(0, 0, 0, view.state.doc.length)], 0, null);
  }
  // Update the document view to a given state.
  update(update) {
    var _a4;
    let changedRanges = update.changedRanges;
    if (this.minWidth > 0 && changedRanges.length) {
      if (!changedRanges.every(({ fromA, toA }) => toA < this.minWidthFrom || fromA > this.minWidthTo)) {
        this.minWidth = this.minWidthFrom = this.minWidthTo = 0;
      } else {
        this.minWidthFrom = update.changes.mapPos(this.minWidthFrom, 1);
        this.minWidthTo = update.changes.mapPos(this.minWidthTo, 1);
      }
    }
    this.updateEditContextFormatting(update);
    let readCompositionAt = -1;
    if (this.view.inputState.composing >= 0 && !this.view.observer.editContext) {
      if ((_a4 = this.domChanged) === null || _a4 === void 0 ? void 0 : _a4.newSel)
        readCompositionAt = this.domChanged.newSel.head;
      else if (!touchesComposition(update.changes, this.hasComposition) && !update.selectionSet)
        readCompositionAt = update.state.selection.main.head;
    }
    let composition = readCompositionAt > -1 ? findCompositionRange(this.view, update.changes, readCompositionAt) : null;
    this.domChanged = null;
    if (this.hasComposition) {
      this.markedForComposition.clear();
      let { from, to: to3 } = this.hasComposition;
      changedRanges = new ChangedRange(from, to3, update.changes.mapPos(from, -1), update.changes.mapPos(to3, 1)).addToSet(changedRanges.slice());
    }
    this.hasComposition = composition ? { from: composition.range.fromB, to: composition.range.toB } : null;
    if ((browser.ie || browser.chrome) && !composition && update && update.state.doc.lines != update.startState.doc.lines)
      this.forceSelection = true;
    let prevDeco = this.decorations, deco = this.updateDeco();
    let decoDiff = findChangedDeco(prevDeco, deco, update.changes);
    changedRanges = ChangedRange.extendWithRanges(changedRanges, decoDiff);
    if (!(this.flags & 7) && changedRanges.length == 0) {
      return false;
    } else {
      this.updateInner(changedRanges, update.startState.doc.length, composition);
      if (update.transactions.length)
        this.lastUpdate = Date.now();
      return true;
    }
  }
  // Used by update and the constructor do perform the actual DOM
  // update
  updateInner(changes, oldLength, composition) {
    this.view.viewState.mustMeasureContent = true;
    this.updateChildren(changes, oldLength, composition);
    let { observer } = this.view;
    observer.ignore(() => {
      this.dom.style.height = this.view.viewState.contentHeight / this.view.scaleY + "px";
      this.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "";
      let track = browser.chrome || browser.ios ? { node: observer.selectionRange.focusNode, written: false } : void 0;
      this.sync(this.view, track);
      this.flags &= ~7;
      if (track && (track.written || observer.selectionRange.focusNode != track.node))
        this.forceSelection = true;
      this.dom.style.height = "";
    });
    this.markedForComposition.forEach(
      (cView) => cView.flags &= ~8
      /* ViewFlag.Composition */
    );
    let gaps = [];
    if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length) {
      for (let child of this.children)
        if (child instanceof BlockWidgetView && child.widget instanceof BlockGapWidget)
          gaps.push(child.dom);
    }
    observer.updateGaps(gaps);
  }
  updateChildren(changes, oldLength, composition) {
    let ranges = composition ? composition.range.addToSet(changes.slice()) : changes;
    let cursor = this.childCursor(oldLength);
    for (let i2 = ranges.length - 1; ; i2--) {
      let next = i2 >= 0 ? ranges[i2] : null;
      if (!next)
        break;
      let { fromA, toA, fromB, toB } = next, content2, breakAtStart, openStart, openEnd;
      if (composition && composition.range.fromB < toB && composition.range.toB > fromB) {
        let before = ContentBuilder.build(this.view.state.doc, fromB, composition.range.fromB, this.decorations, this.dynamicDecorationMap);
        let after = ContentBuilder.build(this.view.state.doc, composition.range.toB, toB, this.decorations, this.dynamicDecorationMap);
        breakAtStart = before.breakAtStart;
        openStart = before.openStart;
        openEnd = after.openEnd;
        let compLine = this.compositionView(composition);
        if (after.breakAtStart) {
          compLine.breakAfter = 1;
        } else if (after.content.length && compLine.merge(compLine.length, compLine.length, after.content[0], false, after.openStart, 0)) {
          compLine.breakAfter = after.content[0].breakAfter;
          after.content.shift();
        }
        if (before.content.length && compLine.merge(0, 0, before.content[before.content.length - 1], true, 0, before.openEnd)) {
          before.content.pop();
        }
        content2 = before.content.concat(compLine).concat(after.content);
      } else {
        ({ content: content2, breakAtStart, openStart, openEnd } = ContentBuilder.build(this.view.state.doc, fromB, toB, this.decorations, this.dynamicDecorationMap));
      }
      let { i: toI, off: toOff } = cursor.findPos(toA, 1);
      let { i: fromI, off: fromOff } = cursor.findPos(fromA, -1);
      replaceRange(this, fromI, fromOff, toI, toOff, content2, breakAtStart, openStart, openEnd);
    }
    if (composition)
      this.fixCompositionDOM(composition);
  }
  updateEditContextFormatting(update) {
    this.editContextFormatting = this.editContextFormatting.map(update.changes);
    for (let tr3 of update.transactions)
      for (let effect of tr3.effects)
        if (effect.is(setEditContextFormatting)) {
          this.editContextFormatting = effect.value;
        }
  }
  compositionView(composition) {
    let cur2 = new TextView(composition.text.nodeValue);
    cur2.flags |= 8;
    for (let { deco } of composition.marks)
      cur2 = new MarkView(deco, [cur2], cur2.length);
    let line = new LineView();
    line.append(cur2, 0);
    return line;
  }
  fixCompositionDOM(composition) {
    let fix = (dom, cView2) => {
      cView2.flags |= 8 | (cView2.children.some(
        (c) => c.flags & 7
        /* ViewFlag.Dirty */
      ) ? 1 : 0);
      this.markedForComposition.add(cView2);
      let prev = ContentView.get(dom);
      if (prev && prev != cView2)
        prev.dom = null;
      cView2.setDOM(dom);
    };
    let pos = this.childPos(composition.range.fromB, 1);
    let cView = this.children[pos.i];
    fix(composition.line, cView);
    for (let i2 = composition.marks.length - 1; i2 >= -1; i2--) {
      pos = cView.childPos(pos.off, 1);
      cView = cView.children[pos.i];
      fix(i2 >= 0 ? composition.marks[i2].node : composition.text, cView);
    }
  }
  // Sync the DOM selection to this.state.selection
  updateSelection(mustRead = false, fromPointer = false) {
    if (mustRead || !this.view.observer.selectionRange.focusNode)
      this.view.observer.readSelectionRange();
    let activeElt = this.view.root.activeElement, focused = activeElt == this.dom;
    let selectionNotFocus = !focused && hasSelection(this.dom, this.view.observer.selectionRange) && !(activeElt && this.dom.contains(activeElt));
    if (!(focused || fromPointer || selectionNotFocus))
      return;
    let force = this.forceSelection;
    this.forceSelection = false;
    let main = this.view.state.selection.main;
    let anchor = this.moveToLine(this.domAtPos(main.anchor));
    let head = main.empty ? anchor : this.moveToLine(this.domAtPos(main.head));
    if (browser.gecko && main.empty && !this.hasComposition && betweenUneditable(anchor)) {
      let dummy = document.createTextNode("");
      this.view.observer.ignore(() => anchor.node.insertBefore(dummy, anchor.node.childNodes[anchor.offset] || null));
      anchor = head = new DOMPos(dummy, 0);
      force = true;
    }
    let domSel = this.view.observer.selectionRange;
    if (force || !domSel.focusNode || (!isEquivalentPosition(anchor.node, anchor.offset, domSel.anchorNode, domSel.anchorOffset) || !isEquivalentPosition(head.node, head.offset, domSel.focusNode, domSel.focusOffset)) && !this.suppressWidgetCursorChange(domSel, main)) {
      this.view.observer.ignore(() => {
        if (browser.android && browser.chrome && this.dom.contains(domSel.focusNode) && inUneditable(domSel.focusNode, this.dom)) {
          this.dom.blur();
          this.dom.focus({ preventScroll: true });
        }
        let rawSel = getSelection(this.view.root);
        if (!rawSel) ;
        else if (main.empty) {
          if (browser.gecko) {
            let nextTo = nextToUneditable(anchor.node, anchor.offset);
            if (nextTo && nextTo != (1 | 2)) {
              let text = (nextTo == 1 ? textNodeBefore : textNodeAfter)(anchor.node, anchor.offset);
              if (text)
                anchor = new DOMPos(text.node, text.offset);
            }
          }
          rawSel.collapse(anchor.node, anchor.offset);
          if (main.bidiLevel != null && rawSel.caretBidiLevel !== void 0)
            rawSel.caretBidiLevel = main.bidiLevel;
        } else if (rawSel.extend) {
          rawSel.collapse(anchor.node, anchor.offset);
          try {
            rawSel.extend(head.node, head.offset);
          } catch (_2) {
          }
        } else {
          let range = document.createRange();
          if (main.anchor > main.head)
            [anchor, head] = [head, anchor];
          range.setEnd(head.node, head.offset);
          range.setStart(anchor.node, anchor.offset);
          rawSel.removeAllRanges();
          rawSel.addRange(range);
        }
        if (selectionNotFocus && this.view.root.activeElement == this.dom) {
          this.dom.blur();
          if (activeElt)
            activeElt.focus();
        }
      });
      this.view.observer.setSelectionRange(anchor, head);
    }
    this.impreciseAnchor = anchor.precise ? null : new DOMPos(domSel.anchorNode, domSel.anchorOffset);
    this.impreciseHead = head.precise ? null : new DOMPos(domSel.focusNode, domSel.focusOffset);
  }
  // If a zero-length widget is inserted next to the cursor during
  // composition, avoid moving it across it and disrupting the
  // composition.
  suppressWidgetCursorChange(sel, cursor) {
    return this.hasComposition && cursor.empty && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset) && this.posFromDOM(sel.focusNode, sel.focusOffset) == cursor.head;
  }
  enforceCursorAssoc() {
    if (this.hasComposition)
      return;
    let { view } = this, cursor = view.state.selection.main;
    let sel = getSelection(view.root);
    let { anchorNode, anchorOffset } = view.observer.selectionRange;
    if (!sel || !cursor.empty || !cursor.assoc || !sel.modify)
      return;
    let line = LineView.find(this, cursor.head);
    if (!line)
      return;
    let lineStart = line.posAtStart;
    if (cursor.head == lineStart || cursor.head == lineStart + line.length)
      return;
    let before = this.coordsAt(cursor.head, -1), after = this.coordsAt(cursor.head, 1);
    if (!before || !after || before.bottom > after.top)
      return;
    let dom = this.domAtPos(cursor.head + cursor.assoc);
    sel.collapse(dom.node, dom.offset);
    sel.modify("move", cursor.assoc < 0 ? "forward" : "backward", "lineboundary");
    view.observer.readSelectionRange();
    let newRange = view.observer.selectionRange;
    if (view.docView.posFromDOM(newRange.anchorNode, newRange.anchorOffset) != cursor.from)
      sel.collapse(anchorNode, anchorOffset);
  }
  // If a position is in/near a block widget, move it to a nearby text
  // line, since we don't want the cursor inside a block widget.
  moveToLine(pos) {
    let dom = this.dom, newPos;
    if (pos.node != dom)
      return pos;
    for (let i2 = pos.offset; !newPos && i2 < dom.childNodes.length; i2++) {
      let view = ContentView.get(dom.childNodes[i2]);
      if (view instanceof LineView)
        newPos = view.domAtPos(0);
    }
    for (let i2 = pos.offset - 1; !newPos && i2 >= 0; i2--) {
      let view = ContentView.get(dom.childNodes[i2]);
      if (view instanceof LineView)
        newPos = view.domAtPos(view.length);
    }
    return newPos ? new DOMPos(newPos.node, newPos.offset, true) : pos;
  }
  nearest(dom) {
    for (let cur2 = dom; cur2; ) {
      let domView = ContentView.get(cur2);
      if (domView && domView.rootView == this)
        return domView;
      cur2 = cur2.parentNode;
    }
    return null;
  }
  posFromDOM(node, offset) {
    let view = this.nearest(node);
    if (!view)
      throw new RangeError("Trying to find position for a DOM position outside of the document");
    return view.localPosFromDOM(node, offset) + view.posAtStart;
  }
  domAtPos(pos) {
    let { i: i2, off } = this.childCursor().findPos(pos, -1);
    for (; i2 < this.children.length - 1; ) {
      let child = this.children[i2];
      if (off < child.length || child instanceof LineView)
        break;
      i2++;
      off = 0;
    }
    return this.children[i2].domAtPos(off);
  }
  coordsAt(pos, side) {
    let best = null, bestPos = 0;
    for (let off = this.length, i2 = this.children.length - 1; i2 >= 0; i2--) {
      let child = this.children[i2], end = off - child.breakAfter, start = end - child.length;
      if (end < pos)
        break;
      if (start <= pos && (start < pos || child.covers(-1)) && (end > pos || child.covers(1)) && (!best || child instanceof LineView && !(best instanceof LineView && side >= 0))) {
        best = child;
        bestPos = start;
      } else if (best && start == pos && end == pos && child instanceof BlockWidgetView && Math.abs(side) < 2) {
        if (child.deco.startSide < 0)
          break;
        else if (i2)
          best = null;
      }
      off = start;
    }
    return best ? best.coordsAt(pos - bestPos, side) : null;
  }
  coordsForChar(pos) {
    let { i: i2, off } = this.childPos(pos, 1), child = this.children[i2];
    if (!(child instanceof LineView))
      return null;
    while (child.children.length) {
      let { i: i3, off: childOff } = child.childPos(off, 1);
      for (; ; i3++) {
        if (i3 == child.children.length)
          return null;
        if ((child = child.children[i3]).length)
          break;
      }
      off = childOff;
    }
    if (!(child instanceof TextView))
      return null;
    let end = findClusterBreak(child.text, off);
    if (end == off)
      return null;
    let rects = textRange(child.dom, off, end).getClientRects();
    for (let i3 = 0; i3 < rects.length; i3++) {
      let rect = rects[i3];
      if (i3 == rects.length - 1 || rect.top < rect.bottom && rect.left < rect.right)
        return rect;
    }
    return null;
  }
  measureVisibleLineHeights(viewport) {
    let result = [], { from, to: to3 } = viewport;
    let contentWidth = this.view.contentDOM.clientWidth;
    let isWider = contentWidth > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1;
    let widest = -1, ltr = this.view.textDirection == Direction.LTR;
    for (let pos = 0, i2 = 0; i2 < this.children.length; i2++) {
      let child = this.children[i2], end = pos + child.length;
      if (end > to3)
        break;
      if (pos >= from) {
        let childRect = child.dom.getBoundingClientRect();
        result.push(childRect.height);
        if (isWider) {
          let last2 = child.dom.lastChild;
          let rects = last2 ? clientRectsFor(last2) : [];
          if (rects.length) {
            let rect = rects[rects.length - 1];
            let width = ltr ? rect.right - childRect.left : childRect.right - rect.left;
            if (width > widest) {
              widest = width;
              this.minWidth = contentWidth;
              this.minWidthFrom = pos;
              this.minWidthTo = end;
            }
          }
        }
      }
      pos = end + child.breakAfter;
    }
    return result;
  }
  textDirectionAt(pos) {
    let { i: i2 } = this.childPos(pos, 1);
    return getComputedStyle(this.children[i2].dom).direction == "rtl" ? Direction.RTL : Direction.LTR;
  }
  measureTextSize() {
    for (let child of this.children) {
      if (child instanceof LineView) {
        let measure = child.measureTextSize();
        if (measure)
          return measure;
      }
    }
    let dummy = document.createElement("div"), lineHeight, charWidth, textHeight;
    dummy.className = "cm-line";
    dummy.style.width = "99999px";
    dummy.style.position = "absolute";
    dummy.textContent = "abc def ghi jkl mno pqr stu";
    this.view.observer.ignore(() => {
      this.dom.appendChild(dummy);
      let rect = clientRectsFor(dummy.firstChild)[0];
      lineHeight = dummy.getBoundingClientRect().height;
      charWidth = rect ? rect.width / 27 : 7;
      textHeight = rect ? rect.height : lineHeight;
      dummy.remove();
    });
    return { lineHeight, charWidth, textHeight };
  }
  childCursor(pos = this.length) {
    let i2 = this.children.length;
    if (i2)
      pos -= this.children[--i2].length;
    return new ChildCursor(this.children, pos, i2);
  }
  computeBlockGapDeco() {
    let deco = [], vs2 = this.view.viewState;
    for (let pos = 0, i2 = 0; ; i2++) {
      let next = i2 == vs2.viewports.length ? null : vs2.viewports[i2];
      let end = next ? next.from - 1 : this.length;
      if (end > pos) {
        let height = (vs2.lineBlockAt(end).bottom - vs2.lineBlockAt(pos).top) / this.view.scaleY;
        deco.push(Decoration.replace({
          widget: new BlockGapWidget(height),
          block: true,
          inclusive: true,
          isBlockGap: true
        }).range(pos, end));
      }
      if (!next)
        break;
      pos = next.to + 1;
    }
    return Decoration.set(deco);
  }
  updateDeco() {
    let i2 = 1;
    let allDeco = this.view.state.facet(decorations).map((d) => {
      let dynamic = this.dynamicDecorationMap[i2++] = typeof d == "function";
      return dynamic ? d(this.view) : d;
    });
    let dynamicOuter = false, outerDeco = this.view.state.facet(outerDecorations).map((d, i3) => {
      let dynamic = typeof d == "function";
      if (dynamic)
        dynamicOuter = true;
      return dynamic ? d(this.view) : d;
    });
    if (outerDeco.length) {
      this.dynamicDecorationMap[i2++] = dynamicOuter;
      allDeco.push(RangeSet.join(outerDeco));
    }
    this.decorations = [
      this.editContextFormatting,
      ...allDeco,
      this.computeBlockGapDeco(),
      this.view.viewState.lineGapDeco
    ];
    while (i2 < this.decorations.length)
      this.dynamicDecorationMap[i2++] = false;
    return this.decorations;
  }
  scrollIntoView(target) {
    if (target.isSnapshot) {
      let ref2 = this.view.viewState.lineBlockAt(target.range.head);
      this.view.scrollDOM.scrollTop = ref2.top - target.yMargin;
      this.view.scrollDOM.scrollLeft = target.xMargin;
      return;
    }
    for (let handler of this.view.state.facet(scrollHandler)) {
      try {
        if (handler(this.view, target.range, target))
          return true;
      } catch (e2) {
        logException(this.view.state, e2, "scroll handler");
      }
    }
    let { range } = target;
    let rect = this.coordsAt(range.head, range.empty ? range.assoc : range.head > range.anchor ? -1 : 1), other;
    if (!rect)
      return;
    if (!range.empty && (other = this.coordsAt(range.anchor, range.anchor > range.head ? -1 : 1)))
      rect = {
        left: Math.min(rect.left, other.left),
        top: Math.min(rect.top, other.top),
        right: Math.max(rect.right, other.right),
        bottom: Math.max(rect.bottom, other.bottom)
      };
    let margins = getScrollMargins(this.view);
    let targetRect = {
      left: rect.left - margins.left,
      top: rect.top - margins.top,
      right: rect.right + margins.right,
      bottom: rect.bottom + margins.bottom
    };
    let { offsetWidth, offsetHeight } = this.view.scrollDOM;
    scrollRectIntoView(this.view.scrollDOM, targetRect, range.head < range.anchor ? -1 : 1, target.x, target.y, Math.max(Math.min(target.xMargin, offsetWidth), -offsetWidth), Math.max(Math.min(target.yMargin, offsetHeight), -offsetHeight), this.view.textDirection == Direction.LTR);
  }
};
function betweenUneditable(pos) {
  return pos.node.nodeType == 1 && pos.node.firstChild && (pos.offset == 0 || pos.node.childNodes[pos.offset - 1].contentEditable == "false") && (pos.offset == pos.node.childNodes.length || pos.node.childNodes[pos.offset].contentEditable == "false");
}
function findCompositionNode(view, headPos) {
  let sel = view.observer.selectionRange;
  if (!sel.focusNode)
    return null;
  let textBefore = textNodeBefore(sel.focusNode, sel.focusOffset);
  let textAfter = textNodeAfter(sel.focusNode, sel.focusOffset);
  let textNode = textBefore || textAfter;
  if (textAfter && textBefore && textAfter.node != textBefore.node) {
    let descAfter = ContentView.get(textAfter.node);
    if (!descAfter || descAfter instanceof TextView && descAfter.text != textAfter.node.nodeValue) {
      textNode = textAfter;
    } else if (view.docView.lastCompositionAfterCursor) {
      let descBefore = ContentView.get(textBefore.node);
      if (!(!descBefore || descBefore instanceof TextView && descBefore.text != textBefore.node.nodeValue))
        textNode = textAfter;
    }
  }
  view.docView.lastCompositionAfterCursor = textNode != textBefore;
  if (!textNode)
    return null;
  let from = headPos - textNode.offset;
  return { from, to: from + textNode.node.nodeValue.length, node: textNode.node };
}
function findCompositionRange(view, changes, headPos) {
  let found = findCompositionNode(view, headPos);
  if (!found)
    return null;
  let { node: textNode, from, to: to3 } = found, text = textNode.nodeValue;
  if (/[\n\r]/.test(text))
    return null;
  if (view.state.doc.sliceString(found.from, found.to) != text)
    return null;
  let inv = changes.invertedDesc;
  let range = new ChangedRange(inv.mapPos(from), inv.mapPos(to3), from, to3);
  let marks2 = [];
  for (let parent = textNode.parentNode; ; parent = parent.parentNode) {
    let parentView = ContentView.get(parent);
    if (parentView instanceof MarkView)
      marks2.push({ node: parent, deco: parentView.mark });
    else if (parentView instanceof LineView || parent.nodeName == "DIV" && parent.parentNode == view.contentDOM)
      return { range, text: textNode, marks: marks2, line: parent };
    else if (parent != view.contentDOM)
      marks2.push({ node: parent, deco: new MarkDecoration({
        inclusive: true,
        attributes: getAttrs(parent),
        tagName: parent.tagName.toLowerCase()
      }) });
    else
      return null;
  }
}
function nextToUneditable(node, offset) {
  if (node.nodeType != 1)
    return 0;
  return (offset && node.childNodes[offset - 1].contentEditable == "false" ? 1 : 0) | (offset < node.childNodes.length && node.childNodes[offset].contentEditable == "false" ? 2 : 0);
}
var DecorationComparator$1 = class DecorationComparator {
  constructor() {
    this.changes = [];
  }
  compareRange(from, to3) {
    addRange(from, to3, this.changes);
  }
  comparePoint(from, to3) {
    addRange(from, to3, this.changes);
  }
};
function findChangedDeco(a2, b2, diff) {
  let comp = new DecorationComparator$1();
  RangeSet.compare(a2, b2, diff, comp);
  return comp.changes;
}
function inUneditable(node, inside2) {
  for (let cur2 = node; cur2 && cur2 != inside2; cur2 = cur2.assignedSlot || cur2.parentNode) {
    if (cur2.nodeType == 1 && cur2.contentEditable == "false") {
      return true;
    }
  }
  return false;
}
function touchesComposition(changes, composition) {
  let touched = false;
  if (composition)
    changes.iterChangedRanges((from, to3) => {
      if (from < composition.to && to3 > composition.from)
        touched = true;
    });
  return touched;
}
function groupAt(state, pos, bias = 1) {
  let categorize = state.charCategorizer(pos);
  let line = state.doc.lineAt(pos), linePos = pos - line.from;
  if (line.length == 0)
    return EditorSelection.cursor(pos);
  if (linePos == 0)
    bias = 1;
  else if (linePos == line.length)
    bias = -1;
  let from = linePos, to3 = linePos;
  if (bias < 0)
    from = findClusterBreak(line.text, linePos, false);
  else
    to3 = findClusterBreak(line.text, linePos);
  let cat = categorize(line.text.slice(from, to3));
  while (from > 0) {
    let prev = findClusterBreak(line.text, from, false);
    if (categorize(line.text.slice(prev, from)) != cat)
      break;
    from = prev;
  }
  while (to3 < line.length) {
    let next = findClusterBreak(line.text, to3);
    if (categorize(line.text.slice(to3, next)) != cat)
      break;
    to3 = next;
  }
  return EditorSelection.range(from + line.from, to3 + line.from);
}
function getdx(x, rect) {
  return rect.left > x ? rect.left - x : Math.max(0, x - rect.right);
}
function getdy(y, rect) {
  return rect.top > y ? rect.top - y : Math.max(0, y - rect.bottom);
}
function yOverlap(a2, b2) {
  return a2.top < b2.bottom - 1 && a2.bottom > b2.top + 1;
}
function upTop(rect, top2) {
  return top2 < rect.top ? { top: top2, left: rect.left, right: rect.right, bottom: rect.bottom } : rect;
}
function upBot(rect, bottom) {
  return bottom > rect.bottom ? { top: rect.top, left: rect.left, right: rect.right, bottom } : rect;
}
function domPosAtCoords(parent, x, y) {
  let closest, closestRect, closestX, closestY, closestOverlap = false;
  let above, below, aboveRect, belowRect;
  for (let child = parent.firstChild; child; child = child.nextSibling) {
    let rects = clientRectsFor(child);
    for (let i2 = 0; i2 < rects.length; i2++) {
      let rect = rects[i2];
      if (closestRect && yOverlap(closestRect, rect))
        rect = upTop(upBot(rect, closestRect.bottom), closestRect.top);
      let dx2 = getdx(x, rect), dy = getdy(y, rect);
      if (dx2 == 0 && dy == 0)
        return child.nodeType == 3 ? domPosInText(child, x, y) : domPosAtCoords(child, x, y);
      if (!closest || closestY > dy || closestY == dy && closestX > dx2) {
        closest = child;
        closestRect = rect;
        closestX = dx2;
        closestY = dy;
        let side = dy ? y < rect.top ? -1 : 1 : dx2 ? x < rect.left ? -1 : 1 : 0;
        closestOverlap = !side || (side > 0 ? i2 < rects.length - 1 : i2 > 0);
      }
      if (dx2 == 0) {
        if (y > rect.bottom && (!aboveRect || aboveRect.bottom < rect.bottom)) {
          above = child;
          aboveRect = rect;
        } else if (y < rect.top && (!belowRect || belowRect.top > rect.top)) {
          below = child;
          belowRect = rect;
        }
      } else if (aboveRect && yOverlap(aboveRect, rect)) {
        aboveRect = upBot(aboveRect, rect.bottom);
      } else if (belowRect && yOverlap(belowRect, rect)) {
        belowRect = upTop(belowRect, rect.top);
      }
    }
  }
  if (aboveRect && aboveRect.bottom >= y) {
    closest = above;
    closestRect = aboveRect;
  } else if (belowRect && belowRect.top <= y) {
    closest = below;
    closestRect = belowRect;
  }
  if (!closest)
    return { node: parent, offset: 0 };
  let clipX = Math.max(closestRect.left, Math.min(closestRect.right, x));
  if (closest.nodeType == 3)
    return domPosInText(closest, clipX, y);
  if (closestOverlap && closest.contentEditable != "false")
    return domPosAtCoords(closest, clipX, y);
  let offset = Array.prototype.indexOf.call(parent.childNodes, closest) + (x >= (closestRect.left + closestRect.right) / 2 ? 1 : 0);
  return { node: parent, offset };
}
function domPosInText(node, x, y) {
  let len = node.nodeValue.length;
  let closestOffset = -1, closestDY = 1e9, generalSide = 0;
  for (let i2 = 0; i2 < len; i2++) {
    let rects = textRange(node, i2, i2 + 1).getClientRects();
    for (let j = 0; j < rects.length; j++) {
      let rect = rects[j];
      if (rect.top == rect.bottom)
        continue;
      if (!generalSide)
        generalSide = x - rect.left;
      let dy = (rect.top > y ? rect.top - y : y - rect.bottom) - 1;
      if (rect.left - 1 <= x && rect.right + 1 >= x && dy < closestDY) {
        let right = x >= (rect.left + rect.right) / 2, after = right;
        if (browser.chrome || browser.gecko) {
          let rectBefore = textRange(node, i2).getBoundingClientRect();
          if (rectBefore.left == rect.right)
            after = !right;
        }
        if (dy <= 0)
          return { node, offset: i2 + (after ? 1 : 0) };
        closestOffset = i2 + (after ? 1 : 0);
        closestDY = dy;
      }
    }
  }
  return { node, offset: closestOffset > -1 ? closestOffset : generalSide > 0 ? node.nodeValue.length : 0 };
}
function posAtCoords(view, coords, precise, bias = -1) {
  var _a4, _b;
  let content2 = view.contentDOM.getBoundingClientRect(), docTop = content2.top + view.viewState.paddingTop;
  let block, { docHeight } = view.viewState;
  let { x, y } = coords, yOffset = y - docTop;
  if (yOffset < 0)
    return 0;
  if (yOffset > docHeight)
    return view.state.doc.length;
  for (let halfLine = view.viewState.heightOracle.textHeight / 2, bounced = false; ; ) {
    block = view.elementAtHeight(yOffset);
    if (block.type == BlockType.Text)
      break;
    for (; ; ) {
      yOffset = bias > 0 ? block.bottom + halfLine : block.top - halfLine;
      if (yOffset >= 0 && yOffset <= docHeight)
        break;
      if (bounced)
        return precise ? null : 0;
      bounced = true;
      bias = -bias;
    }
  }
  y = docTop + yOffset;
  let lineStart = block.from;
  if (lineStart < view.viewport.from)
    return view.viewport.from == 0 ? 0 : precise ? null : posAtCoordsImprecise(view, content2, block, x, y);
  if (lineStart > view.viewport.to)
    return view.viewport.to == view.state.doc.length ? view.state.doc.length : precise ? null : posAtCoordsImprecise(view, content2, block, x, y);
  let doc2 = view.dom.ownerDocument;
  let root = view.root.elementFromPoint ? view.root : doc2;
  let element = root.elementFromPoint(x, y);
  if (element && !view.contentDOM.contains(element))
    element = null;
  if (!element) {
    x = Math.max(content2.left + 1, Math.min(content2.right - 1, x));
    element = root.elementFromPoint(x, y);
    if (element && !view.contentDOM.contains(element))
      element = null;
  }
  let node, offset = -1;
  if (element && ((_a4 = view.docView.nearest(element)) === null || _a4 === void 0 ? void 0 : _a4.isEditable) != false) {
    if (doc2.caretPositionFromPoint) {
      let pos = doc2.caretPositionFromPoint(x, y);
      if (pos)
        ({ offsetNode: node, offset } = pos);
    } else if (doc2.caretRangeFromPoint) {
      let range = doc2.caretRangeFromPoint(x, y);
      if (range) {
        ({ startContainer: node, startOffset: offset } = range);
        if (!view.contentDOM.contains(node) || browser.safari && isSuspiciousSafariCaretResult(node, offset, x) || browser.chrome && isSuspiciousChromeCaretResult(node, offset, x))
          node = void 0;
      }
    }
    if (node)
      offset = Math.min(maxOffset(node), offset);
  }
  if (!node || !view.docView.dom.contains(node)) {
    let line = LineView.find(view.docView, lineStart);
    if (!line)
      return yOffset > block.top + block.height / 2 ? block.to : block.from;
    ({ node, offset } = domPosAtCoords(line.dom, x, y));
  }
  let nearest = view.docView.nearest(node);
  if (!nearest)
    return null;
  if (nearest.isWidget && ((_b = nearest.dom) === null || _b === void 0 ? void 0 : _b.nodeType) == 1) {
    let rect = nearest.dom.getBoundingClientRect();
    return coords.y < rect.top || coords.y <= rect.bottom && coords.x <= (rect.left + rect.right) / 2 ? nearest.posAtStart : nearest.posAtEnd;
  } else {
    return nearest.localPosFromDOM(node, offset) + nearest.posAtStart;
  }
}
function posAtCoordsImprecise(view, contentRect, block, x, y) {
  let into = Math.round((x - contentRect.left) * view.defaultCharacterWidth);
  if (view.lineWrapping && block.height > view.defaultLineHeight * 1.5) {
    let textHeight = view.viewState.heightOracle.textHeight;
    let line = Math.floor((y - block.top - (view.defaultLineHeight - textHeight) * 0.5) / textHeight);
    into += line * view.viewState.heightOracle.lineLength;
  }
  let content2 = view.state.sliceDoc(block.from, block.to);
  return block.from + findColumn(content2, into, view.state.tabSize);
}
function isSuspiciousSafariCaretResult(node, offset, x) {
  let len;
  if (node.nodeType != 3 || offset != (len = node.nodeValue.length))
    return false;
  for (let next = node.nextSibling; next; next = next.nextSibling)
    if (next.nodeType != 1 || next.nodeName != "BR")
      return false;
  return textRange(node, len - 1, len).getBoundingClientRect().left > x;
}
function isSuspiciousChromeCaretResult(node, offset, x) {
  if (offset != 0)
    return false;
  for (let cur2 = node; ; ) {
    let parent = cur2.parentNode;
    if (!parent || parent.nodeType != 1 || parent.firstChild != cur2)
      return false;
    if (parent.classList.contains("cm-line"))
      break;
    cur2 = parent;
  }
  let rect = node.nodeType == 1 ? node.getBoundingClientRect() : textRange(node, 0, Math.max(node.nodeValue.length, 1)).getBoundingClientRect();
  return x - rect.left > 5;
}
function blockAt(view, pos) {
  let line = view.lineBlockAt(pos);
  if (Array.isArray(line.type))
    for (let l of line.type) {
      if (l.to > pos || l.to == pos && (l.to == line.to || l.type == BlockType.Text))
        return l;
    }
  return line;
}
function moveToLineBoundary(view, start, forward, includeWrap) {
  let line = blockAt(view, start.head);
  let coords = !includeWrap || line.type != BlockType.Text || !(view.lineWrapping || line.widgetLineBreaks) ? null : view.coordsAtPos(start.assoc < 0 && start.head > line.from ? start.head - 1 : start.head);
  if (coords) {
    let editorRect = view.dom.getBoundingClientRect();
    let direction = view.textDirectionAt(line.from);
    let pos = view.posAtCoords({
      x: forward == (direction == Direction.LTR) ? editorRect.right - 1 : editorRect.left + 1,
      y: (coords.top + coords.bottom) / 2
    });
    if (pos != null)
      return EditorSelection.cursor(pos, forward ? -1 : 1);
  }
  return EditorSelection.cursor(forward ? line.to : line.from, forward ? -1 : 1);
}
function moveByChar(view, start, forward, by) {
  let line = view.state.doc.lineAt(start.head), spans = view.bidiSpans(line);
  let direction = view.textDirectionAt(line.from);
  for (let cur2 = start, check = null; ; ) {
    let next = moveVisually(line, spans, direction, cur2, forward), char = movedOver;
    if (!next) {
      if (line.number == (forward ? view.state.doc.lines : 1))
        return cur2;
      char = "\n";
      line = view.state.doc.line(line.number + (forward ? 1 : -1));
      spans = view.bidiSpans(line);
      next = view.visualLineSide(line, !forward);
    }
    if (!check) {
      if (!by)
        return next;
      check = by(char);
    } else if (!check(char)) {
      return cur2;
    }
    cur2 = next;
  }
}
function byGroup(view, pos, start) {
  let categorize = view.state.charCategorizer(pos);
  let cat = categorize(start);
  return (next) => {
    let nextCat = categorize(next);
    if (cat == CharCategory.Space)
      cat = nextCat;
    return cat == nextCat;
  };
}
function moveVertically(view, start, forward, distance) {
  let startPos = start.head, dir = forward ? 1 : -1;
  if (startPos == (forward ? view.state.doc.length : 0))
    return EditorSelection.cursor(startPos, start.assoc);
  let goal = start.goalColumn, startY;
  let rect = view.contentDOM.getBoundingClientRect();
  let startCoords = view.coordsAtPos(startPos, start.assoc || -1), docTop = view.documentTop;
  if (startCoords) {
    if (goal == null)
      goal = startCoords.left - rect.left;
    startY = dir < 0 ? startCoords.top : startCoords.bottom;
  } else {
    let line = view.viewState.lineBlockAt(startPos);
    if (goal == null)
      goal = Math.min(rect.right - rect.left, view.defaultCharacterWidth * (startPos - line.from));
    startY = (dir < 0 ? line.top : line.bottom) + docTop;
  }
  let resolvedGoal = rect.left + goal;
  let dist2 = distance !== null && distance !== void 0 ? distance : view.viewState.heightOracle.textHeight >> 1;
  for (let extra = 0; ; extra += 10) {
    let curY = startY + (dist2 + extra) * dir;
    let pos = posAtCoords(view, { x: resolvedGoal, y: curY }, false, dir);
    if (curY < rect.top || curY > rect.bottom || (dir < 0 ? pos < startPos : pos > startPos)) {
      let charRect = view.docView.coordsForChar(pos);
      let assoc = !charRect || curY < charRect.top ? -1 : 1;
      return EditorSelection.cursor(pos, assoc, void 0, goal);
    }
  }
}
function skipAtomicRanges(atoms, pos, bias) {
  for (; ; ) {
    let moved = 0;
    for (let set of atoms) {
      set.between(pos - 1, pos + 1, (from, to3, value) => {
        if (pos > from && pos < to3) {
          let side = moved || bias || (pos - from < to3 - pos ? -1 : 1);
          pos = side < 0 ? from : to3;
          moved = side;
        }
      });
    }
    if (!moved)
      return pos;
  }
}
function skipAtoms(view, oldPos, pos) {
  let newPos = skipAtomicRanges(view.state.facet(atomicRanges).map((f) => f(view)), pos.from, oldPos.head > pos.from ? -1 : 1);
  return newPos == pos.from ? pos : EditorSelection.cursor(newPos, newPos < pos.from ? 1 : -1);
}
var LineBreakPlaceholder = "￿";
var DOMReader = class {
  constructor(points, state) {
    this.points = points;
    this.text = "";
    this.lineSeparator = state.facet(EditorState.lineSeparator);
  }
  append(text) {
    this.text += text;
  }
  lineBreak() {
    this.text += LineBreakPlaceholder;
  }
  readRange(start, end) {
    if (!start)
      return this;
    let parent = start.parentNode;
    for (let cur2 = start; ; ) {
      this.findPointBefore(parent, cur2);
      let oldLen = this.text.length;
      this.readNode(cur2);
      let next = cur2.nextSibling;
      if (next == end)
        break;
      let view = ContentView.get(cur2), nextView = ContentView.get(next);
      if (view && nextView ? view.breakAfter : (view ? view.breakAfter : isBlockElement(cur2)) || isBlockElement(next) && (cur2.nodeName != "BR" || cur2.cmIgnore) && this.text.length > oldLen)
        this.lineBreak();
      cur2 = next;
    }
    this.findPointBefore(parent, end);
    return this;
  }
  readTextNode(node) {
    let text = node.nodeValue;
    for (let point of this.points)
      if (point.node == node)
        point.pos = this.text.length + Math.min(point.offset, text.length);
    for (let off = 0, re2 = this.lineSeparator ? null : /\r\n?|\n/g; ; ) {
      let nextBreak = -1, breakSize = 1, m3;
      if (this.lineSeparator) {
        nextBreak = text.indexOf(this.lineSeparator, off);
        breakSize = this.lineSeparator.length;
      } else if (m3 = re2.exec(text)) {
        nextBreak = m3.index;
        breakSize = m3[0].length;
      }
      this.append(text.slice(off, nextBreak < 0 ? text.length : nextBreak));
      if (nextBreak < 0)
        break;
      this.lineBreak();
      if (breakSize > 1) {
        for (let point of this.points)
          if (point.node == node && point.pos > this.text.length)
            point.pos -= breakSize - 1;
      }
      off = nextBreak + breakSize;
    }
  }
  readNode(node) {
    if (node.cmIgnore)
      return;
    let view = ContentView.get(node);
    let fromView = view && view.overrideDOMText;
    if (fromView != null) {
      this.findPointInside(node, fromView.length);
      for (let i2 = fromView.iter(); !i2.next().done; ) {
        if (i2.lineBreak)
          this.lineBreak();
        else
          this.append(i2.value);
      }
    } else if (node.nodeType == 3) {
      this.readTextNode(node);
    } else if (node.nodeName == "BR") {
      if (node.nextSibling)
        this.lineBreak();
    } else if (node.nodeType == 1) {
      this.readRange(node.firstChild, null);
    }
  }
  findPointBefore(node, next) {
    for (let point of this.points)
      if (point.node == node && node.childNodes[point.offset] == next)
        point.pos = this.text.length;
  }
  findPointInside(node, length) {
    for (let point of this.points)
      if (node.nodeType == 3 ? point.node == node : node.contains(point.node))
        point.pos = this.text.length + (isAtEnd(node, point.node, point.offset) ? length : 0);
  }
};
function isAtEnd(parent, node, offset) {
  for (; ; ) {
    if (!node || offset < maxOffset(node))
      return false;
    if (node == parent)
      return true;
    offset = domIndex(node) + 1;
    node = node.parentNode;
  }
}
var DOMPoint = class {
  constructor(node, offset) {
    this.node = node;
    this.offset = offset;
    this.pos = -1;
  }
};
var DOMChange = class {
  constructor(view, start, end, typeOver) {
    this.typeOver = typeOver;
    this.bounds = null;
    this.text = "";
    this.domChanged = start > -1;
    let { impreciseHead: iHead, impreciseAnchor: iAnchor } = view.docView;
    if (view.state.readOnly && start > -1) {
      this.newSel = null;
    } else if (start > -1 && (this.bounds = view.docView.domBoundsAround(start, end, 0))) {
      let selPoints = iHead || iAnchor ? [] : selectionPoints(view);
      let reader = new DOMReader(selPoints, view.state);
      reader.readRange(this.bounds.startDOM, this.bounds.endDOM);
      this.text = reader.text;
      this.newSel = selectionFromPoints(selPoints, this.bounds.from);
    } else {
      let domSel = view.observer.selectionRange;
      let head = iHead && iHead.node == domSel.focusNode && iHead.offset == domSel.focusOffset || !contains(view.contentDOM, domSel.focusNode) ? view.state.selection.main.head : view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset);
      let anchor = iAnchor && iAnchor.node == domSel.anchorNode && iAnchor.offset == domSel.anchorOffset || !contains(view.contentDOM, domSel.anchorNode) ? view.state.selection.main.anchor : view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset);
      let vp2 = view.viewport;
      if ((browser.ios || browser.chrome) && view.state.selection.main.empty && head != anchor && (vp2.from > 0 || vp2.to < view.state.doc.length)) {
        let from = Math.min(head, anchor), to3 = Math.max(head, anchor);
        let offFrom = vp2.from - from, offTo = vp2.to - to3;
        if ((offFrom == 0 || offFrom == 1 || from == 0) && (offTo == 0 || offTo == -1 || to3 == view.state.doc.length)) {
          head = 0;
          anchor = view.state.doc.length;
        }
      }
      this.newSel = EditorSelection.single(anchor, head);
    }
  }
};
function applyDOMChange(view, domChange) {
  let change;
  let { newSel } = domChange, sel = view.state.selection.main;
  let lastKey = view.inputState.lastKeyTime > Date.now() - 100 ? view.inputState.lastKeyCode : -1;
  if (domChange.bounds) {
    let { from, to: to3 } = domChange.bounds;
    let preferredPos = sel.from, preferredSide = null;
    if (lastKey === 8 || browser.android && domChange.text.length < to3 - from) {
      preferredPos = sel.to;
      preferredSide = "end";
    }
    let diff = findDiff(view.state.doc.sliceString(from, to3, LineBreakPlaceholder), domChange.text, preferredPos - from, preferredSide);
    if (diff) {
      if (browser.chrome && lastKey == 13 && diff.toB == diff.from + 2 && domChange.text.slice(diff.from, diff.toB) == LineBreakPlaceholder + LineBreakPlaceholder)
        diff.toB--;
      change = {
        from: from + diff.from,
        to: from + diff.toA,
        insert: Text.of(domChange.text.slice(diff.from, diff.toB).split(LineBreakPlaceholder))
      };
    }
  } else if (newSel && (!view.hasFocus && view.state.facet(editable) || newSel.main.eq(sel))) {
    newSel = null;
  }
  if (!change && !newSel)
    return false;
  if (!change && domChange.typeOver && !sel.empty && newSel && newSel.main.empty) {
    change = { from: sel.from, to: sel.to, insert: view.state.doc.slice(sel.from, sel.to) };
  } else if (change && change.from >= sel.from && change.to <= sel.to && (change.from != sel.from || change.to != sel.to) && sel.to - sel.from - (change.to - change.from) <= 4) {
    change = {
      from: sel.from,
      to: sel.to,
      insert: view.state.doc.slice(sel.from, change.from).append(change.insert).append(view.state.doc.slice(change.to, sel.to))
    };
  } else if ((browser.mac || browser.android) && change && change.from == change.to && change.from == sel.head - 1 && /^\. ?$/.test(change.insert.toString()) && view.contentDOM.getAttribute("autocorrect") == "off") {
    if (newSel && change.insert.length == 2)
      newSel = EditorSelection.single(newSel.main.anchor - 1, newSel.main.head - 1);
    change = { from: sel.from, to: sel.to, insert: Text.of([" "]) };
  } else if (browser.chrome && change && change.from == change.to && change.from == sel.head && change.insert.toString() == "\n " && view.lineWrapping) {
    if (newSel)
      newSel = EditorSelection.single(newSel.main.anchor - 1, newSel.main.head - 1);
    change = { from: sel.from, to: sel.to, insert: Text.of([" "]) };
  }
  if (change) {
    return applyDOMChangeInner(view, change, newSel, lastKey);
  } else if (newSel && !newSel.main.eq(sel)) {
    let scrollIntoView3 = false, userEvent = "select";
    if (view.inputState.lastSelectionTime > Date.now() - 50) {
      if (view.inputState.lastSelectionOrigin == "select")
        scrollIntoView3 = true;
      userEvent = view.inputState.lastSelectionOrigin;
    }
    view.dispatch({ selection: newSel, scrollIntoView: scrollIntoView3, userEvent });
    return true;
  } else {
    return false;
  }
}
function applyDOMChangeInner(view, change, newSel, lastKey = -1) {
  if (browser.ios && view.inputState.flushIOSKey(change))
    return true;
  let sel = view.state.selection.main;
  if (browser.android && (change.to == sel.to && // GBoard will sometimes remove a space it just inserted
  // after a completion when you press enter
  (change.from == sel.from || change.from == sel.from - 1 && view.state.sliceDoc(change.from, sel.from) == " ") && change.insert.length == 1 && change.insert.lines == 2 && dispatchKey(view.contentDOM, "Enter", 13) || (change.from == sel.from - 1 && change.to == sel.to && change.insert.length == 0 || lastKey == 8 && change.insert.length < change.to - change.from && change.to > sel.head) && dispatchKey(view.contentDOM, "Backspace", 8) || change.from == sel.from && change.to == sel.to + 1 && change.insert.length == 0 && dispatchKey(view.contentDOM, "Delete", 46)))
    return true;
  let text = change.insert.toString();
  if (view.inputState.composing >= 0)
    view.inputState.composing++;
  let defaultTr;
  let defaultInsert = () => defaultTr || (defaultTr = applyDefaultInsert(view, change, newSel));
  if (!view.state.facet(inputHandler).some((h2) => h2(view, change.from, change.to, text, defaultInsert)))
    view.dispatch(defaultInsert());
  return true;
}
function applyDefaultInsert(view, change, newSel) {
  let tr3, startState = view.state, sel = startState.selection.main;
  if (change.from >= sel.from && change.to <= sel.to && change.to - change.from >= (sel.to - sel.from) / 3 && (!newSel || newSel.main.empty && newSel.main.from == change.from + change.insert.length) && view.inputState.composing < 0) {
    let before = sel.from < change.from ? startState.sliceDoc(sel.from, change.from) : "";
    let after = sel.to > change.to ? startState.sliceDoc(change.to, sel.to) : "";
    tr3 = startState.replaceSelection(view.state.toText(before + change.insert.sliceString(0, void 0, view.state.lineBreak) + after));
  } else {
    let changes = startState.changes(change);
    let mainSel = newSel && newSel.main.to <= changes.newLength ? newSel.main : void 0;
    if (startState.selection.ranges.length > 1 && view.inputState.composing >= 0 && change.to <= sel.to && change.to >= sel.to - 10) {
      let replaced = view.state.sliceDoc(change.from, change.to);
      let compositionRange, composition = newSel && findCompositionNode(view, newSel.main.head);
      if (composition) {
        let dLen = change.insert.length - (change.to - change.from);
        compositionRange = { from: composition.from, to: composition.to - dLen };
      } else {
        compositionRange = view.state.doc.lineAt(sel.head);
      }
      let offset = sel.to - change.to, size = sel.to - sel.from;
      tr3 = startState.changeByRange((range) => {
        if (range.from == sel.from && range.to == sel.to)
          return { changes, range: mainSel || range.map(changes) };
        let to3 = range.to - offset, from = to3 - replaced.length;
        if (range.to - range.from != size || view.state.sliceDoc(from, to3) != replaced || // Unfortunately, there's no way to make multiple
        // changes in the same node work without aborting
        // composition, so cursors in the composition range are
        // ignored.
        range.to >= compositionRange.from && range.from <= compositionRange.to)
          return { range };
        let rangeChanges = startState.changes({ from, to: to3, insert: change.insert }), selOff = range.to - sel.to;
        return {
          changes: rangeChanges,
          range: !mainSel ? range.map(rangeChanges) : EditorSelection.range(Math.max(0, mainSel.anchor + selOff), Math.max(0, mainSel.head + selOff))
        };
      });
    } else {
      tr3 = {
        changes,
        selection: mainSel && startState.selection.replaceRange(mainSel)
      };
    }
  }
  let userEvent = "input.type";
  if (view.composing || view.inputState.compositionPendingChange && view.inputState.compositionEndedAt > Date.now() - 50) {
    view.inputState.compositionPendingChange = false;
    userEvent += ".compose";
    if (view.inputState.compositionFirstChange) {
      userEvent += ".start";
      view.inputState.compositionFirstChange = false;
    }
  }
  return startState.update(tr3, { userEvent, scrollIntoView: true });
}
function findDiff(a2, b2, preferredPos, preferredSide) {
  let minLen = Math.min(a2.length, b2.length);
  let from = 0;
  while (from < minLen && a2.charCodeAt(from) == b2.charCodeAt(from))
    from++;
  if (from == minLen && a2.length == b2.length)
    return null;
  let toA = a2.length, toB = b2.length;
  while (toA > 0 && toB > 0 && a2.charCodeAt(toA - 1) == b2.charCodeAt(toB - 1)) {
    toA--;
    toB--;
  }
  if (preferredSide == "end") {
    let adjust = Math.max(0, from - Math.min(toA, toB));
    preferredPos -= toA + adjust - from;
  }
  if (toA < from && a2.length < b2.length) {
    let move2 = preferredPos <= from && preferredPos >= toA ? from - preferredPos : 0;
    from -= move2;
    toB = from + (toB - toA);
    toA = from;
  } else if (toB < from) {
    let move2 = preferredPos <= from && preferredPos >= toB ? from - preferredPos : 0;
    from -= move2;
    toA = from + (toA - toB);
    toB = from;
  }
  return { from, toA, toB };
}
function selectionPoints(view) {
  let result = [];
  if (view.root.activeElement != view.contentDOM)
    return result;
  let { anchorNode, anchorOffset, focusNode, focusOffset } = view.observer.selectionRange;
  if (anchorNode) {
    result.push(new DOMPoint(anchorNode, anchorOffset));
    if (focusNode != anchorNode || focusOffset != anchorOffset)
      result.push(new DOMPoint(focusNode, focusOffset));
  }
  return result;
}
function selectionFromPoints(points, base2) {
  if (points.length == 0)
    return null;
  let anchor = points[0].pos, head = points.length == 2 ? points[1].pos : anchor;
  return anchor > -1 && head > -1 ? EditorSelection.single(anchor + base2, head + base2) : null;
}
var InputState = class {
  setSelectionOrigin(origin) {
    this.lastSelectionOrigin = origin;
    this.lastSelectionTime = Date.now();
  }
  constructor(view) {
    this.view = view;
    this.lastKeyCode = 0;
    this.lastKeyTime = 0;
    this.lastTouchTime = 0;
    this.lastFocusTime = 0;
    this.lastScrollTop = 0;
    this.lastScrollLeft = 0;
    this.pendingIOSKey = void 0;
    this.tabFocusMode = -1;
    this.lastSelectionOrigin = null;
    this.lastSelectionTime = 0;
    this.lastContextMenu = 0;
    this.scrollHandlers = [];
    this.handlers = /* @__PURE__ */ Object.create(null);
    this.composing = -1;
    this.compositionFirstChange = null;
    this.compositionEndedAt = 0;
    this.compositionPendingKey = false;
    this.compositionPendingChange = false;
    this.mouseSelection = null;
    this.draggedContent = null;
    this.handleEvent = this.handleEvent.bind(this);
    this.notifiedFocused = view.hasFocus;
    if (browser.safari)
      view.contentDOM.addEventListener("input", () => null);
    if (browser.gecko)
      firefoxCopyCutHack(view.contentDOM.ownerDocument);
  }
  handleEvent(event) {
    if (!eventBelongsToEditor(this.view, event) || this.ignoreDuringComposition(event))
      return;
    if (event.type == "keydown" && this.keydown(event))
      return;
    this.runHandlers(event.type, event);
  }
  runHandlers(type, event) {
    let handlers2 = this.handlers[type];
    if (handlers2) {
      for (let observer of handlers2.observers)
        observer(this.view, event);
      for (let handler of handlers2.handlers) {
        if (event.defaultPrevented)
          break;
        if (handler(this.view, event)) {
          event.preventDefault();
          break;
        }
      }
    }
  }
  ensureHandlers(plugins) {
    let handlers2 = computeHandlers(plugins), prev = this.handlers, dom = this.view.contentDOM;
    for (let type in handlers2)
      if (type != "scroll") {
        let passive = !handlers2[type].handlers.length;
        let exists = prev[type];
        if (exists && passive != !exists.handlers.length) {
          dom.removeEventListener(type, this.handleEvent);
          exists = null;
        }
        if (!exists)
          dom.addEventListener(type, this.handleEvent, { passive });
      }
    for (let type in prev)
      if (type != "scroll" && !handlers2[type])
        dom.removeEventListener(type, this.handleEvent);
    this.handlers = handlers2;
  }
  keydown(event) {
    this.lastKeyCode = event.keyCode;
    this.lastKeyTime = Date.now();
    if (event.keyCode == 9 && this.tabFocusMode > -1 && (!this.tabFocusMode || Date.now() <= this.tabFocusMode))
      return true;
    if (this.tabFocusMode > 0 && event.keyCode != 27 && modifierCodes.indexOf(event.keyCode) < 0)
      this.tabFocusMode = -1;
    if (browser.android && browser.chrome && !event.synthetic && (event.keyCode == 13 || event.keyCode == 8)) {
      this.view.observer.delayAndroidKey(event.key, event.keyCode);
      return true;
    }
    let pending;
    if (browser.ios && !event.synthetic && !event.altKey && !event.metaKey && ((pending = PendingKeys.find((key) => key.keyCode == event.keyCode)) && !event.ctrlKey || EmacsyPendingKeys.indexOf(event.key) > -1 && event.ctrlKey && !event.shiftKey)) {
      this.pendingIOSKey = pending || event;
      setTimeout(() => this.flushIOSKey(), 250);
      return true;
    }
    if (event.keyCode != 229)
      this.view.observer.forceFlush();
    return false;
  }
  flushIOSKey(change) {
    let key = this.pendingIOSKey;
    if (!key)
      return false;
    if (key.key == "Enter" && change && change.from < change.to && /^\S+$/.test(change.insert.toString()))
      return false;
    this.pendingIOSKey = void 0;
    return dispatchKey(this.view.contentDOM, key.key, key.keyCode, key instanceof KeyboardEvent ? key : void 0);
  }
  ignoreDuringComposition(event) {
    if (!/^key/.test(event.type))
      return false;
    if (this.composing > 0)
      return true;
    if (browser.safari && !browser.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100) {
      this.compositionPendingKey = false;
      return true;
    }
    return false;
  }
  startMouseSelection(mouseSelection) {
    if (this.mouseSelection)
      this.mouseSelection.destroy();
    this.mouseSelection = mouseSelection;
  }
  update(update) {
    this.view.observer.update(update);
    if (this.mouseSelection)
      this.mouseSelection.update(update);
    if (this.draggedContent && update.docChanged)
      this.draggedContent = this.draggedContent.map(update.changes);
    if (update.transactions.length)
      this.lastKeyCode = this.lastSelectionTime = 0;
  }
  destroy() {
    if (this.mouseSelection)
      this.mouseSelection.destroy();
  }
};
function bindHandler(plugin3, handler) {
  return (view, event) => {
    try {
      return handler.call(plugin3, event, view);
    } catch (e2) {
      logException(view.state, e2);
    }
  };
}
function computeHandlers(plugins) {
  let result = /* @__PURE__ */ Object.create(null);
  function record(type) {
    return result[type] || (result[type] = { observers: [], handlers: [] });
  }
  for (let plugin3 of plugins) {
    let spec = plugin3.spec;
    if (spec && spec.domEventHandlers)
      for (let type in spec.domEventHandlers) {
        let f = spec.domEventHandlers[type];
        if (f)
          record(type).handlers.push(bindHandler(plugin3.value, f));
      }
    if (spec && spec.domEventObservers)
      for (let type in spec.domEventObservers) {
        let f = spec.domEventObservers[type];
        if (f)
          record(type).observers.push(bindHandler(plugin3.value, f));
      }
  }
  for (let type in handlers)
    record(type).handlers.push(handlers[type]);
  for (let type in observers)
    record(type).observers.push(observers[type]);
  return result;
}
var PendingKeys = [
  { key: "Backspace", keyCode: 8, inputType: "deleteContentBackward" },
  { key: "Enter", keyCode: 13, inputType: "insertParagraph" },
  { key: "Enter", keyCode: 13, inputType: "insertLineBreak" },
  { key: "Delete", keyCode: 46, inputType: "deleteContentForward" }
];
var EmacsyPendingKeys = "dthko";
var modifierCodes = [16, 17, 18, 20, 91, 92, 224, 225];
var dragScrollMargin = 6;
function dragScrollSpeed(dist2) {
  return Math.max(0, dist2) * 0.7 + 8;
}
function dist(a2, b2) {
  return Math.max(Math.abs(a2.clientX - b2.clientX), Math.abs(a2.clientY - b2.clientY));
}
var MouseSelection = class {
  constructor(view, startEvent, style, mustSelect) {
    this.view = view;
    this.startEvent = startEvent;
    this.style = style;
    this.mustSelect = mustSelect;
    this.scrollSpeed = { x: 0, y: 0 };
    this.scrolling = -1;
    this.lastEvent = startEvent;
    this.scrollParents = scrollableParents(view.contentDOM);
    this.atoms = view.state.facet(atomicRanges).map((f) => f(view));
    let doc2 = view.contentDOM.ownerDocument;
    doc2.addEventListener("mousemove", this.move = this.move.bind(this));
    doc2.addEventListener("mouseup", this.up = this.up.bind(this));
    this.extend = startEvent.shiftKey;
    this.multiple = view.state.facet(EditorState.allowMultipleSelections) && addsSelectionRange(view, startEvent);
    this.dragging = isInPrimarySelection(view, startEvent) && getClickType(startEvent) == 1 ? null : false;
  }
  start(event) {
    if (this.dragging === false)
      this.select(event);
  }
  move(event) {
    if (event.buttons == 0)
      return this.destroy();
    if (this.dragging || this.dragging == null && dist(this.startEvent, event) < 10)
      return;
    this.select(this.lastEvent = event);
    let sx2 = 0, sy = 0;
    let left = 0, top2 = 0, right = this.view.win.innerWidth, bottom = this.view.win.innerHeight;
    if (this.scrollParents.x)
      ({ left, right } = this.scrollParents.x.getBoundingClientRect());
    if (this.scrollParents.y)
      ({ top: top2, bottom } = this.scrollParents.y.getBoundingClientRect());
    let margins = getScrollMargins(this.view);
    if (event.clientX - margins.left <= left + dragScrollMargin)
      sx2 = -dragScrollSpeed(left - event.clientX);
    else if (event.clientX + margins.right >= right - dragScrollMargin)
      sx2 = dragScrollSpeed(event.clientX - right);
    if (event.clientY - margins.top <= top2 + dragScrollMargin)
      sy = -dragScrollSpeed(top2 - event.clientY);
    else if (event.clientY + margins.bottom >= bottom - dragScrollMargin)
      sy = dragScrollSpeed(event.clientY - bottom);
    this.setScrollSpeed(sx2, sy);
  }
  up(event) {
    if (this.dragging == null)
      this.select(this.lastEvent);
    if (!this.dragging)
      event.preventDefault();
    this.destroy();
  }
  destroy() {
    this.setScrollSpeed(0, 0);
    let doc2 = this.view.contentDOM.ownerDocument;
    doc2.removeEventListener("mousemove", this.move);
    doc2.removeEventListener("mouseup", this.up);
    this.view.inputState.mouseSelection = this.view.inputState.draggedContent = null;
  }
  setScrollSpeed(sx2, sy) {
    this.scrollSpeed = { x: sx2, y: sy };
    if (sx2 || sy) {
      if (this.scrolling < 0)
        this.scrolling = setInterval(() => this.scroll(), 50);
    } else if (this.scrolling > -1) {
      clearInterval(this.scrolling);
      this.scrolling = -1;
    }
  }
  scroll() {
    let { x, y } = this.scrollSpeed;
    if (x && this.scrollParents.x) {
      this.scrollParents.x.scrollLeft += x;
      x = 0;
    }
    if (y && this.scrollParents.y) {
      this.scrollParents.y.scrollTop += y;
      y = 0;
    }
    if (x || y)
      this.view.win.scrollBy(x, y);
    if (this.dragging === false)
      this.select(this.lastEvent);
  }
  skipAtoms(sel) {
    let ranges = null;
    for (let i2 = 0; i2 < sel.ranges.length; i2++) {
      let range = sel.ranges[i2], updated = null;
      if (range.empty) {
        let pos = skipAtomicRanges(this.atoms, range.from, 0);
        if (pos != range.from)
          updated = EditorSelection.cursor(pos, -1);
      } else {
        let from = skipAtomicRanges(this.atoms, range.from, -1);
        let to3 = skipAtomicRanges(this.atoms, range.to, 1);
        if (from != range.from || to3 != range.to)
          updated = EditorSelection.range(range.from == range.anchor ? from : to3, range.from == range.head ? from : to3);
      }
      if (updated) {
        if (!ranges)
          ranges = sel.ranges.slice();
        ranges[i2] = updated;
      }
    }
    return ranges ? EditorSelection.create(ranges, sel.mainIndex) : sel;
  }
  select(event) {
    let { view } = this, selection = this.skipAtoms(this.style.get(event, this.extend, this.multiple));
    if (this.mustSelect || !selection.eq(view.state.selection, this.dragging === false))
      this.view.dispatch({
        selection,
        userEvent: "select.pointer"
      });
    this.mustSelect = false;
  }
  update(update) {
    if (update.transactions.some((tr3) => tr3.isUserEvent("input.type")))
      this.destroy();
    else if (this.style.update(update))
      setTimeout(() => this.select(this.lastEvent), 20);
  }
};
function addsSelectionRange(view, event) {
  let facet = view.state.facet(clickAddsSelectionRange);
  return facet.length ? facet[0](event) : browser.mac ? event.metaKey : event.ctrlKey;
}
function dragMovesSelection(view, event) {
  let facet = view.state.facet(dragMovesSelection$1);
  return facet.length ? facet[0](event) : browser.mac ? !event.altKey : !event.ctrlKey;
}
function isInPrimarySelection(view, event) {
  let { main } = view.state.selection;
  if (main.empty)
    return false;
  let sel = getSelection(view.root);
  if (!sel || sel.rangeCount == 0)
    return true;
  let rects = sel.getRangeAt(0).getClientRects();
  for (let i2 = 0; i2 < rects.length; i2++) {
    let rect = rects[i2];
    if (rect.left <= event.clientX && rect.right >= event.clientX && rect.top <= event.clientY && rect.bottom >= event.clientY)
      return true;
  }
  return false;
}
function eventBelongsToEditor(view, event) {
  if (!event.bubbles)
    return true;
  if (event.defaultPrevented)
    return false;
  for (let node = event.target, cView; node != view.contentDOM; node = node.parentNode)
    if (!node || node.nodeType == 11 || (cView = ContentView.get(node)) && cView.ignoreEvent(event))
      return false;
  return true;
}
var handlers = /* @__PURE__ */ Object.create(null);
var observers = /* @__PURE__ */ Object.create(null);
var brokenClipboardAPI = browser.ie && browser.ie_version < 15 || browser.ios && browser.webkit_version < 604;
function capturePaste(view) {
  let parent = view.dom.parentNode;
  if (!parent)
    return;
  let target = parent.appendChild(document.createElement("textarea"));
  target.style.cssText = "position: fixed; left: -10000px; top: 10px";
  target.focus();
  setTimeout(() => {
    view.focus();
    target.remove();
    doPaste(view, target.value);
  }, 50);
}
function textFilter(state, facet, text) {
  for (let filter of state.facet(facet))
    text = filter(text, state);
  return text;
}
function doPaste(view, input) {
  input = textFilter(view.state, clipboardInputFilter, input);
  let { state } = view, changes, i2 = 1, text = state.toText(input);
  let byLine = text.lines == state.selection.ranges.length;
  let linewise = lastLinewiseCopy != null && state.selection.ranges.every((r2) => r2.empty) && lastLinewiseCopy == text.toString();
  if (linewise) {
    let lastLine = -1;
    changes = state.changeByRange((range) => {
      let line = state.doc.lineAt(range.from);
      if (line.from == lastLine)
        return { range };
      lastLine = line.from;
      let insert2 = state.toText((byLine ? text.line(i2++).text : input) + state.lineBreak);
      return {
        changes: { from: line.from, insert: insert2 },
        range: EditorSelection.cursor(range.from + insert2.length)
      };
    });
  } else if (byLine) {
    changes = state.changeByRange((range) => {
      let line = text.line(i2++);
      return {
        changes: { from: range.from, to: range.to, insert: line.text },
        range: EditorSelection.cursor(range.from + line.length)
      };
    });
  } else {
    changes = state.replaceSelection(text);
  }
  view.dispatch(changes, {
    userEvent: "input.paste",
    scrollIntoView: true
  });
}
observers.scroll = (view) => {
  view.inputState.lastScrollTop = view.scrollDOM.scrollTop;
  view.inputState.lastScrollLeft = view.scrollDOM.scrollLeft;
};
handlers.keydown = (view, event) => {
  view.inputState.setSelectionOrigin("select");
  if (event.keyCode == 27 && view.inputState.tabFocusMode != 0)
    view.inputState.tabFocusMode = Date.now() + 2e3;
  return false;
};
observers.touchstart = (view, e2) => {
  view.inputState.lastTouchTime = Date.now();
  view.inputState.setSelectionOrigin("select.pointer");
};
observers.touchmove = (view) => {
  view.inputState.setSelectionOrigin("select.pointer");
};
handlers.mousedown = (view, event) => {
  view.observer.flush();
  if (view.inputState.lastTouchTime > Date.now() - 2e3)
    return false;
  let style = null;
  for (let makeStyle of view.state.facet(mouseSelectionStyle)) {
    style = makeStyle(view, event);
    if (style)
      break;
  }
  if (!style && event.button == 0)
    style = basicMouseSelection(view, event);
  if (style) {
    let mustFocus = !view.hasFocus;
    view.inputState.startMouseSelection(new MouseSelection(view, event, style, mustFocus));
    if (mustFocus)
      view.observer.ignore(() => {
        focusPreventScroll(view.contentDOM);
        let active = view.root.activeElement;
        if (active && !active.contains(view.contentDOM))
          active.blur();
      });
    let mouseSel = view.inputState.mouseSelection;
    if (mouseSel) {
      mouseSel.start(event);
      return mouseSel.dragging === false;
    }
  }
  return false;
};
function rangeForClick(view, pos, bias, type) {
  if (type == 1) {
    return EditorSelection.cursor(pos, bias);
  } else if (type == 2) {
    return groupAt(view.state, pos, bias);
  } else {
    let visual = LineView.find(view.docView, pos), line = view.state.doc.lineAt(visual ? visual.posAtEnd : pos);
    let from = visual ? visual.posAtStart : line.from, to3 = visual ? visual.posAtEnd : line.to;
    if (to3 < view.state.doc.length && to3 == line.to)
      to3++;
    return EditorSelection.range(from, to3);
  }
}
var inside = (x, y, rect) => y >= rect.top && y <= rect.bottom && x >= rect.left && x <= rect.right;
function findPositionSide(view, pos, x, y) {
  let line = LineView.find(view.docView, pos);
  if (!line)
    return 1;
  let off = pos - line.posAtStart;
  if (off == 0)
    return 1;
  if (off == line.length)
    return -1;
  let before = line.coordsAt(off, -1);
  if (before && inside(x, y, before))
    return -1;
  let after = line.coordsAt(off, 1);
  if (after && inside(x, y, after))
    return 1;
  return before && before.bottom >= y ? -1 : 1;
}
function queryPos(view, event) {
  let pos = view.posAtCoords({ x: event.clientX, y: event.clientY }, false);
  return { pos, bias: findPositionSide(view, pos, event.clientX, event.clientY) };
}
var BadMouseDetail = browser.ie && browser.ie_version <= 11;
var lastMouseDown = null;
var lastMouseDownCount = 0;
var lastMouseDownTime = 0;
function getClickType(event) {
  if (!BadMouseDetail)
    return event.detail;
  let last2 = lastMouseDown, lastTime = lastMouseDownTime;
  lastMouseDown = event;
  lastMouseDownTime = Date.now();
  return lastMouseDownCount = !last2 || lastTime > Date.now() - 400 && Math.abs(last2.clientX - event.clientX) < 2 && Math.abs(last2.clientY - event.clientY) < 2 ? (lastMouseDownCount + 1) % 3 : 1;
}
function basicMouseSelection(view, event) {
  let start = queryPos(view, event), type = getClickType(event);
  let startSel = view.state.selection;
  return {
    update(update) {
      if (update.docChanged) {
        start.pos = update.changes.mapPos(start.pos);
        startSel = startSel.map(update.changes);
      }
    },
    get(event2, extend2, multiple) {
      let cur2 = queryPos(view, event2), removed;
      let range = rangeForClick(view, cur2.pos, cur2.bias, type);
      if (start.pos != cur2.pos && !extend2) {
        let startRange = rangeForClick(view, start.pos, start.bias, type);
        let from = Math.min(startRange.from, range.from), to3 = Math.max(startRange.to, range.to);
        range = from < range.from ? EditorSelection.range(from, to3) : EditorSelection.range(to3, from);
      }
      if (extend2)
        return startSel.replaceRange(startSel.main.extend(range.from, range.to));
      else if (multiple && type == 1 && startSel.ranges.length > 1 && (removed = removeRangeAround(startSel, cur2.pos)))
        return removed;
      else if (multiple)
        return startSel.addRange(range);
      else
        return EditorSelection.create([range]);
    }
  };
}
function removeRangeAround(sel, pos) {
  for (let i2 = 0; i2 < sel.ranges.length; i2++) {
    let { from, to: to3 } = sel.ranges[i2];
    if (from <= pos && to3 >= pos)
      return EditorSelection.create(sel.ranges.slice(0, i2).concat(sel.ranges.slice(i2 + 1)), sel.mainIndex == i2 ? 0 : sel.mainIndex - (sel.mainIndex > i2 ? 1 : 0));
  }
  return null;
}
handlers.dragstart = (view, event) => {
  let { selection: { main: range } } = view.state;
  if (event.target.draggable) {
    let cView = view.docView.nearest(event.target);
    if (cView && cView.isWidget) {
      let from = cView.posAtStart, to3 = from + cView.length;
      if (from >= range.to || to3 <= range.from)
        range = EditorSelection.range(from, to3);
    }
  }
  let { inputState } = view;
  if (inputState.mouseSelection)
    inputState.mouseSelection.dragging = true;
  inputState.draggedContent = range;
  if (event.dataTransfer) {
    event.dataTransfer.setData("Text", textFilter(view.state, clipboardOutputFilter, view.state.sliceDoc(range.from, range.to)));
    event.dataTransfer.effectAllowed = "copyMove";
  }
  return false;
};
handlers.dragend = (view) => {
  view.inputState.draggedContent = null;
  return false;
};
function dropText(view, event, text, direct) {
  text = textFilter(view.state, clipboardInputFilter, text);
  if (!text)
    return;
  let dropPos = view.posAtCoords({ x: event.clientX, y: event.clientY }, false);
  let { draggedContent } = view.inputState;
  let del = direct && draggedContent && dragMovesSelection(view, event) ? { from: draggedContent.from, to: draggedContent.to } : null;
  let ins = { from: dropPos, insert: text };
  let changes = view.state.changes(del ? [del, ins] : ins);
  view.focus();
  view.dispatch({
    changes,
    selection: { anchor: changes.mapPos(dropPos, -1), head: changes.mapPos(dropPos, 1) },
    userEvent: del ? "move.drop" : "input.drop"
  });
  view.inputState.draggedContent = null;
}
handlers.drop = (view, event) => {
  if (!event.dataTransfer)
    return false;
  if (view.state.readOnly)
    return true;
  let files = event.dataTransfer.files;
  if (files && files.length) {
    let text = Array(files.length), read = 0;
    let finishFile = () => {
      if (++read == files.length)
        dropText(view, event, text.filter((s2) => s2 != null).join(view.state.lineBreak), false);
    };
    for (let i2 = 0; i2 < files.length; i2++) {
      let reader = new FileReader();
      reader.onerror = finishFile;
      reader.onload = () => {
        if (!/[\x00-\x08\x0e-\x1f]{2}/.test(reader.result))
          text[i2] = reader.result;
        finishFile();
      };
      reader.readAsText(files[i2]);
    }
    return true;
  } else {
    let text = event.dataTransfer.getData("Text");
    if (text) {
      dropText(view, event, text, true);
      return true;
    }
  }
  return false;
};
handlers.paste = (view, event) => {
  if (view.state.readOnly)
    return true;
  view.observer.flush();
  let data = brokenClipboardAPI ? null : event.clipboardData;
  if (data) {
    doPaste(view, data.getData("text/plain") || data.getData("text/uri-list"));
    return true;
  } else {
    capturePaste(view);
    return false;
  }
};
function captureCopy(view, text) {
  let parent = view.dom.parentNode;
  if (!parent)
    return;
  let target = parent.appendChild(document.createElement("textarea"));
  target.style.cssText = "position: fixed; left: -10000px; top: 10px";
  target.value = text;
  target.focus();
  target.selectionEnd = text.length;
  target.selectionStart = 0;
  setTimeout(() => {
    target.remove();
    view.focus();
  }, 50);
}
function copiedRange(state) {
  let content2 = [], ranges = [], linewise = false;
  for (let range of state.selection.ranges)
    if (!range.empty) {
      content2.push(state.sliceDoc(range.from, range.to));
      ranges.push(range);
    }
  if (!content2.length) {
    let upto = -1;
    for (let { from } of state.selection.ranges) {
      let line = state.doc.lineAt(from);
      if (line.number > upto) {
        content2.push(line.text);
        ranges.push({ from: line.from, to: Math.min(state.doc.length, line.to + 1) });
      }
      upto = line.number;
    }
    linewise = true;
  }
  return { text: textFilter(state, clipboardOutputFilter, content2.join(state.lineBreak)), ranges, linewise };
}
var lastLinewiseCopy = null;
handlers.copy = handlers.cut = (view, event) => {
  let { text, ranges, linewise } = copiedRange(view.state);
  if (!text && !linewise)
    return false;
  lastLinewiseCopy = linewise ? text : null;
  if (event.type == "cut" && !view.state.readOnly)
    view.dispatch({
      changes: ranges,
      scrollIntoView: true,
      userEvent: "delete.cut"
    });
  let data = brokenClipboardAPI ? null : event.clipboardData;
  if (data) {
    data.clearData();
    data.setData("text/plain", text);
    return true;
  } else {
    captureCopy(view, text);
    return false;
  }
};
var isFocusChange = Annotation.define();
function focusChangeTransaction(state, focus) {
  let effects = [];
  for (let getEffect of state.facet(focusChangeEffect)) {
    let effect = getEffect(state, focus);
    if (effect)
      effects.push(effect);
  }
  return effects ? state.update({ effects, annotations: isFocusChange.of(true) }) : null;
}
function updateForFocusChange(view) {
  setTimeout(() => {
    let focus = view.hasFocus;
    if (focus != view.inputState.notifiedFocused) {
      let tr3 = focusChangeTransaction(view.state, focus);
      if (tr3)
        view.dispatch(tr3);
      else
        view.update([]);
    }
  }, 10);
}
observers.focus = (view) => {
  view.inputState.lastFocusTime = Date.now();
  if (!view.scrollDOM.scrollTop && (view.inputState.lastScrollTop || view.inputState.lastScrollLeft)) {
    view.scrollDOM.scrollTop = view.inputState.lastScrollTop;
    view.scrollDOM.scrollLeft = view.inputState.lastScrollLeft;
  }
  updateForFocusChange(view);
};
observers.blur = (view) => {
  view.observer.clearSelectionRange();
  updateForFocusChange(view);
};
observers.compositionstart = observers.compositionupdate = (view) => {
  if (view.observer.editContext)
    return;
  if (view.inputState.compositionFirstChange == null)
    view.inputState.compositionFirstChange = true;
  if (view.inputState.composing < 0) {
    view.inputState.composing = 0;
  }
};
observers.compositionend = (view) => {
  if (view.observer.editContext)
    return;
  view.inputState.composing = -1;
  view.inputState.compositionEndedAt = Date.now();
  view.inputState.compositionPendingKey = true;
  view.inputState.compositionPendingChange = view.observer.pendingRecords().length > 0;
  view.inputState.compositionFirstChange = null;
  if (browser.chrome && browser.android) {
    view.observer.flushSoon();
  } else if (view.inputState.compositionPendingChange) {
    Promise.resolve().then(() => view.observer.flush());
  } else {
    setTimeout(() => {
      if (view.inputState.composing < 0 && view.docView.hasComposition)
        view.update([]);
    }, 50);
  }
};
observers.contextmenu = (view) => {
  view.inputState.lastContextMenu = Date.now();
};
handlers.beforeinput = (view, event) => {
  var _a4, _b;
  if (event.inputType == "insertReplacementText" && view.observer.editContext) {
    let text = (_a4 = event.dataTransfer) === null || _a4 === void 0 ? void 0 : _a4.getData("text/plain"), ranges = event.getTargetRanges();
    if (text && ranges.length) {
      let r2 = ranges[0];
      let from = view.posAtDOM(r2.startContainer, r2.startOffset), to3 = view.posAtDOM(r2.endContainer, r2.endOffset);
      applyDOMChangeInner(view, { from, to: to3, insert: view.state.toText(text) }, null);
      return true;
    }
  }
  let pending;
  if (browser.chrome && browser.android && (pending = PendingKeys.find((key) => key.inputType == event.inputType))) {
    view.observer.delayAndroidKey(pending.key, pending.keyCode);
    if (pending.key == "Backspace" || pending.key == "Delete") {
      let startViewHeight = ((_b = window.visualViewport) === null || _b === void 0 ? void 0 : _b.height) || 0;
      setTimeout(() => {
        var _a5;
        if ((((_a5 = window.visualViewport) === null || _a5 === void 0 ? void 0 : _a5.height) || 0) > startViewHeight + 10 && view.hasFocus) {
          view.contentDOM.blur();
          view.focus();
        }
      }, 100);
    }
  }
  if (browser.ios && event.inputType == "deleteContentForward") {
    view.observer.flushSoon();
  }
  if (browser.safari && event.inputType == "insertText" && view.inputState.composing >= 0) {
    setTimeout(() => observers.compositionend(view, event), 20);
  }
  return false;
};
var appliedFirefoxHack = /* @__PURE__ */ new Set();
function firefoxCopyCutHack(doc2) {
  if (!appliedFirefoxHack.has(doc2)) {
    appliedFirefoxHack.add(doc2);
    doc2.addEventListener("copy", () => {
    });
    doc2.addEventListener("cut", () => {
    });
  }
}
var wrappingWhiteSpace = ["pre-wrap", "normal", "pre-line", "break-spaces"];
var heightChangeFlag = false;
function clearHeightChangeFlag() {
  heightChangeFlag = false;
}
var HeightOracle = class {
  constructor(lineWrapping) {
    this.lineWrapping = lineWrapping;
    this.doc = Text.empty;
    this.heightSamples = {};
    this.lineHeight = 14;
    this.charWidth = 7;
    this.textHeight = 14;
    this.lineLength = 30;
  }
  heightForGap(from, to3) {
    let lines = this.doc.lineAt(to3).number - this.doc.lineAt(from).number + 1;
    if (this.lineWrapping)
      lines += Math.max(0, Math.ceil((to3 - from - lines * this.lineLength * 0.5) / this.lineLength));
    return this.lineHeight * lines;
  }
  heightForLine(length) {
    if (!this.lineWrapping)
      return this.lineHeight;
    let lines = 1 + Math.max(0, Math.ceil((length - this.lineLength) / (this.lineLength - 5)));
    return lines * this.lineHeight;
  }
  setDoc(doc2) {
    this.doc = doc2;
    return this;
  }
  mustRefreshForWrapping(whiteSpace) {
    return wrappingWhiteSpace.indexOf(whiteSpace) > -1 != this.lineWrapping;
  }
  mustRefreshForHeights(lineHeights) {
    let newHeight = false;
    for (let i2 = 0; i2 < lineHeights.length; i2++) {
      let h2 = lineHeights[i2];
      if (h2 < 0) {
        i2++;
      } else if (!this.heightSamples[Math.floor(h2 * 10)]) {
        newHeight = true;
        this.heightSamples[Math.floor(h2 * 10)] = true;
      }
    }
    return newHeight;
  }
  refresh(whiteSpace, lineHeight, charWidth, textHeight, lineLength, knownHeights) {
    let lineWrapping = wrappingWhiteSpace.indexOf(whiteSpace) > -1;
    let changed = Math.round(lineHeight) != Math.round(this.lineHeight) || this.lineWrapping != lineWrapping;
    this.lineWrapping = lineWrapping;
    this.lineHeight = lineHeight;
    this.charWidth = charWidth;
    this.textHeight = textHeight;
    this.lineLength = lineLength;
    if (changed) {
      this.heightSamples = {};
      for (let i2 = 0; i2 < knownHeights.length; i2++) {
        let h2 = knownHeights[i2];
        if (h2 < 0)
          i2++;
        else
          this.heightSamples[Math.floor(h2 * 10)] = true;
      }
    }
    return changed;
  }
};
var MeasuredHeights = class {
  constructor(from, heights) {
    this.from = from;
    this.heights = heights;
    this.index = 0;
  }
  get more() {
    return this.index < this.heights.length;
  }
};
var BlockInfo = class _BlockInfo {
  /**
  @internal
  */
  constructor(from, length, top2, height, _content) {
    this.from = from;
    this.length = length;
    this.top = top2;
    this.height = height;
    this._content = _content;
  }
  /**
  The type of element this is. When querying lines, this may be
  an array of all the blocks that make up the line.
  */
  get type() {
    return typeof this._content == "number" ? BlockType.Text : Array.isArray(this._content) ? this._content : this._content.type;
  }
  /**
  The end of the element as a document position.
  */
  get to() {
    return this.from + this.length;
  }
  /**
  The bottom position of the element.
  */
  get bottom() {
    return this.top + this.height;
  }
  /**
  If this is a widget block, this will return the widget
  associated with it.
  */
  get widget() {
    return this._content instanceof PointDecoration ? this._content.widget : null;
  }
  /**
  If this is a textblock, this holds the number of line breaks
  that appear in widgets inside the block.
  */
  get widgetLineBreaks() {
    return typeof this._content == "number" ? this._content : 0;
  }
  /**
  @internal
  */
  join(other) {
    let content2 = (Array.isArray(this._content) ? this._content : [this]).concat(Array.isArray(other._content) ? other._content : [other]);
    return new _BlockInfo(this.from, this.length + other.length, this.top, this.height + other.height, content2);
  }
};
var QueryType = function(QueryType3) {
  QueryType3[QueryType3["ByPos"] = 0] = "ByPos";
  QueryType3[QueryType3["ByHeight"] = 1] = "ByHeight";
  QueryType3[QueryType3["ByPosNoHeight"] = 2] = "ByPosNoHeight";
  return QueryType3;
}(QueryType || (QueryType = {}));
var Epsilon = 1e-3;
var HeightMap = class _HeightMap {
  constructor(length, height, flags = 2) {
    this.length = length;
    this.height = height;
    this.flags = flags;
  }
  get outdated() {
    return (this.flags & 2) > 0;
  }
  set outdated(value) {
    this.flags = (value ? 2 : 0) | this.flags & ~2;
  }
  setHeight(height) {
    if (this.height != height) {
      if (Math.abs(this.height - height) > Epsilon)
        heightChangeFlag = true;
      this.height = height;
    }
  }
  // Base case is to replace a leaf node, which simply builds a tree
  // from the new nodes and returns that (HeightMapBranch and
  // HeightMapGap override this to actually use from/to)
  replace(_from, _to, nodes) {
    return _HeightMap.of(nodes);
  }
  // Again, these are base cases, and are overridden for branch and gap nodes.
  decomposeLeft(_to, result) {
    result.push(this);
  }
  decomposeRight(_from, result) {
    result.push(this);
  }
  applyChanges(decorations2, oldDoc, oracle, changes) {
    let me2 = this, doc2 = oracle.doc;
    for (let i2 = changes.length - 1; i2 >= 0; i2--) {
      let { fromA, toA, fromB, toB } = changes[i2];
      let start = me2.lineAt(fromA, QueryType.ByPosNoHeight, oracle.setDoc(oldDoc), 0, 0);
      let end = start.to >= toA ? start : me2.lineAt(toA, QueryType.ByPosNoHeight, oracle, 0, 0);
      toB += end.to - toA;
      toA = end.to;
      while (i2 > 0 && start.from <= changes[i2 - 1].toA) {
        fromA = changes[i2 - 1].fromA;
        fromB = changes[i2 - 1].fromB;
        i2--;
        if (fromA < start.from)
          start = me2.lineAt(fromA, QueryType.ByPosNoHeight, oracle, 0, 0);
      }
      fromB += start.from - fromA;
      fromA = start.from;
      let nodes = NodeBuilder.build(oracle.setDoc(doc2), decorations2, fromB, toB);
      me2 = replace2(me2, me2.replace(fromA, toA, nodes));
    }
    return me2.updateHeight(oracle, 0);
  }
  static empty() {
    return new HeightMapText(0, 0);
  }
  // nodes uses null values to indicate the position of line breaks.
  // There are never line breaks at the start or end of the array, or
  // two line breaks next to each other, and the array isn't allowed
  // to be empty (same restrictions as return value from the builder).
  static of(nodes) {
    if (nodes.length == 1)
      return nodes[0];
    let i2 = 0, j = nodes.length, before = 0, after = 0;
    for (; ; ) {
      if (i2 == j) {
        if (before > after * 2) {
          let split = nodes[i2 - 1];
          if (split.break)
            nodes.splice(--i2, 1, split.left, null, split.right);
          else
            nodes.splice(--i2, 1, split.left, split.right);
          j += 1 + split.break;
          before -= split.size;
        } else if (after > before * 2) {
          let split = nodes[j];
          if (split.break)
            nodes.splice(j, 1, split.left, null, split.right);
          else
            nodes.splice(j, 1, split.left, split.right);
          j += 2 + split.break;
          after -= split.size;
        } else {
          break;
        }
      } else if (before < after) {
        let next = nodes[i2++];
        if (next)
          before += next.size;
      } else {
        let next = nodes[--j];
        if (next)
          after += next.size;
      }
    }
    let brk = 0;
    if (nodes[i2 - 1] == null) {
      brk = 1;
      i2--;
    } else if (nodes[i2] == null) {
      brk = 1;
      j++;
    }
    return new HeightMapBranch(_HeightMap.of(nodes.slice(0, i2)), brk, _HeightMap.of(nodes.slice(j)));
  }
};
function replace2(old, val) {
  if (old == val)
    return old;
  if (old.constructor != val.constructor)
    heightChangeFlag = true;
  return val;
}
HeightMap.prototype.size = 1;
var HeightMapBlock = class extends HeightMap {
  constructor(length, height, deco) {
    super(length, height);
    this.deco = deco;
  }
  blockAt(_height, _oracle, top2, offset) {
    return new BlockInfo(offset, this.length, top2, this.height, this.deco || 0);
  }
  lineAt(_value, _type, oracle, top2, offset) {
    return this.blockAt(0, oracle, top2, offset);
  }
  forEachLine(from, to3, oracle, top2, offset, f) {
    if (from <= offset + this.length && to3 >= offset)
      f(this.blockAt(0, oracle, top2, offset));
  }
  updateHeight(oracle, offset = 0, _force = false, measured) {
    if (measured && measured.from <= offset && measured.more)
      this.setHeight(measured.heights[measured.index++]);
    this.outdated = false;
    return this;
  }
  toString() {
    return `block(${this.length})`;
  }
};
var HeightMapText = class _HeightMapText extends HeightMapBlock {
  constructor(length, height) {
    super(length, height, null);
    this.collapsed = 0;
    this.widgetHeight = 0;
    this.breaks = 0;
  }
  blockAt(_height, _oracle, top2, offset) {
    return new BlockInfo(offset, this.length, top2, this.height, this.breaks);
  }
  replace(_from, _to, nodes) {
    let node = nodes[0];
    if (nodes.length == 1 && (node instanceof _HeightMapText || node instanceof HeightMapGap && node.flags & 4) && Math.abs(this.length - node.length) < 10) {
      if (node instanceof HeightMapGap)
        node = new _HeightMapText(node.length, this.height);
      else
        node.height = this.height;
      if (!this.outdated)
        node.outdated = false;
      return node;
    } else {
      return HeightMap.of(nodes);
    }
  }
  updateHeight(oracle, offset = 0, force = false, measured) {
    if (measured && measured.from <= offset && measured.more)
      this.setHeight(measured.heights[measured.index++]);
    else if (force || this.outdated)
      this.setHeight(Math.max(this.widgetHeight, oracle.heightForLine(this.length - this.collapsed)) + this.breaks * oracle.lineHeight);
    this.outdated = false;
    return this;
  }
  toString() {
    return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
  }
};
var HeightMapGap = class _HeightMapGap extends HeightMap {
  constructor(length) {
    super(length, 0);
  }
  heightMetrics(oracle, offset) {
    let firstLine = oracle.doc.lineAt(offset).number, lastLine = oracle.doc.lineAt(offset + this.length).number;
    let lines = lastLine - firstLine + 1;
    let perLine, perChar = 0;
    if (oracle.lineWrapping) {
      let totalPerLine = Math.min(this.height, oracle.lineHeight * lines);
      perLine = totalPerLine / lines;
      if (this.length > lines + 1)
        perChar = (this.height - totalPerLine) / (this.length - lines - 1);
    } else {
      perLine = this.height / lines;
    }
    return { firstLine, lastLine, perLine, perChar };
  }
  blockAt(height, oracle, top2, offset) {
    let { firstLine, lastLine, perLine, perChar } = this.heightMetrics(oracle, offset);
    if (oracle.lineWrapping) {
      let guess = offset + (height < oracle.lineHeight ? 0 : Math.round(Math.max(0, Math.min(1, (height - top2) / this.height)) * this.length));
      let line = oracle.doc.lineAt(guess), lineHeight = perLine + line.length * perChar;
      let lineTop = Math.max(top2, height - lineHeight / 2);
      return new BlockInfo(line.from, line.length, lineTop, lineHeight, 0);
    } else {
      let line = Math.max(0, Math.min(lastLine - firstLine, Math.floor((height - top2) / perLine)));
      let { from, length } = oracle.doc.line(firstLine + line);
      return new BlockInfo(from, length, top2 + perLine * line, perLine, 0);
    }
  }
  lineAt(value, type, oracle, top2, offset) {
    if (type == QueryType.ByHeight)
      return this.blockAt(value, oracle, top2, offset);
    if (type == QueryType.ByPosNoHeight) {
      let { from, to: to3 } = oracle.doc.lineAt(value);
      return new BlockInfo(from, to3 - from, 0, 0, 0);
    }
    let { firstLine, perLine, perChar } = this.heightMetrics(oracle, offset);
    let line = oracle.doc.lineAt(value), lineHeight = perLine + line.length * perChar;
    let linesAbove = line.number - firstLine;
    let lineTop = top2 + perLine * linesAbove + perChar * (line.from - offset - linesAbove);
    return new BlockInfo(line.from, line.length, Math.max(top2, Math.min(lineTop, top2 + this.height - lineHeight)), lineHeight, 0);
  }
  forEachLine(from, to3, oracle, top2, offset, f) {
    from = Math.max(from, offset);
    to3 = Math.min(to3, offset + this.length);
    let { firstLine, perLine, perChar } = this.heightMetrics(oracle, offset);
    for (let pos = from, lineTop = top2; pos <= to3; ) {
      let line = oracle.doc.lineAt(pos);
      if (pos == from) {
        let linesAbove = line.number - firstLine;
        lineTop += perLine * linesAbove + perChar * (from - offset - linesAbove);
      }
      let lineHeight = perLine + perChar * line.length;
      f(new BlockInfo(line.from, line.length, lineTop, lineHeight, 0));
      lineTop += lineHeight;
      pos = line.to + 1;
    }
  }
  replace(from, to3, nodes) {
    let after = this.length - to3;
    if (after > 0) {
      let last2 = nodes[nodes.length - 1];
      if (last2 instanceof _HeightMapGap)
        nodes[nodes.length - 1] = new _HeightMapGap(last2.length + after);
      else
        nodes.push(null, new _HeightMapGap(after - 1));
    }
    if (from > 0) {
      let first = nodes[0];
      if (first instanceof _HeightMapGap)
        nodes[0] = new _HeightMapGap(from + first.length);
      else
        nodes.unshift(new _HeightMapGap(from - 1), null);
    }
    return HeightMap.of(nodes);
  }
  decomposeLeft(to3, result) {
    result.push(new _HeightMapGap(to3 - 1), null);
  }
  decomposeRight(from, result) {
    result.push(null, new _HeightMapGap(this.length - from - 1));
  }
  updateHeight(oracle, offset = 0, force = false, measured) {
    let end = offset + this.length;
    if (measured && measured.from <= offset + this.length && measured.more) {
      let nodes = [], pos = Math.max(offset, measured.from), singleHeight = -1;
      if (measured.from > offset)
        nodes.push(new _HeightMapGap(measured.from - offset - 1).updateHeight(oracle, offset));
      while (pos <= end && measured.more) {
        let len = oracle.doc.lineAt(pos).length;
        if (nodes.length)
          nodes.push(null);
        let height = measured.heights[measured.index++];
        if (singleHeight == -1)
          singleHeight = height;
        else if (Math.abs(height - singleHeight) >= Epsilon)
          singleHeight = -2;
        let line = new HeightMapText(len, height);
        line.outdated = false;
        nodes.push(line);
        pos += len + 1;
      }
      if (pos <= end)
        nodes.push(null, new _HeightMapGap(end - pos).updateHeight(oracle, pos));
      let result = HeightMap.of(nodes);
      if (singleHeight < 0 || Math.abs(result.height - this.height) >= Epsilon || Math.abs(singleHeight - this.heightMetrics(oracle, offset).perLine) >= Epsilon)
        heightChangeFlag = true;
      return replace2(this, result);
    } else if (force || this.outdated) {
      this.setHeight(oracle.heightForGap(offset, offset + this.length));
      this.outdated = false;
    }
    return this;
  }
  toString() {
    return `gap(${this.length})`;
  }
};
var HeightMapBranch = class extends HeightMap {
  constructor(left, brk, right) {
    super(left.length + brk + right.length, left.height + right.height, brk | (left.outdated || right.outdated ? 2 : 0));
    this.left = left;
    this.right = right;
    this.size = left.size + right.size;
  }
  get break() {
    return this.flags & 1;
  }
  blockAt(height, oracle, top2, offset) {
    let mid = top2 + this.left.height;
    return height < mid ? this.left.blockAt(height, oracle, top2, offset) : this.right.blockAt(height, oracle, mid, offset + this.left.length + this.break);
  }
  lineAt(value, type, oracle, top2, offset) {
    let rightTop = top2 + this.left.height, rightOffset = offset + this.left.length + this.break;
    let left = type == QueryType.ByHeight ? value < rightTop : value < rightOffset;
    let base2 = left ? this.left.lineAt(value, type, oracle, top2, offset) : this.right.lineAt(value, type, oracle, rightTop, rightOffset);
    if (this.break || (left ? base2.to < rightOffset : base2.from > rightOffset))
      return base2;
    let subQuery = type == QueryType.ByPosNoHeight ? QueryType.ByPosNoHeight : QueryType.ByPos;
    if (left)
      return base2.join(this.right.lineAt(rightOffset, subQuery, oracle, rightTop, rightOffset));
    else
      return this.left.lineAt(rightOffset, subQuery, oracle, top2, offset).join(base2);
  }
  forEachLine(from, to3, oracle, top2, offset, f) {
    let rightTop = top2 + this.left.height, rightOffset = offset + this.left.length + this.break;
    if (this.break) {
      if (from < rightOffset)
        this.left.forEachLine(from, to3, oracle, top2, offset, f);
      if (to3 >= rightOffset)
        this.right.forEachLine(from, to3, oracle, rightTop, rightOffset, f);
    } else {
      let mid = this.lineAt(rightOffset, QueryType.ByPos, oracle, top2, offset);
      if (from < mid.from)
        this.left.forEachLine(from, mid.from - 1, oracle, top2, offset, f);
      if (mid.to >= from && mid.from <= to3)
        f(mid);
      if (to3 > mid.to)
        this.right.forEachLine(mid.to + 1, to3, oracle, rightTop, rightOffset, f);
    }
  }
  replace(from, to3, nodes) {
    let rightStart = this.left.length + this.break;
    if (to3 < rightStart)
      return this.balanced(this.left.replace(from, to3, nodes), this.right);
    if (from > this.left.length)
      return this.balanced(this.left, this.right.replace(from - rightStart, to3 - rightStart, nodes));
    let result = [];
    if (from > 0)
      this.decomposeLeft(from, result);
    let left = result.length;
    for (let node of nodes)
      result.push(node);
    if (from > 0)
      mergeGaps(result, left - 1);
    if (to3 < this.length) {
      let right = result.length;
      this.decomposeRight(to3, result);
      mergeGaps(result, right);
    }
    return HeightMap.of(result);
  }
  decomposeLeft(to3, result) {
    let left = this.left.length;
    if (to3 <= left)
      return this.left.decomposeLeft(to3, result);
    result.push(this.left);
    if (this.break) {
      left++;
      if (to3 >= left)
        result.push(null);
    }
    if (to3 > left)
      this.right.decomposeLeft(to3 - left, result);
  }
  decomposeRight(from, result) {
    let left = this.left.length, right = left + this.break;
    if (from >= right)
      return this.right.decomposeRight(from - right, result);
    if (from < left)
      this.left.decomposeRight(from, result);
    if (this.break && from < right)
      result.push(null);
    result.push(this.right);
  }
  balanced(left, right) {
    if (left.size > 2 * right.size || right.size > 2 * left.size)
      return HeightMap.of(this.break ? [left, null, right] : [left, right]);
    this.left = replace2(this.left, left);
    this.right = replace2(this.right, right);
    this.setHeight(left.height + right.height);
    this.outdated = left.outdated || right.outdated;
    this.size = left.size + right.size;
    this.length = left.length + this.break + right.length;
    return this;
  }
  updateHeight(oracle, offset = 0, force = false, measured) {
    let { left, right } = this, rightStart = offset + left.length + this.break, rebalance = null;
    if (measured && measured.from <= offset + left.length && measured.more)
      rebalance = left = left.updateHeight(oracle, offset, force, measured);
    else
      left.updateHeight(oracle, offset, force);
    if (measured && measured.from <= rightStart + right.length && measured.more)
      rebalance = right = right.updateHeight(oracle, rightStart, force, measured);
    else
      right.updateHeight(oracle, rightStart, force);
    if (rebalance)
      return this.balanced(left, right);
    this.height = this.left.height + this.right.height;
    this.outdated = false;
    return this;
  }
  toString() {
    return this.left + (this.break ? " " : "-") + this.right;
  }
};
function mergeGaps(nodes, around) {
  let before, after;
  if (nodes[around] == null && (before = nodes[around - 1]) instanceof HeightMapGap && (after = nodes[around + 1]) instanceof HeightMapGap)
    nodes.splice(around - 1, 3, new HeightMapGap(before.length + 1 + after.length));
}
var relevantWidgetHeight = 5;
var NodeBuilder = class _NodeBuilder {
  constructor(pos, oracle) {
    this.pos = pos;
    this.oracle = oracle;
    this.nodes = [];
    this.lineStart = -1;
    this.lineEnd = -1;
    this.covering = null;
    this.writtenTo = pos;
  }
  get isCovered() {
    return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
  }
  span(_from, to3) {
    if (this.lineStart > -1) {
      let end = Math.min(to3, this.lineEnd), last2 = this.nodes[this.nodes.length - 1];
      if (last2 instanceof HeightMapText)
        last2.length += end - this.pos;
      else if (end > this.pos || !this.isCovered)
        this.nodes.push(new HeightMapText(end - this.pos, -1));
      this.writtenTo = end;
      if (to3 > end) {
        this.nodes.push(null);
        this.writtenTo++;
        this.lineStart = -1;
      }
    }
    this.pos = to3;
  }
  point(from, to3, deco) {
    if (from < to3 || deco.heightRelevant) {
      let height = deco.widget ? deco.widget.estimatedHeight : 0;
      let breaks = deco.widget ? deco.widget.lineBreaks : 0;
      if (height < 0)
        height = this.oracle.lineHeight;
      let len = to3 - from;
      if (deco.block) {
        this.addBlock(new HeightMapBlock(len, height, deco));
      } else if (len || breaks || height >= relevantWidgetHeight) {
        this.addLineDeco(height, breaks, len);
      }
    } else if (to3 > from) {
      this.span(from, to3);
    }
    if (this.lineEnd > -1 && this.lineEnd < this.pos)
      this.lineEnd = this.oracle.doc.lineAt(this.pos).to;
  }
  enterLine() {
    if (this.lineStart > -1)
      return;
    let { from, to: to3 } = this.oracle.doc.lineAt(this.pos);
    this.lineStart = from;
    this.lineEnd = to3;
    if (this.writtenTo < from) {
      if (this.writtenTo < from - 1 || this.nodes[this.nodes.length - 1] == null)
        this.nodes.push(this.blankContent(this.writtenTo, from - 1));
      this.nodes.push(null);
    }
    if (this.pos > from)
      this.nodes.push(new HeightMapText(this.pos - from, -1));
    this.writtenTo = this.pos;
  }
  blankContent(from, to3) {
    let gap = new HeightMapGap(to3 - from);
    if (this.oracle.doc.lineAt(from).to == to3)
      gap.flags |= 4;
    return gap;
  }
  ensureLine() {
    this.enterLine();
    let last2 = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
    if (last2 instanceof HeightMapText)
      return last2;
    let line = new HeightMapText(0, -1);
    this.nodes.push(line);
    return line;
  }
  addBlock(block) {
    this.enterLine();
    let deco = block.deco;
    if (deco && deco.startSide > 0 && !this.isCovered)
      this.ensureLine();
    this.nodes.push(block);
    this.writtenTo = this.pos = this.pos + block.length;
    if (deco && deco.endSide > 0)
      this.covering = block;
  }
  addLineDeco(height, breaks, length) {
    let line = this.ensureLine();
    line.length += length;
    line.collapsed += length;
    line.widgetHeight = Math.max(line.widgetHeight, height);
    line.breaks += breaks;
    this.writtenTo = this.pos = this.pos + length;
  }
  finish(from) {
    let last2 = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
    if (this.lineStart > -1 && !(last2 instanceof HeightMapText) && !this.isCovered)
      this.nodes.push(new HeightMapText(0, -1));
    else if (this.writtenTo < this.pos || last2 == null)
      this.nodes.push(this.blankContent(this.writtenTo, this.pos));
    let pos = from;
    for (let node of this.nodes) {
      if (node instanceof HeightMapText)
        node.updateHeight(this.oracle, pos);
      pos += node ? node.length : 1;
    }
    return this.nodes;
  }
  // Always called with a region that on both sides either stretches
  // to a line break or the end of the document.
  // The returned array uses null to indicate line breaks, but never
  // starts or ends in a line break, or has multiple line breaks next
  // to each other.
  static build(oracle, decorations2, from, to3) {
    let builder = new _NodeBuilder(from, oracle);
    RangeSet.spans(decorations2, from, to3, builder, 0);
    return builder.finish(from);
  }
};
function heightRelevantDecoChanges(a2, b2, diff) {
  let comp = new DecorationComparator2();
  RangeSet.compare(a2, b2, diff, comp, 0);
  return comp.changes;
}
var DecorationComparator2 = class {
  constructor() {
    this.changes = [];
  }
  compareRange() {
  }
  comparePoint(from, to3, a2, b2) {
    if (from < to3 || a2 && a2.heightRelevant || b2 && b2.heightRelevant)
      addRange(from, to3, this.changes, 5);
  }
};
function visiblePixelRange(dom, paddingTop) {
  let rect = dom.getBoundingClientRect();
  let doc2 = dom.ownerDocument, win = doc2.defaultView || window;
  let left = Math.max(0, rect.left), right = Math.min(win.innerWidth, rect.right);
  let top2 = Math.max(0, rect.top), bottom = Math.min(win.innerHeight, rect.bottom);
  for (let parent = dom.parentNode; parent && parent != doc2.body; ) {
    if (parent.nodeType == 1) {
      let elt = parent;
      let style = window.getComputedStyle(elt);
      if ((elt.scrollHeight > elt.clientHeight || elt.scrollWidth > elt.clientWidth) && style.overflow != "visible") {
        let parentRect = elt.getBoundingClientRect();
        left = Math.max(left, parentRect.left);
        right = Math.min(right, parentRect.right);
        top2 = Math.max(top2, parentRect.top);
        bottom = Math.min(parent == dom.parentNode ? win.innerHeight : bottom, parentRect.bottom);
      }
      parent = style.position == "absolute" || style.position == "fixed" ? elt.offsetParent : elt.parentNode;
    } else if (parent.nodeType == 11) {
      parent = parent.host;
    } else {
      break;
    }
  }
  return {
    left: left - rect.left,
    right: Math.max(left, right) - rect.left,
    top: top2 - (rect.top + paddingTop),
    bottom: Math.max(top2, bottom) - (rect.top + paddingTop)
  };
}
function fullPixelRange(dom, paddingTop) {
  let rect = dom.getBoundingClientRect();
  return {
    left: 0,
    right: rect.right - rect.left,
    top: paddingTop,
    bottom: rect.bottom - (rect.top + paddingTop)
  };
}
var LineGap = class {
  constructor(from, to3, size, displaySize) {
    this.from = from;
    this.to = to3;
    this.size = size;
    this.displaySize = displaySize;
  }
  static same(a2, b2) {
    if (a2.length != b2.length)
      return false;
    for (let i2 = 0; i2 < a2.length; i2++) {
      let gA = a2[i2], gB = b2[i2];
      if (gA.from != gB.from || gA.to != gB.to || gA.size != gB.size)
        return false;
    }
    return true;
  }
  draw(viewState, wrapping) {
    return Decoration.replace({
      widget: new LineGapWidget(this.displaySize * (wrapping ? viewState.scaleY : viewState.scaleX), wrapping)
    }).range(this.from, this.to);
  }
};
var LineGapWidget = class extends WidgetType {
  constructor(size, vertical) {
    super();
    this.size = size;
    this.vertical = vertical;
  }
  eq(other) {
    return other.size == this.size && other.vertical == this.vertical;
  }
  toDOM() {
    let elt = document.createElement("div");
    if (this.vertical) {
      elt.style.height = this.size + "px";
    } else {
      elt.style.width = this.size + "px";
      elt.style.height = "2px";
      elt.style.display = "inline-block";
    }
    return elt;
  }
  get estimatedHeight() {
    return this.vertical ? this.size : -1;
  }
};
var ViewState = class {
  constructor(state) {
    this.state = state;
    this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 };
    this.inView = true;
    this.paddingTop = 0;
    this.paddingBottom = 0;
    this.contentDOMWidth = 0;
    this.contentDOMHeight = 0;
    this.editorHeight = 0;
    this.editorWidth = 0;
    this.scrollTop = 0;
    this.scrolledToBottom = false;
    this.scaleX = 1;
    this.scaleY = 1;
    this.scrollAnchorPos = 0;
    this.scrollAnchorHeight = -1;
    this.scaler = IdScaler;
    this.scrollTarget = null;
    this.printing = false;
    this.mustMeasureContent = true;
    this.defaultTextDirection = Direction.LTR;
    this.visibleRanges = [];
    this.mustEnforceCursorAssoc = false;
    let guessWrapping = state.facet(contentAttributes).some((v) => typeof v != "function" && v.class == "cm-lineWrapping");
    this.heightOracle = new HeightOracle(guessWrapping);
    this.stateDeco = state.facet(decorations).filter((d) => typeof d != "function");
    this.heightMap = HeightMap.empty().applyChanges(this.stateDeco, Text.empty, this.heightOracle.setDoc(state.doc), [new ChangedRange(0, 0, 0, state.doc.length)]);
    for (let i2 = 0; i2 < 2; i2++) {
      this.viewport = this.getViewport(0, null);
      if (!this.updateForViewport())
        break;
    }
    this.updateViewportLines();
    this.lineGaps = this.ensureLineGaps([]);
    this.lineGapDeco = Decoration.set(this.lineGaps.map((gap) => gap.draw(this, false)));
    this.computeVisibleRanges();
  }
  updateForViewport() {
    let viewports = [this.viewport], { main } = this.state.selection;
    for (let i2 = 0; i2 <= 1; i2++) {
      let pos = i2 ? main.head : main.anchor;
      if (!viewports.some(({ from, to: to3 }) => pos >= from && pos <= to3)) {
        let { from, to: to3 } = this.lineBlockAt(pos);
        viewports.push(new Viewport(from, to3));
      }
    }
    this.viewports = viewports.sort((a2, b2) => a2.from - b2.from);
    return this.updateScaler();
  }
  updateScaler() {
    let scaler = this.scaler;
    this.scaler = this.heightMap.height <= 7e6 ? IdScaler : new BigScaler(this.heightOracle, this.heightMap, this.viewports);
    return scaler.eq(this.scaler) ? 0 : 2;
  }
  updateViewportLines() {
    this.viewportLines = [];
    this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, (block) => {
      this.viewportLines.push(scaleBlock(block, this.scaler));
    });
  }
  update(update, scrollTarget = null) {
    this.state = update.state;
    let prevDeco = this.stateDeco;
    this.stateDeco = this.state.facet(decorations).filter((d) => typeof d != "function");
    let contentChanges = update.changedRanges;
    let heightChanges = ChangedRange.extendWithRanges(contentChanges, heightRelevantDecoChanges(prevDeco, this.stateDeco, update ? update.changes : ChangeSet.empty(this.state.doc.length)));
    let prevHeight = this.heightMap.height;
    let scrollAnchor = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop);
    clearHeightChangeFlag();
    this.heightMap = this.heightMap.applyChanges(this.stateDeco, update.startState.doc, this.heightOracle.setDoc(this.state.doc), heightChanges);
    if (this.heightMap.height != prevHeight || heightChangeFlag)
      update.flags |= 2;
    if (scrollAnchor) {
      this.scrollAnchorPos = update.changes.mapPos(scrollAnchor.from, -1);
      this.scrollAnchorHeight = scrollAnchor.top;
    } else {
      this.scrollAnchorPos = -1;
      this.scrollAnchorHeight = this.heightMap.height;
    }
    let viewport = heightChanges.length ? this.mapViewport(this.viewport, update.changes) : this.viewport;
    if (scrollTarget && (scrollTarget.range.head < viewport.from || scrollTarget.range.head > viewport.to) || !this.viewportIsAppropriate(viewport))
      viewport = this.getViewport(0, scrollTarget);
    let viewportChange = viewport.from != this.viewport.from || viewport.to != this.viewport.to;
    this.viewport = viewport;
    update.flags |= this.updateForViewport();
    if (viewportChange || !update.changes.empty || update.flags & 2)
      this.updateViewportLines();
    if (this.lineGaps.length || this.viewport.to - this.viewport.from > 2e3 << 1)
      this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, update.changes)));
    update.flags |= this.computeVisibleRanges();
    if (scrollTarget)
      this.scrollTarget = scrollTarget;
    if (!this.mustEnforceCursorAssoc && update.selectionSet && update.view.lineWrapping && update.state.selection.main.empty && update.state.selection.main.assoc && !update.state.facet(nativeSelectionHidden))
      this.mustEnforceCursorAssoc = true;
  }
  measure(view) {
    let dom = view.contentDOM, style = window.getComputedStyle(dom);
    let oracle = this.heightOracle;
    let whiteSpace = style.whiteSpace;
    this.defaultTextDirection = style.direction == "rtl" ? Direction.RTL : Direction.LTR;
    let refresh = this.heightOracle.mustRefreshForWrapping(whiteSpace);
    let domRect = dom.getBoundingClientRect();
    let measureContent = refresh || this.mustMeasureContent || this.contentDOMHeight != domRect.height;
    this.contentDOMHeight = domRect.height;
    this.mustMeasureContent = false;
    let result = 0, bias = 0;
    if (domRect.width && domRect.height) {
      let { scaleX, scaleY } = getScale(dom, domRect);
      if (scaleX > 5e-3 && Math.abs(this.scaleX - scaleX) > 5e-3 || scaleY > 5e-3 && Math.abs(this.scaleY - scaleY) > 5e-3) {
        this.scaleX = scaleX;
        this.scaleY = scaleY;
        result |= 8;
        refresh = measureContent = true;
      }
    }
    let paddingTop = (parseInt(style.paddingTop) || 0) * this.scaleY;
    let paddingBottom = (parseInt(style.paddingBottom) || 0) * this.scaleY;
    if (this.paddingTop != paddingTop || this.paddingBottom != paddingBottom) {
      this.paddingTop = paddingTop;
      this.paddingBottom = paddingBottom;
      result |= 8 | 2;
    }
    if (this.editorWidth != view.scrollDOM.clientWidth) {
      if (oracle.lineWrapping)
        measureContent = true;
      this.editorWidth = view.scrollDOM.clientWidth;
      result |= 8;
    }
    let scrollTop = view.scrollDOM.scrollTop * this.scaleY;
    if (this.scrollTop != scrollTop) {
      this.scrollAnchorHeight = -1;
      this.scrollTop = scrollTop;
    }
    this.scrolledToBottom = isScrolledToBottom(view.scrollDOM);
    let pixelViewport = (this.printing ? fullPixelRange : visiblePixelRange)(dom, this.paddingTop);
    let dTop = pixelViewport.top - this.pixelViewport.top, dBottom = pixelViewport.bottom - this.pixelViewport.bottom;
    this.pixelViewport = pixelViewport;
    let inView = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
    if (inView != this.inView) {
      this.inView = inView;
      if (inView)
        measureContent = true;
    }
    if (!this.inView && !this.scrollTarget)
      return 0;
    let contentWidth = domRect.width;
    if (this.contentDOMWidth != contentWidth || this.editorHeight != view.scrollDOM.clientHeight) {
      this.contentDOMWidth = domRect.width;
      this.editorHeight = view.scrollDOM.clientHeight;
      result |= 8;
    }
    if (measureContent) {
      let lineHeights = view.docView.measureVisibleLineHeights(this.viewport);
      if (oracle.mustRefreshForHeights(lineHeights))
        refresh = true;
      if (refresh || oracle.lineWrapping && Math.abs(contentWidth - this.contentDOMWidth) > oracle.charWidth) {
        let { lineHeight, charWidth, textHeight } = view.docView.measureTextSize();
        refresh = lineHeight > 0 && oracle.refresh(whiteSpace, lineHeight, charWidth, textHeight, contentWidth / charWidth, lineHeights);
        if (refresh) {
          view.docView.minWidth = 0;
          result |= 8;
        }
      }
      if (dTop > 0 && dBottom > 0)
        bias = Math.max(dTop, dBottom);
      else if (dTop < 0 && dBottom < 0)
        bias = Math.min(dTop, dBottom);
      clearHeightChangeFlag();
      for (let vp2 of this.viewports) {
        let heights = vp2.from == this.viewport.from ? lineHeights : view.docView.measureVisibleLineHeights(vp2);
        this.heightMap = (refresh ? HeightMap.empty().applyChanges(this.stateDeco, Text.empty, this.heightOracle, [new ChangedRange(0, 0, 0, view.state.doc.length)]) : this.heightMap).updateHeight(oracle, 0, refresh, new MeasuredHeights(vp2.from, heights));
      }
      if (heightChangeFlag)
        result |= 2;
    }
    let viewportChange = !this.viewportIsAppropriate(this.viewport, bias) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);
    if (viewportChange) {
      if (result & 2)
        result |= this.updateScaler();
      this.viewport = this.getViewport(bias, this.scrollTarget);
      result |= this.updateForViewport();
    }
    if (result & 2 || viewportChange)
      this.updateViewportLines();
    if (this.lineGaps.length || this.viewport.to - this.viewport.from > 2e3 << 1)
      this.updateLineGaps(this.ensureLineGaps(refresh ? [] : this.lineGaps, view));
    result |= this.computeVisibleRanges();
    if (this.mustEnforceCursorAssoc) {
      this.mustEnforceCursorAssoc = false;
      view.docView.enforceCursorAssoc();
    }
    return result;
  }
  get visibleTop() {
    return this.scaler.fromDOM(this.pixelViewport.top);
  }
  get visibleBottom() {
    return this.scaler.fromDOM(this.pixelViewport.bottom);
  }
  getViewport(bias, scrollTarget) {
    let marginTop = 0.5 - Math.max(-0.5, Math.min(0.5, bias / 1e3 / 2));
    let map = this.heightMap, oracle = this.heightOracle;
    let { visibleTop, visibleBottom } = this;
    let viewport = new Viewport(map.lineAt(visibleTop - marginTop * 1e3, QueryType.ByHeight, oracle, 0, 0).from, map.lineAt(visibleBottom + (1 - marginTop) * 1e3, QueryType.ByHeight, oracle, 0, 0).to);
    if (scrollTarget) {
      let { head } = scrollTarget.range;
      if (head < viewport.from || head > viewport.to) {
        let viewHeight = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top);
        let block = map.lineAt(head, QueryType.ByPos, oracle, 0, 0), topPos;
        if (scrollTarget.y == "center")
          topPos = (block.top + block.bottom) / 2 - viewHeight / 2;
        else if (scrollTarget.y == "start" || scrollTarget.y == "nearest" && head < viewport.from)
          topPos = block.top;
        else
          topPos = block.bottom - viewHeight;
        viewport = new Viewport(map.lineAt(topPos - 1e3 / 2, QueryType.ByHeight, oracle, 0, 0).from, map.lineAt(topPos + viewHeight + 1e3 / 2, QueryType.ByHeight, oracle, 0, 0).to);
      }
    }
    return viewport;
  }
  mapViewport(viewport, changes) {
    let from = changes.mapPos(viewport.from, -1), to3 = changes.mapPos(viewport.to, 1);
    return new Viewport(this.heightMap.lineAt(from, QueryType.ByPos, this.heightOracle, 0, 0).from, this.heightMap.lineAt(to3, QueryType.ByPos, this.heightOracle, 0, 0).to);
  }
  // Checks if a given viewport covers the visible part of the
  // document and not too much beyond that.
  viewportIsAppropriate({ from, to: to3 }, bias = 0) {
    if (!this.inView)
      return true;
    let { top: top2 } = this.heightMap.lineAt(from, QueryType.ByPos, this.heightOracle, 0, 0);
    let { bottom } = this.heightMap.lineAt(to3, QueryType.ByPos, this.heightOracle, 0, 0);
    let { visibleTop, visibleBottom } = this;
    return (from == 0 || top2 <= visibleTop - Math.max(10, Math.min(
      -bias,
      250
      /* VP.MaxCoverMargin */
    ))) && (to3 == this.state.doc.length || bottom >= visibleBottom + Math.max(10, Math.min(
      bias,
      250
      /* VP.MaxCoverMargin */
    ))) && (top2 > visibleTop - 2 * 1e3 && bottom < visibleBottom + 2 * 1e3);
  }
  mapLineGaps(gaps, changes) {
    if (!gaps.length || changes.empty)
      return gaps;
    let mapped = [];
    for (let gap of gaps)
      if (!changes.touchesRange(gap.from, gap.to))
        mapped.push(new LineGap(changes.mapPos(gap.from), changes.mapPos(gap.to), gap.size, gap.displaySize));
    return mapped;
  }
  // Computes positions in the viewport where the start or end of a
  // line should be hidden, trying to reuse existing line gaps when
  // appropriate to avoid unneccesary redraws.
  // Uses crude character-counting for the positioning and sizing,
  // since actual DOM coordinates aren't always available and
  // predictable. Relies on generous margins (see LG.Margin) to hide
  // the artifacts this might produce from the user.
  ensureLineGaps(current, mayMeasure) {
    let wrapping = this.heightOracle.lineWrapping;
    let margin = wrapping ? 1e4 : 2e3, halfMargin = margin >> 1, doubleMargin = margin << 1;
    if (this.defaultTextDirection != Direction.LTR && !wrapping)
      return [];
    let gaps = [];
    let addGap = (from, to3, line, structure) => {
      if (to3 - from < halfMargin)
        return;
      let sel = this.state.selection.main, avoid = [sel.from];
      if (!sel.empty)
        avoid.push(sel.to);
      for (let pos of avoid) {
        if (pos > from && pos < to3) {
          addGap(from, pos - 10, line, structure);
          addGap(pos + 10, to3, line, structure);
          return;
        }
      }
      let gap = find(current, (gap2) => gap2.from >= line.from && gap2.to <= line.to && Math.abs(gap2.from - from) < halfMargin && Math.abs(gap2.to - to3) < halfMargin && !avoid.some((pos) => gap2.from < pos && gap2.to > pos));
      if (!gap) {
        if (to3 < line.to && mayMeasure && wrapping && mayMeasure.visibleRanges.some((r2) => r2.from <= to3 && r2.to >= to3)) {
          let lineStart = mayMeasure.moveToLineBoundary(EditorSelection.cursor(to3), false, true).head;
          if (lineStart > from)
            to3 = lineStart;
        }
        let size = this.gapSize(line, from, to3, structure);
        let displaySize = wrapping || size < 2e6 ? size : 2e6;
        gap = new LineGap(from, to3, size, displaySize);
      }
      gaps.push(gap);
    };
    let checkLine = (line) => {
      if (line.length < doubleMargin || line.type != BlockType.Text)
        return;
      let structure = lineStructure(line.from, line.to, this.stateDeco);
      if (structure.total < doubleMargin)
        return;
      let target = this.scrollTarget ? this.scrollTarget.range.head : null;
      let viewFrom, viewTo;
      if (wrapping) {
        let marginHeight = margin / this.heightOracle.lineLength * this.heightOracle.lineHeight;
        let top2, bot;
        if (target != null) {
          let targetFrac = findFraction(structure, target);
          let spaceFrac = ((this.visibleBottom - this.visibleTop) / 2 + marginHeight) / line.height;
          top2 = targetFrac - spaceFrac;
          bot = targetFrac + spaceFrac;
        } else {
          top2 = (this.visibleTop - line.top - marginHeight) / line.height;
          bot = (this.visibleBottom - line.top + marginHeight) / line.height;
        }
        viewFrom = findPosition(structure, top2);
        viewTo = findPosition(structure, bot);
      } else {
        let totalWidth = structure.total * this.heightOracle.charWidth;
        let marginWidth = margin * this.heightOracle.charWidth;
        let horizOffset = 0;
        if (totalWidth > 2e6)
          for (let old of current) {
            if (old.from >= line.from && old.from < line.to && old.size != old.displaySize && old.from * this.heightOracle.charWidth + horizOffset < this.pixelViewport.left)
              horizOffset = old.size - old.displaySize;
          }
        let pxLeft = this.pixelViewport.left + horizOffset, pxRight = this.pixelViewport.right + horizOffset;
        let left, right;
        if (target != null) {
          let targetFrac = findFraction(structure, target);
          let spaceFrac = ((pxRight - pxLeft) / 2 + marginWidth) / totalWidth;
          left = targetFrac - spaceFrac;
          right = targetFrac + spaceFrac;
        } else {
          left = (pxLeft - marginWidth) / totalWidth;
          right = (pxRight + marginWidth) / totalWidth;
        }
        viewFrom = findPosition(structure, left);
        viewTo = findPosition(structure, right);
      }
      if (viewFrom > line.from)
        addGap(line.from, viewFrom, line, structure);
      if (viewTo < line.to)
        addGap(viewTo, line.to, line, structure);
    };
    for (let line of this.viewportLines) {
      if (Array.isArray(line.type))
        line.type.forEach(checkLine);
      else
        checkLine(line);
    }
    return gaps;
  }
  gapSize(line, from, to3, structure) {
    let fraction = findFraction(structure, to3) - findFraction(structure, from);
    if (this.heightOracle.lineWrapping) {
      return line.height * fraction;
    } else {
      return structure.total * this.heightOracle.charWidth * fraction;
    }
  }
  updateLineGaps(gaps) {
    if (!LineGap.same(gaps, this.lineGaps)) {
      this.lineGaps = gaps;
      this.lineGapDeco = Decoration.set(gaps.map((gap) => gap.draw(this, this.heightOracle.lineWrapping)));
    }
  }
  computeVisibleRanges() {
    let deco = this.stateDeco;
    if (this.lineGaps.length)
      deco = deco.concat(this.lineGapDeco);
    let ranges = [];
    RangeSet.spans(deco, this.viewport.from, this.viewport.to, {
      span(from, to3) {
        ranges.push({ from, to: to3 });
      },
      point() {
      }
    }, 20);
    let changed = ranges.length != this.visibleRanges.length || this.visibleRanges.some((r2, i2) => r2.from != ranges[i2].from || r2.to != ranges[i2].to);
    this.visibleRanges = ranges;
    return changed ? 4 : 0;
  }
  lineBlockAt(pos) {
    return pos >= this.viewport.from && pos <= this.viewport.to && this.viewportLines.find((b2) => b2.from <= pos && b2.to >= pos) || scaleBlock(this.heightMap.lineAt(pos, QueryType.ByPos, this.heightOracle, 0, 0), this.scaler);
  }
  lineBlockAtHeight(height) {
    return height >= this.viewportLines[0].top && height <= this.viewportLines[this.viewportLines.length - 1].bottom && this.viewportLines.find((l) => l.top <= height && l.bottom >= height) || scaleBlock(this.heightMap.lineAt(this.scaler.fromDOM(height), QueryType.ByHeight, this.heightOracle, 0, 0), this.scaler);
  }
  scrollAnchorAt(scrollTop) {
    let block = this.lineBlockAtHeight(scrollTop + 8);
    return block.from >= this.viewport.from || this.viewportLines[0].top - scrollTop > 200 ? block : this.viewportLines[0];
  }
  elementAtHeight(height) {
    return scaleBlock(this.heightMap.blockAt(this.scaler.fromDOM(height), this.heightOracle, 0, 0), this.scaler);
  }
  get docHeight() {
    return this.scaler.toDOM(this.heightMap.height);
  }
  get contentHeight() {
    return this.docHeight + this.paddingTop + this.paddingBottom;
  }
};
var Viewport = class {
  constructor(from, to3) {
    this.from = from;
    this.to = to3;
  }
};
function lineStructure(from, to3, stateDeco) {
  let ranges = [], pos = from, total = 0;
  RangeSet.spans(stateDeco, from, to3, {
    span() {
    },
    point(from2, to4) {
      if (from2 > pos) {
        ranges.push({ from: pos, to: from2 });
        total += from2 - pos;
      }
      pos = to4;
    }
  }, 20);
  if (pos < to3) {
    ranges.push({ from: pos, to: to3 });
    total += to3 - pos;
  }
  return { total, ranges };
}
function findPosition({ total, ranges }, ratio) {
  if (ratio <= 0)
    return ranges[0].from;
  if (ratio >= 1)
    return ranges[ranges.length - 1].to;
  let dist2 = Math.floor(total * ratio);
  for (let i2 = 0; ; i2++) {
    let { from, to: to3 } = ranges[i2], size = to3 - from;
    if (dist2 <= size)
      return from + dist2;
    dist2 -= size;
  }
}
function findFraction(structure, pos) {
  let counted = 0;
  for (let { from, to: to3 } of structure.ranges) {
    if (pos <= to3) {
      counted += pos - from;
      break;
    }
    counted += to3 - from;
  }
  return counted / structure.total;
}
function find(array, f) {
  for (let val of array)
    if (f(val))
      return val;
  return void 0;
}
var IdScaler = {
  toDOM(n2) {
    return n2;
  },
  fromDOM(n2) {
    return n2;
  },
  scale: 1,
  eq(other) {
    return other == this;
  }
};
var BigScaler = class _BigScaler {
  constructor(oracle, heightMap, viewports) {
    let vpHeight = 0, base2 = 0, domBase = 0;
    this.viewports = viewports.map(({ from, to: to3 }) => {
      let top2 = heightMap.lineAt(from, QueryType.ByPos, oracle, 0, 0).top;
      let bottom = heightMap.lineAt(to3, QueryType.ByPos, oracle, 0, 0).bottom;
      vpHeight += bottom - top2;
      return { from, to: to3, top: top2, bottom, domTop: 0, domBottom: 0 };
    });
    this.scale = (7e6 - vpHeight) / (heightMap.height - vpHeight);
    for (let obj of this.viewports) {
      obj.domTop = domBase + (obj.top - base2) * this.scale;
      domBase = obj.domBottom = obj.domTop + (obj.bottom - obj.top);
      base2 = obj.bottom;
    }
  }
  toDOM(n2) {
    for (let i2 = 0, base2 = 0, domBase = 0; ; i2++) {
      let vp2 = i2 < this.viewports.length ? this.viewports[i2] : null;
      if (!vp2 || n2 < vp2.top)
        return domBase + (n2 - base2) * this.scale;
      if (n2 <= vp2.bottom)
        return vp2.domTop + (n2 - vp2.top);
      base2 = vp2.bottom;
      domBase = vp2.domBottom;
    }
  }
  fromDOM(n2) {
    for (let i2 = 0, base2 = 0, domBase = 0; ; i2++) {
      let vp2 = i2 < this.viewports.length ? this.viewports[i2] : null;
      if (!vp2 || n2 < vp2.domTop)
        return base2 + (n2 - domBase) / this.scale;
      if (n2 <= vp2.domBottom)
        return vp2.top + (n2 - vp2.domTop);
      base2 = vp2.bottom;
      domBase = vp2.domBottom;
    }
  }
  eq(other) {
    if (!(other instanceof _BigScaler))
      return false;
    return this.scale == other.scale && this.viewports.length == other.viewports.length && this.viewports.every((vp2, i2) => vp2.from == other.viewports[i2].from && vp2.to == other.viewports[i2].to);
  }
};
function scaleBlock(block, scaler) {
  if (scaler.scale == 1)
    return block;
  let bTop = scaler.toDOM(block.top), bBottom = scaler.toDOM(block.bottom);
  return new BlockInfo(block.from, block.length, bTop, bBottom - bTop, Array.isArray(block._content) ? block._content.map((b2) => scaleBlock(b2, scaler)) : block._content);
}
var theme = Facet.define({ combine: (strs) => strs.join(" ") });
var darkTheme = Facet.define({ combine: (values) => values.indexOf(true) > -1 });
var baseThemeID = StyleModule.newName();
var baseLightID = StyleModule.newName();
var baseDarkID = StyleModule.newName();
var lightDarkIDs = { "&light": "." + baseLightID, "&dark": "." + baseDarkID };
function buildTheme(main, spec, scopes) {
  return new StyleModule(spec, {
    finish(sel) {
      return /&/.test(sel) ? sel.replace(/&\w*/, (m3) => {
        if (m3 == "&")
          return main;
        if (!scopes || !scopes[m3])
          throw new RangeError(`Unsupported selector: ${m3}`);
        return scopes[m3];
      }) : main + " " + sel;
    }
  });
}
var baseTheme$1 = buildTheme("." + baseThemeID, {
  "&": {
    position: "relative !important",
    boxSizing: "border-box",
    "&.cm-focused": {
      // Provide a simple default outline to make sure a focused
      // editor is visually distinct. Can't leave the default behavior
      // because that will apply to the content element, which is
      // inside the scrollable container and doesn't include the
      // gutters. We also can't use an 'auto' outline, since those
      // are, for some reason, drawn behind the element content, which
      // will cause things like the active line background to cover
      // the outline (#297).
      outline: "1px dotted #212121"
    },
    display: "flex !important",
    flexDirection: "column"
  },
  ".cm-scroller": {
    display: "flex !important",
    alignItems: "flex-start !important",
    fontFamily: "monospace",
    lineHeight: 1.4,
    height: "100%",
    overflowX: "auto",
    position: "relative",
    zIndex: 0,
    overflowAnchor: "none"
  },
  ".cm-content": {
    margin: 0,
    flexGrow: 2,
    flexShrink: 0,
    display: "block",
    whiteSpace: "pre",
    wordWrap: "normal",
    // https://github.com/codemirror/dev/issues/456
    boxSizing: "border-box",
    minHeight: "100%",
    padding: "4px 0",
    outline: "none",
    "&[contenteditable=true]": {
      WebkitUserModify: "read-write-plaintext-only"
    }
  },
  ".cm-lineWrapping": {
    whiteSpace_fallback: "pre-wrap",
    // For IE
    whiteSpace: "break-spaces",
    wordBreak: "break-word",
    // For Safari, which doesn't support overflow-wrap: anywhere
    overflowWrap: "anywhere",
    flexShrink: 1
  },
  "&light .cm-content": { caretColor: "black" },
  "&dark .cm-content": { caretColor: "white" },
  ".cm-line": {
    display: "block",
    padding: "0 2px 0 6px"
  },
  ".cm-layer": {
    position: "absolute",
    left: 0,
    top: 0,
    contain: "size style",
    "& > *": {
      position: "absolute"
    }
  },
  "&light .cm-selectionBackground": {
    background: "#d9d9d9"
  },
  "&dark .cm-selectionBackground": {
    background: "#222"
  },
  "&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#d7d4f0"
  },
  "&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#233"
  },
  ".cm-cursorLayer": {
    pointerEvents: "none"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer": {
    animation: "steps(1) cm-blink 1.2s infinite"
  },
  // Two animations defined so that we can switch between them to
  // restart the animation without forcing another style
  // recomputation.
  "@keyframes cm-blink": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  "@keyframes cm-blink2": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  ".cm-cursor, .cm-dropCursor": {
    borderLeft: "1.2px solid black",
    marginLeft: "-0.6px",
    pointerEvents: "none"
  },
  ".cm-cursor": {
    display: "none"
  },
  "&dark .cm-cursor": {
    borderLeftColor: "#444"
  },
  ".cm-dropCursor": {
    position: "absolute"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor": {
    display: "block"
  },
  ".cm-iso": {
    unicodeBidi: "isolate"
  },
  ".cm-announced": {
    position: "fixed",
    top: "-10000px"
  },
  "@media print": {
    ".cm-announced": { display: "none" }
  },
  "&light .cm-activeLine": { backgroundColor: "#cceeff44" },
  "&dark .cm-activeLine": { backgroundColor: "#99eeff33" },
  "&light .cm-specialChar": { color: "red" },
  "&dark .cm-specialChar": { color: "#f78" },
  ".cm-gutters": {
    flexShrink: 0,
    display: "flex",
    height: "100%",
    boxSizing: "border-box",
    insetInlineStart: 0,
    zIndex: 200
  },
  "&light .cm-gutters": {
    backgroundColor: "#f5f5f5",
    color: "#6c6c6c",
    borderRight: "1px solid #ddd"
  },
  "&dark .cm-gutters": {
    backgroundColor: "#333338",
    color: "#ccc"
  },
  ".cm-gutter": {
    display: "flex !important",
    // Necessary -- prevents margin collapsing
    flexDirection: "column",
    flexShrink: 0,
    boxSizing: "border-box",
    minHeight: "100%",
    overflow: "hidden"
  },
  ".cm-gutterElement": {
    boxSizing: "border-box"
  },
  ".cm-lineNumbers .cm-gutterElement": {
    padding: "0 3px 0 5px",
    minWidth: "20px",
    textAlign: "right",
    whiteSpace: "nowrap"
  },
  "&light .cm-activeLineGutter": {
    backgroundColor: "#e2f2ff"
  },
  "&dark .cm-activeLineGutter": {
    backgroundColor: "#222227"
  },
  ".cm-panels": {
    boxSizing: "border-box",
    position: "sticky",
    left: 0,
    right: 0,
    zIndex: 300
  },
  "&light .cm-panels": {
    backgroundColor: "#f5f5f5",
    color: "black"
  },
  "&light .cm-panels-top": {
    borderBottom: "1px solid #ddd"
  },
  "&light .cm-panels-bottom": {
    borderTop: "1px solid #ddd"
  },
  "&dark .cm-panels": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tab": {
    display: "inline-block",
    overflow: "hidden",
    verticalAlign: "bottom"
  },
  ".cm-widgetBuffer": {
    verticalAlign: "text-top",
    height: "1em",
    width: 0,
    display: "inline"
  },
  ".cm-placeholder": {
    color: "#888",
    display: "inline-block",
    verticalAlign: "top"
  },
  ".cm-highlightSpace": {
    backgroundImage: "radial-gradient(circle at 50% 55%, #aaa 20%, transparent 5%)",
    backgroundPosition: "center"
  },
  ".cm-highlightTab": {
    backgroundImage: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>')`,
    backgroundSize: "auto 100%",
    backgroundPosition: "right 90%",
    backgroundRepeat: "no-repeat"
  },
  ".cm-trailingSpace": {
    backgroundColor: "#ff332255"
  },
  ".cm-button": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    padding: ".2em 1em",
    borderRadius: "1px"
  },
  "&light .cm-button": {
    backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
    }
  },
  "&dark .cm-button": {
    backgroundImage: "linear-gradient(#393939, #111)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#111, #333)"
    }
  },
  ".cm-textfield": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    border: "1px solid silver",
    padding: ".2em .5em"
  },
  "&light .cm-textfield": {
    backgroundColor: "white"
  },
  "&dark .cm-textfield": {
    border: "1px solid #555",
    backgroundColor: "inherit"
  }
}, lightDarkIDs);
var observeOptions = {
  childList: true,
  characterData: true,
  subtree: true,
  attributes: true,
  characterDataOldValue: true
};
var useCharData = browser.ie && browser.ie_version <= 11;
var DOMObserver = class {
  constructor(view) {
    this.view = view;
    this.active = false;
    this.editContext = null;
    this.selectionRange = new DOMSelectionState();
    this.selectionChanged = false;
    this.delayedFlush = -1;
    this.resizeTimeout = -1;
    this.queue = [];
    this.delayedAndroidKey = null;
    this.flushingAndroidKey = -1;
    this.lastChange = 0;
    this.scrollTargets = [];
    this.intersection = null;
    this.resizeScroll = null;
    this.intersecting = false;
    this.gapIntersection = null;
    this.gaps = [];
    this.printQuery = null;
    this.parentCheck = -1;
    this.dom = view.contentDOM;
    this.observer = new MutationObserver((mutations) => {
      for (let mut of mutations)
        this.queue.push(mut);
      if ((browser.ie && browser.ie_version <= 11 || browser.ios && view.composing) && mutations.some((m3) => m3.type == "childList" && m3.removedNodes.length || m3.type == "characterData" && m3.oldValue.length > m3.target.nodeValue.length))
        this.flushSoon();
      else
        this.flush();
    });
    if (window.EditContext && view.constructor.EDIT_CONTEXT !== false && // Chrome <126 doesn't support inverted selections in edit context (#1392)
    !(browser.chrome && browser.chrome_version < 126)) {
      this.editContext = new EditContextManager(view);
      if (view.state.facet(editable))
        view.contentDOM.editContext = this.editContext.editContext;
    }
    if (useCharData)
      this.onCharData = (event) => {
        this.queue.push({
          target: event.target,
          type: "characterData",
          oldValue: event.prevValue
        });
        this.flushSoon();
      };
    this.onSelectionChange = this.onSelectionChange.bind(this);
    this.onResize = this.onResize.bind(this);
    this.onPrint = this.onPrint.bind(this);
    this.onScroll = this.onScroll.bind(this);
    if (window.matchMedia)
      this.printQuery = window.matchMedia("print");
    if (typeof ResizeObserver == "function") {
      this.resizeScroll = new ResizeObserver(() => {
        var _a4;
        if (((_a4 = this.view.docView) === null || _a4 === void 0 ? void 0 : _a4.lastUpdate) < Date.now() - 75)
          this.onResize();
      });
      this.resizeScroll.observe(view.scrollDOM);
    }
    this.addWindowListeners(this.win = view.win);
    this.start();
    if (typeof IntersectionObserver == "function") {
      this.intersection = new IntersectionObserver((entries) => {
        if (this.parentCheck < 0)
          this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3);
        if (entries.length > 0 && entries[entries.length - 1].intersectionRatio > 0 != this.intersecting) {
          this.intersecting = !this.intersecting;
          if (this.intersecting != this.view.inView)
            this.onScrollChanged(document.createEvent("Event"));
        }
      }, { threshold: [0, 1e-3] });
      this.intersection.observe(this.dom);
      this.gapIntersection = new IntersectionObserver((entries) => {
        if (entries.length > 0 && entries[entries.length - 1].intersectionRatio > 0)
          this.onScrollChanged(document.createEvent("Event"));
      }, {});
    }
    this.listenForScroll();
    this.readSelectionRange();
  }
  onScrollChanged(e2) {
    this.view.inputState.runHandlers("scroll", e2);
    if (this.intersecting)
      this.view.measure();
  }
  onScroll(e2) {
    if (this.intersecting)
      this.flush(false);
    if (this.editContext)
      this.view.requestMeasure(this.editContext.measureReq);
    this.onScrollChanged(e2);
  }
  onResize() {
    if (this.resizeTimeout < 0)
      this.resizeTimeout = setTimeout(() => {
        this.resizeTimeout = -1;
        this.view.requestMeasure();
      }, 50);
  }
  onPrint(event) {
    if ((event.type == "change" || !event.type) && !event.matches)
      return;
    this.view.viewState.printing = true;
    this.view.measure();
    setTimeout(() => {
      this.view.viewState.printing = false;
      this.view.requestMeasure();
    }, 500);
  }
  updateGaps(gaps) {
    if (this.gapIntersection && (gaps.length != this.gaps.length || this.gaps.some((g, i2) => g != gaps[i2]))) {
      this.gapIntersection.disconnect();
      for (let gap of gaps)
        this.gapIntersection.observe(gap);
      this.gaps = gaps;
    }
  }
  onSelectionChange(event) {
    let wasChanged = this.selectionChanged;
    if (!this.readSelectionRange() || this.delayedAndroidKey)
      return;
    let { view } = this, sel = this.selectionRange;
    if (view.state.facet(editable) ? view.root.activeElement != this.dom : !hasSelection(this.dom, sel))
      return;
    let context = sel.anchorNode && view.docView.nearest(sel.anchorNode);
    if (context && context.ignoreEvent(event)) {
      if (!wasChanged)
        this.selectionChanged = false;
      return;
    }
    if ((browser.ie && browser.ie_version <= 11 || browser.android && browser.chrome) && !view.state.selection.main.empty && // (Selection.isCollapsed isn't reliable on IE)
    sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset))
      this.flushSoon();
    else
      this.flush(false);
  }
  readSelectionRange() {
    let { view } = this;
    let selection = getSelection(view.root);
    if (!selection)
      return false;
    let range = browser.safari && view.root.nodeType == 11 && view.root.activeElement == this.dom && safariSelectionRangeHack(this.view, selection) || selection;
    if (!range || this.selectionRange.eq(range))
      return false;
    let local = hasSelection(this.dom, range);
    if (local && !this.selectionChanged && view.inputState.lastFocusTime > Date.now() - 200 && view.inputState.lastTouchTime < Date.now() - 300 && atElementStart(this.dom, range)) {
      this.view.inputState.lastFocusTime = 0;
      view.docView.updateSelection();
      return false;
    }
    this.selectionRange.setRange(range);
    if (local)
      this.selectionChanged = true;
    return true;
  }
  setSelectionRange(anchor, head) {
    this.selectionRange.set(anchor.node, anchor.offset, head.node, head.offset);
    this.selectionChanged = false;
  }
  clearSelectionRange() {
    this.selectionRange.set(null, 0, null, 0);
  }
  listenForScroll() {
    this.parentCheck = -1;
    let i2 = 0, changed = null;
    for (let dom = this.dom; dom; ) {
      if (dom.nodeType == 1) {
        if (!changed && i2 < this.scrollTargets.length && this.scrollTargets[i2] == dom)
          i2++;
        else if (!changed)
          changed = this.scrollTargets.slice(0, i2);
        if (changed)
          changed.push(dom);
        dom = dom.assignedSlot || dom.parentNode;
      } else if (dom.nodeType == 11) {
        dom = dom.host;
      } else {
        break;
      }
    }
    if (i2 < this.scrollTargets.length && !changed)
      changed = this.scrollTargets.slice(0, i2);
    if (changed) {
      for (let dom of this.scrollTargets)
        dom.removeEventListener("scroll", this.onScroll);
      for (let dom of this.scrollTargets = changed)
        dom.addEventListener("scroll", this.onScroll);
    }
  }
  ignore(f) {
    if (!this.active)
      return f();
    try {
      this.stop();
      return f();
    } finally {
      this.start();
      this.clear();
    }
  }
  start() {
    if (this.active)
      return;
    this.observer.observe(this.dom, observeOptions);
    if (useCharData)
      this.dom.addEventListener("DOMCharacterDataModified", this.onCharData);
    this.active = true;
  }
  stop() {
    if (!this.active)
      return;
    this.active = false;
    this.observer.disconnect();
    if (useCharData)
      this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData);
  }
  // Throw away any pending changes
  clear() {
    this.processRecords();
    this.queue.length = 0;
    this.selectionChanged = false;
  }
  // Chrome Android, especially in combination with GBoard, not only
  // doesn't reliably fire regular key events, but also often
  // surrounds the effect of enter or backspace with a bunch of
  // composition events that, when interrupted, cause text duplication
  // or other kinds of corruption. This hack makes the editor back off
  // from handling DOM changes for a moment when such a key is
  // detected (via beforeinput or keydown), and then tries to flush
  // them or, if that has no effect, dispatches the given key.
  delayAndroidKey(key, keyCode) {
    var _a4;
    if (!this.delayedAndroidKey) {
      let flush = () => {
        let key2 = this.delayedAndroidKey;
        if (key2) {
          this.clearDelayedAndroidKey();
          this.view.inputState.lastKeyCode = key2.keyCode;
          this.view.inputState.lastKeyTime = Date.now();
          let flushed = this.flush();
          if (!flushed && key2.force)
            dispatchKey(this.dom, key2.key, key2.keyCode);
        }
      };
      this.flushingAndroidKey = this.view.win.requestAnimationFrame(flush);
    }
    if (!this.delayedAndroidKey || key == "Enter")
      this.delayedAndroidKey = {
        key,
        keyCode,
        // Only run the key handler when no changes are detected if
        // this isn't coming right after another change, in which case
        // it is probably part of a weird chain of updates, and should
        // be ignored if it returns the DOM to its previous state.
        force: this.lastChange < Date.now() - 50 || !!((_a4 = this.delayedAndroidKey) === null || _a4 === void 0 ? void 0 : _a4.force)
      };
  }
  clearDelayedAndroidKey() {
    this.win.cancelAnimationFrame(this.flushingAndroidKey);
    this.delayedAndroidKey = null;
    this.flushingAndroidKey = -1;
  }
  flushSoon() {
    if (this.delayedFlush < 0)
      this.delayedFlush = this.view.win.requestAnimationFrame(() => {
        this.delayedFlush = -1;
        this.flush();
      });
  }
  forceFlush() {
    if (this.delayedFlush >= 0) {
      this.view.win.cancelAnimationFrame(this.delayedFlush);
      this.delayedFlush = -1;
    }
    this.flush();
  }
  pendingRecords() {
    for (let mut of this.observer.takeRecords())
      this.queue.push(mut);
    return this.queue;
  }
  processRecords() {
    let records = this.pendingRecords();
    if (records.length)
      this.queue = [];
    let from = -1, to3 = -1, typeOver = false;
    for (let record of records) {
      let range = this.readMutation(record);
      if (!range)
        continue;
      if (range.typeOver)
        typeOver = true;
      if (from == -1) {
        ({ from, to: to3 } = range);
      } else {
        from = Math.min(range.from, from);
        to3 = Math.max(range.to, to3);
      }
    }
    return { from, to: to3, typeOver };
  }
  readChange() {
    let { from, to: to3, typeOver } = this.processRecords();
    let newSel = this.selectionChanged && hasSelection(this.dom, this.selectionRange);
    if (from < 0 && !newSel)
      return null;
    if (from > -1)
      this.lastChange = Date.now();
    this.view.inputState.lastFocusTime = 0;
    this.selectionChanged = false;
    let change = new DOMChange(this.view, from, to3, typeOver);
    this.view.docView.domChanged = { newSel: change.newSel ? change.newSel.main : null };
    return change;
  }
  // Apply pending changes, if any
  flush(readSelection = true) {
    if (this.delayedFlush >= 0 || this.delayedAndroidKey)
      return false;
    if (readSelection)
      this.readSelectionRange();
    let domChange = this.readChange();
    if (!domChange) {
      this.view.requestMeasure();
      return false;
    }
    let startState = this.view.state;
    let handled = applyDOMChange(this.view, domChange);
    if (this.view.state == startState && (domChange.domChanged || domChange.newSel && !domChange.newSel.main.eq(this.view.state.selection.main)))
      this.view.update([]);
    return handled;
  }
  readMutation(rec) {
    let cView = this.view.docView.nearest(rec.target);
    if (!cView || cView.ignoreMutation(rec))
      return null;
    cView.markDirty(rec.type == "attributes");
    if (rec.type == "attributes")
      cView.flags |= 4;
    if (rec.type == "childList") {
      let childBefore = findChild(cView, rec.previousSibling || rec.target.previousSibling, -1);
      let childAfter = findChild(cView, rec.nextSibling || rec.target.nextSibling, 1);
      return {
        from: childBefore ? cView.posAfter(childBefore) : cView.posAtStart,
        to: childAfter ? cView.posBefore(childAfter) : cView.posAtEnd,
        typeOver: false
      };
    } else if (rec.type == "characterData") {
      return { from: cView.posAtStart, to: cView.posAtEnd, typeOver: rec.target.nodeValue == rec.oldValue };
    } else {
      return null;
    }
  }
  setWindow(win) {
    if (win != this.win) {
      this.removeWindowListeners(this.win);
      this.win = win;
      this.addWindowListeners(this.win);
    }
  }
  addWindowListeners(win) {
    win.addEventListener("resize", this.onResize);
    if (this.printQuery) {
      if (this.printQuery.addEventListener)
        this.printQuery.addEventListener("change", this.onPrint);
      else
        this.printQuery.addListener(this.onPrint);
    } else
      win.addEventListener("beforeprint", this.onPrint);
    win.addEventListener("scroll", this.onScroll);
    win.document.addEventListener("selectionchange", this.onSelectionChange);
  }
  removeWindowListeners(win) {
    win.removeEventListener("scroll", this.onScroll);
    win.removeEventListener("resize", this.onResize);
    if (this.printQuery) {
      if (this.printQuery.removeEventListener)
        this.printQuery.removeEventListener("change", this.onPrint);
      else
        this.printQuery.removeListener(this.onPrint);
    } else
      win.removeEventListener("beforeprint", this.onPrint);
    win.document.removeEventListener("selectionchange", this.onSelectionChange);
  }
  update(update) {
    if (this.editContext) {
      this.editContext.update(update);
      if (update.startState.facet(editable) != update.state.facet(editable))
        update.view.contentDOM.editContext = update.state.facet(editable) ? this.editContext.editContext : null;
    }
  }
  destroy() {
    var _a4, _b, _c2;
    this.stop();
    (_a4 = this.intersection) === null || _a4 === void 0 ? void 0 : _a4.disconnect();
    (_b = this.gapIntersection) === null || _b === void 0 ? void 0 : _b.disconnect();
    (_c2 = this.resizeScroll) === null || _c2 === void 0 ? void 0 : _c2.disconnect();
    for (let dom of this.scrollTargets)
      dom.removeEventListener("scroll", this.onScroll);
    this.removeWindowListeners(this.win);
    clearTimeout(this.parentCheck);
    clearTimeout(this.resizeTimeout);
    this.win.cancelAnimationFrame(this.delayedFlush);
    this.win.cancelAnimationFrame(this.flushingAndroidKey);
    if (this.editContext) {
      this.view.contentDOM.editContext = null;
      this.editContext.destroy();
    }
  }
};
function findChild(cView, dom, dir) {
  while (dom) {
    let curView = ContentView.get(dom);
    if (curView && curView.parent == cView)
      return curView;
    let parent = dom.parentNode;
    dom = parent != cView.dom ? parent : dir > 0 ? dom.nextSibling : dom.previousSibling;
  }
  return null;
}
function buildSelectionRangeFromRange(view, range) {
  let anchorNode = range.startContainer, anchorOffset = range.startOffset;
  let focusNode = range.endContainer, focusOffset = range.endOffset;
  let curAnchor = view.docView.domAtPos(view.state.selection.main.anchor);
  if (isEquivalentPosition(curAnchor.node, curAnchor.offset, focusNode, focusOffset))
    [anchorNode, anchorOffset, focusNode, focusOffset] = [focusNode, focusOffset, anchorNode, anchorOffset];
  return { anchorNode, anchorOffset, focusNode, focusOffset };
}
function safariSelectionRangeHack(view, selection) {
  if (selection.getComposedRanges) {
    let range = selection.getComposedRanges(view.root)[0];
    if (range)
      return buildSelectionRangeFromRange(view, range);
  }
  let found = null;
  function read(event) {
    event.preventDefault();
    event.stopImmediatePropagation();
    found = event.getTargetRanges()[0];
  }
  view.contentDOM.addEventListener("beforeinput", read, true);
  view.dom.ownerDocument.execCommand("indent");
  view.contentDOM.removeEventListener("beforeinput", read, true);
  return found ? buildSelectionRangeFromRange(view, found) : null;
}
var EditContextManager = class {
  constructor(view) {
    this.from = 0;
    this.to = 0;
    this.pendingContextChange = null;
    this.handlers = /* @__PURE__ */ Object.create(null);
    this.resetRange(view.state);
    let context = this.editContext = new window.EditContext({
      text: view.state.doc.sliceString(this.from, this.to),
      selectionStart: this.toContextPos(Math.max(this.from, Math.min(this.to, view.state.selection.main.anchor))),
      selectionEnd: this.toContextPos(view.state.selection.main.head)
    });
    this.handlers.textupdate = (e2) => {
      let { anchor } = view.state.selection.main;
      let change = {
        from: this.toEditorPos(e2.updateRangeStart),
        to: this.toEditorPos(e2.updateRangeEnd),
        insert: Text.of(e2.text.split("\n"))
      };
      if (change.from == this.from && anchor < this.from)
        change.from = anchor;
      else if (change.to == this.to && anchor > this.to)
        change.to = anchor;
      if (change.from == change.to && !change.insert.length)
        return;
      this.pendingContextChange = change;
      if (!view.state.readOnly)
        applyDOMChangeInner(view, change, EditorSelection.single(this.toEditorPos(e2.selectionStart), this.toEditorPos(e2.selectionEnd)));
      if (this.pendingContextChange) {
        this.revertPending(view.state);
        this.setSelection(view.state);
      }
    };
    this.handlers.characterboundsupdate = (e2) => {
      let rects = [], prev = null;
      for (let i2 = this.toEditorPos(e2.rangeStart), end = this.toEditorPos(e2.rangeEnd); i2 < end; i2++) {
        let rect = view.coordsForChar(i2);
        prev = rect && new DOMRect(rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top) || prev || new DOMRect();
        rects.push(prev);
      }
      context.updateCharacterBounds(e2.rangeStart, rects);
    };
    this.handlers.textformatupdate = (e2) => {
      let deco = [];
      for (let format of e2.getTextFormats()) {
        let lineStyle = format.underlineStyle, thickness = format.underlineThickness;
        if (lineStyle != "None" && thickness != "None") {
          let style = `text-decoration: underline ${lineStyle == "Dashed" ? "dashed " : lineStyle == "Squiggle" ? "wavy " : ""}${thickness == "Thin" ? 1 : 2}px`;
          deco.push(Decoration.mark({ attributes: { style } }).range(this.toEditorPos(format.rangeStart), this.toEditorPos(format.rangeEnd)));
        }
      }
      view.dispatch({ effects: setEditContextFormatting.of(Decoration.set(deco)) });
    };
    this.handlers.compositionstart = () => {
      if (view.inputState.composing < 0) {
        view.inputState.composing = 0;
        view.inputState.compositionFirstChange = true;
      }
    };
    this.handlers.compositionend = () => {
      view.inputState.composing = -1;
      view.inputState.compositionFirstChange = null;
    };
    for (let event in this.handlers)
      context.addEventListener(event, this.handlers[event]);
    this.measureReq = { read: (view2) => {
      this.editContext.updateControlBounds(view2.contentDOM.getBoundingClientRect());
      let sel = getSelection(view2.root);
      if (sel && sel.rangeCount)
        this.editContext.updateSelectionBounds(sel.getRangeAt(0).getBoundingClientRect());
    } };
  }
  applyEdits(update) {
    let off = 0, abort = false, pending = this.pendingContextChange;
    update.changes.iterChanges((fromA, toA, _fromB, _toB, insert2) => {
      if (abort)
        return;
      let dLen = insert2.length - (toA - fromA);
      if (pending && toA >= pending.to) {
        if (pending.from == fromA && pending.to == toA && pending.insert.eq(insert2)) {
          pending = this.pendingContextChange = null;
          off += dLen;
          this.to += dLen;
          return;
        } else {
          pending = null;
          this.revertPending(update.state);
        }
      }
      fromA += off;
      toA += off;
      if (toA <= this.from) {
        this.from += dLen;
        this.to += dLen;
      } else if (fromA < this.to) {
        if (fromA < this.from || toA > this.to || this.to - this.from + insert2.length > 3e4) {
          abort = true;
          return;
        }
        this.editContext.updateText(this.toContextPos(fromA), this.toContextPos(toA), insert2.toString());
        this.to += dLen;
      }
      off += dLen;
    });
    if (pending && !abort)
      this.revertPending(update.state);
    return !abort;
  }
  update(update) {
    let reverted = this.pendingContextChange;
    if (!this.applyEdits(update) || !this.rangeIsValid(update.state)) {
      this.pendingContextChange = null;
      this.resetRange(update.state);
      this.editContext.updateText(0, this.editContext.text.length, update.state.doc.sliceString(this.from, this.to));
      this.setSelection(update.state);
    } else if (update.docChanged || update.selectionSet || reverted) {
      this.setSelection(update.state);
    }
    if (update.geometryChanged || update.docChanged || update.selectionSet)
      update.view.requestMeasure(this.measureReq);
  }
  resetRange(state) {
    let { head } = state.selection.main;
    this.from = Math.max(
      0,
      head - 1e4
      /* CxVp.Margin */
    );
    this.to = Math.min(
      state.doc.length,
      head + 1e4
      /* CxVp.Margin */
    );
  }
  revertPending(state) {
    let pending = this.pendingContextChange;
    this.pendingContextChange = null;
    this.editContext.updateText(this.toContextPos(pending.from), this.toContextPos(pending.from + pending.insert.length), state.doc.sliceString(pending.from, pending.to));
  }
  setSelection(state) {
    let { main } = state.selection;
    let start = this.toContextPos(Math.max(this.from, Math.min(this.to, main.anchor)));
    let end = this.toContextPos(main.head);
    if (this.editContext.selectionStart != start || this.editContext.selectionEnd != end)
      this.editContext.updateSelection(start, end);
  }
  rangeIsValid(state) {
    let { head } = state.selection.main;
    return !(this.from > 0 && head - this.from < 500 || this.to < state.doc.length && this.to - head < 500 || this.to - this.from > 1e4 * 3);
  }
  toEditorPos(contextPos) {
    return contextPos + this.from;
  }
  toContextPos(editorPos) {
    return editorPos - this.from;
  }
  destroy() {
    for (let event in this.handlers)
      this.editContext.removeEventListener(event, this.handlers[event]);
  }
};
var EditorView = class _EditorView {
  /**
  The current editor state.
  */
  get state() {
    return this.viewState.state;
  }
  /**
  To be able to display large documents without consuming too much
  memory or overloading the browser, CodeMirror only draws the
  code that is visible (plus a margin around it) to the DOM. This
  property tells you the extent of the current drawn viewport, in
  document positions.
  */
  get viewport() {
    return this.viewState.viewport;
  }
  /**
  When there are, for example, large collapsed ranges in the
  viewport, its size can be a lot bigger than the actual visible
  content. Thus, if you are doing something like styling the
  content in the viewport, it is preferable to only do so for
  these ranges, which are the subset of the viewport that is
  actually drawn.
  */
  get visibleRanges() {
    return this.viewState.visibleRanges;
  }
  /**
  Returns false when the editor is entirely scrolled out of view
  or otherwise hidden.
  */
  get inView() {
    return this.viewState.inView;
  }
  /**
  Indicates whether the user is currently composing text via
  [IME](https://en.wikipedia.org/wiki/Input_method), and at least
  one change has been made in the current composition.
  */
  get composing() {
    return this.inputState.composing > 0;
  }
  /**
  Indicates whether the user is currently in composing state. Note
  that on some platforms, like Android, this will be the case a
  lot, since just putting the cursor on a word starts a
  composition there.
  */
  get compositionStarted() {
    return this.inputState.composing >= 0;
  }
  /**
  The document or shadow root that the view lives in.
  */
  get root() {
    return this._root;
  }
  /**
  @internal
  */
  get win() {
    return this.dom.ownerDocument.defaultView || window;
  }
  /**
  Construct a new view. You'll want to either provide a `parent`
  option, or put `view.dom` into your document after creating a
  view, so that the user can see the editor.
  */
  constructor(config2 = {}) {
    var _a4;
    this.plugins = [];
    this.pluginMap = /* @__PURE__ */ new Map();
    this.editorAttrs = {};
    this.contentAttrs = {};
    this.bidiCache = [];
    this.destroyed = false;
    this.updateState = 2;
    this.measureScheduled = -1;
    this.measureRequests = [];
    this.contentDOM = document.createElement("div");
    this.scrollDOM = document.createElement("div");
    this.scrollDOM.tabIndex = -1;
    this.scrollDOM.className = "cm-scroller";
    this.scrollDOM.appendChild(this.contentDOM);
    this.announceDOM = document.createElement("div");
    this.announceDOM.className = "cm-announced";
    this.announceDOM.setAttribute("aria-live", "polite");
    this.dom = document.createElement("div");
    this.dom.appendChild(this.announceDOM);
    this.dom.appendChild(this.scrollDOM);
    if (config2.parent)
      config2.parent.appendChild(this.dom);
    let { dispatch } = config2;
    this.dispatchTransactions = config2.dispatchTransactions || dispatch && ((trs) => trs.forEach((tr3) => dispatch(tr3, this))) || ((trs) => this.update(trs));
    this.dispatch = this.dispatch.bind(this);
    this._root = config2.root || getRoot(config2.parent) || document;
    this.viewState = new ViewState(config2.state || EditorState.create(config2));
    if (config2.scrollTo && config2.scrollTo.is(scrollIntoView))
      this.viewState.scrollTarget = config2.scrollTo.value.clip(this.viewState.state);
    this.plugins = this.state.facet(viewPlugin).map((spec) => new PluginInstance(spec));
    for (let plugin3 of this.plugins)
      plugin3.update(this);
    this.observer = new DOMObserver(this);
    this.inputState = new InputState(this);
    this.inputState.ensureHandlers(this.plugins);
    this.docView = new DocView(this);
    this.mountStyles();
    this.updateAttrs();
    this.updateState = 0;
    this.requestMeasure();
    if ((_a4 = document.fonts) === null || _a4 === void 0 ? void 0 : _a4.ready)
      document.fonts.ready.then(() => this.requestMeasure());
  }
  dispatch(...input) {
    let trs = input.length == 1 && input[0] instanceof Transaction ? input : input.length == 1 && Array.isArray(input[0]) ? input[0] : [this.state.update(...input)];
    this.dispatchTransactions(trs, this);
  }
  /**
  Update the view for the given array of transactions. This will
  update the visible document and selection to match the state
  produced by the transactions, and notify view plugins of the
  change. You should usually call
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead, which uses this
  as a primitive.
  */
  update(transactions) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
    let redrawn = false, attrsChanged = false, update;
    let state = this.state;
    for (let tr3 of transactions) {
      if (tr3.startState != state)
        throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
      state = tr3.state;
    }
    if (this.destroyed) {
      this.viewState.state = state;
      return;
    }
    let focus = this.hasFocus, focusFlag = 0, dispatchFocus = null;
    if (transactions.some((tr3) => tr3.annotation(isFocusChange))) {
      this.inputState.notifiedFocused = focus;
      focusFlag = 1;
    } else if (focus != this.inputState.notifiedFocused) {
      this.inputState.notifiedFocused = focus;
      dispatchFocus = focusChangeTransaction(state, focus);
      if (!dispatchFocus)
        focusFlag = 1;
    }
    let pendingKey = this.observer.delayedAndroidKey, domChange = null;
    if (pendingKey) {
      this.observer.clearDelayedAndroidKey();
      domChange = this.observer.readChange();
      if (domChange && !this.state.doc.eq(state.doc) || !this.state.selection.eq(state.selection))
        domChange = null;
    } else {
      this.observer.clear();
    }
    if (state.facet(EditorState.phrases) != this.state.facet(EditorState.phrases))
      return this.setState(state);
    update = ViewUpdate.create(this, state, transactions);
    update.flags |= focusFlag;
    let scrollTarget = this.viewState.scrollTarget;
    try {
      this.updateState = 2;
      for (let tr3 of transactions) {
        if (scrollTarget)
          scrollTarget = scrollTarget.map(tr3.changes);
        if (tr3.scrollIntoView) {
          let { main } = tr3.state.selection;
          scrollTarget = new ScrollTarget(main.empty ? main : EditorSelection.cursor(main.head, main.head > main.anchor ? -1 : 1));
        }
        for (let e2 of tr3.effects)
          if (e2.is(scrollIntoView))
            scrollTarget = e2.value.clip(this.state);
      }
      this.viewState.update(update, scrollTarget);
      this.bidiCache = CachedOrder.update(this.bidiCache, update.changes);
      if (!update.empty) {
        this.updatePlugins(update);
        this.inputState.update(update);
      }
      redrawn = this.docView.update(update);
      if (this.state.facet(styleModule) != this.styleModules)
        this.mountStyles();
      attrsChanged = this.updateAttrs();
      this.showAnnouncements(transactions);
      this.docView.updateSelection(redrawn, transactions.some((tr3) => tr3.isUserEvent("select.pointer")));
    } finally {
      this.updateState = 0;
    }
    if (update.startState.facet(theme) != update.state.facet(theme))
      this.viewState.mustMeasureContent = true;
    if (redrawn || attrsChanged || scrollTarget || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent)
      this.requestMeasure();
    if (redrawn)
      this.docViewUpdate();
    if (!update.empty)
      for (let listener of this.state.facet(updateListener)) {
        try {
          listener(update);
        } catch (e2) {
          logException(this.state, e2, "update listener");
        }
      }
    if (dispatchFocus || domChange)
      Promise.resolve().then(() => {
        if (dispatchFocus && this.state == dispatchFocus.startState)
          this.dispatch(dispatchFocus);
        if (domChange) {
          if (!applyDOMChange(this, domChange) && pendingKey.force)
            dispatchKey(this.contentDOM, pendingKey.key, pendingKey.keyCode);
        }
      });
  }
  /**
  Reset the view to the given state. (This will cause the entire
  document to be redrawn and all view plugins to be reinitialized,
  so you should probably only use it when the new state isn't
  derived from the old state. Otherwise, use
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead.)
  */
  setState(newState) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
    if (this.destroyed) {
      this.viewState.state = newState;
      return;
    }
    this.updateState = 2;
    let hadFocus = this.hasFocus;
    try {
      for (let plugin3 of this.plugins)
        plugin3.destroy(this);
      this.viewState = new ViewState(newState);
      this.plugins = newState.facet(viewPlugin).map((spec) => new PluginInstance(spec));
      this.pluginMap.clear();
      for (let plugin3 of this.plugins)
        plugin3.update(this);
      this.docView.destroy();
      this.docView = new DocView(this);
      this.inputState.ensureHandlers(this.plugins);
      this.mountStyles();
      this.updateAttrs();
      this.bidiCache = [];
    } finally {
      this.updateState = 0;
    }
    if (hadFocus)
      this.focus();
    this.requestMeasure();
  }
  updatePlugins(update) {
    let prevSpecs = update.startState.facet(viewPlugin), specs = update.state.facet(viewPlugin);
    if (prevSpecs != specs) {
      let newPlugins = [];
      for (let spec of specs) {
        let found = prevSpecs.indexOf(spec);
        if (found < 0) {
          newPlugins.push(new PluginInstance(spec));
        } else {
          let plugin3 = this.plugins[found];
          plugin3.mustUpdate = update;
          newPlugins.push(plugin3);
        }
      }
      for (let plugin3 of this.plugins)
        if (plugin3.mustUpdate != update)
          plugin3.destroy(this);
      this.plugins = newPlugins;
      this.pluginMap.clear();
    } else {
      for (let p of this.plugins)
        p.mustUpdate = update;
    }
    for (let i2 = 0; i2 < this.plugins.length; i2++)
      this.plugins[i2].update(this);
    if (prevSpecs != specs)
      this.inputState.ensureHandlers(this.plugins);
  }
  docViewUpdate() {
    for (let plugin3 of this.plugins) {
      let val = plugin3.value;
      if (val && val.docViewUpdate) {
        try {
          val.docViewUpdate(this);
        } catch (e2) {
          logException(this.state, e2, "doc view update listener");
        }
      }
    }
  }
  /**
  @internal
  */
  measure(flush = true) {
    if (this.destroyed)
      return;
    if (this.measureScheduled > -1)
      this.win.cancelAnimationFrame(this.measureScheduled);
    if (this.observer.delayedAndroidKey) {
      this.measureScheduled = -1;
      this.requestMeasure();
      return;
    }
    this.measureScheduled = 0;
    if (flush)
      this.observer.forceFlush();
    let updated = null;
    let sDOM = this.scrollDOM, scrollTop = sDOM.scrollTop * this.scaleY;
    let { scrollAnchorPos, scrollAnchorHeight } = this.viewState;
    if (Math.abs(scrollTop - this.viewState.scrollTop) > 1)
      scrollAnchorHeight = -1;
    this.viewState.scrollAnchorHeight = -1;
    try {
      for (let i2 = 0; ; i2++) {
        if (scrollAnchorHeight < 0) {
          if (isScrolledToBottom(sDOM)) {
            scrollAnchorPos = -1;
            scrollAnchorHeight = this.viewState.heightMap.height;
          } else {
            let block = this.viewState.scrollAnchorAt(scrollTop);
            scrollAnchorPos = block.from;
            scrollAnchorHeight = block.top;
          }
        }
        this.updateState = 1;
        let changed = this.viewState.measure(this);
        if (!changed && !this.measureRequests.length && this.viewState.scrollTarget == null)
          break;
        if (i2 > 5) {
          console.warn(this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize");
          break;
        }
        let measuring = [];
        if (!(changed & 4))
          [this.measureRequests, measuring] = [measuring, this.measureRequests];
        let measured = measuring.map((m3) => {
          try {
            return m3.read(this);
          } catch (e2) {
            logException(this.state, e2);
            return BadMeasure;
          }
        });
        let update = ViewUpdate.create(this, this.state, []), redrawn = false;
        update.flags |= changed;
        if (!updated)
          updated = update;
        else
          updated.flags |= changed;
        this.updateState = 2;
        if (!update.empty) {
          this.updatePlugins(update);
          this.inputState.update(update);
          this.updateAttrs();
          redrawn = this.docView.update(update);
          if (redrawn)
            this.docViewUpdate();
        }
        for (let i3 = 0; i3 < measuring.length; i3++)
          if (measured[i3] != BadMeasure) {
            try {
              let m3 = measuring[i3];
              if (m3.write)
                m3.write(measured[i3], this);
            } catch (e2) {
              logException(this.state, e2);
            }
          }
        if (redrawn)
          this.docView.updateSelection(true);
        if (!update.viewportChanged && this.measureRequests.length == 0) {
          if (this.viewState.editorHeight) {
            if (this.viewState.scrollTarget) {
              this.docView.scrollIntoView(this.viewState.scrollTarget);
              this.viewState.scrollTarget = null;
              scrollAnchorHeight = -1;
              continue;
            } else {
              let newAnchorHeight = scrollAnchorPos < 0 ? this.viewState.heightMap.height : this.viewState.lineBlockAt(scrollAnchorPos).top;
              let diff = newAnchorHeight - scrollAnchorHeight;
              if (diff > 1 || diff < -1) {
                scrollTop = scrollTop + diff;
                sDOM.scrollTop = scrollTop / this.scaleY;
                scrollAnchorHeight = -1;
                continue;
              }
            }
          }
          break;
        }
      }
    } finally {
      this.updateState = 0;
      this.measureScheduled = -1;
    }
    if (updated && !updated.empty)
      for (let listener of this.state.facet(updateListener))
        listener(updated);
  }
  /**
  Get the CSS classes for the currently active editor themes.
  */
  get themeClasses() {
    return baseThemeID + " " + (this.state.facet(darkTheme) ? baseDarkID : baseLightID) + " " + this.state.facet(theme);
  }
  updateAttrs() {
    let editorAttrs = attrsFromFacet(this, editorAttributes, {
      class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
    });
    let contentAttrs = {
      spellcheck: "false",
      autocorrect: "off",
      autocapitalize: "off",
      translate: "no",
      contenteditable: !this.state.facet(editable) ? "false" : "true",
      class: "cm-content",
      style: `${browser.tabSize}: ${this.state.tabSize}`,
      role: "textbox",
      "aria-multiline": "true"
    };
    if (this.state.readOnly)
      contentAttrs["aria-readonly"] = "true";
    attrsFromFacet(this, contentAttributes, contentAttrs);
    let changed = this.observer.ignore(() => {
      let changedContent = updateAttrs(this.contentDOM, this.contentAttrs, contentAttrs);
      let changedEditor = updateAttrs(this.dom, this.editorAttrs, editorAttrs);
      return changedContent || changedEditor;
    });
    this.editorAttrs = editorAttrs;
    this.contentAttrs = contentAttrs;
    return changed;
  }
  showAnnouncements(trs) {
    let first = true;
    for (let tr3 of trs)
      for (let effect of tr3.effects)
        if (effect.is(_EditorView.announce)) {
          if (first)
            this.announceDOM.textContent = "";
          first = false;
          let div = this.announceDOM.appendChild(document.createElement("div"));
          div.textContent = effect.value;
        }
  }
  mountStyles() {
    this.styleModules = this.state.facet(styleModule);
    let nonce = this.state.facet(_EditorView.cspNonce);
    StyleModule.mount(this.root, this.styleModules.concat(baseTheme$1).reverse(), nonce ? { nonce } : void 0);
  }
  readMeasured() {
    if (this.updateState == 2)
      throw new Error("Reading the editor layout isn't allowed during an update");
    if (this.updateState == 0 && this.measureScheduled > -1)
      this.measure(false);
  }
  /**
  Schedule a layout measurement, optionally providing callbacks to
  do custom DOM measuring followed by a DOM write phase. Using
  this is preferable reading DOM layout directly from, for
  example, an event handler, because it'll make sure measuring and
  drawing done by other components is synchronized, avoiding
  unnecessary DOM layout computations.
  */
  requestMeasure(request) {
    if (this.measureScheduled < 0)
      this.measureScheduled = this.win.requestAnimationFrame(() => this.measure());
    if (request) {
      if (this.measureRequests.indexOf(request) > -1)
        return;
      if (request.key != null)
        for (let i2 = 0; i2 < this.measureRequests.length; i2++) {
          if (this.measureRequests[i2].key === request.key) {
            this.measureRequests[i2] = request;
            return;
          }
        }
      this.measureRequests.push(request);
    }
  }
  /**
  Get the value of a specific plugin, if present. Note that
  plugins that crash can be dropped from a view, so even when you
  know you registered a given plugin, it is recommended to check
  the return value of this method.
  */
  plugin(plugin3) {
    let known = this.pluginMap.get(plugin3);
    if (known === void 0 || known && known.spec != plugin3)
      this.pluginMap.set(plugin3, known = this.plugins.find((p) => p.spec == plugin3) || null);
    return known && known.update(this).value;
  }
  /**
  The top position of the document, in screen coordinates. This
  may be negative when the editor is scrolled down. Points
  directly to the top of the first line, not above the padding.
  */
  get documentTop() {
    return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
  }
  /**
  Reports the padding above and below the document.
  */
  get documentPadding() {
    return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom };
  }
  /**
  If the editor is transformed with CSS, this provides the scale
  along the X axis. Otherwise, it will just be 1. Note that
  transforms other than translation and scaling are not supported.
  */
  get scaleX() {
    return this.viewState.scaleX;
  }
  /**
  Provide the CSS transformed scale along the Y axis.
  */
  get scaleY() {
    return this.viewState.scaleY;
  }
  /**
  Find the text line or block widget at the given vertical
  position (which is interpreted as relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop)).
  */
  elementAtHeight(height) {
    this.readMeasured();
    return this.viewState.elementAtHeight(height);
  }
  /**
  Find the line block (see
  [`lineBlockAt`](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) at the given
  height, again interpreted relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop).
  */
  lineBlockAtHeight(height) {
    this.readMeasured();
    return this.viewState.lineBlockAtHeight(height);
  }
  /**
  Get the extent and vertical position of all [line
  blocks](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) in the viewport. Positions
  are relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop);
  */
  get viewportLineBlocks() {
    return this.viewState.viewportLines;
  }
  /**
  Find the line block around the given document position. A line
  block is a range delimited on both sides by either a
  non-[hidden](https://codemirror.net/6/docs/ref/#view.Decoration^replace) line break, or the
  start/end of the document. It will usually just hold a line of
  text, but may be broken into multiple textblocks by block
  widgets.
  */
  lineBlockAt(pos) {
    return this.viewState.lineBlockAt(pos);
  }
  /**
  The editor's total content height.
  */
  get contentHeight() {
    return this.viewState.contentHeight;
  }
  /**
  Move a cursor position by [grapheme
  cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak). `forward` determines whether
  the motion is away from the line start, or towards it. In
  bidirectional text, the line is traversed in visual order, using
  the editor's [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).
  When the start position was the last one on the line, the
  returned position will be across the line break. If there is no
  further line, the original position is returned.
  
  By default, this method moves over a single cluster. The
  optional `by` argument can be used to move across more. It will
  be called with the first cluster as argument, and should return
  a predicate that determines, for each subsequent cluster,
  whether it should also be moved over.
  */
  moveByChar(start, forward, by) {
    return skipAtoms(this, start, moveByChar(this, start, forward, by));
  }
  /**
  Move a cursor position across the next group of either
  [letters](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) or non-letter
  non-whitespace characters.
  */
  moveByGroup(start, forward) {
    return skipAtoms(this, start, moveByChar(this, start, forward, (initial2) => byGroup(this, start.head, initial2)));
  }
  /**
  Get the cursor position visually at the start or end of a line.
  Note that this may differ from the _logical_ position at its
  start or end (which is simply at `line.from`/`line.to`) if text
  at the start or end goes against the line's base text direction.
  */
  visualLineSide(line, end) {
    let order = this.bidiSpans(line), dir = this.textDirectionAt(line.from);
    let span = order[end ? order.length - 1 : 0];
    return EditorSelection.cursor(span.side(end, dir) + line.from, span.forward(!end, dir) ? 1 : -1);
  }
  /**
  Move to the next line boundary in the given direction. If
  `includeWrap` is true, line wrapping is on, and there is a
  further wrap point on the current line, the wrap point will be
  returned. Otherwise this function will return the start or end
  of the line.
  */
  moveToLineBoundary(start, forward, includeWrap = true) {
    return moveToLineBoundary(this, start, forward, includeWrap);
  }
  /**
  Move a cursor position vertically. When `distance` isn't given,
  it defaults to moving to the next line (including wrapped
  lines). Otherwise, `distance` should provide a positive distance
  in pixels.
  
  When `start` has a
  [`goalColumn`](https://codemirror.net/6/docs/ref/#state.SelectionRange.goalColumn), the vertical
  motion will use that as a target horizontal position. Otherwise,
  the cursor's own horizontal position is used. The returned
  cursor will have its goal column set to whichever column was
  used.
  */
  moveVertically(start, forward, distance) {
    return skipAtoms(this, start, moveVertically(this, start, forward, distance));
  }
  /**
  Find the DOM parent node and offset (child offset if `node` is
  an element, character offset when it is a text node) at the
  given document position.
  
  Note that for positions that aren't currently in
  `visibleRanges`, the resulting DOM position isn't necessarily
  meaningful (it may just point before or after a placeholder
  element).
  */
  domAtPos(pos) {
    return this.docView.domAtPos(pos);
  }
  /**
  Find the document position at the given DOM node. Can be useful
  for associating positions with DOM events. Will raise an error
  when `node` isn't part of the editor content.
  */
  posAtDOM(node, offset = 0) {
    return this.docView.posFromDOM(node, offset);
  }
  posAtCoords(coords, precise = true) {
    this.readMeasured();
    return posAtCoords(this, coords, precise);
  }
  /**
  Get the screen coordinates at the given document position.
  `side` determines whether the coordinates are based on the
  element before (-1) or after (1) the position (if no element is
  available on the given side, the method will transparently use
  another strategy to get reasonable coordinates).
  */
  coordsAtPos(pos, side = 1) {
    this.readMeasured();
    let rect = this.docView.coordsAt(pos, side);
    if (!rect || rect.left == rect.right)
      return rect;
    let line = this.state.doc.lineAt(pos), order = this.bidiSpans(line);
    let span = order[BidiSpan.find(order, pos - line.from, -1, side)];
    return flattenRect(rect, span.dir == Direction.LTR == side > 0);
  }
  /**
  Return the rectangle around a given character. If `pos` does not
  point in front of a character that is in the viewport and
  rendered (i.e. not replaced, not a line break), this will return
  null. For space characters that are a line wrap point, this will
  return the position before the line break.
  */
  coordsForChar(pos) {
    this.readMeasured();
    return this.docView.coordsForChar(pos);
  }
  /**
  The default width of a character in the editor. May not
  accurately reflect the width of all characters (given variable
  width fonts or styling of invididual ranges).
  */
  get defaultCharacterWidth() {
    return this.viewState.heightOracle.charWidth;
  }
  /**
  The default height of a line in the editor. May not be accurate
  for all lines.
  */
  get defaultLineHeight() {
    return this.viewState.heightOracle.lineHeight;
  }
  /**
  The text direction
  ([`direction`](https://developer.mozilla.org/en-US/docs/Web/CSS/direction)
  CSS property) of the editor's content element.
  */
  get textDirection() {
    return this.viewState.defaultTextDirection;
  }
  /**
  Find the text direction of the block at the given position, as
  assigned by CSS. If
  [`perLineTextDirection`](https://codemirror.net/6/docs/ref/#view.EditorView^perLineTextDirection)
  isn't enabled, or the given position is outside of the viewport,
  this will always return the same as
  [`textDirection`](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection). Note that
  this may trigger a DOM layout.
  */
  textDirectionAt(pos) {
    let perLine = this.state.facet(perLineTextDirection);
    if (!perLine || pos < this.viewport.from || pos > this.viewport.to)
      return this.textDirection;
    this.readMeasured();
    return this.docView.textDirectionAt(pos);
  }
  /**
  Whether this editor [wraps lines](https://codemirror.net/6/docs/ref/#view.EditorView.lineWrapping)
  (as determined by the
  [`white-space`](https://developer.mozilla.org/en-US/docs/Web/CSS/white-space)
  CSS property of its content element).
  */
  get lineWrapping() {
    return this.viewState.heightOracle.lineWrapping;
  }
  /**
  Returns the bidirectional text structure of the given line
  (which should be in the current document) as an array of span
  objects. The order of these spans matches the [text
  direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection)—if that is
  left-to-right, the leftmost spans come first, otherwise the
  rightmost spans come first.
  */
  bidiSpans(line) {
    if (line.length > MaxBidiLine)
      return trivialOrder(line.length);
    let dir = this.textDirectionAt(line.from), isolates;
    for (let entry of this.bidiCache) {
      if (entry.from == line.from && entry.dir == dir && (entry.fresh || isolatesEq(entry.isolates, isolates = getIsolatedRanges(this, line))))
        return entry.order;
    }
    if (!isolates)
      isolates = getIsolatedRanges(this, line);
    let order = computeOrder(line.text, dir, isolates);
    this.bidiCache.push(new CachedOrder(line.from, line.to, dir, isolates, true, order));
    return order;
  }
  /**
  Check whether the editor has focus.
  */
  get hasFocus() {
    var _a4;
    return (this.dom.ownerDocument.hasFocus() || browser.safari && ((_a4 = this.inputState) === null || _a4 === void 0 ? void 0 : _a4.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;
  }
  /**
  Put focus on the editor.
  */
  focus() {
    this.observer.ignore(() => {
      focusPreventScroll(this.contentDOM);
      this.docView.updateSelection();
    });
  }
  /**
  Update the [root](https://codemirror.net/6/docs/ref/##view.EditorViewConfig.root) in which the editor lives. This is only
  necessary when moving the editor's existing DOM to a new window or shadow root.
  */
  setRoot(root) {
    if (this._root != root) {
      this._root = root;
      this.observer.setWindow((root.nodeType == 9 ? root : root.ownerDocument).defaultView || window);
      this.mountStyles();
    }
  }
  /**
  Clean up this editor view, removing its element from the
  document, unregistering event handlers, and notifying
  plugins. The view instance can no longer be used after
  calling this.
  */
  destroy() {
    if (this.root.activeElement == this.contentDOM)
      this.contentDOM.blur();
    for (let plugin3 of this.plugins)
      plugin3.destroy(this);
    this.plugins = [];
    this.inputState.destroy();
    this.docView.destroy();
    this.dom.remove();
    this.observer.destroy();
    if (this.measureScheduled > -1)
      this.win.cancelAnimationFrame(this.measureScheduled);
    this.destroyed = true;
  }
  /**
  Returns an effect that can be
  [added](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) to a transaction to
  cause it to scroll the given position or range into view.
  */
  static scrollIntoView(pos, options = {}) {
    return scrollIntoView.of(new ScrollTarget(typeof pos == "number" ? EditorSelection.cursor(pos) : pos, options.y, options.x, options.yMargin, options.xMargin));
  }
  /**
  Return an effect that resets the editor to its current (at the
  time this method was called) scroll position. Note that this
  only affects the editor's own scrollable element, not parents.
  See also
  [`EditorViewConfig.scrollTo`](https://codemirror.net/6/docs/ref/#view.EditorViewConfig.scrollTo).
  
  The effect should be used with a document identical to the one
  it was created for. Failing to do so is not an error, but may
  not scroll to the expected position. You can
  [map](https://codemirror.net/6/docs/ref/#state.StateEffect.map) the effect to account for changes.
  */
  scrollSnapshot() {
    let { scrollTop, scrollLeft } = this.scrollDOM;
    let ref2 = this.viewState.scrollAnchorAt(scrollTop);
    return scrollIntoView.of(new ScrollTarget(EditorSelection.cursor(ref2.from), "start", "start", ref2.top - scrollTop, scrollLeft, true));
  }
  /**
  Enable or disable tab-focus mode, which disables key bindings
  for Tab and Shift-Tab, letting the browser's default
  focus-changing behavior go through instead. This is useful to
  prevent trapping keyboard users in your editor.
  
  Without argument, this toggles the mode. With a boolean, it
  enables (true) or disables it (false). Given a number, it
  temporarily enables the mode until that number of milliseconds
  have passed or another non-Tab key is pressed.
  */
  setTabFocusMode(to3) {
    if (to3 == null)
      this.inputState.tabFocusMode = this.inputState.tabFocusMode < 0 ? 0 : -1;
    else if (typeof to3 == "boolean")
      this.inputState.tabFocusMode = to3 ? 0 : -1;
    else if (this.inputState.tabFocusMode != 0)
      this.inputState.tabFocusMode = Date.now() + to3;
  }
  /**
  Returns an extension that can be used to add DOM event handlers.
  The value should be an object mapping event names to handler
  functions. For any given event, such functions are ordered by
  extension precedence, and the first handler to return true will
  be assumed to have handled that event, and no other handlers or
  built-in behavior will be activated for it. These are registered
  on the [content element](https://codemirror.net/6/docs/ref/#view.EditorView.contentDOM), except
  for `scroll` handlers, which will be called any time the
  editor's [scroll element](https://codemirror.net/6/docs/ref/#view.EditorView.scrollDOM) or one of
  its parent nodes is scrolled.
  */
  static domEventHandlers(handlers2) {
    return ViewPlugin.define(() => ({}), { eventHandlers: handlers2 });
  }
  /**
  Create an extension that registers DOM event observers. Contrary
  to event [handlers](https://codemirror.net/6/docs/ref/#view.EditorView^domEventHandlers),
  observers can't be prevented from running by a higher-precedence
  handler returning true. They also don't prevent other handlers
  and observers from running when they return true, and should not
  call `preventDefault`.
  */
  static domEventObservers(observers2) {
    return ViewPlugin.define(() => ({}), { eventObservers: observers2 });
  }
  /**
  Create a theme extension. The first argument can be a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)
  style spec providing the styles for the theme. These will be
  prefixed with a generated class for the style.
  
  Because the selectors will be prefixed with a scope class, rule
  that directly match the editor's [wrapper
  element](https://codemirror.net/6/docs/ref/#view.EditorView.dom)—to which the scope class will be
  added—need to be explicitly differentiated by adding an `&` to
  the selector for that element—for example
  `&.cm-focused`.
  
  When `dark` is set to true, the theme will be marked as dark,
  which will cause the `&dark` rules from [base
  themes](https://codemirror.net/6/docs/ref/#view.EditorView^baseTheme) to be used (as opposed to
  `&light` when a light theme is active).
  */
  static theme(spec, options) {
    let prefix = StyleModule.newName();
    let result = [theme.of(prefix), styleModule.of(buildTheme(`.${prefix}`, spec))];
    if (options && options.dark)
      result.push(darkTheme.of(true));
    return result;
  }
  /**
  Create an extension that adds styles to the base theme. Like
  with [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme), use `&` to indicate the
  place of the editor wrapper element when directly targeting
  that. You can also use `&dark` or `&light` instead to only
  target editors with a dark or light theme.
  */
  static baseTheme(spec) {
    return Prec.lowest(styleModule.of(buildTheme("." + baseThemeID, spec, lightDarkIDs)));
  }
  /**
  Retrieve an editor view instance from the view's DOM
  representation.
  */
  static findFromDOM(dom) {
    var _a4;
    let content2 = dom.querySelector(".cm-content");
    let cView = content2 && ContentView.get(content2) || ContentView.get(dom);
    return ((_a4 = cView === null || cView === void 0 ? void 0 : cView.rootView) === null || _a4 === void 0 ? void 0 : _a4.view) || null;
  }
};
EditorView.styleModule = styleModule;
EditorView.inputHandler = inputHandler;
EditorView.clipboardInputFilter = clipboardInputFilter;
EditorView.clipboardOutputFilter = clipboardOutputFilter;
EditorView.scrollHandler = scrollHandler;
EditorView.focusChangeEffect = focusChangeEffect;
EditorView.perLineTextDirection = perLineTextDirection;
EditorView.exceptionSink = exceptionSink;
EditorView.updateListener = updateListener;
EditorView.editable = editable;
EditorView.mouseSelectionStyle = mouseSelectionStyle;
EditorView.dragMovesSelection = dragMovesSelection$1;
EditorView.clickAddsSelectionRange = clickAddsSelectionRange;
EditorView.decorations = decorations;
EditorView.outerDecorations = outerDecorations;
EditorView.atomicRanges = atomicRanges;
EditorView.bidiIsolatedRanges = bidiIsolatedRanges;
EditorView.scrollMargins = scrollMargins;
EditorView.darkTheme = darkTheme;
EditorView.cspNonce = Facet.define({ combine: (values) => values.length ? values[0] : "" });
EditorView.contentAttributes = contentAttributes;
EditorView.editorAttributes = editorAttributes;
EditorView.lineWrapping = EditorView.contentAttributes.of({ "class": "cm-lineWrapping" });
EditorView.announce = StateEffect.define();
var MaxBidiLine = 4096;
var BadMeasure = {};
var CachedOrder = class _CachedOrder {
  constructor(from, to3, dir, isolates, fresh, order) {
    this.from = from;
    this.to = to3;
    this.dir = dir;
    this.isolates = isolates;
    this.fresh = fresh;
    this.order = order;
  }
  static update(cache, changes) {
    if (changes.empty && !cache.some((c) => c.fresh))
      return cache;
    let result = [], lastDir = cache.length ? cache[cache.length - 1].dir : Direction.LTR;
    for (let i2 = Math.max(0, cache.length - 10); i2 < cache.length; i2++) {
      let entry = cache[i2];
      if (entry.dir == lastDir && !changes.touchesRange(entry.from, entry.to))
        result.push(new _CachedOrder(changes.mapPos(entry.from, 1), changes.mapPos(entry.to, -1), entry.dir, entry.isolates, false, entry.order));
    }
    return result;
  }
};
function attrsFromFacet(view, facet, base2) {
  for (let sources = view.state.facet(facet), i2 = sources.length - 1; i2 >= 0; i2--) {
    let source = sources[i2], value = typeof source == "function" ? source(view) : source;
    if (value)
      combineAttrs(value, base2);
  }
  return base2;
}
var currentPlatform = browser.mac ? "mac" : browser.windows ? "win" : browser.linux ? "linux" : "key";
function normalizeKeyName(name2, platform) {
  const parts = name2.split(/-(?!$)/);
  let result = parts[parts.length - 1];
  if (result == "Space")
    result = " ";
  let alt, ctrl, shift2, meta2;
  for (let i2 = 0; i2 < parts.length - 1; ++i2) {
    const mod = parts[i2];
    if (/^(cmd|meta|m)$/i.test(mod))
      meta2 = true;
    else if (/^a(lt)?$/i.test(mod))
      alt = true;
    else if (/^(c|ctrl|control)$/i.test(mod))
      ctrl = true;
    else if (/^s(hift)?$/i.test(mod))
      shift2 = true;
    else if (/^mod$/i.test(mod)) {
      if (platform == "mac")
        meta2 = true;
      else
        ctrl = true;
    } else
      throw new Error("Unrecognized modifier name: " + mod);
  }
  if (alt)
    result = "Alt-" + result;
  if (ctrl)
    result = "Ctrl-" + result;
  if (meta2)
    result = "Meta-" + result;
  if (shift2)
    result = "Shift-" + result;
  return result;
}
function modifiers(name2, event, shift2) {
  if (event.altKey)
    name2 = "Alt-" + name2;
  if (event.ctrlKey)
    name2 = "Ctrl-" + name2;
  if (event.metaKey)
    name2 = "Meta-" + name2;
  if (shift2 !== false && event.shiftKey)
    name2 = "Shift-" + name2;
  return name2;
}
var handleKeyEvents = Prec.default(EditorView.domEventHandlers({
  keydown(event, view) {
    return runHandlers(getKeymap(view.state), event, view, "editor");
  }
}));
var keymap = Facet.define({ enables: handleKeyEvents });
var Keymaps = /* @__PURE__ */ new WeakMap();
function getKeymap(state) {
  let bindings = state.facet(keymap);
  let map = Keymaps.get(bindings);
  if (!map)
    Keymaps.set(bindings, map = buildKeymap(bindings.reduce((a2, b2) => a2.concat(b2), [])));
  return map;
}
function runScopeHandlers(view, event, scope) {
  return runHandlers(getKeymap(view.state), event, view, scope);
}
var storedPrefix = null;
var PrefixTimeout = 4e3;
function buildKeymap(bindings, platform = currentPlatform) {
  let bound = /* @__PURE__ */ Object.create(null);
  let isPrefix = /* @__PURE__ */ Object.create(null);
  let checkPrefix = (name2, is2) => {
    let current = isPrefix[name2];
    if (current == null)
      isPrefix[name2] = is2;
    else if (current != is2)
      throw new Error("Key binding " + name2 + " is used both as a regular binding and as a multi-stroke prefix");
  };
  let add3 = (scope, key, command2, preventDefault, stopPropagation) => {
    var _a4, _b;
    let scopeObj = bound[scope] || (bound[scope] = /* @__PURE__ */ Object.create(null));
    let parts = key.split(/ (?!$)/).map((k2) => normalizeKeyName(k2, platform));
    for (let i2 = 1; i2 < parts.length; i2++) {
      let prefix = parts.slice(0, i2).join(" ");
      checkPrefix(prefix, true);
      if (!scopeObj[prefix])
        scopeObj[prefix] = {
          preventDefault: true,
          stopPropagation: false,
          run: [(view) => {
            let ourObj = storedPrefix = { view, prefix, scope };
            setTimeout(() => {
              if (storedPrefix == ourObj)
                storedPrefix = null;
            }, PrefixTimeout);
            return true;
          }]
        };
    }
    let full = parts.join(" ");
    checkPrefix(full, false);
    let binding = scopeObj[full] || (scopeObj[full] = {
      preventDefault: false,
      stopPropagation: false,
      run: ((_b = (_a4 = scopeObj._any) === null || _a4 === void 0 ? void 0 : _a4.run) === null || _b === void 0 ? void 0 : _b.slice()) || []
    });
    if (command2)
      binding.run.push(command2);
    if (preventDefault)
      binding.preventDefault = true;
    if (stopPropagation)
      binding.stopPropagation = true;
  };
  for (let b2 of bindings) {
    let scopes = b2.scope ? b2.scope.split(" ") : ["editor"];
    if (b2.any)
      for (let scope of scopes) {
        let scopeObj = bound[scope] || (bound[scope] = /* @__PURE__ */ Object.create(null));
        if (!scopeObj._any)
          scopeObj._any = { preventDefault: false, stopPropagation: false, run: [] };
        let { any } = b2;
        for (let key in scopeObj)
          scopeObj[key].run.push((view) => any(view, currentKeyEvent));
      }
    let name2 = b2[platform] || b2.key;
    if (!name2)
      continue;
    for (let scope of scopes) {
      add3(scope, name2, b2.run, b2.preventDefault, b2.stopPropagation);
      if (b2.shift)
        add3(scope, "Shift-" + name2, b2.shift, b2.preventDefault, b2.stopPropagation);
    }
  }
  return bound;
}
var currentKeyEvent = null;
function runHandlers(map, event, view, scope) {
  currentKeyEvent = event;
  let name2 = keyName(event);
  let charCode = codePointAt(name2, 0), isChar = codePointSize(charCode) == name2.length && name2 != " ";
  let prefix = "", handled = false, prevented = false, stopPropagation = false;
  if (storedPrefix && storedPrefix.view == view && storedPrefix.scope == scope) {
    prefix = storedPrefix.prefix + " ";
    if (modifierCodes.indexOf(event.keyCode) < 0) {
      prevented = true;
      storedPrefix = null;
    }
  }
  let ran = /* @__PURE__ */ new Set();
  let runFor = (binding) => {
    if (binding) {
      for (let cmd2 of binding.run)
        if (!ran.has(cmd2)) {
          ran.add(cmd2);
          if (cmd2(view)) {
            if (binding.stopPropagation)
              stopPropagation = true;
            return true;
          }
        }
      if (binding.preventDefault) {
        if (binding.stopPropagation)
          stopPropagation = true;
        prevented = true;
      }
    }
    return false;
  };
  let scopeObj = map[scope], baseName, shiftName;
  if (scopeObj) {
    if (runFor(scopeObj[prefix + modifiers(name2, event, !isChar)])) {
      handled = true;
    } else if (isChar && (event.altKey || event.metaKey || event.ctrlKey) && // Ctrl-Alt may be used for AltGr on Windows
    !(browser.windows && event.ctrlKey && event.altKey) && (baseName = base[event.keyCode]) && baseName != name2) {
      if (runFor(scopeObj[prefix + modifiers(baseName, event, true)])) {
        handled = true;
      } else if (event.shiftKey && (shiftName = shift[event.keyCode]) != name2 && shiftName != baseName && runFor(scopeObj[prefix + modifiers(shiftName, event, false)])) {
        handled = true;
      }
    } else if (isChar && event.shiftKey && runFor(scopeObj[prefix + modifiers(name2, event, true)])) {
      handled = true;
    }
    if (!handled && runFor(scopeObj._any))
      handled = true;
  }
  if (prevented)
    handled = true;
  if (handled && stopPropagation)
    event.stopPropagation();
  currentKeyEvent = null;
  return handled;
}
var RectangleMarker = class _RectangleMarker {
  /**
  Create a marker with the given class and dimensions. If `width`
  is null, the DOM element will get no width style.
  */
  constructor(className, left, top2, width, height) {
    this.className = className;
    this.left = left;
    this.top = top2;
    this.width = width;
    this.height = height;
  }
  draw() {
    let elt = document.createElement("div");
    elt.className = this.className;
    this.adjust(elt);
    return elt;
  }
  update(elt, prev) {
    if (prev.className != this.className)
      return false;
    this.adjust(elt);
    return true;
  }
  adjust(elt) {
    elt.style.left = this.left + "px";
    elt.style.top = this.top + "px";
    if (this.width != null)
      elt.style.width = this.width + "px";
    elt.style.height = this.height + "px";
  }
  eq(p) {
    return this.left == p.left && this.top == p.top && this.width == p.width && this.height == p.height && this.className == p.className;
  }
  /**
  Create a set of rectangles for the given selection range,
  assigning them theclass`className`. Will create a single
  rectangle for empty ranges, and a set of selection-style
  rectangles covering the range's content (in a bidi-aware
  way) for non-empty ones.
  */
  static forRange(view, className, range) {
    if (range.empty) {
      let pos = view.coordsAtPos(range.head, range.assoc || 1);
      if (!pos)
        return [];
      let base2 = getBase(view);
      return [new _RectangleMarker(className, pos.left - base2.left, pos.top - base2.top, null, pos.bottom - pos.top)];
    } else {
      return rectanglesForRange(view, className, range);
    }
  }
};
function getBase(view) {
  let rect = view.scrollDOM.getBoundingClientRect();
  let left = view.textDirection == Direction.LTR ? rect.left : rect.right - view.scrollDOM.clientWidth * view.scaleX;
  return { left: left - view.scrollDOM.scrollLeft * view.scaleX, top: rect.top - view.scrollDOM.scrollTop * view.scaleY };
}
function wrappedLine(view, pos, side, inside2) {
  let coords = view.coordsAtPos(pos, side * 2);
  if (!coords)
    return inside2;
  let editorRect = view.dom.getBoundingClientRect();
  let y = (coords.top + coords.bottom) / 2;
  let left = view.posAtCoords({ x: editorRect.left + 1, y });
  let right = view.posAtCoords({ x: editorRect.right - 1, y });
  if (left == null || right == null)
    return inside2;
  return { from: Math.max(inside2.from, Math.min(left, right)), to: Math.min(inside2.to, Math.max(left, right)) };
}
function rectanglesForRange(view, className, range) {
  if (range.to <= view.viewport.from || range.from >= view.viewport.to)
    return [];
  let from = Math.max(range.from, view.viewport.from), to3 = Math.min(range.to, view.viewport.to);
  let ltr = view.textDirection == Direction.LTR;
  let content2 = view.contentDOM, contentRect = content2.getBoundingClientRect(), base2 = getBase(view);
  let lineElt = content2.querySelector(".cm-line"), lineStyle = lineElt && window.getComputedStyle(lineElt);
  let leftSide = contentRect.left + (lineStyle ? parseInt(lineStyle.paddingLeft) + Math.min(0, parseInt(lineStyle.textIndent)) : 0);
  let rightSide = contentRect.right - (lineStyle ? parseInt(lineStyle.paddingRight) : 0);
  let startBlock = blockAt(view, from), endBlock = blockAt(view, to3);
  let visualStart = startBlock.type == BlockType.Text ? startBlock : null;
  let visualEnd = endBlock.type == BlockType.Text ? endBlock : null;
  if (visualStart && (view.lineWrapping || startBlock.widgetLineBreaks))
    visualStart = wrappedLine(view, from, 1, visualStart);
  if (visualEnd && (view.lineWrapping || endBlock.widgetLineBreaks))
    visualEnd = wrappedLine(view, to3, -1, visualEnd);
  if (visualStart && visualEnd && visualStart.from == visualEnd.from && visualStart.to == visualEnd.to) {
    return pieces(drawForLine(range.from, range.to, visualStart));
  } else {
    let top2 = visualStart ? drawForLine(range.from, null, visualStart) : drawForWidget(startBlock, false);
    let bottom = visualEnd ? drawForLine(null, range.to, visualEnd) : drawForWidget(endBlock, true);
    let between = [];
    if ((visualStart || startBlock).to < (visualEnd || endBlock).from - (visualStart && visualEnd ? 1 : 0) || startBlock.widgetLineBreaks > 1 && top2.bottom + view.defaultLineHeight / 2 < bottom.top)
      between.push(piece(leftSide, top2.bottom, rightSide, bottom.top));
    else if (top2.bottom < bottom.top && view.elementAtHeight((top2.bottom + bottom.top) / 2).type == BlockType.Text)
      top2.bottom = bottom.top = (top2.bottom + bottom.top) / 2;
    return pieces(top2).concat(between).concat(pieces(bottom));
  }
  function piece(left, top2, right, bottom) {
    return new RectangleMarker(
      className,
      left - base2.left,
      top2 - base2.top - 0.01,
      right - left,
      bottom - top2 + 0.01
      /* C.Epsilon */
    );
  }
  function pieces({ top: top2, bottom, horizontal }) {
    let pieces2 = [];
    for (let i2 = 0; i2 < horizontal.length; i2 += 2)
      pieces2.push(piece(horizontal[i2], top2, horizontal[i2 + 1], bottom));
    return pieces2;
  }
  function drawForLine(from2, to4, line) {
    let top2 = 1e9, bottom = -1e9, horizontal = [];
    function addSpan(from3, fromOpen, to5, toOpen, dir) {
      let fromCoords = view.coordsAtPos(from3, from3 == line.to ? -2 : 2);
      let toCoords = view.coordsAtPos(to5, to5 == line.from ? 2 : -2);
      if (!fromCoords || !toCoords)
        return;
      top2 = Math.min(fromCoords.top, toCoords.top, top2);
      bottom = Math.max(fromCoords.bottom, toCoords.bottom, bottom);
      if (dir == Direction.LTR)
        horizontal.push(ltr && fromOpen ? leftSide : fromCoords.left, ltr && toOpen ? rightSide : toCoords.right);
      else
        horizontal.push(!ltr && toOpen ? leftSide : toCoords.left, !ltr && fromOpen ? rightSide : fromCoords.right);
    }
    let start = from2 !== null && from2 !== void 0 ? from2 : line.from, end = to4 !== null && to4 !== void 0 ? to4 : line.to;
    for (let r2 of view.visibleRanges)
      if (r2.to > start && r2.from < end) {
        for (let pos = Math.max(r2.from, start), endPos = Math.min(r2.to, end); ; ) {
          let docLine = view.state.doc.lineAt(pos);
          for (let span of view.bidiSpans(docLine)) {
            let spanFrom = span.from + docLine.from, spanTo = span.to + docLine.from;
            if (spanFrom >= endPos)
              break;
            if (spanTo > pos)
              addSpan(Math.max(spanFrom, pos), from2 == null && spanFrom <= start, Math.min(spanTo, endPos), to4 == null && spanTo >= end, span.dir);
          }
          pos = docLine.to + 1;
          if (pos >= endPos)
            break;
        }
      }
    if (horizontal.length == 0)
      addSpan(start, from2 == null, end, to4 == null, view.textDirection);
    return { top: top2, bottom, horizontal };
  }
  function drawForWidget(block, top2) {
    let y = contentRect.top + (top2 ? block.top : block.bottom);
    return { top: y, bottom: y, horizontal: [] };
  }
}
function sameMarker(a2, b2) {
  return a2.constructor == b2.constructor && a2.eq(b2);
}
var LayerView = class {
  constructor(view, layer2) {
    this.view = view;
    this.layer = layer2;
    this.drawn = [];
    this.scaleX = 1;
    this.scaleY = 1;
    this.measureReq = { read: this.measure.bind(this), write: this.draw.bind(this) };
    this.dom = view.scrollDOM.appendChild(document.createElement("div"));
    this.dom.classList.add("cm-layer");
    if (layer2.above)
      this.dom.classList.add("cm-layer-above");
    if (layer2.class)
      this.dom.classList.add(layer2.class);
    this.scale();
    this.dom.setAttribute("aria-hidden", "true");
    this.setOrder(view.state);
    view.requestMeasure(this.measureReq);
    if (layer2.mount)
      layer2.mount(this.dom, view);
  }
  update(update) {
    if (update.startState.facet(layerOrder) != update.state.facet(layerOrder))
      this.setOrder(update.state);
    if (this.layer.update(update, this.dom) || update.geometryChanged) {
      this.scale();
      update.view.requestMeasure(this.measureReq);
    }
  }
  docViewUpdate(view) {
    if (this.layer.updateOnDocViewUpdate !== false)
      view.requestMeasure(this.measureReq);
  }
  setOrder(state) {
    let pos = 0, order = state.facet(layerOrder);
    while (pos < order.length && order[pos] != this.layer)
      pos++;
    this.dom.style.zIndex = String((this.layer.above ? 150 : -1) - pos);
  }
  measure() {
    return this.layer.markers(this.view);
  }
  scale() {
    let { scaleX, scaleY } = this.view;
    if (scaleX != this.scaleX || scaleY != this.scaleY) {
      this.scaleX = scaleX;
      this.scaleY = scaleY;
      this.dom.style.transform = `scale(${1 / scaleX}, ${1 / scaleY})`;
    }
  }
  draw(markers) {
    if (markers.length != this.drawn.length || markers.some((p, i2) => !sameMarker(p, this.drawn[i2]))) {
      let old = this.dom.firstChild, oldI = 0;
      for (let marker of markers) {
        if (marker.update && old && marker.constructor && this.drawn[oldI].constructor && marker.update(old, this.drawn[oldI])) {
          old = old.nextSibling;
          oldI++;
        } else {
          this.dom.insertBefore(marker.draw(), old);
        }
      }
      while (old) {
        let next = old.nextSibling;
        old.remove();
        old = next;
      }
      this.drawn = markers;
    }
  }
  destroy() {
    if (this.layer.destroy)
      this.layer.destroy(this.dom, this.view);
    this.dom.remove();
  }
};
var layerOrder = Facet.define();
function layer(config2) {
  return [
    ViewPlugin.define((v) => new LayerView(v, config2)),
    layerOrder.of(config2)
  ];
}
var CanHidePrimary = !browser.ios;
var selectionConfig = Facet.define({
  combine(configs) {
    return combineConfig(configs, {
      cursorBlinkRate: 1200,
      drawRangeCursor: true
    }, {
      cursorBlinkRate: (a2, b2) => Math.min(a2, b2),
      drawRangeCursor: (a2, b2) => a2 || b2
    });
  }
});
function drawSelection(config2 = {}) {
  return [
    selectionConfig.of(config2),
    cursorLayer,
    selectionLayer,
    hideNativeSelection,
    nativeSelectionHidden.of(true)
  ];
}
function configChanged(update) {
  return update.startState.facet(selectionConfig) != update.state.facet(selectionConfig);
}
var cursorLayer = layer({
  above: true,
  markers(view) {
    let { state } = view, conf = state.facet(selectionConfig);
    let cursors = [];
    for (let r2 of state.selection.ranges) {
      let prim = r2 == state.selection.main;
      if (r2.empty ? !prim || CanHidePrimary : conf.drawRangeCursor) {
        let className = prim ? "cm-cursor cm-cursor-primary" : "cm-cursor cm-cursor-secondary";
        let cursor = r2.empty ? r2 : EditorSelection.cursor(r2.head, r2.head > r2.anchor ? -1 : 1);
        for (let piece of RectangleMarker.forRange(view, className, cursor))
          cursors.push(piece);
      }
    }
    return cursors;
  },
  update(update, dom) {
    if (update.transactions.some((tr3) => tr3.selection))
      dom.style.animationName = dom.style.animationName == "cm-blink" ? "cm-blink2" : "cm-blink";
    let confChange = configChanged(update);
    if (confChange)
      setBlinkRate(update.state, dom);
    return update.docChanged || update.selectionSet || confChange;
  },
  mount(dom, view) {
    setBlinkRate(view.state, dom);
  },
  class: "cm-cursorLayer"
});
function setBlinkRate(state, dom) {
  dom.style.animationDuration = state.facet(selectionConfig).cursorBlinkRate + "ms";
}
var selectionLayer = layer({
  above: false,
  markers(view) {
    return view.state.selection.ranges.map((r2) => r2.empty ? [] : RectangleMarker.forRange(view, "cm-selectionBackground", r2)).reduce((a2, b2) => a2.concat(b2));
  },
  update(update, dom) {
    return update.docChanged || update.selectionSet || update.viewportChanged || configChanged(update);
  },
  class: "cm-selectionLayer"
});
var themeSpec = {
  ".cm-line": {
    "& ::selection, &::selection": { backgroundColor: "transparent !important" }
  },
  ".cm-content": {
    "& :focus": {
      caretColor: "initial !important",
      "&::selection, & ::selection": {
        backgroundColor: "Highlight !important"
      }
    }
  }
};
if (CanHidePrimary)
  themeSpec[".cm-line"].caretColor = themeSpec[".cm-content"].caretColor = "transparent !important";
var hideNativeSelection = Prec.highest(EditorView.theme(themeSpec));
var setDropCursorPos = StateEffect.define({
  map(pos, mapping) {
    return pos == null ? null : mapping.mapPos(pos);
  }
});
var dropCursorPos = StateField.define({
  create() {
    return null;
  },
  update(pos, tr3) {
    if (pos != null)
      pos = tr3.changes.mapPos(pos);
    return tr3.effects.reduce((pos2, e2) => e2.is(setDropCursorPos) ? e2.value : pos2, pos);
  }
});
var drawDropCursor = ViewPlugin.fromClass(class {
  constructor(view) {
    this.view = view;
    this.cursor = null;
    this.measureReq = { read: this.readPos.bind(this), write: this.drawCursor.bind(this) };
  }
  update(update) {
    var _a4;
    let cursorPos = update.state.field(dropCursorPos);
    if (cursorPos == null) {
      if (this.cursor != null) {
        (_a4 = this.cursor) === null || _a4 === void 0 ? void 0 : _a4.remove();
        this.cursor = null;
      }
    } else {
      if (!this.cursor) {
        this.cursor = this.view.scrollDOM.appendChild(document.createElement("div"));
        this.cursor.className = "cm-dropCursor";
      }
      if (update.startState.field(dropCursorPos) != cursorPos || update.docChanged || update.geometryChanged)
        this.view.requestMeasure(this.measureReq);
    }
  }
  readPos() {
    let { view } = this;
    let pos = view.state.field(dropCursorPos);
    let rect = pos != null && view.coordsAtPos(pos);
    if (!rect)
      return null;
    let outer = view.scrollDOM.getBoundingClientRect();
    return {
      left: rect.left - outer.left + view.scrollDOM.scrollLeft * view.scaleX,
      top: rect.top - outer.top + view.scrollDOM.scrollTop * view.scaleY,
      height: rect.bottom - rect.top
    };
  }
  drawCursor(pos) {
    if (this.cursor) {
      let { scaleX, scaleY } = this.view;
      if (pos) {
        this.cursor.style.left = pos.left / scaleX + "px";
        this.cursor.style.top = pos.top / scaleY + "px";
        this.cursor.style.height = pos.height / scaleY + "px";
      } else {
        this.cursor.style.left = "-100000px";
      }
    }
  }
  destroy() {
    if (this.cursor)
      this.cursor.remove();
  }
  setDropPos(pos) {
    if (this.view.state.field(dropCursorPos) != pos)
      this.view.dispatch({ effects: setDropCursorPos.of(pos) });
  }
}, {
  eventObservers: {
    dragover(event) {
      this.setDropPos(this.view.posAtCoords({ x: event.clientX, y: event.clientY }));
    },
    dragleave(event) {
      if (event.target == this.view.contentDOM || !this.view.contentDOM.contains(event.relatedTarget))
        this.setDropPos(null);
    },
    dragend() {
      this.setDropPos(null);
    },
    drop() {
      this.setDropPos(null);
    }
  }
});
function dropCursor() {
  return [dropCursorPos, drawDropCursor];
}
function iterMatches(doc2, re2, from, to3, f) {
  re2.lastIndex = 0;
  for (let cursor = doc2.iterRange(from, to3), pos = from, m3; !cursor.next().done; pos += cursor.value.length) {
    if (!cursor.lineBreak)
      while (m3 = re2.exec(cursor.value))
        f(pos + m3.index, m3);
  }
}
function matchRanges(view, maxLength) {
  let visible = view.visibleRanges;
  if (visible.length == 1 && visible[0].from == view.viewport.from && visible[0].to == view.viewport.to)
    return visible;
  let result = [];
  for (let { from, to: to3 } of visible) {
    from = Math.max(view.state.doc.lineAt(from).from, from - maxLength);
    to3 = Math.min(view.state.doc.lineAt(to3).to, to3 + maxLength);
    if (result.length && result[result.length - 1].to >= from)
      result[result.length - 1].to = to3;
    else
      result.push({ from, to: to3 });
  }
  return result;
}
var MatchDecorator = class {
  /**
  Create a decorator.
  */
  constructor(config2) {
    const { regexp, decoration, decorate, boundary, maxLength = 1e3 } = config2;
    if (!regexp.global)
      throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set");
    this.regexp = regexp;
    if (decorate) {
      this.addMatch = (match, view, from, add3) => decorate(add3, from, from + match[0].length, match, view);
    } else if (typeof decoration == "function") {
      this.addMatch = (match, view, from, add3) => {
        let deco = decoration(match, view, from);
        if (deco)
          add3(from, from + match[0].length, deco);
      };
    } else if (decoration) {
      this.addMatch = (match, _view, from, add3) => add3(from, from + match[0].length, decoration);
    } else {
      throw new RangeError("Either 'decorate' or 'decoration' should be provided to MatchDecorator");
    }
    this.boundary = boundary;
    this.maxLength = maxLength;
  }
  /**
  Compute the full set of decorations for matches in the given
  view's viewport. You'll want to call this when initializing your
  plugin.
  */
  createDeco(view) {
    let build = new RangeSetBuilder(), add3 = build.add.bind(build);
    for (let { from, to: to3 } of matchRanges(view, this.maxLength))
      iterMatches(view.state.doc, this.regexp, from, to3, (from2, m3) => this.addMatch(m3, view, from2, add3));
    return build.finish();
  }
  /**
  Update a set of decorations for a view update. `deco` _must_ be
  the set of decorations produced by _this_ `MatchDecorator` for
  the view state before the update.
  */
  updateDeco(update, deco) {
    let changeFrom = 1e9, changeTo = -1;
    if (update.docChanged)
      update.changes.iterChanges((_f2, _t3, from, to3) => {
        if (to3 > update.view.viewport.from && from < update.view.viewport.to) {
          changeFrom = Math.min(from, changeFrom);
          changeTo = Math.max(to3, changeTo);
        }
      });
    if (update.viewportChanged || changeTo - changeFrom > 1e3)
      return this.createDeco(update.view);
    if (changeTo > -1)
      return this.updateRange(update.view, deco.map(update.changes), changeFrom, changeTo);
    return deco;
  }
  updateRange(view, deco, updateFrom, updateTo) {
    for (let r2 of view.visibleRanges) {
      let from = Math.max(r2.from, updateFrom), to3 = Math.min(r2.to, updateTo);
      if (to3 > from) {
        let fromLine = view.state.doc.lineAt(from), toLine = fromLine.to < to3 ? view.state.doc.lineAt(to3) : fromLine;
        let start = Math.max(r2.from, fromLine.from), end = Math.min(r2.to, toLine.to);
        if (this.boundary) {
          for (; from > fromLine.from; from--)
            if (this.boundary.test(fromLine.text[from - 1 - fromLine.from])) {
              start = from;
              break;
            }
          for (; to3 < toLine.to; to3++)
            if (this.boundary.test(toLine.text[to3 - toLine.from])) {
              end = to3;
              break;
            }
        }
        let ranges = [], m3;
        let add3 = (from2, to4, deco2) => ranges.push(deco2.range(from2, to4));
        if (fromLine == toLine) {
          this.regexp.lastIndex = start - fromLine.from;
          while ((m3 = this.regexp.exec(fromLine.text)) && m3.index < end - fromLine.from)
            this.addMatch(m3, view, m3.index + fromLine.from, add3);
        } else {
          iterMatches(view.state.doc, this.regexp, start, end, (from2, m4) => this.addMatch(m4, view, from2, add3));
        }
        deco = deco.update({ filterFrom: start, filterTo: end, filter: (from2, to4) => from2 < start || to4 > end, add: ranges });
      }
    }
    return deco;
  }
};
var UnicodeRegexpSupport = /x/.unicode != null ? "gu" : "g";
var Specials = new RegExp("[\0-\b\n--­؜​‎‏\u2028\u2029‭‮⁦⁧⁩\uFEFF￹-￼]", UnicodeRegexpSupport);
var Names = {
  0: "null",
  7: "bell",
  8: "backspace",
  10: "newline",
  11: "vertical tab",
  13: "carriage return",
  27: "escape",
  8203: "zero width space",
  8204: "zero width non-joiner",
  8205: "zero width joiner",
  8206: "left-to-right mark",
  8207: "right-to-left mark",
  8232: "line separator",
  8237: "left-to-right override",
  8238: "right-to-left override",
  8294: "left-to-right isolate",
  8295: "right-to-left isolate",
  8297: "pop directional isolate",
  8233: "paragraph separator",
  65279: "zero width no-break space",
  65532: "object replacement"
};
var _supportsTabSize = null;
function supportsTabSize() {
  var _a4;
  if (_supportsTabSize == null && typeof document != "undefined" && document.body) {
    let styles = document.body.style;
    _supportsTabSize = ((_a4 = styles.tabSize) !== null && _a4 !== void 0 ? _a4 : styles.MozTabSize) != null;
  }
  return _supportsTabSize || false;
}
var specialCharConfig = Facet.define({
  combine(configs) {
    let config2 = combineConfig(configs, {
      render: null,
      specialChars: Specials,
      addSpecialChars: null
    });
    if (config2.replaceTabs = !supportsTabSize())
      config2.specialChars = new RegExp("	|" + config2.specialChars.source, UnicodeRegexpSupport);
    if (config2.addSpecialChars)
      config2.specialChars = new RegExp(config2.specialChars.source + "|" + config2.addSpecialChars.source, UnicodeRegexpSupport);
    return config2;
  }
});
function highlightSpecialChars(config2 = {}) {
  return [specialCharConfig.of(config2), specialCharPlugin()];
}
var _plugin = null;
function specialCharPlugin() {
  return _plugin || (_plugin = ViewPlugin.fromClass(class {
    constructor(view) {
      this.view = view;
      this.decorations = Decoration.none;
      this.decorationCache = /* @__PURE__ */ Object.create(null);
      this.decorator = this.makeDecorator(view.state.facet(specialCharConfig));
      this.decorations = this.decorator.createDeco(view);
    }
    makeDecorator(conf) {
      return new MatchDecorator({
        regexp: conf.specialChars,
        decoration: (m3, view, pos) => {
          let { doc: doc2 } = view.state;
          let code = codePointAt(m3[0], 0);
          if (code == 9) {
            let line = doc2.lineAt(pos);
            let size = view.state.tabSize, col = countColumn(line.text, size, pos - line.from);
            return Decoration.replace({
              widget: new TabWidget((size - col % size) * this.view.defaultCharacterWidth / this.view.scaleX)
            });
          }
          return this.decorationCache[code] || (this.decorationCache[code] = Decoration.replace({ widget: new SpecialCharWidget(conf, code) }));
        },
        boundary: conf.replaceTabs ? void 0 : /[^]/
      });
    }
    update(update) {
      let conf = update.state.facet(specialCharConfig);
      if (update.startState.facet(specialCharConfig) != conf) {
        this.decorator = this.makeDecorator(conf);
        this.decorations = this.decorator.createDeco(update.view);
      } else {
        this.decorations = this.decorator.updateDeco(update, this.decorations);
      }
    }
  }, {
    decorations: (v) => v.decorations
  }));
}
var DefaultPlaceholder = "•";
function placeholder$1(code) {
  if (code >= 32)
    return DefaultPlaceholder;
  if (code == 10)
    return "␤";
  return String.fromCharCode(9216 + code);
}
var SpecialCharWidget = class extends WidgetType {
  constructor(options, code) {
    super();
    this.options = options;
    this.code = code;
  }
  eq(other) {
    return other.code == this.code;
  }
  toDOM(view) {
    let ph2 = placeholder$1(this.code);
    let desc = view.state.phrase("Control character") + " " + (Names[this.code] || "0x" + this.code.toString(16));
    let custom = this.options.render && this.options.render(this.code, desc, ph2);
    if (custom)
      return custom;
    let span = document.createElement("span");
    span.textContent = ph2;
    span.title = desc;
    span.setAttribute("aria-label", desc);
    span.className = "cm-specialChar";
    return span;
  }
  ignoreEvent() {
    return false;
  }
};
var TabWidget = class extends WidgetType {
  constructor(width) {
    super();
    this.width = width;
  }
  eq(other) {
    return other.width == this.width;
  }
  toDOM() {
    let span = document.createElement("span");
    span.textContent = "	";
    span.className = "cm-tab";
    span.style.width = this.width + "px";
    return span;
  }
  ignoreEvent() {
    return false;
  }
};
var plugin = ViewPlugin.fromClass(class {
  constructor() {
    this.height = 1e3;
    this.attrs = { style: "padding-bottom: 1000px" };
  }
  update(update) {
    let { view } = update;
    let height = view.viewState.editorHeight - view.defaultLineHeight - view.documentPadding.top - 0.5;
    if (height >= 0 && height != this.height) {
      this.height = height;
      this.attrs = { style: `padding-bottom: ${height}px` };
    }
  }
});
function highlightActiveLine() {
  return activeLineHighlighter;
}
var lineDeco = Decoration.line({ class: "cm-activeLine" });
var activeLineHighlighter = ViewPlugin.fromClass(class {
  constructor(view) {
    this.decorations = this.getDeco(view);
  }
  update(update) {
    if (update.docChanged || update.selectionSet)
      this.decorations = this.getDeco(update.view);
  }
  getDeco(view) {
    let lastLineStart = -1, deco = [];
    for (let r2 of view.state.selection.ranges) {
      let line = view.lineBlockAt(r2.head);
      if (line.from > lastLineStart) {
        deco.push(lineDeco.range(line.from));
        lastLineStart = line.from;
      }
    }
    return Decoration.set(deco);
  }
}, {
  decorations: (v) => v.decorations
});
var MaxOff = 2e3;
function rectangleFor(state, a2, b2) {
  let startLine = Math.min(a2.line, b2.line), endLine = Math.max(a2.line, b2.line);
  let ranges = [];
  if (a2.off > MaxOff || b2.off > MaxOff || a2.col < 0 || b2.col < 0) {
    let startOff = Math.min(a2.off, b2.off), endOff = Math.max(a2.off, b2.off);
    for (let i2 = startLine; i2 <= endLine; i2++) {
      let line = state.doc.line(i2);
      if (line.length <= endOff)
        ranges.push(EditorSelection.range(line.from + startOff, line.to + endOff));
    }
  } else {
    let startCol = Math.min(a2.col, b2.col), endCol = Math.max(a2.col, b2.col);
    for (let i2 = startLine; i2 <= endLine; i2++) {
      let line = state.doc.line(i2);
      let start = findColumn(line.text, startCol, state.tabSize, true);
      if (start < 0) {
        ranges.push(EditorSelection.cursor(line.to));
      } else {
        let end = findColumn(line.text, endCol, state.tabSize);
        ranges.push(EditorSelection.range(line.from + start, line.from + end));
      }
    }
  }
  return ranges;
}
function absoluteColumn(view, x) {
  let ref2 = view.coordsAtPos(view.viewport.from);
  return ref2 ? Math.round(Math.abs((ref2.left - x) / view.defaultCharacterWidth)) : -1;
}
function getPos(view, event) {
  let offset = view.posAtCoords({ x: event.clientX, y: event.clientY }, false);
  let line = view.state.doc.lineAt(offset), off = offset - line.from;
  let col = off > MaxOff ? -1 : off == line.length ? absoluteColumn(view, event.clientX) : countColumn(line.text, view.state.tabSize, offset - line.from);
  return { line: line.number, col, off };
}
function rectangleSelectionStyle(view, event) {
  let start = getPos(view, event), startSel = view.state.selection;
  if (!start)
    return null;
  return {
    update(update) {
      if (update.docChanged) {
        let newStart = update.changes.mapPos(update.startState.doc.line(start.line).from);
        let newLine = update.state.doc.lineAt(newStart);
        start = { line: newLine.number, col: start.col, off: Math.min(start.off, newLine.length) };
        startSel = startSel.map(update.changes);
      }
    },
    get(event2, _extend, multiple) {
      let cur2 = getPos(view, event2);
      if (!cur2)
        return startSel;
      let ranges = rectangleFor(view.state, start, cur2);
      if (!ranges.length)
        return startSel;
      if (multiple)
        return EditorSelection.create(ranges.concat(startSel.ranges));
      else
        return EditorSelection.create(ranges);
    }
  };
}
function rectangularSelection(options) {
  let filter = (options === null || options === void 0 ? void 0 : options.eventFilter) || ((e2) => e2.altKey && e2.button == 0);
  return EditorView.mouseSelectionStyle.of((view, event) => filter(event) ? rectangleSelectionStyle(view, event) : null);
}
var keys = {
  Alt: [18, (e2) => !!e2.altKey],
  Control: [17, (e2) => !!e2.ctrlKey],
  Shift: [16, (e2) => !!e2.shiftKey],
  Meta: [91, (e2) => !!e2.metaKey]
};
var showCrosshair = { style: "cursor: crosshair" };
function crosshairCursor(options = {}) {
  let [code, getter] = keys[options.key || "Alt"];
  let plugin3 = ViewPlugin.fromClass(class {
    constructor(view) {
      this.view = view;
      this.isDown = false;
    }
    set(isDown) {
      if (this.isDown != isDown) {
        this.isDown = isDown;
        this.view.update([]);
      }
    }
  }, {
    eventObservers: {
      keydown(e2) {
        this.set(e2.keyCode == code || getter(e2));
      },
      keyup(e2) {
        if (e2.keyCode == code || !getter(e2))
          this.set(false);
      },
      mousemove(e2) {
        this.set(getter(e2));
      }
    }
  });
  return [
    plugin3,
    EditorView.contentAttributes.of((view) => {
      var _a4;
      return ((_a4 = view.plugin(plugin3)) === null || _a4 === void 0 ? void 0 : _a4.isDown) ? showCrosshair : null;
    })
  ];
}
var Outside = "-10000px";
var TooltipViewManager = class {
  constructor(view, facet, createTooltipView, removeTooltipView) {
    this.facet = facet;
    this.createTooltipView = createTooltipView;
    this.removeTooltipView = removeTooltipView;
    this.input = view.state.facet(facet);
    this.tooltips = this.input.filter((t3) => t3);
    let prev = null;
    this.tooltipViews = this.tooltips.map((t3) => prev = createTooltipView(t3, prev));
  }
  update(update, above) {
    var _a4;
    let input = update.state.facet(this.facet);
    let tooltips = input.filter((x) => x);
    if (input === this.input) {
      for (let t3 of this.tooltipViews)
        if (t3.update)
          t3.update(update);
      return false;
    }
    let tooltipViews = [], newAbove = above ? [] : null;
    for (let i2 = 0; i2 < tooltips.length; i2++) {
      let tip = tooltips[i2], known = -1;
      if (!tip)
        continue;
      for (let i3 = 0; i3 < this.tooltips.length; i3++) {
        let other = this.tooltips[i3];
        if (other && other.create == tip.create)
          known = i3;
      }
      if (known < 0) {
        tooltipViews[i2] = this.createTooltipView(tip, i2 ? tooltipViews[i2 - 1] : null);
        if (newAbove)
          newAbove[i2] = !!tip.above;
      } else {
        let tooltipView = tooltipViews[i2] = this.tooltipViews[known];
        if (newAbove)
          newAbove[i2] = above[known];
        if (tooltipView.update)
          tooltipView.update(update);
      }
    }
    for (let t3 of this.tooltipViews)
      if (tooltipViews.indexOf(t3) < 0) {
        this.removeTooltipView(t3);
        (_a4 = t3.destroy) === null || _a4 === void 0 ? void 0 : _a4.call(t3);
      }
    if (above) {
      newAbove.forEach((val, i2) => above[i2] = val);
      above.length = newAbove.length;
    }
    this.input = input;
    this.tooltips = tooltips;
    this.tooltipViews = tooltipViews;
    return true;
  }
};
function windowSpace(view) {
  let { win } = view;
  return { top: 0, left: 0, bottom: win.innerHeight, right: win.innerWidth };
}
var tooltipConfig = Facet.define({
  combine: (values) => {
    var _a4, _b, _c2;
    return {
      position: browser.ios ? "absolute" : ((_a4 = values.find((conf) => conf.position)) === null || _a4 === void 0 ? void 0 : _a4.position) || "fixed",
      parent: ((_b = values.find((conf) => conf.parent)) === null || _b === void 0 ? void 0 : _b.parent) || null,
      tooltipSpace: ((_c2 = values.find((conf) => conf.tooltipSpace)) === null || _c2 === void 0 ? void 0 : _c2.tooltipSpace) || windowSpace
    };
  }
});
var knownHeight = /* @__PURE__ */ new WeakMap();
var tooltipPlugin = ViewPlugin.fromClass(class {
  constructor(view) {
    this.view = view;
    this.above = [];
    this.inView = true;
    this.madeAbsolute = false;
    this.lastTransaction = 0;
    this.measureTimeout = -1;
    let config2 = view.state.facet(tooltipConfig);
    this.position = config2.position;
    this.parent = config2.parent;
    this.classes = view.themeClasses;
    this.createContainer();
    this.measureReq = { read: this.readMeasure.bind(this), write: this.writeMeasure.bind(this), key: this };
    this.resizeObserver = typeof ResizeObserver == "function" ? new ResizeObserver(() => this.measureSoon()) : null;
    this.manager = new TooltipViewManager(view, showTooltip, (t3, p) => this.createTooltip(t3, p), (t3) => {
      if (this.resizeObserver)
        this.resizeObserver.unobserve(t3.dom);
      t3.dom.remove();
    });
    this.above = this.manager.tooltips.map((t3) => !!t3.above);
    this.intersectionObserver = typeof IntersectionObserver == "function" ? new IntersectionObserver((entries) => {
      if (Date.now() > this.lastTransaction - 50 && entries.length > 0 && entries[entries.length - 1].intersectionRatio < 1)
        this.measureSoon();
    }, { threshold: [1] }) : null;
    this.observeIntersection();
    view.win.addEventListener("resize", this.measureSoon = this.measureSoon.bind(this));
    this.maybeMeasure();
  }
  createContainer() {
    if (this.parent) {
      this.container = document.createElement("div");
      this.container.style.position = "relative";
      this.container.className = this.view.themeClasses;
      this.parent.appendChild(this.container);
    } else {
      this.container = this.view.dom;
    }
  }
  observeIntersection() {
    if (this.intersectionObserver) {
      this.intersectionObserver.disconnect();
      for (let tooltip of this.manager.tooltipViews)
        this.intersectionObserver.observe(tooltip.dom);
    }
  }
  measureSoon() {
    if (this.measureTimeout < 0)
      this.measureTimeout = setTimeout(() => {
        this.measureTimeout = -1;
        this.maybeMeasure();
      }, 50);
  }
  update(update) {
    if (update.transactions.length)
      this.lastTransaction = Date.now();
    let updated = this.manager.update(update, this.above);
    if (updated)
      this.observeIntersection();
    let shouldMeasure = updated || update.geometryChanged;
    let newConfig = update.state.facet(tooltipConfig);
    if (newConfig.position != this.position && !this.madeAbsolute) {
      this.position = newConfig.position;
      for (let t3 of this.manager.tooltipViews)
        t3.dom.style.position = this.position;
      shouldMeasure = true;
    }
    if (newConfig.parent != this.parent) {
      if (this.parent)
        this.container.remove();
      this.parent = newConfig.parent;
      this.createContainer();
      for (let t3 of this.manager.tooltipViews)
        this.container.appendChild(t3.dom);
      shouldMeasure = true;
    } else if (this.parent && this.view.themeClasses != this.classes) {
      this.classes = this.container.className = this.view.themeClasses;
    }
    if (shouldMeasure)
      this.maybeMeasure();
  }
  createTooltip(tooltip, prev) {
    let tooltipView = tooltip.create(this.view);
    let before = prev ? prev.dom : null;
    tooltipView.dom.classList.add("cm-tooltip");
    if (tooltip.arrow && !tooltipView.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow")) {
      let arrow = document.createElement("div");
      arrow.className = "cm-tooltip-arrow";
      tooltipView.dom.appendChild(arrow);
    }
    tooltipView.dom.style.position = this.position;
    tooltipView.dom.style.top = Outside;
    tooltipView.dom.style.left = "0px";
    this.container.insertBefore(tooltipView.dom, before);
    if (tooltipView.mount)
      tooltipView.mount(this.view);
    if (this.resizeObserver)
      this.resizeObserver.observe(tooltipView.dom);
    return tooltipView;
  }
  destroy() {
    var _a4, _b, _c2;
    this.view.win.removeEventListener("resize", this.measureSoon);
    for (let tooltipView of this.manager.tooltipViews) {
      tooltipView.dom.remove();
      (_a4 = tooltipView.destroy) === null || _a4 === void 0 ? void 0 : _a4.call(tooltipView);
    }
    if (this.parent)
      this.container.remove();
    (_b = this.resizeObserver) === null || _b === void 0 ? void 0 : _b.disconnect();
    (_c2 = this.intersectionObserver) === null || _c2 === void 0 ? void 0 : _c2.disconnect();
    clearTimeout(this.measureTimeout);
  }
  readMeasure() {
    let editor = this.view.dom.getBoundingClientRect();
    let scaleX = 1, scaleY = 1, makeAbsolute = false;
    if (this.position == "fixed" && this.manager.tooltipViews.length) {
      let { dom } = this.manager.tooltipViews[0];
      if (browser.gecko) {
        makeAbsolute = dom.offsetParent != this.container.ownerDocument.body;
      } else if (dom.style.top == Outside && dom.style.left == "0px") {
        let rect = dom.getBoundingClientRect();
        makeAbsolute = Math.abs(rect.top + 1e4) > 1 || Math.abs(rect.left) > 1;
      }
    }
    if (makeAbsolute || this.position == "absolute") {
      if (this.parent) {
        let rect = this.parent.getBoundingClientRect();
        if (rect.width && rect.height) {
          scaleX = rect.width / this.parent.offsetWidth;
          scaleY = rect.height / this.parent.offsetHeight;
        }
      } else {
        ({ scaleX, scaleY } = this.view.viewState);
      }
    }
    return {
      editor,
      parent: this.parent ? this.container.getBoundingClientRect() : editor,
      pos: this.manager.tooltips.map((t3, i2) => {
        let tv2 = this.manager.tooltipViews[i2];
        return tv2.getCoords ? tv2.getCoords(t3.pos) : this.view.coordsAtPos(t3.pos);
      }),
      size: this.manager.tooltipViews.map(({ dom }) => dom.getBoundingClientRect()),
      space: this.view.state.facet(tooltipConfig).tooltipSpace(this.view),
      scaleX,
      scaleY,
      makeAbsolute
    };
  }
  writeMeasure(measured) {
    var _a4;
    if (measured.makeAbsolute) {
      this.madeAbsolute = true;
      this.position = "absolute";
      for (let t3 of this.manager.tooltipViews)
        t3.dom.style.position = "absolute";
    }
    let { editor, space, scaleX, scaleY } = measured;
    let others = [];
    for (let i2 = 0; i2 < this.manager.tooltips.length; i2++) {
      let tooltip = this.manager.tooltips[i2], tView = this.manager.tooltipViews[i2], { dom } = tView;
      let pos = measured.pos[i2], size = measured.size[i2];
      if (!pos || pos.bottom <= Math.max(editor.top, space.top) || pos.top >= Math.min(editor.bottom, space.bottom) || pos.right < Math.max(editor.left, space.left) - 0.1 || pos.left > Math.min(editor.right, space.right) + 0.1) {
        dom.style.top = Outside;
        continue;
      }
      let arrow = tooltip.arrow ? tView.dom.querySelector(".cm-tooltip-arrow") : null;
      let arrowHeight = arrow ? 7 : 0;
      let width = size.right - size.left, height = (_a4 = knownHeight.get(tView)) !== null && _a4 !== void 0 ? _a4 : size.bottom - size.top;
      let offset = tView.offset || noOffset, ltr = this.view.textDirection == Direction.LTR;
      let left = size.width > space.right - space.left ? ltr ? space.left : space.right - size.width : ltr ? Math.max(space.left, Math.min(pos.left - (arrow ? 14 : 0) + offset.x, space.right - width)) : Math.min(Math.max(space.left, pos.left - width + (arrow ? 14 : 0) - offset.x), space.right - width);
      let above = this.above[i2];
      if (!tooltip.strictSide && (above ? pos.top - (size.bottom - size.top) - offset.y < space.top : pos.bottom + (size.bottom - size.top) + offset.y > space.bottom) && above == space.bottom - pos.bottom > pos.top - space.top)
        above = this.above[i2] = !above;
      let spaceVert = (above ? pos.top - space.top : space.bottom - pos.bottom) - arrowHeight;
      if (spaceVert < height && tView.resize !== false) {
        if (spaceVert < this.view.defaultLineHeight) {
          dom.style.top = Outside;
          continue;
        }
        knownHeight.set(tView, height);
        dom.style.height = (height = spaceVert) / scaleY + "px";
      } else if (dom.style.height) {
        dom.style.height = "";
      }
      let top2 = above ? pos.top - height - arrowHeight - offset.y : pos.bottom + arrowHeight + offset.y;
      let right = left + width;
      if (tView.overlap !== true) {
        for (let r2 of others)
          if (r2.left < right && r2.right > left && r2.top < top2 + height && r2.bottom > top2)
            top2 = above ? r2.top - height - 2 - arrowHeight : r2.bottom + arrowHeight + 2;
      }
      if (this.position == "absolute") {
        dom.style.top = (top2 - measured.parent.top) / scaleY + "px";
        dom.style.left = (left - measured.parent.left) / scaleX + "px";
      } else {
        dom.style.top = top2 / scaleY + "px";
        dom.style.left = left / scaleX + "px";
      }
      if (arrow) {
        let arrowLeft = pos.left + (ltr ? offset.x : -offset.x) - (left + 14 - 7);
        arrow.style.left = arrowLeft / scaleX + "px";
      }
      if (tView.overlap !== true)
        others.push({ left, top: top2, right, bottom: top2 + height });
      dom.classList.toggle("cm-tooltip-above", above);
      dom.classList.toggle("cm-tooltip-below", !above);
      if (tView.positioned)
        tView.positioned(measured.space);
    }
  }
  maybeMeasure() {
    if (this.manager.tooltips.length) {
      if (this.view.inView)
        this.view.requestMeasure(this.measureReq);
      if (this.inView != this.view.inView) {
        this.inView = this.view.inView;
        if (!this.inView)
          for (let tv2 of this.manager.tooltipViews)
            tv2.dom.style.top = Outside;
      }
    }
  }
}, {
  eventObservers: {
    scroll() {
      this.maybeMeasure();
    }
  }
});
var baseTheme = EditorView.baseTheme({
  ".cm-tooltip": {
    zIndex: 100,
    boxSizing: "border-box"
  },
  "&light .cm-tooltip": {
    border: "1px solid #bbb",
    backgroundColor: "#f5f5f5"
  },
  "&light .cm-tooltip-section:not(:first-child)": {
    borderTop: "1px solid #bbb"
  },
  "&dark .cm-tooltip": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tooltip-arrow": {
    height: `${7}px`,
    width: `${7 * 2}px`,
    position: "absolute",
    zIndex: -1,
    overflow: "hidden",
    "&:before, &:after": {
      content: "''",
      position: "absolute",
      width: 0,
      height: 0,
      borderLeft: `${7}px solid transparent`,
      borderRight: `${7}px solid transparent`
    },
    ".cm-tooltip-above &": {
      bottom: `-${7}px`,
      "&:before": {
        borderTop: `${7}px solid #bbb`
      },
      "&:after": {
        borderTop: `${7}px solid #f5f5f5`,
        bottom: "1px"
      }
    },
    ".cm-tooltip-below &": {
      top: `-${7}px`,
      "&:before": {
        borderBottom: `${7}px solid #bbb`
      },
      "&:after": {
        borderBottom: `${7}px solid #f5f5f5`,
        top: "1px"
      }
    }
  },
  "&dark .cm-tooltip .cm-tooltip-arrow": {
    "&:before": {
      borderTopColor: "#333338",
      borderBottomColor: "#333338"
    },
    "&:after": {
      borderTopColor: "transparent",
      borderBottomColor: "transparent"
    }
  }
});
var noOffset = { x: 0, y: 0 };
var showTooltip = Facet.define({
  enables: [tooltipPlugin, baseTheme]
});
var showHoverTooltip = Facet.define({
  combine: (inputs) => inputs.reduce((a2, i2) => a2.concat(i2), [])
});
var HoverTooltipHost = class _HoverTooltipHost {
  // Needs to be static so that host tooltip instances always match
  static create(view) {
    return new _HoverTooltipHost(view);
  }
  constructor(view) {
    this.view = view;
    this.mounted = false;
    this.dom = document.createElement("div");
    this.dom.classList.add("cm-tooltip-hover");
    this.manager = new TooltipViewManager(view, showHoverTooltip, (t3, p) => this.createHostedView(t3, p), (t3) => t3.dom.remove());
  }
  createHostedView(tooltip, prev) {
    let hostedView = tooltip.create(this.view);
    hostedView.dom.classList.add("cm-tooltip-section");
    this.dom.insertBefore(hostedView.dom, prev ? prev.dom.nextSibling : this.dom.firstChild);
    if (this.mounted && hostedView.mount)
      hostedView.mount(this.view);
    return hostedView;
  }
  mount(view) {
    for (let hostedView of this.manager.tooltipViews) {
      if (hostedView.mount)
        hostedView.mount(view);
    }
    this.mounted = true;
  }
  positioned(space) {
    for (let hostedView of this.manager.tooltipViews) {
      if (hostedView.positioned)
        hostedView.positioned(space);
    }
  }
  update(update) {
    this.manager.update(update);
  }
  destroy() {
    var _a4;
    for (let t3 of this.manager.tooltipViews)
      (_a4 = t3.destroy) === null || _a4 === void 0 ? void 0 : _a4.call(t3);
  }
  passProp(name2) {
    let value = void 0;
    for (let view of this.manager.tooltipViews) {
      let given = view[name2];
      if (given !== void 0) {
        if (value === void 0)
          value = given;
        else if (value !== given)
          return void 0;
      }
    }
    return value;
  }
  get offset() {
    return this.passProp("offset");
  }
  get getCoords() {
    return this.passProp("getCoords");
  }
  get overlap() {
    return this.passProp("overlap");
  }
  get resize() {
    return this.passProp("resize");
  }
};
var showHoverTooltipHost = showTooltip.compute([showHoverTooltip], (state) => {
  let tooltips = state.facet(showHoverTooltip);
  if (tooltips.length === 0)
    return null;
  return {
    pos: Math.min(...tooltips.map((t3) => t3.pos)),
    end: Math.max(...tooltips.map((t3) => {
      var _a4;
      return (_a4 = t3.end) !== null && _a4 !== void 0 ? _a4 : t3.pos;
    })),
    create: HoverTooltipHost.create,
    above: tooltips[0].above,
    arrow: tooltips.some((t3) => t3.arrow)
  };
});
var HoverPlugin = class {
  constructor(view, source, field, setHover, hoverTime) {
    this.view = view;
    this.source = source;
    this.field = field;
    this.setHover = setHover;
    this.hoverTime = hoverTime;
    this.hoverTimeout = -1;
    this.restartTimeout = -1;
    this.pending = null;
    this.lastMove = { x: 0, y: 0, target: view.dom, time: 0 };
    this.checkHover = this.checkHover.bind(this);
    view.dom.addEventListener("mouseleave", this.mouseleave = this.mouseleave.bind(this));
    view.dom.addEventListener("mousemove", this.mousemove = this.mousemove.bind(this));
  }
  update() {
    if (this.pending) {
      this.pending = null;
      clearTimeout(this.restartTimeout);
      this.restartTimeout = setTimeout(() => this.startHover(), 20);
    }
  }
  get active() {
    return this.view.state.field(this.field);
  }
  checkHover() {
    this.hoverTimeout = -1;
    if (this.active.length)
      return;
    let hovered = Date.now() - this.lastMove.time;
    if (hovered < this.hoverTime)
      this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - hovered);
    else
      this.startHover();
  }
  startHover() {
    clearTimeout(this.restartTimeout);
    let { view, lastMove } = this;
    let desc = view.docView.nearest(lastMove.target);
    if (!desc)
      return;
    let pos, side = 1;
    if (desc instanceof WidgetView) {
      pos = desc.posAtStart;
    } else {
      pos = view.posAtCoords(lastMove);
      if (pos == null)
        return;
      let posCoords = view.coordsAtPos(pos);
      if (!posCoords || lastMove.y < posCoords.top || lastMove.y > posCoords.bottom || lastMove.x < posCoords.left - view.defaultCharacterWidth || lastMove.x > posCoords.right + view.defaultCharacterWidth)
        return;
      let bidi = view.bidiSpans(view.state.doc.lineAt(pos)).find((s2) => s2.from <= pos && s2.to >= pos);
      let rtl = bidi && bidi.dir == Direction.RTL ? -1 : 1;
      side = lastMove.x < posCoords.left ? -rtl : rtl;
    }
    let open = this.source(view, pos, side);
    if (open === null || open === void 0 ? void 0 : open.then) {
      let pending = this.pending = { pos };
      open.then((result) => {
        if (this.pending == pending) {
          this.pending = null;
          if (result && !(Array.isArray(result) && !result.length))
            view.dispatch({ effects: this.setHover.of(Array.isArray(result) ? result : [result]) });
        }
      }, (e2) => logException(view.state, e2, "hover tooltip"));
    } else if (open && !(Array.isArray(open) && !open.length)) {
      view.dispatch({ effects: this.setHover.of(Array.isArray(open) ? open : [open]) });
    }
  }
  get tooltip() {
    let plugin3 = this.view.plugin(tooltipPlugin);
    let index2 = plugin3 ? plugin3.manager.tooltips.findIndex((t3) => t3.create == HoverTooltipHost.create) : -1;
    return index2 > -1 ? plugin3.manager.tooltipViews[index2] : null;
  }
  mousemove(event) {
    var _a4, _b;
    this.lastMove = { x: event.clientX, y: event.clientY, target: event.target, time: Date.now() };
    if (this.hoverTimeout < 0)
      this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime);
    let { active, tooltip } = this;
    if (active.length && tooltip && !isInTooltip(tooltip.dom, event) || this.pending) {
      let { pos } = active[0] || this.pending, end = (_b = (_a4 = active[0]) === null || _a4 === void 0 ? void 0 : _a4.end) !== null && _b !== void 0 ? _b : pos;
      if (pos == end ? this.view.posAtCoords(this.lastMove) != pos : !isOverRange(this.view, pos, end, event.clientX, event.clientY)) {
        this.view.dispatch({ effects: this.setHover.of([]) });
        this.pending = null;
      }
    }
  }
  mouseleave(event) {
    clearTimeout(this.hoverTimeout);
    this.hoverTimeout = -1;
    let { active } = this;
    if (active.length) {
      let { tooltip } = this;
      let inTooltip = tooltip && tooltip.dom.contains(event.relatedTarget);
      if (!inTooltip)
        this.view.dispatch({ effects: this.setHover.of([]) });
      else
        this.watchTooltipLeave(tooltip.dom);
    }
  }
  watchTooltipLeave(tooltip) {
    let watch2 = (event) => {
      tooltip.removeEventListener("mouseleave", watch2);
      if (this.active.length && !this.view.dom.contains(event.relatedTarget))
        this.view.dispatch({ effects: this.setHover.of([]) });
    };
    tooltip.addEventListener("mouseleave", watch2);
  }
  destroy() {
    clearTimeout(this.hoverTimeout);
    this.view.dom.removeEventListener("mouseleave", this.mouseleave);
    this.view.dom.removeEventListener("mousemove", this.mousemove);
  }
};
var tooltipMargin = 4;
function isInTooltip(tooltip, event) {
  let { left, right, top: top2, bottom } = tooltip.getBoundingClientRect(), arrow;
  if (arrow = tooltip.querySelector(".cm-tooltip-arrow")) {
    let arrowRect = arrow.getBoundingClientRect();
    top2 = Math.min(arrowRect.top, top2);
    bottom = Math.max(arrowRect.bottom, bottom);
  }
  return event.clientX >= left - tooltipMargin && event.clientX <= right + tooltipMargin && event.clientY >= top2 - tooltipMargin && event.clientY <= bottom + tooltipMargin;
}
function isOverRange(view, from, to3, x, y, margin) {
  let rect = view.scrollDOM.getBoundingClientRect();
  let docBottom = view.documentTop + view.documentPadding.top + view.contentHeight;
  if (rect.left > x || rect.right < x || rect.top > y || Math.min(rect.bottom, docBottom) < y)
    return false;
  let pos = view.posAtCoords({ x, y }, false);
  return pos >= from && pos <= to3;
}
function hoverTooltip(source, options = {}) {
  let setHover = StateEffect.define();
  let hoverState = StateField.define({
    create() {
      return [];
    },
    update(value, tr3) {
      if (value.length) {
        if (options.hideOnChange && (tr3.docChanged || tr3.selection))
          value = [];
        else if (options.hideOn)
          value = value.filter((v) => !options.hideOn(tr3, v));
        if (tr3.docChanged) {
          let mapped = [];
          for (let tooltip of value) {
            let newPos = tr3.changes.mapPos(tooltip.pos, -1, MapMode.TrackDel);
            if (newPos != null) {
              let copy2 = Object.assign(/* @__PURE__ */ Object.create(null), tooltip);
              copy2.pos = newPos;
              if (copy2.end != null)
                copy2.end = tr3.changes.mapPos(copy2.end);
              mapped.push(copy2);
            }
          }
          value = mapped;
        }
      }
      for (let effect of tr3.effects) {
        if (effect.is(setHover))
          value = effect.value;
        if (effect.is(closeHoverTooltipEffect))
          value = [];
      }
      return value;
    },
    provide: (f) => showHoverTooltip.from(f)
  });
  return {
    active: hoverState,
    extension: [
      hoverState,
      ViewPlugin.define((view) => new HoverPlugin(
        view,
        source,
        hoverState,
        setHover,
        options.hoverTime || 300
        /* Hover.Time */
      )),
      showHoverTooltipHost
    ]
  };
}
function getTooltip(view, tooltip) {
  let plugin3 = view.plugin(tooltipPlugin);
  if (!plugin3)
    return null;
  let found = plugin3.manager.tooltips.indexOf(tooltip);
  return found < 0 ? null : plugin3.manager.tooltipViews[found];
}
var closeHoverTooltipEffect = StateEffect.define();
var closeHoverTooltips = closeHoverTooltipEffect.of(null);
var panelConfig = Facet.define({
  combine(configs) {
    let topContainer, bottomContainer;
    for (let c of configs) {
      topContainer = topContainer || c.topContainer;
      bottomContainer = bottomContainer || c.bottomContainer;
    }
    return { topContainer, bottomContainer };
  }
});
function getPanel(view, panel) {
  let plugin3 = view.plugin(panelPlugin);
  let index2 = plugin3 ? plugin3.specs.indexOf(panel) : -1;
  return index2 > -1 ? plugin3.panels[index2] : null;
}
var panelPlugin = ViewPlugin.fromClass(class {
  constructor(view) {
    this.input = view.state.facet(showPanel);
    this.specs = this.input.filter((s2) => s2);
    this.panels = this.specs.map((spec) => spec(view));
    let conf = view.state.facet(panelConfig);
    this.top = new PanelGroup(view, true, conf.topContainer);
    this.bottom = new PanelGroup(view, false, conf.bottomContainer);
    this.top.sync(this.panels.filter((p) => p.top));
    this.bottom.sync(this.panels.filter((p) => !p.top));
    for (let p of this.panels) {
      p.dom.classList.add("cm-panel");
      if (p.mount)
        p.mount();
    }
  }
  update(update) {
    let conf = update.state.facet(panelConfig);
    if (this.top.container != conf.topContainer) {
      this.top.sync([]);
      this.top = new PanelGroup(update.view, true, conf.topContainer);
    }
    if (this.bottom.container != conf.bottomContainer) {
      this.bottom.sync([]);
      this.bottom = new PanelGroup(update.view, false, conf.bottomContainer);
    }
    this.top.syncClasses();
    this.bottom.syncClasses();
    let input = update.state.facet(showPanel);
    if (input != this.input) {
      let specs = input.filter((x) => x);
      let panels = [], top2 = [], bottom = [], mount = [];
      for (let spec of specs) {
        let known = this.specs.indexOf(spec), panel;
        if (known < 0) {
          panel = spec(update.view);
          mount.push(panel);
        } else {
          panel = this.panels[known];
          if (panel.update)
            panel.update(update);
        }
        panels.push(panel);
        (panel.top ? top2 : bottom).push(panel);
      }
      this.specs = specs;
      this.panels = panels;
      this.top.sync(top2);
      this.bottom.sync(bottom);
      for (let p of mount) {
        p.dom.classList.add("cm-panel");
        if (p.mount)
          p.mount();
      }
    } else {
      for (let p of this.panels)
        if (p.update)
          p.update(update);
    }
  }
  destroy() {
    this.top.sync([]);
    this.bottom.sync([]);
  }
}, {
  provide: (plugin3) => EditorView.scrollMargins.of((view) => {
    let value = view.plugin(plugin3);
    return value && { top: value.top.scrollMargin(), bottom: value.bottom.scrollMargin() };
  })
});
var PanelGroup = class {
  constructor(view, top2, container) {
    this.view = view;
    this.top = top2;
    this.container = container;
    this.dom = void 0;
    this.classes = "";
    this.panels = [];
    this.syncClasses();
  }
  sync(panels) {
    for (let p of this.panels)
      if (p.destroy && panels.indexOf(p) < 0)
        p.destroy();
    this.panels = panels;
    this.syncDOM();
  }
  syncDOM() {
    if (this.panels.length == 0) {
      if (this.dom) {
        this.dom.remove();
        this.dom = void 0;
      }
      return;
    }
    if (!this.dom) {
      this.dom = document.createElement("div");
      this.dom.className = this.top ? "cm-panels cm-panels-top" : "cm-panels cm-panels-bottom";
      this.dom.style[this.top ? "top" : "bottom"] = "0";
      let parent = this.container || this.view.dom;
      parent.insertBefore(this.dom, this.top ? parent.firstChild : null);
    }
    let curDOM = this.dom.firstChild;
    for (let panel of this.panels) {
      if (panel.dom.parentNode == this.dom) {
        while (curDOM != panel.dom)
          curDOM = rm(curDOM);
        curDOM = curDOM.nextSibling;
      } else {
        this.dom.insertBefore(panel.dom, curDOM);
      }
    }
    while (curDOM)
      curDOM = rm(curDOM);
  }
  scrollMargin() {
    return !this.dom || this.container ? 0 : Math.max(0, this.top ? this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) : Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top);
  }
  syncClasses() {
    if (!this.container || this.classes == this.view.themeClasses)
      return;
    for (let cls of this.classes.split(" "))
      if (cls)
        this.container.classList.remove(cls);
    for (let cls of (this.classes = this.view.themeClasses).split(" "))
      if (cls)
        this.container.classList.add(cls);
  }
};
function rm(node) {
  let next = node.nextSibling;
  node.remove();
  return next;
}
var showPanel = Facet.define({
  enables: panelPlugin
});
var GutterMarker = class extends RangeValue {
  /**
  @internal
  */
  compare(other) {
    return this == other || this.constructor == other.constructor && this.eq(other);
  }
  /**
  Compare this marker to another marker of the same type.
  */
  eq(other) {
    return false;
  }
  /**
  Called if the marker has a `toDOM` method and its representation
  was removed from a gutter.
  */
  destroy(dom) {
  }
};
GutterMarker.prototype.elementClass = "";
GutterMarker.prototype.toDOM = void 0;
GutterMarker.prototype.mapMode = MapMode.TrackBefore;
GutterMarker.prototype.startSide = GutterMarker.prototype.endSide = -1;
GutterMarker.prototype.point = true;
var gutterLineClass = Facet.define();
var gutterWidgetClass = Facet.define();
var defaults = {
  class: "",
  renderEmptyElements: false,
  elementStyle: "",
  markers: () => RangeSet.empty,
  lineMarker: () => null,
  widgetMarker: () => null,
  lineMarkerChange: null,
  initialSpacer: null,
  updateSpacer: null,
  domEventHandlers: {}
};
var activeGutters = Facet.define();
function gutter(config2) {
  return [gutters(), activeGutters.of(Object.assign(Object.assign({}, defaults), config2))];
}
var unfixGutters = Facet.define({
  combine: (values) => values.some((x) => x)
});
function gutters(config2) {
  let result = [
    gutterView
  ];
  if (config2 && config2.fixed === false)
    result.push(unfixGutters.of(true));
  return result;
}
var gutterView = ViewPlugin.fromClass(class {
  constructor(view) {
    this.view = view;
    this.prevViewport = view.viewport;
    this.dom = document.createElement("div");
    this.dom.className = "cm-gutters";
    this.dom.setAttribute("aria-hidden", "true");
    this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + "px";
    this.gutters = view.state.facet(activeGutters).map((conf) => new SingleGutterView(view, conf));
    for (let gutter2 of this.gutters)
      this.dom.appendChild(gutter2.dom);
    this.fixed = !view.state.facet(unfixGutters);
    if (this.fixed) {
      this.dom.style.position = "sticky";
    }
    this.syncGutters(false);
    view.scrollDOM.insertBefore(this.dom, view.contentDOM);
  }
  update(update) {
    if (this.updateGutters(update)) {
      let vpA = this.prevViewport, vpB = update.view.viewport;
      let vpOverlap = Math.min(vpA.to, vpB.to) - Math.max(vpA.from, vpB.from);
      this.syncGutters(vpOverlap < (vpB.to - vpB.from) * 0.8);
    }
    if (update.geometryChanged) {
      this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + "px";
    }
    if (this.view.state.facet(unfixGutters) != !this.fixed) {
      this.fixed = !this.fixed;
      this.dom.style.position = this.fixed ? "sticky" : "";
    }
    this.prevViewport = update.view.viewport;
  }
  syncGutters(detach) {
    let after = this.dom.nextSibling;
    if (detach)
      this.dom.remove();
    let lineClasses = RangeSet.iter(this.view.state.facet(gutterLineClass), this.view.viewport.from);
    let classSet = [];
    let contexts = this.gutters.map((gutter2) => new UpdateContext(gutter2, this.view.viewport, -this.view.documentPadding.top));
    for (let line of this.view.viewportLineBlocks) {
      if (classSet.length)
        classSet = [];
      if (Array.isArray(line.type)) {
        let first = true;
        for (let b2 of line.type) {
          if (b2.type == BlockType.Text && first) {
            advanceCursor(lineClasses, classSet, b2.from);
            for (let cx2 of contexts)
              cx2.line(this.view, b2, classSet);
            first = false;
          } else if (b2.widget) {
            for (let cx2 of contexts)
              cx2.widget(this.view, b2);
          }
        }
      } else if (line.type == BlockType.Text) {
        advanceCursor(lineClasses, classSet, line.from);
        for (let cx2 of contexts)
          cx2.line(this.view, line, classSet);
      } else if (line.widget) {
        for (let cx2 of contexts)
          cx2.widget(this.view, line);
      }
    }
    for (let cx2 of contexts)
      cx2.finish();
    if (detach)
      this.view.scrollDOM.insertBefore(this.dom, after);
  }
  updateGutters(update) {
    let prev = update.startState.facet(activeGutters), cur2 = update.state.facet(activeGutters);
    let change = update.docChanged || update.heightChanged || update.viewportChanged || !RangeSet.eq(update.startState.facet(gutterLineClass), update.state.facet(gutterLineClass), update.view.viewport.from, update.view.viewport.to);
    if (prev == cur2) {
      for (let gutter2 of this.gutters)
        if (gutter2.update(update))
          change = true;
    } else {
      change = true;
      let gutters2 = [];
      for (let conf of cur2) {
        let known = prev.indexOf(conf);
        if (known < 0) {
          gutters2.push(new SingleGutterView(this.view, conf));
        } else {
          this.gutters[known].update(update);
          gutters2.push(this.gutters[known]);
        }
      }
      for (let g of this.gutters) {
        g.dom.remove();
        if (gutters2.indexOf(g) < 0)
          g.destroy();
      }
      for (let g of gutters2)
        this.dom.appendChild(g.dom);
      this.gutters = gutters2;
    }
    return change;
  }
  destroy() {
    for (let view of this.gutters)
      view.destroy();
    this.dom.remove();
  }
}, {
  provide: (plugin3) => EditorView.scrollMargins.of((view) => {
    let value = view.plugin(plugin3);
    if (!value || value.gutters.length == 0 || !value.fixed)
      return null;
    return view.textDirection == Direction.LTR ? { left: value.dom.offsetWidth * view.scaleX } : { right: value.dom.offsetWidth * view.scaleX };
  })
});
function asArray2(val) {
  return Array.isArray(val) ? val : [val];
}
function advanceCursor(cursor, collect, pos) {
  while (cursor.value && cursor.from <= pos) {
    if (cursor.from == pos)
      collect.push(cursor.value);
    cursor.next();
  }
}
var UpdateContext = class {
  constructor(gutter2, viewport, height) {
    this.gutter = gutter2;
    this.height = height;
    this.i = 0;
    this.cursor = RangeSet.iter(gutter2.markers, viewport.from);
  }
  addElement(view, block, markers) {
    let { gutter: gutter2 } = this, above = (block.top - this.height) / view.scaleY, height = block.height / view.scaleY;
    if (this.i == gutter2.elements.length) {
      let newElt = new GutterElement(view, height, above, markers);
      gutter2.elements.push(newElt);
      gutter2.dom.appendChild(newElt.dom);
    } else {
      gutter2.elements[this.i].update(view, height, above, markers);
    }
    this.height = block.bottom;
    this.i++;
  }
  line(view, line, extraMarkers) {
    let localMarkers = [];
    advanceCursor(this.cursor, localMarkers, line.from);
    if (extraMarkers.length)
      localMarkers = localMarkers.concat(extraMarkers);
    let forLine = this.gutter.config.lineMarker(view, line, localMarkers);
    if (forLine)
      localMarkers.unshift(forLine);
    let gutter2 = this.gutter;
    if (localMarkers.length == 0 && !gutter2.config.renderEmptyElements)
      return;
    this.addElement(view, line, localMarkers);
  }
  widget(view, block) {
    let marker = this.gutter.config.widgetMarker(view, block.widget, block), markers = marker ? [marker] : null;
    for (let cls of view.state.facet(gutterWidgetClass)) {
      let marker2 = cls(view, block.widget, block);
      if (marker2)
        (markers || (markers = [])).push(marker2);
    }
    if (markers)
      this.addElement(view, block, markers);
  }
  finish() {
    let gutter2 = this.gutter;
    while (gutter2.elements.length > this.i) {
      let last2 = gutter2.elements.pop();
      gutter2.dom.removeChild(last2.dom);
      last2.destroy();
    }
  }
};
var SingleGutterView = class {
  constructor(view, config2) {
    this.view = view;
    this.config = config2;
    this.elements = [];
    this.spacer = null;
    this.dom = document.createElement("div");
    this.dom.className = "cm-gutter" + (this.config.class ? " " + this.config.class : "");
    for (let prop in config2.domEventHandlers) {
      this.dom.addEventListener(prop, (event) => {
        let target = event.target, y;
        if (target != this.dom && this.dom.contains(target)) {
          while (target.parentNode != this.dom)
            target = target.parentNode;
          let rect = target.getBoundingClientRect();
          y = (rect.top + rect.bottom) / 2;
        } else {
          y = event.clientY;
        }
        let line = view.lineBlockAtHeight(y - view.documentTop);
        if (config2.domEventHandlers[prop](view, line, event))
          event.preventDefault();
      });
    }
    this.markers = asArray2(config2.markers(view));
    if (config2.initialSpacer) {
      this.spacer = new GutterElement(view, 0, 0, [config2.initialSpacer(view)]);
      this.dom.appendChild(this.spacer.dom);
      this.spacer.dom.style.cssText += "visibility: hidden; pointer-events: none";
    }
  }
  update(update) {
    let prevMarkers = this.markers;
    this.markers = asArray2(this.config.markers(update.view));
    if (this.spacer && this.config.updateSpacer) {
      let updated = this.config.updateSpacer(this.spacer.markers[0], update);
      if (updated != this.spacer.markers[0])
        this.spacer.update(update.view, 0, 0, [updated]);
    }
    let vp2 = update.view.viewport;
    return !RangeSet.eq(this.markers, prevMarkers, vp2.from, vp2.to) || (this.config.lineMarkerChange ? this.config.lineMarkerChange(update) : false);
  }
  destroy() {
    for (let elt of this.elements)
      elt.destroy();
  }
};
var GutterElement = class {
  constructor(view, height, above, markers) {
    this.height = -1;
    this.above = 0;
    this.markers = [];
    this.dom = document.createElement("div");
    this.dom.className = "cm-gutterElement";
    this.update(view, height, above, markers);
  }
  update(view, height, above, markers) {
    if (this.height != height) {
      this.height = height;
      this.dom.style.height = height + "px";
    }
    if (this.above != above)
      this.dom.style.marginTop = (this.above = above) ? above + "px" : "";
    if (!sameMarkers(this.markers, markers))
      this.setMarkers(view, markers);
  }
  setMarkers(view, markers) {
    let cls = "cm-gutterElement", domPos = this.dom.firstChild;
    for (let iNew = 0, iOld = 0; ; ) {
      let skipTo = iOld, marker = iNew < markers.length ? markers[iNew++] : null, matched = false;
      if (marker) {
        let c = marker.elementClass;
        if (c)
          cls += " " + c;
        for (let i2 = iOld; i2 < this.markers.length; i2++)
          if (this.markers[i2].compare(marker)) {
            skipTo = i2;
            matched = true;
            break;
          }
      } else {
        skipTo = this.markers.length;
      }
      while (iOld < skipTo) {
        let next = this.markers[iOld++];
        if (next.toDOM) {
          next.destroy(domPos);
          let after = domPos.nextSibling;
          domPos.remove();
          domPos = after;
        }
      }
      if (!marker)
        break;
      if (marker.toDOM) {
        if (matched)
          domPos = domPos.nextSibling;
        else
          this.dom.insertBefore(marker.toDOM(view), domPos);
      }
      if (matched)
        iOld++;
    }
    this.dom.className = cls;
    this.markers = markers;
  }
  destroy() {
    this.setMarkers(null, []);
  }
};
function sameMarkers(a2, b2) {
  if (a2.length != b2.length)
    return false;
  for (let i2 = 0; i2 < a2.length; i2++)
    if (!a2[i2].compare(b2[i2]))
      return false;
  return true;
}
var lineNumberMarkers = Facet.define();
var lineNumberWidgetMarker = Facet.define();
var lineNumberConfig = Facet.define({
  combine(values) {
    return combineConfig(values, { formatNumber: String, domEventHandlers: {} }, {
      domEventHandlers(a2, b2) {
        let result = Object.assign({}, a2);
        for (let event in b2) {
          let exists = result[event], add3 = b2[event];
          result[event] = exists ? (view, line, event2) => exists(view, line, event2) || add3(view, line, event2) : add3;
        }
        return result;
      }
    });
  }
});
var NumberMarker = class extends GutterMarker {
  constructor(number2) {
    super();
    this.number = number2;
  }
  eq(other) {
    return this.number == other.number;
  }
  toDOM() {
    return document.createTextNode(this.number);
  }
};
function formatNumber(view, number2) {
  return view.state.facet(lineNumberConfig).formatNumber(number2, view.state);
}
var lineNumberGutter = activeGutters.compute([lineNumberConfig], (state) => ({
  class: "cm-lineNumbers",
  renderEmptyElements: false,
  markers(view) {
    return view.state.facet(lineNumberMarkers);
  },
  lineMarker(view, line, others) {
    if (others.some((m3) => m3.toDOM))
      return null;
    return new NumberMarker(formatNumber(view, view.state.doc.lineAt(line.from).number));
  },
  widgetMarker: (view, widget, block) => {
    for (let m3 of view.state.facet(lineNumberWidgetMarker)) {
      let result = m3(view, widget, block);
      if (result)
        return result;
    }
    return null;
  },
  lineMarkerChange: (update) => update.startState.facet(lineNumberConfig) != update.state.facet(lineNumberConfig),
  initialSpacer(view) {
    return new NumberMarker(formatNumber(view, maxLineNumber(view.state.doc.lines)));
  },
  updateSpacer(spacer, update) {
    let max = formatNumber(update.view, maxLineNumber(update.view.state.doc.lines));
    return max == spacer.number ? spacer : new NumberMarker(max);
  },
  domEventHandlers: state.facet(lineNumberConfig).domEventHandlers
}));
function lineNumbers(config2 = {}) {
  return [
    lineNumberConfig.of(config2),
    gutters(),
    lineNumberGutter
  ];
}
function maxLineNumber(lines) {
  let last2 = 9;
  while (last2 < lines)
    last2 = last2 * 10 + 9;
  return last2;
}
var activeLineGutterMarker = new class extends GutterMarker {
  constructor() {
    super(...arguments);
    this.elementClass = "cm-activeLineGutter";
  }
}();
var activeLineGutterHighlighter = gutterLineClass.compute(["selection"], (state) => {
  let marks2 = [], last2 = -1;
  for (let range of state.selection.ranges) {
    let linePos = state.doc.lineAt(range.head).from;
    if (linePos > last2) {
      last2 = linePos;
      marks2.push(activeLineGutterMarker.range(linePos));
    }
  }
  return RangeSet.of(marks2);
});
function highlightActiveLineGutter() {
  return activeLineGutterHighlighter;
}
function matcher(decorator) {
  return ViewPlugin.define((view) => ({
    decorations: decorator.createDeco(view),
    update(u) {
      this.decorations = decorator.updateDeco(u, this.decorations);
    }
  }), {
    decorations: (v) => v.decorations
  });
}
var tabDeco = Decoration.mark({ class: "cm-highlightTab" });
var spaceDeco = Decoration.mark({ class: "cm-highlightSpace" });
var whitespaceHighlighter = matcher(new MatchDecorator({
  regexp: /\t| /g,
  decoration: (match) => match[0] == "	" ? tabDeco : spaceDeco,
  boundary: /\S/
}));
var trailingHighlighter = matcher(new MatchDecorator({
  regexp: /\s+$/g,
  decoration: Decoration.mark({ class: "cm-trailingSpace" }),
  boundary: /\S/
}));

// node_modules/@lezer/common/dist/index.js
var DefaultBufferLength = 1024;
var nextPropID = 0;
var Range2 = class {
  constructor(from, to3) {
    this.from = from;
    this.to = to3;
  }
};
var NodeProp = class {
  /**
  Create a new node prop type.
  */
  constructor(config2 = {}) {
    this.id = nextPropID++;
    this.perNode = !!config2.perNode;
    this.deserialize = config2.deserialize || (() => {
      throw new Error("This node type doesn't define a deserialize function");
    });
  }
  /**
  This is meant to be used with
  [`NodeSet.extend`](#common.NodeSet.extend) or
  [`LRParser.configure`](#lr.ParserConfig.props) to compute
  prop values for each node type in the set. Takes a [match
  object](#common.NodeType^match) or function that returns undefined
  if the node type doesn't get this prop, and the prop's value if
  it does.
  */
  add(match) {
    if (this.perNode)
      throw new RangeError("Can't add per-node props to node types");
    if (typeof match != "function")
      match = NodeType.match(match);
    return (type) => {
      let result = match(type);
      return result === void 0 ? null : [this, result];
    };
  }
};
NodeProp.closedBy = new NodeProp({ deserialize: (str) => str.split(" ") });
NodeProp.openedBy = new NodeProp({ deserialize: (str) => str.split(" ") });
NodeProp.group = new NodeProp({ deserialize: (str) => str.split(" ") });
NodeProp.isolate = new NodeProp({ deserialize: (value) => {
  if (value && value != "rtl" && value != "ltr" && value != "auto")
    throw new RangeError("Invalid value for isolate: " + value);
  return value || "auto";
} });
NodeProp.contextHash = new NodeProp({ perNode: true });
NodeProp.lookAhead = new NodeProp({ perNode: true });
NodeProp.mounted = new NodeProp({ perNode: true });
var MountedTree = class {
  constructor(tree, overlay, parser2) {
    this.tree = tree;
    this.overlay = overlay;
    this.parser = parser2;
  }
  /**
  @internal
  */
  static get(tree) {
    return tree && tree.props && tree.props[NodeProp.mounted.id];
  }
};
var noProps = /* @__PURE__ */ Object.create(null);
var NodeType = class _NodeType {
  /**
  @internal
  */
  constructor(name2, props, id2, flags = 0) {
    this.name = name2;
    this.props = props;
    this.id = id2;
    this.flags = flags;
  }
  /**
  Define a node type.
  */
  static define(spec) {
    let props = spec.props && spec.props.length ? /* @__PURE__ */ Object.create(null) : noProps;
    let flags = (spec.top ? 1 : 0) | (spec.skipped ? 2 : 0) | (spec.error ? 4 : 0) | (spec.name == null ? 8 : 0);
    let type = new _NodeType(spec.name || "", props, spec.id, flags);
    if (spec.props)
      for (let src of spec.props) {
        if (!Array.isArray(src))
          src = src(type);
        if (src) {
          if (src[0].perNode)
            throw new RangeError("Can't store a per-node prop on a node type");
          props[src[0].id] = src[1];
        }
      }
    return type;
  }
  /**
  Retrieves a node prop for this type. Will return `undefined` if
  the prop isn't present on this node.
  */
  prop(prop) {
    return this.props[prop.id];
  }
  /**
  True when this is the top node of a grammar.
  */
  get isTop() {
    return (this.flags & 1) > 0;
  }
  /**
  True when this node is produced by a skip rule.
  */
  get isSkipped() {
    return (this.flags & 2) > 0;
  }
  /**
  Indicates whether this is an error node.
  */
  get isError() {
    return (this.flags & 4) > 0;
  }
  /**
  When true, this node type doesn't correspond to a user-declared
  named node, for example because it is used to cache repetition.
  */
  get isAnonymous() {
    return (this.flags & 8) > 0;
  }
  /**
  Returns true when this node's name or one of its
  [groups](#common.NodeProp^group) matches the given string.
  */
  is(name2) {
    if (typeof name2 == "string") {
      if (this.name == name2)
        return true;
      let group = this.prop(NodeProp.group);
      return group ? group.indexOf(name2) > -1 : false;
    }
    return this.id == name2;
  }
  /**
  Create a function from node types to arbitrary values by
  specifying an object whose property names are node or
  [group](#common.NodeProp^group) names. Often useful with
  [`NodeProp.add`](#common.NodeProp.add). You can put multiple
  names, separated by spaces, in a single property name to map
  multiple node names to a single value.
  */
  static match(map) {
    let direct = /* @__PURE__ */ Object.create(null);
    for (let prop in map)
      for (let name2 of prop.split(" "))
        direct[name2] = map[prop];
    return (node) => {
      for (let groups = node.prop(NodeProp.group), i2 = -1; i2 < (groups ? groups.length : 0); i2++) {
        let found = direct[i2 < 0 ? node.name : groups[i2]];
        if (found)
          return found;
      }
    };
  }
};
NodeType.none = new NodeType(
  "",
  /* @__PURE__ */ Object.create(null),
  0,
  8
  /* NodeFlag.Anonymous */
);
var NodeSet = class _NodeSet {
  /**
  Create a set with the given types. The `id` property of each
  type should correspond to its position within the array.
  */
  constructor(types2) {
    this.types = types2;
    for (let i2 = 0; i2 < types2.length; i2++)
      if (types2[i2].id != i2)
        throw new RangeError("Node type ids should correspond to array positions when creating a node set");
  }
  /**
  Create a copy of this set with some node properties added. The
  arguments to this method can be created with
  [`NodeProp.add`](#common.NodeProp.add).
  */
  extend(...props) {
    let newTypes = [];
    for (let type of this.types) {
      let newProps = null;
      for (let source of props) {
        let add3 = source(type);
        if (add3) {
          if (!newProps)
            newProps = Object.assign({}, type.props);
          newProps[add3[0].id] = add3[1];
        }
      }
      newTypes.push(newProps ? new NodeType(type.name, newProps, type.id, type.flags) : type);
    }
    return new _NodeSet(newTypes);
  }
};
var CachedNode = /* @__PURE__ */ new WeakMap();
var CachedInnerNode = /* @__PURE__ */ new WeakMap();
var IterMode;
(function(IterMode2) {
  IterMode2[IterMode2["ExcludeBuffers"] = 1] = "ExcludeBuffers";
  IterMode2[IterMode2["IncludeAnonymous"] = 2] = "IncludeAnonymous";
  IterMode2[IterMode2["IgnoreMounts"] = 4] = "IgnoreMounts";
  IterMode2[IterMode2["IgnoreOverlays"] = 8] = "IgnoreOverlays";
})(IterMode || (IterMode = {}));
var Tree = class _Tree {
  /**
  Construct a new tree. See also [`Tree.build`](#common.Tree^build).
  */
  constructor(type, children, positions, length, props) {
    this.type = type;
    this.children = children;
    this.positions = positions;
    this.length = length;
    this.props = null;
    if (props && props.length) {
      this.props = /* @__PURE__ */ Object.create(null);
      for (let [prop, value] of props)
        this.props[typeof prop == "number" ? prop : prop.id] = value;
    }
  }
  /**
  @internal
  */
  toString() {
    let mounted = MountedTree.get(this);
    if (mounted && !mounted.overlay)
      return mounted.tree.toString();
    let children = "";
    for (let ch2 of this.children) {
      let str = ch2.toString();
      if (str) {
        if (children)
          children += ",";
        children += str;
      }
    }
    return !this.type.name ? children : (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (children.length ? "(" + children + ")" : "");
  }
  /**
  Get a [tree cursor](#common.TreeCursor) positioned at the top of
  the tree. Mode can be used to [control](#common.IterMode) which
  nodes the cursor visits.
  */
  cursor(mode = 0) {
    return new TreeCursor(this.topNode, mode);
  }
  /**
  Get a [tree cursor](#common.TreeCursor) pointing into this tree
  at the given position and side (see
  [`moveTo`](#common.TreeCursor.moveTo).
  */
  cursorAt(pos, side = 0, mode = 0) {
    let scope = CachedNode.get(this) || this.topNode;
    let cursor = new TreeCursor(scope);
    cursor.moveTo(pos, side);
    CachedNode.set(this, cursor._tree);
    return cursor;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) object for the top of the
  tree.
  */
  get topNode() {
    return new TreeNode(this, 0, 0, null);
  }
  /**
  Get the [syntax node](#common.SyntaxNode) at the given position.
  If `side` is -1, this will move into nodes that end at the
  position. If 1, it'll move into nodes that start at the
  position. With 0, it'll only enter nodes that cover the position
  from both sides.
  
  Note that this will not enter
  [overlays](#common.MountedTree.overlay), and you often want
  [`resolveInner`](#common.Tree.resolveInner) instead.
  */
  resolve(pos, side = 0) {
    let node = resolveNode(CachedNode.get(this) || this.topNode, pos, side, false);
    CachedNode.set(this, node);
    return node;
  }
  /**
  Like [`resolve`](#common.Tree.resolve), but will enter
  [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node
  pointing into the innermost overlaid tree at the given position
  (with parent links going through all parent structure, including
  the host trees).
  */
  resolveInner(pos, side = 0) {
    let node = resolveNode(CachedInnerNode.get(this) || this.topNode, pos, side, true);
    CachedInnerNode.set(this, node);
    return node;
  }
  /**
  In some situations, it can be useful to iterate through all
  nodes around a position, including those in overlays that don't
  directly cover the position. This method gives you an iterator
  that will produce all nodes, from small to big, around the given
  position.
  */
  resolveStack(pos, side = 0) {
    return stackIterator(this, pos, side);
  }
  /**
  Iterate over the tree and its children, calling `enter` for any
  node that touches the `from`/`to` region (if given) before
  running over such a node's children, and `leave` (if given) when
  leaving the node. When `enter` returns `false`, that node will
  not have its children iterated over (or `leave` called).
  */
  iterate(spec) {
    let { enter, leave, from = 0, to: to3 = this.length } = spec;
    let mode = spec.mode || 0, anon = (mode & IterMode.IncludeAnonymous) > 0;
    for (let c = this.cursor(mode | IterMode.IncludeAnonymous); ; ) {
      let entered = false;
      if (c.from <= to3 && c.to >= from && (!anon && c.type.isAnonymous || enter(c) !== false)) {
        if (c.firstChild())
          continue;
        entered = true;
      }
      for (; ; ) {
        if (entered && leave && (anon || !c.type.isAnonymous))
          leave(c);
        if (c.nextSibling())
          break;
        if (!c.parent())
          return;
        entered = true;
      }
    }
  }
  /**
  Get the value of the given [node prop](#common.NodeProp) for this
  node. Works with both per-node and per-type props.
  */
  prop(prop) {
    return !prop.perNode ? this.type.prop(prop) : this.props ? this.props[prop.id] : void 0;
  }
  /**
  Returns the node's [per-node props](#common.NodeProp.perNode) in a
  format that can be passed to the [`Tree`](#common.Tree)
  constructor.
  */
  get propValues() {
    let result = [];
    if (this.props)
      for (let id2 in this.props)
        result.push([+id2, this.props[id2]]);
    return result;
  }
  /**
  Balance the direct children of this tree, producing a copy of
  which may have children grouped into subtrees with type
  [`NodeType.none`](#common.NodeType^none).
  */
  balance(config2 = {}) {
    return this.children.length <= 8 ? this : balanceRange(NodeType.none, this.children, this.positions, 0, this.children.length, 0, this.length, (children, positions, length) => new _Tree(this.type, children, positions, length, this.propValues), config2.makeTree || ((children, positions, length) => new _Tree(NodeType.none, children, positions, length)));
  }
  /**
  Build a tree from a postfix-ordered buffer of node information,
  or a cursor over such a buffer.
  */
  static build(data) {
    return buildTree(data);
  }
};
Tree.empty = new Tree(NodeType.none, [], [], 0);
var FlatBufferCursor = class _FlatBufferCursor {
  constructor(buffer, index2) {
    this.buffer = buffer;
    this.index = index2;
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  get pos() {
    return this.index;
  }
  next() {
    this.index -= 4;
  }
  fork() {
    return new _FlatBufferCursor(this.buffer, this.index);
  }
};
var TreeBuffer = class _TreeBuffer {
  /**
  Create a tree buffer.
  */
  constructor(buffer, length, set) {
    this.buffer = buffer;
    this.length = length;
    this.set = set;
  }
  /**
  @internal
  */
  get type() {
    return NodeType.none;
  }
  /**
  @internal
  */
  toString() {
    let result = [];
    for (let index2 = 0; index2 < this.buffer.length; ) {
      result.push(this.childString(index2));
      index2 = this.buffer[index2 + 3];
    }
    return result.join(",");
  }
  /**
  @internal
  */
  childString(index2) {
    let id2 = this.buffer[index2], endIndex = this.buffer[index2 + 3];
    let type = this.set.types[id2], result = type.name;
    if (/\W/.test(result) && !type.isError)
      result = JSON.stringify(result);
    index2 += 4;
    if (endIndex == index2)
      return result;
    let children = [];
    while (index2 < endIndex) {
      children.push(this.childString(index2));
      index2 = this.buffer[index2 + 3];
    }
    return result + "(" + children.join(",") + ")";
  }
  /**
  @internal
  */
  findChild(startIndex, endIndex, dir, pos, side) {
    let { buffer } = this, pick = -1;
    for (let i2 = startIndex; i2 != endIndex; i2 = buffer[i2 + 3]) {
      if (checkSide(side, pos, buffer[i2 + 1], buffer[i2 + 2])) {
        pick = i2;
        if (dir > 0)
          break;
      }
    }
    return pick;
  }
  /**
  @internal
  */
  slice(startI, endI, from) {
    let b2 = this.buffer;
    let copy2 = new Uint16Array(endI - startI), len = 0;
    for (let i2 = startI, j = 0; i2 < endI; ) {
      copy2[j++] = b2[i2++];
      copy2[j++] = b2[i2++] - from;
      let to3 = copy2[j++] = b2[i2++] - from;
      copy2[j++] = b2[i2++] - startI;
      len = Math.max(len, to3);
    }
    return new _TreeBuffer(copy2, len, this.set);
  }
};
function checkSide(side, pos, from, to3) {
  switch (side) {
    case -2:
      return from < pos;
    case -1:
      return to3 >= pos && from < pos;
    case 0:
      return from < pos && to3 > pos;
    case 1:
      return from <= pos && to3 > pos;
    case 2:
      return to3 > pos;
    case 4:
      return true;
  }
}
function resolveNode(node, pos, side, overlays) {
  var _a4;
  while (node.from == node.to || (side < 1 ? node.from >= pos : node.from > pos) || (side > -1 ? node.to <= pos : node.to < pos)) {
    let parent = !overlays && node instanceof TreeNode && node.index < 0 ? null : node.parent;
    if (!parent)
      return node;
    node = parent;
  }
  let mode = overlays ? 0 : IterMode.IgnoreOverlays;
  if (overlays)
    for (let scan = node, parent = scan.parent; parent; scan = parent, parent = scan.parent) {
      if (scan instanceof TreeNode && scan.index < 0 && ((_a4 = parent.enter(pos, side, mode)) === null || _a4 === void 0 ? void 0 : _a4.from) != scan.from)
        node = parent;
    }
  for (; ; ) {
    let inner = node.enter(pos, side, mode);
    if (!inner)
      return node;
    node = inner;
  }
}
var BaseNode = class {
  cursor(mode = 0) {
    return new TreeCursor(this, mode);
  }
  getChild(type, before = null, after = null) {
    let r2 = getChildren(this, type, before, after);
    return r2.length ? r2[0] : null;
  }
  getChildren(type, before = null, after = null) {
    return getChildren(this, type, before, after);
  }
  resolve(pos, side = 0) {
    return resolveNode(this, pos, side, false);
  }
  resolveInner(pos, side = 0) {
    return resolveNode(this, pos, side, true);
  }
  matchContext(context) {
    return matchNodeContext(this.parent, context);
  }
  enterUnfinishedNodesBefore(pos) {
    let scan = this.childBefore(pos), node = this;
    while (scan) {
      let last2 = scan.lastChild;
      if (!last2 || last2.to != scan.to)
        break;
      if (last2.type.isError && last2.from == last2.to) {
        node = scan;
        scan = last2.prevSibling;
      } else {
        scan = last2;
      }
    }
    return node;
  }
  get node() {
    return this;
  }
  get next() {
    return this.parent;
  }
};
var TreeNode = class _TreeNode extends BaseNode {
  constructor(_tree, from, index2, _parent) {
    super();
    this._tree = _tree;
    this.from = from;
    this.index = index2;
    this._parent = _parent;
  }
  get type() {
    return this._tree.type;
  }
  get name() {
    return this._tree.type.name;
  }
  get to() {
    return this.from + this._tree.length;
  }
  nextChild(i2, dir, pos, side, mode = 0) {
    for (let parent = this; ; ) {
      for (let { children, positions } = parent._tree, e2 = dir > 0 ? children.length : -1; i2 != e2; i2 += dir) {
        let next = children[i2], start = positions[i2] + parent.from;
        if (!checkSide(side, pos, start, start + next.length))
          continue;
        if (next instanceof TreeBuffer) {
          if (mode & IterMode.ExcludeBuffers)
            continue;
          let index2 = next.findChild(0, next.buffer.length, dir, pos - start, side);
          if (index2 > -1)
            return new BufferNode(new BufferContext(parent, next, i2, start), null, index2);
        } else if (mode & IterMode.IncludeAnonymous || (!next.type.isAnonymous || hasChild(next))) {
          let mounted;
          if (!(mode & IterMode.IgnoreMounts) && (mounted = MountedTree.get(next)) && !mounted.overlay)
            return new _TreeNode(mounted.tree, start, i2, parent);
          let inner = new _TreeNode(next, start, i2, parent);
          return mode & IterMode.IncludeAnonymous || !inner.type.isAnonymous ? inner : inner.nextChild(dir < 0 ? next.children.length - 1 : 0, dir, pos, side);
        }
      }
      if (mode & IterMode.IncludeAnonymous || !parent.type.isAnonymous)
        return null;
      if (parent.index >= 0)
        i2 = parent.index + dir;
      else
        i2 = dir < 0 ? -1 : parent._parent._tree.children.length;
      parent = parent._parent;
      if (!parent)
        return null;
    }
  }
  get firstChild() {
    return this.nextChild(
      0,
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(pos) {
    return this.nextChild(
      0,
      1,
      pos,
      2
      /* Side.After */
    );
  }
  childBefore(pos) {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      pos,
      -2
      /* Side.Before */
    );
  }
  enter(pos, side, mode = 0) {
    let mounted;
    if (!(mode & IterMode.IgnoreOverlays) && (mounted = MountedTree.get(this._tree)) && mounted.overlay) {
      let rPos = pos - this.from;
      for (let { from, to: to3 } of mounted.overlay) {
        if ((side > 0 ? from <= rPos : from < rPos) && (side < 0 ? to3 >= rPos : to3 > rPos))
          return new _TreeNode(mounted.tree, mounted.overlay[0].from + this.from, -1, this);
      }
    }
    return this.nextChild(0, 1, pos, side, mode);
  }
  nextSignificantParent() {
    let val = this;
    while (val.type.isAnonymous && val._parent)
      val = val._parent;
    return val;
  }
  get parent() {
    return this._parent ? this._parent.nextSignificantParent() : null;
  }
  get nextSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index + 1,
      1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get prevSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get tree() {
    return this._tree;
  }
  toTree() {
    return this._tree;
  }
  /**
  @internal
  */
  toString() {
    return this._tree.toString();
  }
};
function getChildren(node, type, before, after) {
  let cur2 = node.cursor(), result = [];
  if (!cur2.firstChild())
    return result;
  if (before != null)
    for (let found = false; !found; ) {
      found = cur2.type.is(before);
      if (!cur2.nextSibling())
        return result;
    }
  for (; ; ) {
    if (after != null && cur2.type.is(after))
      return result;
    if (cur2.type.is(type))
      result.push(cur2.node);
    if (!cur2.nextSibling())
      return after == null ? result : [];
  }
}
function matchNodeContext(node, context, i2 = context.length - 1) {
  for (let p = node; i2 >= 0; p = p.parent) {
    if (!p)
      return false;
    if (!p.type.isAnonymous) {
      if (context[i2] && context[i2] != p.name)
        return false;
      i2--;
    }
  }
  return true;
}
var BufferContext = class {
  constructor(parent, buffer, index2, start) {
    this.parent = parent;
    this.buffer = buffer;
    this.index = index2;
    this.start = start;
  }
};
var BufferNode = class _BufferNode extends BaseNode {
  get name() {
    return this.type.name;
  }
  get from() {
    return this.context.start + this.context.buffer.buffer[this.index + 1];
  }
  get to() {
    return this.context.start + this.context.buffer.buffer[this.index + 2];
  }
  constructor(context, _parent, index2) {
    super();
    this.context = context;
    this._parent = _parent;
    this.index = index2;
    this.type = context.buffer.set.types[context.buffer.buffer[index2]];
  }
  child(dir, pos, side) {
    let { buffer } = this.context;
    let index2 = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.context.start, side);
    return index2 < 0 ? null : new _BufferNode(this.context, this, index2);
  }
  get firstChild() {
    return this.child(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.child(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(pos) {
    return this.child(
      1,
      pos,
      2
      /* Side.After */
    );
  }
  childBefore(pos) {
    return this.child(
      -1,
      pos,
      -2
      /* Side.Before */
    );
  }
  enter(pos, side, mode = 0) {
    if (mode & IterMode.ExcludeBuffers)
      return null;
    let { buffer } = this.context;
    let index2 = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], side > 0 ? 1 : -1, pos - this.context.start, side);
    return index2 < 0 ? null : new _BufferNode(this.context, this, index2);
  }
  get parent() {
    return this._parent || this.context.parent.nextSignificantParent();
  }
  externalSibling(dir) {
    return this._parent ? null : this.context.parent.nextChild(
      this.context.index + dir,
      dir,
      0,
      4
      /* Side.DontCare */
    );
  }
  get nextSibling() {
    let { buffer } = this.context;
    let after = buffer.buffer[this.index + 3];
    if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length))
      return new _BufferNode(this.context, this._parent, after);
    return this.externalSibling(1);
  }
  get prevSibling() {
    let { buffer } = this.context;
    let parentStart = this._parent ? this._parent.index + 4 : 0;
    if (this.index == parentStart)
      return this.externalSibling(-1);
    return new _BufferNode(this.context, this._parent, buffer.findChild(
      parentStart,
      this.index,
      -1,
      0,
      4
      /* Side.DontCare */
    ));
  }
  get tree() {
    return null;
  }
  toTree() {
    let children = [], positions = [];
    let { buffer } = this.context;
    let startI = this.index + 4, endI = buffer.buffer[this.index + 3];
    if (endI > startI) {
      let from = buffer.buffer[this.index + 1];
      children.push(buffer.slice(startI, endI, from));
      positions.push(0);
    }
    return new Tree(this.type, children, positions, this.to - this.from);
  }
  /**
  @internal
  */
  toString() {
    return this.context.buffer.childString(this.index);
  }
};
function iterStack(heads) {
  if (!heads.length)
    return null;
  let pick = 0, picked = heads[0];
  for (let i2 = 1; i2 < heads.length; i2++) {
    let node = heads[i2];
    if (node.from > picked.from || node.to < picked.to) {
      picked = node;
      pick = i2;
    }
  }
  let next = picked instanceof TreeNode && picked.index < 0 ? null : picked.parent;
  let newHeads = heads.slice();
  if (next)
    newHeads[pick] = next;
  else
    newHeads.splice(pick, 1);
  return new StackIterator(newHeads, picked);
}
var StackIterator = class {
  constructor(heads, node) {
    this.heads = heads;
    this.node = node;
  }
  get next() {
    return iterStack(this.heads);
  }
};
function stackIterator(tree, pos, side) {
  let inner = tree.resolveInner(pos, side), layers = null;
  for (let scan = inner instanceof TreeNode ? inner : inner.context.parent; scan; scan = scan.parent) {
    if (scan.index < 0) {
      let parent = scan.parent;
      (layers || (layers = [inner])).push(parent.resolve(pos, side));
      scan = parent;
    } else {
      let mount = MountedTree.get(scan.tree);
      if (mount && mount.overlay && mount.overlay[0].from <= pos && mount.overlay[mount.overlay.length - 1].to >= pos) {
        let root = new TreeNode(mount.tree, mount.overlay[0].from + scan.from, -1, scan);
        (layers || (layers = [inner])).push(resolveNode(root, pos, side, false));
      }
    }
  }
  return layers ? iterStack(layers) : inner;
}
var TreeCursor = class {
  /**
  Shorthand for `.type.name`.
  */
  get name() {
    return this.type.name;
  }
  /**
  @internal
  */
  constructor(node, mode = 0) {
    this.mode = mode;
    this.buffer = null;
    this.stack = [];
    this.index = 0;
    this.bufferNode = null;
    if (node instanceof TreeNode) {
      this.yieldNode(node);
    } else {
      this._tree = node.context.parent;
      this.buffer = node.context;
      for (let n2 = node._parent; n2; n2 = n2._parent)
        this.stack.unshift(n2.index);
      this.bufferNode = node;
      this.yieldBuf(node.index);
    }
  }
  yieldNode(node) {
    if (!node)
      return false;
    this._tree = node;
    this.type = node.type;
    this.from = node.from;
    this.to = node.to;
    return true;
  }
  yieldBuf(index2, type) {
    this.index = index2;
    let { start, buffer } = this.buffer;
    this.type = type || buffer.set.types[buffer.buffer[index2]];
    this.from = start + buffer.buffer[index2 + 1];
    this.to = start + buffer.buffer[index2 + 2];
    return true;
  }
  /**
  @internal
  */
  yield(node) {
    if (!node)
      return false;
    if (node instanceof TreeNode) {
      this.buffer = null;
      return this.yieldNode(node);
    }
    this.buffer = node.context;
    return this.yieldBuf(node.index, node.type);
  }
  /**
  @internal
  */
  toString() {
    return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
  }
  /**
  @internal
  */
  enterChild(dir, pos, side) {
    if (!this.buffer)
      return this.yield(this._tree.nextChild(dir < 0 ? this._tree._tree.children.length - 1 : 0, dir, pos, side, this.mode));
    let { buffer } = this.buffer;
    let index2 = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.buffer.start, side);
    if (index2 < 0)
      return false;
    this.stack.push(this.index);
    return this.yieldBuf(index2);
  }
  /**
  Move the cursor to this node's first child. When this returns
  false, the node has no child, and the cursor has not been moved.
  */
  firstChild() {
    return this.enterChild(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to this node's last child.
  */
  lastChild() {
    return this.enterChild(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to the first child that ends after `pos`.
  */
  childAfter(pos) {
    return this.enterChild(
      1,
      pos,
      2
      /* Side.After */
    );
  }
  /**
  Move to the last child that starts before `pos`.
  */
  childBefore(pos) {
    return this.enterChild(
      -1,
      pos,
      -2
      /* Side.Before */
    );
  }
  /**
  Move the cursor to the child around `pos`. If side is -1 the
  child may end at that position, when 1 it may start there. This
  will also enter [overlaid](#common.MountedTree.overlay)
  [mounted](#common.NodeProp^mounted) trees unless `overlays` is
  set to false.
  */
  enter(pos, side, mode = this.mode) {
    if (!this.buffer)
      return this.yield(this._tree.enter(pos, side, mode));
    return mode & IterMode.ExcludeBuffers ? false : this.enterChild(1, pos, side);
  }
  /**
  Move to the node's parent node, if this isn't the top node.
  */
  parent() {
    if (!this.buffer)
      return this.yieldNode(this.mode & IterMode.IncludeAnonymous ? this._tree._parent : this._tree.parent);
    if (this.stack.length)
      return this.yieldBuf(this.stack.pop());
    let parent = this.mode & IterMode.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
    this.buffer = null;
    return this.yieldNode(parent);
  }
  /**
  @internal
  */
  sibling(dir) {
    if (!this.buffer)
      return !this._tree._parent ? false : this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + dir, dir, 0, 4, this.mode));
    let { buffer } = this.buffer, d = this.stack.length - 1;
    if (dir < 0) {
      let parentStart = d < 0 ? 0 : this.stack[d] + 4;
      if (this.index != parentStart)
        return this.yieldBuf(buffer.findChild(
          parentStart,
          this.index,
          -1,
          0,
          4
          /* Side.DontCare */
        ));
    } else {
      let after = buffer.buffer[this.index + 3];
      if (after < (d < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d] + 3]))
        return this.yieldBuf(after);
    }
    return d < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, 0, 4, this.mode)) : false;
  }
  /**
  Move to this node's next sibling, if any.
  */
  nextSibling() {
    return this.sibling(1);
  }
  /**
  Move to this node's previous sibling, if any.
  */
  prevSibling() {
    return this.sibling(-1);
  }
  atLastNode(dir) {
    let index2, parent, { buffer } = this;
    if (buffer) {
      if (dir > 0) {
        if (this.index < buffer.buffer.buffer.length)
          return false;
      } else {
        for (let i2 = 0; i2 < this.index; i2++)
          if (buffer.buffer.buffer[i2 + 3] < this.index)
            return false;
      }
      ({ index: index2, parent } = buffer);
    } else {
      ({ index: index2, _parent: parent } = this._tree);
    }
    for (; parent; { index: index2, _parent: parent } = parent) {
      if (index2 > -1)
        for (let i2 = index2 + dir, e2 = dir < 0 ? -1 : parent._tree.children.length; i2 != e2; i2 += dir) {
          let child = parent._tree.children[i2];
          if (this.mode & IterMode.IncludeAnonymous || child instanceof TreeBuffer || !child.type.isAnonymous || hasChild(child))
            return false;
        }
    }
    return true;
  }
  move(dir, enter) {
    if (enter && this.enterChild(
      dir,
      0,
      4
      /* Side.DontCare */
    ))
      return true;
    for (; ; ) {
      if (this.sibling(dir))
        return true;
      if (this.atLastNode(dir) || !this.parent())
        return false;
    }
  }
  /**
  Move to the next node in a
  [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR)
  traversal, going from a node to its first child or, if the
  current node is empty or `enter` is false, its next sibling or
  the next sibling of the first parent node that has one.
  */
  next(enter = true) {
    return this.move(1, enter);
  }
  /**
  Move to the next node in a last-to-first pre-order traversal. A
  node is followed by its last child or, if it has none, its
  previous sibling or the previous sibling of the first parent
  node that has one.
  */
  prev(enter = true) {
    return this.move(-1, enter);
  }
  /**
  Move the cursor to the innermost node that covers `pos`. If
  `side` is -1, it will enter nodes that end at `pos`. If it is 1,
  it will enter nodes that start at `pos`.
  */
  moveTo(pos, side = 0) {
    while (this.from == this.to || (side < 1 ? this.from >= pos : this.from > pos) || (side > -1 ? this.to <= pos : this.to < pos))
      if (!this.parent())
        break;
    while (this.enterChild(1, pos, side)) {
    }
    return this;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) at the cursor's current
  position.
  */
  get node() {
    if (!this.buffer)
      return this._tree;
    let cache = this.bufferNode, result = null, depth2 = 0;
    if (cache && cache.context == this.buffer) {
      scan: for (let index2 = this.index, d = this.stack.length; d >= 0; ) {
        for (let c = cache; c; c = c._parent)
          if (c.index == index2) {
            if (index2 == this.index)
              return c;
            result = c;
            depth2 = d + 1;
            break scan;
          }
        index2 = this.stack[--d];
      }
    }
    for (let i2 = depth2; i2 < this.stack.length; i2++)
      result = new BufferNode(this.buffer, result, this.stack[i2]);
    return this.bufferNode = new BufferNode(this.buffer, result, this.index);
  }
  /**
  Get the [tree](#common.Tree) that represents the current node, if
  any. Will return null when the node is in a [tree
  buffer](#common.TreeBuffer).
  */
  get tree() {
    return this.buffer ? null : this._tree._tree;
  }
  /**
  Iterate over the current node and all its descendants, calling
  `enter` when entering a node and `leave`, if given, when leaving
  one. When `enter` returns `false`, any children of that node are
  skipped, and `leave` isn't called for it.
  */
  iterate(enter, leave) {
    for (let depth2 = 0; ; ) {
      let mustLeave = false;
      if (this.type.isAnonymous || enter(this) !== false) {
        if (this.firstChild()) {
          depth2++;
          continue;
        }
        if (!this.type.isAnonymous)
          mustLeave = true;
      }
      for (; ; ) {
        if (mustLeave && leave)
          leave(this);
        mustLeave = this.type.isAnonymous;
        if (!depth2)
          return;
        if (this.nextSibling())
          break;
        this.parent();
        depth2--;
        mustLeave = true;
      }
    }
  }
  /**
  Test whether the current node matches a given context—a sequence
  of direct parent node names. Empty strings in the context array
  are treated as wildcards.
  */
  matchContext(context) {
    if (!this.buffer)
      return matchNodeContext(this.node.parent, context);
    let { buffer } = this.buffer, { types: types2 } = buffer.set;
    for (let i2 = context.length - 1, d = this.stack.length - 1; i2 >= 0; d--) {
      if (d < 0)
        return matchNodeContext(this._tree, context, i2);
      let type = types2[buffer.buffer[this.stack[d]]];
      if (!type.isAnonymous) {
        if (context[i2] && context[i2] != type.name)
          return false;
        i2--;
      }
    }
    return true;
  }
};
function hasChild(tree) {
  return tree.children.some((ch2) => ch2 instanceof TreeBuffer || !ch2.type.isAnonymous || hasChild(ch2));
}
function buildTree(data) {
  var _a4;
  let { buffer, nodeSet: nodeSet2, maxBufferLength = DefaultBufferLength, reused = [], minRepeatType = nodeSet2.types.length } = data;
  let cursor = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer;
  let types2 = nodeSet2.types;
  let contextHash = 0, lookAhead = 0;
  function takeNode(parentStart, minPos, children2, positions2, inRepeat, depth2) {
    let { id: id2, start, end, size } = cursor;
    let lookAheadAtStart = lookAhead, contextAtStart = contextHash;
    while (size < 0) {
      cursor.next();
      if (size == -1) {
        let node2 = reused[id2];
        children2.push(node2);
        positions2.push(start - parentStart);
        return;
      } else if (size == -3) {
        contextHash = id2;
        return;
      } else if (size == -4) {
        lookAhead = id2;
        return;
      } else {
        throw new RangeError(`Unrecognized record size: ${size}`);
      }
    }
    let type = types2[id2], node, buffer2;
    let startPos = start - parentStart;
    if (end - start <= maxBufferLength && (buffer2 = findBufferSize(cursor.pos - minPos, inRepeat))) {
      let data2 = new Uint16Array(buffer2.size - buffer2.skip);
      let endPos = cursor.pos - buffer2.size, index2 = data2.length;
      while (cursor.pos > endPos)
        index2 = copyToBuffer(buffer2.start, data2, index2);
      node = new TreeBuffer(data2, end - buffer2.start, nodeSet2);
      startPos = buffer2.start - parentStart;
    } else {
      let endPos = cursor.pos - size;
      cursor.next();
      let localChildren = [], localPositions = [];
      let localInRepeat = id2 >= minRepeatType ? id2 : -1;
      let lastGroup = 0, lastEnd = end;
      while (cursor.pos > endPos) {
        if (localInRepeat >= 0 && cursor.id == localInRepeat && cursor.size >= 0) {
          if (cursor.end <= lastEnd - maxBufferLength) {
            makeRepeatLeaf(localChildren, localPositions, start, lastGroup, cursor.end, lastEnd, localInRepeat, lookAheadAtStart, contextAtStart);
            lastGroup = localChildren.length;
            lastEnd = cursor.end;
          }
          cursor.next();
        } else if (depth2 > 2500) {
          takeFlatNode(start, endPos, localChildren, localPositions);
        } else {
          takeNode(start, endPos, localChildren, localPositions, localInRepeat, depth2 + 1);
        }
      }
      if (localInRepeat >= 0 && lastGroup > 0 && lastGroup < localChildren.length)
        makeRepeatLeaf(localChildren, localPositions, start, lastGroup, start, lastEnd, localInRepeat, lookAheadAtStart, contextAtStart);
      localChildren.reverse();
      localPositions.reverse();
      if (localInRepeat > -1 && lastGroup > 0) {
        let make = makeBalanced(type, contextAtStart);
        node = balanceRange(type, localChildren, localPositions, 0, localChildren.length, 0, end - start, make, make);
      } else {
        node = makeTree(type, localChildren, localPositions, end - start, lookAheadAtStart - end, contextAtStart);
      }
    }
    children2.push(node);
    positions2.push(startPos);
  }
  function takeFlatNode(parentStart, minPos, children2, positions2) {
    let nodes = [];
    let nodeCount = 0, stopAt = -1;
    while (cursor.pos > minPos) {
      let { id: id2, start, end, size } = cursor;
      if (size > 4) {
        cursor.next();
      } else if (stopAt > -1 && start < stopAt) {
        break;
      } else {
        if (stopAt < 0)
          stopAt = end - maxBufferLength;
        nodes.push(id2, start, end);
        nodeCount++;
        cursor.next();
      }
    }
    if (nodeCount) {
      let buffer2 = new Uint16Array(nodeCount * 4);
      let start = nodes[nodes.length - 2];
      for (let i2 = nodes.length - 3, j = 0; i2 >= 0; i2 -= 3) {
        buffer2[j++] = nodes[i2];
        buffer2[j++] = nodes[i2 + 1] - start;
        buffer2[j++] = nodes[i2 + 2] - start;
        buffer2[j++] = j;
      }
      children2.push(new TreeBuffer(buffer2, nodes[2] - start, nodeSet2));
      positions2.push(start - parentStart);
    }
  }
  function makeBalanced(type, contextHash2) {
    return (children2, positions2, length2) => {
      let lookAhead2 = 0, lastI = children2.length - 1, last2, lookAheadProp;
      if (lastI >= 0 && (last2 = children2[lastI]) instanceof Tree) {
        if (!lastI && last2.type == type && last2.length == length2)
          return last2;
        if (lookAheadProp = last2.prop(NodeProp.lookAhead))
          lookAhead2 = positions2[lastI] + last2.length + lookAheadProp;
      }
      return makeTree(type, children2, positions2, length2, lookAhead2, contextHash2);
    };
  }
  function makeRepeatLeaf(children2, positions2, base2, i2, from, to3, type, lookAhead2, contextHash2) {
    let localChildren = [], localPositions = [];
    while (children2.length > i2) {
      localChildren.push(children2.pop());
      localPositions.push(positions2.pop() + base2 - from);
    }
    children2.push(makeTree(nodeSet2.types[type], localChildren, localPositions, to3 - from, lookAhead2 - to3, contextHash2));
    positions2.push(from - base2);
  }
  function makeTree(type, children2, positions2, length2, lookAhead2, contextHash2, props) {
    if (contextHash2) {
      let pair2 = [NodeProp.contextHash, contextHash2];
      props = props ? [pair2].concat(props) : [pair2];
    }
    if (lookAhead2 > 25) {
      let pair2 = [NodeProp.lookAhead, lookAhead2];
      props = props ? [pair2].concat(props) : [pair2];
    }
    return new Tree(type, children2, positions2, length2, props);
  }
  function findBufferSize(maxSize, inRepeat) {
    let fork = cursor.fork();
    let size = 0, start = 0, skip = 0, minStart = fork.end - maxBufferLength;
    let result = { size: 0, start: 0, skip: 0 };
    scan: for (let minPos = fork.pos - maxSize; fork.pos > minPos; ) {
      let nodeSize2 = fork.size;
      if (fork.id == inRepeat && nodeSize2 >= 0) {
        result.size = size;
        result.start = start;
        result.skip = skip;
        skip += 4;
        size += 4;
        fork.next();
        continue;
      }
      let startPos = fork.pos - nodeSize2;
      if (nodeSize2 < 0 || startPos < minPos || fork.start < minStart)
        break;
      let localSkipped = fork.id >= minRepeatType ? 4 : 0;
      let nodeStart2 = fork.start;
      fork.next();
      while (fork.pos > startPos) {
        if (fork.size < 0) {
          if (fork.size == -3)
            localSkipped += 4;
          else
            break scan;
        } else if (fork.id >= minRepeatType) {
          localSkipped += 4;
        }
        fork.next();
      }
      start = nodeStart2;
      size += nodeSize2;
      skip += localSkipped;
    }
    if (inRepeat < 0 || size == maxSize) {
      result.size = size;
      result.start = start;
      result.skip = skip;
    }
    return result.size > 4 ? result : void 0;
  }
  function copyToBuffer(bufferStart, buffer2, index2) {
    let { id: id2, start, end, size } = cursor;
    cursor.next();
    if (size >= 0 && id2 < minRepeatType) {
      let startIndex = index2;
      if (size > 4) {
        let endPos = cursor.pos - (size - 4);
        while (cursor.pos > endPos)
          index2 = copyToBuffer(bufferStart, buffer2, index2);
      }
      buffer2[--index2] = startIndex;
      buffer2[--index2] = end - bufferStart;
      buffer2[--index2] = start - bufferStart;
      buffer2[--index2] = id2;
    } else if (size == -3) {
      contextHash = id2;
    } else if (size == -4) {
      lookAhead = id2;
    }
    return index2;
  }
  let children = [], positions = [];
  while (cursor.pos > 0)
    takeNode(data.start || 0, data.bufferStart || 0, children, positions, -1, 0);
  let length = (_a4 = data.length) !== null && _a4 !== void 0 ? _a4 : children.length ? positions[0] + children[0].length : 0;
  return new Tree(types2[data.topID], children.reverse(), positions.reverse(), length);
}
var nodeSizeCache = /* @__PURE__ */ new WeakMap();
function nodeSize(balanceType, node) {
  if (!balanceType.isAnonymous || node instanceof TreeBuffer || node.type != balanceType)
    return 1;
  let size = nodeSizeCache.get(node);
  if (size == null) {
    size = 1;
    for (let child of node.children) {
      if (child.type != balanceType || !(child instanceof Tree)) {
        size = 1;
        break;
      }
      size += nodeSize(balanceType, child);
    }
    nodeSizeCache.set(node, size);
  }
  return size;
}
function balanceRange(balanceType, children, positions, from, to3, start, length, mkTop, mkTree) {
  let total = 0;
  for (let i2 = from; i2 < to3; i2++)
    total += nodeSize(balanceType, children[i2]);
  let maxChild = Math.ceil(
    total * 1.5 / 8
    /* Balance.BranchFactor */
  );
  let localChildren = [], localPositions = [];
  function divide(children2, positions2, from2, to4, offset) {
    for (let i2 = from2; i2 < to4; ) {
      let groupFrom = i2, groupStart = positions2[i2], groupSize = nodeSize(balanceType, children2[i2]);
      i2++;
      for (; i2 < to4; i2++) {
        let nextSize = nodeSize(balanceType, children2[i2]);
        if (groupSize + nextSize >= maxChild)
          break;
        groupSize += nextSize;
      }
      if (i2 == groupFrom + 1) {
        if (groupSize > maxChild) {
          let only = children2[groupFrom];
          divide(only.children, only.positions, 0, only.children.length, positions2[groupFrom] + offset);
          continue;
        }
        localChildren.push(children2[groupFrom]);
      } else {
        let length2 = positions2[i2 - 1] + children2[i2 - 1].length - groupStart;
        localChildren.push(balanceRange(balanceType, children2, positions2, groupFrom, i2, groupStart, length2, null, mkTree));
      }
      localPositions.push(groupStart + offset - start);
    }
  }
  divide(children, positions, from, to3, 0);
  return (mkTop || mkTree)(localChildren, localPositions, length);
}
var TreeFragment = class _TreeFragment {
  /**
  Construct a tree fragment. You'll usually want to use
  [`addTree`](#common.TreeFragment^addTree) and
  [`applyChanges`](#common.TreeFragment^applyChanges) instead of
  calling this directly.
  */
  constructor(from, to3, tree, offset, openStart = false, openEnd = false) {
    this.from = from;
    this.to = to3;
    this.tree = tree;
    this.offset = offset;
    this.open = (openStart ? 1 : 0) | (openEnd ? 2 : 0);
  }
  /**
  Whether the start of the fragment represents the start of a
  parse, or the end of a change. (In the second case, it may not
  be safe to reuse some nodes at the start, depending on the
  parsing algorithm.)
  */
  get openStart() {
    return (this.open & 1) > 0;
  }
  /**
  Whether the end of the fragment represents the end of a
  full-document parse, or the start of a change.
  */
  get openEnd() {
    return (this.open & 2) > 0;
  }
  /**
  Create a set of fragments from a freshly parsed tree, or update
  an existing set of fragments by replacing the ones that overlap
  with a tree with content from the new tree. When `partial` is
  true, the parse is treated as incomplete, and the resulting
  fragment has [`openEnd`](#common.TreeFragment.openEnd) set to
  true.
  */
  static addTree(tree, fragments = [], partial = false) {
    let result = [new _TreeFragment(0, tree.length, tree, 0, false, partial)];
    for (let f of fragments)
      if (f.to > tree.length)
        result.push(f);
    return result;
  }
  /**
  Apply a set of edits to an array of fragments, removing or
  splitting fragments as necessary to remove edited ranges, and
  adjusting offsets for fragments that moved.
  */
  static applyChanges(fragments, changes, minGap = 128) {
    if (!changes.length)
      return fragments;
    let result = [];
    let fI = 1, nextF = fragments.length ? fragments[0] : null;
    for (let cI = 0, pos = 0, off = 0; ; cI++) {
      let nextC = cI < changes.length ? changes[cI] : null;
      let nextPos = nextC ? nextC.fromA : 1e9;
      if (nextPos - pos >= minGap)
        while (nextF && nextF.from < nextPos) {
          let cut = nextF;
          if (pos >= cut.from || nextPos <= cut.to || off) {
            let fFrom = Math.max(cut.from, pos) - off, fTo = Math.min(cut.to, nextPos) - off;
            cut = fFrom >= fTo ? null : new _TreeFragment(fFrom, fTo, cut.tree, cut.offset + off, cI > 0, !!nextC);
          }
          if (cut)
            result.push(cut);
          if (nextF.to > nextPos)
            break;
          nextF = fI < fragments.length ? fragments[fI++] : null;
        }
      if (!nextC)
        break;
      pos = nextC.toA;
      off = nextC.toA - nextC.toB;
    }
    return result;
  }
};
var Parser = class {
  /**
  Start a parse, returning a [partial parse](#common.PartialParse)
  object. [`fragments`](#common.TreeFragment) can be passed in to
  make the parse incremental.
  
  By default, the entire input is parsed. You can pass `ranges`,
  which should be a sorted array of non-empty, non-overlapping
  ranges, to parse only those ranges. The tree returned in that
  case will start at `ranges[0].from`.
  */
  startParse(input, fragments, ranges) {
    if (typeof input == "string")
      input = new StringInput(input);
    ranges = !ranges ? [new Range2(0, input.length)] : ranges.length ? ranges.map((r2) => new Range2(r2.from, r2.to)) : [new Range2(0, 0)];
    return this.createParse(input, fragments || [], ranges);
  }
  /**
  Run a full parse, returning the resulting tree.
  */
  parse(input, fragments, ranges) {
    let parse = this.startParse(input, fragments, ranges);
    for (; ; ) {
      let done = parse.advance();
      if (done)
        return done;
    }
  }
};
var StringInput = class {
  constructor(string2) {
    this.string = string2;
  }
  get length() {
    return this.string.length;
  }
  chunk(from) {
    return this.string.slice(from);
  }
  get lineChunks() {
    return false;
  }
  read(from, to3) {
    return this.string.slice(from, to3);
  }
};
var stoppedInner = new NodeProp({ perNode: true });

// node_modules/@lezer/highlight/dist/index.js
var nextTagID = 0;
var Tag = class _Tag {
  /**
  @internal
  */
  constructor(name2, set, base2, modified) {
    this.name = name2;
    this.set = set;
    this.base = base2;
    this.modified = modified;
    this.id = nextTagID++;
  }
  toString() {
    let { name: name2 } = this;
    for (let mod of this.modified)
      if (mod.name)
        name2 = `${mod.name}(${name2})`;
    return name2;
  }
  static define(nameOrParent, parent) {
    let name2 = typeof nameOrParent == "string" ? nameOrParent : "?";
    if (nameOrParent instanceof _Tag)
      parent = nameOrParent;
    if (parent === null || parent === void 0 ? void 0 : parent.base)
      throw new Error("Can not derive from a modified tag");
    let tag = new _Tag(name2, [], null, []);
    tag.set.push(tag);
    if (parent)
      for (let t3 of parent.set)
        tag.set.push(t3);
    return tag;
  }
  /**
  Define a tag _modifier_, which is a function that, given a tag,
  will return a tag that is a subtag of the original. Applying the
  same modifier to a twice tag will return the same value (`m1(t1)
  == m1(t1)`) and applying multiple modifiers will, regardless or
  order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).
  
  When multiple modifiers are applied to a given base tag, each
  smaller set of modifiers is registered as a parent, so that for
  example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,
  `m1(m3(t1)`, and so on.
  */
  static defineModifier(name2) {
    let mod = new Modifier(name2);
    return (tag) => {
      if (tag.modified.indexOf(mod) > -1)
        return tag;
      return Modifier.get(tag.base || tag, tag.modified.concat(mod).sort((a2, b2) => a2.id - b2.id));
    };
  }
};
var nextModifierID = 0;
var Modifier = class _Modifier {
  constructor(name2) {
    this.name = name2;
    this.instances = [];
    this.id = nextModifierID++;
  }
  static get(base2, mods) {
    if (!mods.length)
      return base2;
    let exists = mods[0].instances.find((t3) => t3.base == base2 && sameArray2(mods, t3.modified));
    if (exists)
      return exists;
    let set = [], tag = new Tag(base2.name, set, base2, mods);
    for (let m3 of mods)
      m3.instances.push(tag);
    let configs = powerSet(mods);
    for (let parent of base2.set)
      if (!parent.modified.length)
        for (let config2 of configs)
          set.push(_Modifier.get(parent, config2));
    return tag;
  }
};
function sameArray2(a2, b2) {
  return a2.length == b2.length && a2.every((x, i2) => x == b2[i2]);
}
function powerSet(array) {
  let sets = [[]];
  for (let i2 = 0; i2 < array.length; i2++) {
    for (let j = 0, e2 = sets.length; j < e2; j++) {
      sets.push(sets[j].concat(array[i2]));
    }
  }
  return sets.sort((a2, b2) => b2.length - a2.length);
}
function styleTags(spec) {
  let byName = /* @__PURE__ */ Object.create(null);
  for (let prop in spec) {
    let tags2 = spec[prop];
    if (!Array.isArray(tags2))
      tags2 = [tags2];
    for (let part of prop.split(" "))
      if (part) {
        let pieces = [], mode = 2, rest = part;
        for (let pos = 0; ; ) {
          if (rest == "..." && pos > 0 && pos + 3 == part.length) {
            mode = 1;
            break;
          }
          let m3 = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(rest);
          if (!m3)
            throw new RangeError("Invalid path: " + part);
          pieces.push(m3[0] == "*" ? "" : m3[0][0] == '"' ? JSON.parse(m3[0]) : m3[0]);
          pos += m3[0].length;
          if (pos == part.length)
            break;
          let next = part[pos++];
          if (pos == part.length && next == "!") {
            mode = 0;
            break;
          }
          if (next != "/")
            throw new RangeError("Invalid path: " + part);
          rest = part.slice(pos);
        }
        let last2 = pieces.length - 1, inner = pieces[last2];
        if (!inner)
          throw new RangeError("Invalid path: " + part);
        let rule = new Rule(tags2, mode, last2 > 0 ? pieces.slice(0, last2) : null);
        byName[inner] = rule.sort(byName[inner]);
      }
  }
  return ruleNodeProp.add(byName);
}
var ruleNodeProp = new NodeProp();
var Rule = class {
  constructor(tags2, mode, context, next) {
    this.tags = tags2;
    this.mode = mode;
    this.context = context;
    this.next = next;
  }
  get opaque() {
    return this.mode == 0;
  }
  get inherit() {
    return this.mode == 1;
  }
  sort(other) {
    if (!other || other.depth < this.depth) {
      this.next = other;
      return this;
    }
    other.next = this.sort(other.next);
    return other;
  }
  get depth() {
    return this.context ? this.context.length : 0;
  }
};
Rule.empty = new Rule([], 2, null);
function tagHighlighter(tags2, options) {
  let map = /* @__PURE__ */ Object.create(null);
  for (let style of tags2) {
    if (!Array.isArray(style.tag))
      map[style.tag.id] = style.class;
    else
      for (let tag of style.tag)
        map[tag.id] = style.class;
  }
  let { scope, all = null } = options || {};
  return {
    style: (tags3) => {
      let cls = all;
      for (let tag of tags3) {
        for (let sub of tag.set) {
          let tagClass = map[sub.id];
          if (tagClass) {
            cls = cls ? cls + " " + tagClass : tagClass;
            break;
          }
        }
      }
      return cls;
    },
    scope
  };
}
function highlightTags(highlighters, tags2) {
  let result = null;
  for (let highlighter of highlighters) {
    let value = highlighter.style(tags2);
    if (value)
      result = result ? result + " " + value : value;
  }
  return result;
}
function highlightTree(tree, highlighter, putStyle, from = 0, to3 = tree.length) {
  let builder = new HighlightBuilder(from, Array.isArray(highlighter) ? highlighter : [highlighter], putStyle);
  builder.highlightRange(tree.cursor(), from, to3, "", builder.highlighters);
  builder.flush(to3);
}
var HighlightBuilder = class {
  constructor(at2, highlighters, span) {
    this.at = at2;
    this.highlighters = highlighters;
    this.span = span;
    this.class = "";
  }
  startSpan(at2, cls) {
    if (cls != this.class) {
      this.flush(at2);
      if (at2 > this.at)
        this.at = at2;
      this.class = cls;
    }
  }
  flush(to3) {
    if (to3 > this.at && this.class)
      this.span(this.at, to3, this.class);
  }
  highlightRange(cursor, from, to3, inheritedClass, highlighters) {
    let { type, from: start, to: end } = cursor;
    if (start >= to3 || end <= from)
      return;
    if (type.isTop)
      highlighters = this.highlighters.filter((h2) => !h2.scope || h2.scope(type));
    let cls = inheritedClass;
    let rule = getStyleTags(cursor) || Rule.empty;
    let tagCls = highlightTags(highlighters, rule.tags);
    if (tagCls) {
      if (cls)
        cls += " ";
      cls += tagCls;
      if (rule.mode == 1)
        inheritedClass += (inheritedClass ? " " : "") + tagCls;
    }
    this.startSpan(Math.max(from, start), cls);
    if (rule.opaque)
      return;
    let mounted = cursor.tree && cursor.tree.prop(NodeProp.mounted);
    if (mounted && mounted.overlay) {
      let inner = cursor.node.enter(mounted.overlay[0].from + start, 1);
      let innerHighlighters = this.highlighters.filter((h2) => !h2.scope || h2.scope(mounted.tree.type));
      let hasChild2 = cursor.firstChild();
      for (let i2 = 0, pos = start; ; i2++) {
        let next = i2 < mounted.overlay.length ? mounted.overlay[i2] : null;
        let nextPos = next ? next.from + start : end;
        let rangeFrom = Math.max(from, pos), rangeTo = Math.min(to3, nextPos);
        if (rangeFrom < rangeTo && hasChild2) {
          while (cursor.from < rangeTo) {
            this.highlightRange(cursor, rangeFrom, rangeTo, inheritedClass, highlighters);
            this.startSpan(Math.min(rangeTo, cursor.to), cls);
            if (cursor.to >= nextPos || !cursor.nextSibling())
              break;
          }
        }
        if (!next || nextPos > to3)
          break;
        pos = next.to + start;
        if (pos > from) {
          this.highlightRange(inner.cursor(), Math.max(from, next.from + start), Math.min(to3, pos), "", innerHighlighters);
          this.startSpan(Math.min(to3, pos), cls);
        }
      }
      if (hasChild2)
        cursor.parent();
    } else if (cursor.firstChild()) {
      if (mounted)
        inheritedClass = "";
      do {
        if (cursor.to <= from)
          continue;
        if (cursor.from >= to3)
          break;
        this.highlightRange(cursor, from, to3, inheritedClass, highlighters);
        this.startSpan(Math.min(to3, cursor.to), cls);
      } while (cursor.nextSibling());
      cursor.parent();
    }
  }
};
function getStyleTags(node) {
  let rule = node.type.prop(ruleNodeProp);
  while (rule && rule.context && !node.matchContext(rule.context))
    rule = rule.next;
  return rule || null;
}
var t = Tag.define;
var comment = t();
var name = t();
var typeName = t(name);
var propertyName = t(name);
var literal = t();
var string = t(literal);
var number = t(literal);
var content = t();
var heading = t(content);
var keyword = t();
var operator = t();
var punctuation = t();
var bracket = t(punctuation);
var meta = t();
var tags = {
  /**
  A comment.
  */
  comment,
  /**
  A line [comment](#highlight.tags.comment).
  */
  lineComment: t(comment),
  /**
  A block [comment](#highlight.tags.comment).
  */
  blockComment: t(comment),
  /**
  A documentation [comment](#highlight.tags.comment).
  */
  docComment: t(comment),
  /**
  Any kind of identifier.
  */
  name,
  /**
  The [name](#highlight.tags.name) of a variable.
  */
  variableName: t(name),
  /**
  A type [name](#highlight.tags.name).
  */
  typeName,
  /**
  A tag name (subtag of [`typeName`](#highlight.tags.typeName)).
  */
  tagName: t(typeName),
  /**
  A property or field [name](#highlight.tags.name).
  */
  propertyName,
  /**
  An attribute name (subtag of [`propertyName`](#highlight.tags.propertyName)).
  */
  attributeName: t(propertyName),
  /**
  The [name](#highlight.tags.name) of a class.
  */
  className: t(name),
  /**
  A label [name](#highlight.tags.name).
  */
  labelName: t(name),
  /**
  A namespace [name](#highlight.tags.name).
  */
  namespace: t(name),
  /**
  The [name](#highlight.tags.name) of a macro.
  */
  macroName: t(name),
  /**
  A literal value.
  */
  literal,
  /**
  A string [literal](#highlight.tags.literal).
  */
  string,
  /**
  A documentation [string](#highlight.tags.string).
  */
  docString: t(string),
  /**
  A character literal (subtag of [string](#highlight.tags.string)).
  */
  character: t(string),
  /**
  An attribute value (subtag of [string](#highlight.tags.string)).
  */
  attributeValue: t(string),
  /**
  A number [literal](#highlight.tags.literal).
  */
  number,
  /**
  An integer [number](#highlight.tags.number) literal.
  */
  integer: t(number),
  /**
  A floating-point [number](#highlight.tags.number) literal.
  */
  float: t(number),
  /**
  A boolean [literal](#highlight.tags.literal).
  */
  bool: t(literal),
  /**
  Regular expression [literal](#highlight.tags.literal).
  */
  regexp: t(literal),
  /**
  An escape [literal](#highlight.tags.literal), for example a
  backslash escape in a string.
  */
  escape: t(literal),
  /**
  A color [literal](#highlight.tags.literal).
  */
  color: t(literal),
  /**
  A URL [literal](#highlight.tags.literal).
  */
  url: t(literal),
  /**
  A language keyword.
  */
  keyword,
  /**
  The [keyword](#highlight.tags.keyword) for the self or this
  object.
  */
  self: t(keyword),
  /**
  The [keyword](#highlight.tags.keyword) for null.
  */
  null: t(keyword),
  /**
  A [keyword](#highlight.tags.keyword) denoting some atomic value.
  */
  atom: t(keyword),
  /**
  A [keyword](#highlight.tags.keyword) that represents a unit.
  */
  unit: t(keyword),
  /**
  A modifier [keyword](#highlight.tags.keyword).
  */
  modifier: t(keyword),
  /**
  A [keyword](#highlight.tags.keyword) that acts as an operator.
  */
  operatorKeyword: t(keyword),
  /**
  A control-flow related [keyword](#highlight.tags.keyword).
  */
  controlKeyword: t(keyword),
  /**
  A [keyword](#highlight.tags.keyword) that defines something.
  */
  definitionKeyword: t(keyword),
  /**
  A [keyword](#highlight.tags.keyword) related to defining or
  interfacing with modules.
  */
  moduleKeyword: t(keyword),
  /**
  An operator.
  */
  operator,
  /**
  An [operator](#highlight.tags.operator) that dereferences something.
  */
  derefOperator: t(operator),
  /**
  Arithmetic-related [operator](#highlight.tags.operator).
  */
  arithmeticOperator: t(operator),
  /**
  Logical [operator](#highlight.tags.operator).
  */
  logicOperator: t(operator),
  /**
  Bit [operator](#highlight.tags.operator).
  */
  bitwiseOperator: t(operator),
  /**
  Comparison [operator](#highlight.tags.operator).
  */
  compareOperator: t(operator),
  /**
  [Operator](#highlight.tags.operator) that updates its operand.
  */
  updateOperator: t(operator),
  /**
  [Operator](#highlight.tags.operator) that defines something.
  */
  definitionOperator: t(operator),
  /**
  Type-related [operator](#highlight.tags.operator).
  */
  typeOperator: t(operator),
  /**
  Control-flow [operator](#highlight.tags.operator).
  */
  controlOperator: t(operator),
  /**
  Program or markup punctuation.
  */
  punctuation,
  /**
  [Punctuation](#highlight.tags.punctuation) that separates
  things.
  */
  separator: t(punctuation),
  /**
  Bracket-style [punctuation](#highlight.tags.punctuation).
  */
  bracket,
  /**
  Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`
  tokens).
  */
  angleBracket: t(bracket),
  /**
  Square [brackets](#highlight.tags.bracket) (usually `[` and `]`
  tokens).
  */
  squareBracket: t(bracket),
  /**
  Parentheses (usually `(` and `)` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  paren: t(bracket),
  /**
  Braces (usually `{` and `}` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  brace: t(bracket),
  /**
  Content, for example plain text in XML or markup documents.
  */
  content,
  /**
  [Content](#highlight.tags.content) that represents a heading.
  */
  heading,
  /**
  A level 1 [heading](#highlight.tags.heading).
  */
  heading1: t(heading),
  /**
  A level 2 [heading](#highlight.tags.heading).
  */
  heading2: t(heading),
  /**
  A level 3 [heading](#highlight.tags.heading).
  */
  heading3: t(heading),
  /**
  A level 4 [heading](#highlight.tags.heading).
  */
  heading4: t(heading),
  /**
  A level 5 [heading](#highlight.tags.heading).
  */
  heading5: t(heading),
  /**
  A level 6 [heading](#highlight.tags.heading).
  */
  heading6: t(heading),
  /**
  A prose [content](#highlight.tags.content) separator (such as a horizontal rule).
  */
  contentSeparator: t(content),
  /**
  [Content](#highlight.tags.content) that represents a list.
  */
  list: t(content),
  /**
  [Content](#highlight.tags.content) that represents a quote.
  */
  quote: t(content),
  /**
  [Content](#highlight.tags.content) that is emphasized.
  */
  emphasis: t(content),
  /**
  [Content](#highlight.tags.content) that is styled strong.
  */
  strong: t(content),
  /**
  [Content](#highlight.tags.content) that is part of a link.
  */
  link: t(content),
  /**
  [Content](#highlight.tags.content) that is styled as code or
  monospace.
  */
  monospace: t(content),
  /**
  [Content](#highlight.tags.content) that has a strike-through
  style.
  */
  strikethrough: t(content),
  /**
  Inserted text in a change-tracking format.
  */
  inserted: t(),
  /**
  Deleted text.
  */
  deleted: t(),
  /**
  Changed text.
  */
  changed: t(),
  /**
  An invalid or unsyntactic element.
  */
  invalid: t(),
  /**
  Metadata or meta-instruction.
  */
  meta,
  /**
  [Metadata](#highlight.tags.meta) that applies to the entire
  document.
  */
  documentMeta: t(meta),
  /**
  [Metadata](#highlight.tags.meta) that annotates or adds
  attributes to a given syntactic element.
  */
  annotation: t(meta),
  /**
  Processing instruction or preprocessor directive. Subtag of
  [meta](#highlight.tags.meta).
  */
  processingInstruction: t(meta),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that a
  given element is being defined. Expected to be used with the
  various [name](#highlight.tags.name) tags.
  */
  definition: Tag.defineModifier("definition"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that
  something is constant. Mostly expected to be used with
  [variable names](#highlight.tags.variableName).
  */
  constant: Tag.defineModifier("constant"),
  /**
  [Modifier](#highlight.Tag^defineModifier) used to indicate that
  a [variable](#highlight.tags.variableName) or [property
  name](#highlight.tags.propertyName) is being called or defined
  as a function.
  */
  function: Tag.defineModifier("function"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that can be applied to
  [names](#highlight.tags.name) to indicate that they belong to
  the language's standard environment.
  */
  standard: Tag.defineModifier("standard"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates a given
  [names](#highlight.tags.name) is local to some scope.
  */
  local: Tag.defineModifier("local"),
  /**
  A generic variant [modifier](#highlight.Tag^defineModifier) that
  can be used to tag language-specific alternative variants of
  some common tag. It is recommended for themes to define special
  forms of at least the [string](#highlight.tags.string) and
  [variable name](#highlight.tags.variableName) tags, since those
  come up a lot.
  */
  special: Tag.defineModifier("special")
};
for (let name2 in tags) {
  let val = tags[name2];
  if (val instanceof Tag)
    val.name = name2;
}
var classHighlighter = tagHighlighter([
  { tag: tags.link, class: "tok-link" },
  { tag: tags.heading, class: "tok-heading" },
  { tag: tags.emphasis, class: "tok-emphasis" },
  { tag: tags.strong, class: "tok-strong" },
  { tag: tags.keyword, class: "tok-keyword" },
  { tag: tags.atom, class: "tok-atom" },
  { tag: tags.bool, class: "tok-bool" },
  { tag: tags.url, class: "tok-url" },
  { tag: tags.labelName, class: "tok-labelName" },
  { tag: tags.inserted, class: "tok-inserted" },
  { tag: tags.deleted, class: "tok-deleted" },
  { tag: tags.literal, class: "tok-literal" },
  { tag: tags.string, class: "tok-string" },
  { tag: tags.number, class: "tok-number" },
  { tag: [tags.regexp, tags.escape, tags.special(tags.string)], class: "tok-string2" },
  { tag: tags.variableName, class: "tok-variableName" },
  { tag: tags.local(tags.variableName), class: "tok-variableName tok-local" },
  { tag: tags.definition(tags.variableName), class: "tok-variableName tok-definition" },
  { tag: tags.special(tags.variableName), class: "tok-variableName2" },
  { tag: tags.definition(tags.propertyName), class: "tok-propertyName tok-definition" },
  { tag: tags.typeName, class: "tok-typeName" },
  { tag: tags.namespace, class: "tok-namespace" },
  { tag: tags.className, class: "tok-className" },
  { tag: tags.macroName, class: "tok-macroName" },
  { tag: tags.propertyName, class: "tok-propertyName" },
  { tag: tags.operator, class: "tok-operator" },
  { tag: tags.comment, class: "tok-comment" },
  { tag: tags.meta, class: "tok-meta" },
  { tag: tags.invalid, class: "tok-invalid" },
  { tag: tags.punctuation, class: "tok-punctuation" }
]);

// node_modules/@codemirror/language/dist/index.js
var _a;
var languageDataProp = new NodeProp();
function defineLanguageFacet(baseData) {
  return Facet.define({
    combine: baseData ? (values) => values.concat(baseData) : void 0
  });
}
var sublanguageProp = new NodeProp();
var Language = class {
  /**
  Construct a language object. If you need to invoke this
  directly, first define a data facet with
  [`defineLanguageFacet`](https://codemirror.net/6/docs/ref/#language.defineLanguageFacet), and then
  configure your parser to [attach](https://codemirror.net/6/docs/ref/#language.languageDataProp) it
  to the language's outer syntax node.
  */
  constructor(data, parser2, extraExtensions = [], name2 = "") {
    this.data = data;
    this.name = name2;
    if (!EditorState.prototype.hasOwnProperty("tree"))
      Object.defineProperty(EditorState.prototype, "tree", { get() {
        return syntaxTree(this);
      } });
    this.parser = parser2;
    this.extension = [
      language.of(this),
      EditorState.languageData.of((state, pos, side) => {
        let top2 = topNodeAt(state, pos, side), data2 = top2.type.prop(languageDataProp);
        if (!data2)
          return [];
        let base2 = state.facet(data2), sub = top2.type.prop(sublanguageProp);
        if (sub) {
          let innerNode = top2.resolve(pos - top2.from, side);
          for (let sublang of sub)
            if (sublang.test(innerNode, state)) {
              let data3 = state.facet(sublang.facet);
              return sublang.type == "replace" ? data3 : data3.concat(base2);
            }
        }
        return base2;
      })
    ].concat(extraExtensions);
  }
  /**
  Query whether this language is active at the given position.
  */
  isActiveAt(state, pos, side = -1) {
    return topNodeAt(state, pos, side).type.prop(languageDataProp) == this.data;
  }
  /**
  Find the document regions that were parsed using this language.
  The returned regions will _include_ any nested languages rooted
  in this language, when those exist.
  */
  findRegions(state) {
    let lang = state.facet(language);
    if ((lang === null || lang === void 0 ? void 0 : lang.data) == this.data)
      return [{ from: 0, to: state.doc.length }];
    if (!lang || !lang.allowsNesting)
      return [];
    let result = [];
    let explore = (tree, from) => {
      if (tree.prop(languageDataProp) == this.data) {
        result.push({ from, to: from + tree.length });
        return;
      }
      let mount = tree.prop(NodeProp.mounted);
      if (mount) {
        if (mount.tree.prop(languageDataProp) == this.data) {
          if (mount.overlay)
            for (let r2 of mount.overlay)
              result.push({ from: r2.from + from, to: r2.to + from });
          else
            result.push({ from, to: from + tree.length });
          return;
        } else if (mount.overlay) {
          let size = result.length;
          explore(mount.tree, mount.overlay[0].from + from);
          if (result.length > size)
            return;
        }
      }
      for (let i2 = 0; i2 < tree.children.length; i2++) {
        let ch2 = tree.children[i2];
        if (ch2 instanceof Tree)
          explore(ch2, tree.positions[i2] + from);
      }
    };
    explore(syntaxTree(state), 0);
    return result;
  }
  /**
  Indicates whether this language allows nested languages. The
  default implementation returns true.
  */
  get allowsNesting() {
    return true;
  }
};
Language.setState = StateEffect.define();
function topNodeAt(state, pos, side) {
  let topLang = state.facet(language), tree = syntaxTree(state).topNode;
  if (!topLang || topLang.allowsNesting) {
    for (let node = tree; node; node = node.enter(pos, side, IterMode.ExcludeBuffers))
      if (node.type.isTop)
        tree = node;
  }
  return tree;
}
var LRLanguage = class _LRLanguage extends Language {
  constructor(data, parser2, name2) {
    super(data, parser2, [], name2);
    this.parser = parser2;
  }
  /**
  Define a language from a parser.
  */
  static define(spec) {
    let data = defineLanguageFacet(spec.languageData);
    return new _LRLanguage(data, spec.parser.configure({
      props: [languageDataProp.add((type) => type.isTop ? data : void 0)]
    }), spec.name);
  }
  /**
  Create a new instance of this language with a reconfigured
  version of its parser and optionally a new name.
  */
  configure(options, name2) {
    return new _LRLanguage(this.data, this.parser.configure(options), name2 || this.name);
  }
  get allowsNesting() {
    return this.parser.hasWrappers();
  }
};
function syntaxTree(state) {
  let field = state.field(Language.state, false);
  return field ? field.tree : Tree.empty;
}
var DocInput = class {
  /**
  Create an input object for the given document.
  */
  constructor(doc2) {
    this.doc = doc2;
    this.cursorPos = 0;
    this.string = "";
    this.cursor = doc2.iter();
  }
  get length() {
    return this.doc.length;
  }
  syncTo(pos) {
    this.string = this.cursor.next(pos - this.cursorPos).value;
    this.cursorPos = pos + this.string.length;
    return this.cursorPos - this.string.length;
  }
  chunk(pos) {
    this.syncTo(pos);
    return this.string;
  }
  get lineChunks() {
    return true;
  }
  read(from, to3) {
    let stringStart = this.cursorPos - this.string.length;
    if (from < stringStart || to3 >= this.cursorPos)
      return this.doc.sliceString(from, to3);
    else
      return this.string.slice(from - stringStart, to3 - stringStart);
  }
};
var currentContext = null;
var ParseContext = class _ParseContext {
  constructor(parser2, state, fragments = [], tree, treeLen, viewport, skipped, scheduleOn) {
    this.parser = parser2;
    this.state = state;
    this.fragments = fragments;
    this.tree = tree;
    this.treeLen = treeLen;
    this.viewport = viewport;
    this.skipped = skipped;
    this.scheduleOn = scheduleOn;
    this.parse = null;
    this.tempSkipped = [];
  }
  /**
  @internal
  */
  static create(parser2, state, viewport) {
    return new _ParseContext(parser2, state, [], Tree.empty, 0, viewport, [], null);
  }
  startParse() {
    return this.parser.startParse(new DocInput(this.state.doc), this.fragments);
  }
  /**
  @internal
  */
  work(until, upto) {
    if (upto != null && upto >= this.state.doc.length)
      upto = void 0;
    if (this.tree != Tree.empty && this.isDone(upto !== null && upto !== void 0 ? upto : this.state.doc.length)) {
      this.takeTree();
      return true;
    }
    return this.withContext(() => {
      var _a4;
      if (typeof until == "number") {
        let endTime = Date.now() + until;
        until = () => Date.now() > endTime;
      }
      if (!this.parse)
        this.parse = this.startParse();
      if (upto != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > upto) && upto < this.state.doc.length)
        this.parse.stopAt(upto);
      for (; ; ) {
        let done = this.parse.advance();
        if (done) {
          this.fragments = this.withoutTempSkipped(TreeFragment.addTree(done, this.fragments, this.parse.stoppedAt != null));
          this.treeLen = (_a4 = this.parse.stoppedAt) !== null && _a4 !== void 0 ? _a4 : this.state.doc.length;
          this.tree = done;
          this.parse = null;
          if (this.treeLen < (upto !== null && upto !== void 0 ? upto : this.state.doc.length))
            this.parse = this.startParse();
          else
            return true;
        }
        if (until())
          return false;
      }
    });
  }
  /**
  @internal
  */
  takeTree() {
    let pos, tree;
    if (this.parse && (pos = this.parse.parsedPos) >= this.treeLen) {
      if (this.parse.stoppedAt == null || this.parse.stoppedAt > pos)
        this.parse.stopAt(pos);
      this.withContext(() => {
        while (!(tree = this.parse.advance())) {
        }
      });
      this.treeLen = pos;
      this.tree = tree;
      this.fragments = this.withoutTempSkipped(TreeFragment.addTree(this.tree, this.fragments, true));
      this.parse = null;
    }
  }
  withContext(f) {
    let prev = currentContext;
    currentContext = this;
    try {
      return f();
    } finally {
      currentContext = prev;
    }
  }
  withoutTempSkipped(fragments) {
    for (let r2; r2 = this.tempSkipped.pop(); )
      fragments = cutFragments(fragments, r2.from, r2.to);
    return fragments;
  }
  /**
  @internal
  */
  changes(changes, newState) {
    let { fragments, tree, treeLen, viewport, skipped } = this;
    this.takeTree();
    if (!changes.empty) {
      let ranges = [];
      changes.iterChangedRanges((fromA, toA, fromB, toB) => ranges.push({ fromA, toA, fromB, toB }));
      fragments = TreeFragment.applyChanges(fragments, ranges);
      tree = Tree.empty;
      treeLen = 0;
      viewport = { from: changes.mapPos(viewport.from, -1), to: changes.mapPos(viewport.to, 1) };
      if (this.skipped.length) {
        skipped = [];
        for (let r2 of this.skipped) {
          let from = changes.mapPos(r2.from, 1), to3 = changes.mapPos(r2.to, -1);
          if (from < to3)
            skipped.push({ from, to: to3 });
        }
      }
    }
    return new _ParseContext(this.parser, newState, fragments, tree, treeLen, viewport, skipped, this.scheduleOn);
  }
  /**
  @internal
  */
  updateViewport(viewport) {
    if (this.viewport.from == viewport.from && this.viewport.to == viewport.to)
      return false;
    this.viewport = viewport;
    let startLen = this.skipped.length;
    for (let i2 = 0; i2 < this.skipped.length; i2++) {
      let { from, to: to3 } = this.skipped[i2];
      if (from < viewport.to && to3 > viewport.from) {
        this.fragments = cutFragments(this.fragments, from, to3);
        this.skipped.splice(i2--, 1);
      }
    }
    if (this.skipped.length >= startLen)
      return false;
    this.reset();
    return true;
  }
  /**
  @internal
  */
  reset() {
    if (this.parse) {
      this.takeTree();
      this.parse = null;
    }
  }
  /**
  Notify the parse scheduler that the given region was skipped
  because it wasn't in view, and the parse should be restarted
  when it comes into view.
  */
  skipUntilInView(from, to3) {
    this.skipped.push({ from, to: to3 });
  }
  /**
  Returns a parser intended to be used as placeholder when
  asynchronously loading a nested parser. It'll skip its input and
  mark it as not-really-parsed, so that the next update will parse
  it again.
  
  When `until` is given, a reparse will be scheduled when that
  promise resolves.
  */
  static getSkippingParser(until) {
    return new class extends Parser {
      createParse(input, fragments, ranges) {
        let from = ranges[0].from, to3 = ranges[ranges.length - 1].to;
        let parser2 = {
          parsedPos: from,
          advance() {
            let cx2 = currentContext;
            if (cx2) {
              for (let r2 of ranges)
                cx2.tempSkipped.push(r2);
              if (until)
                cx2.scheduleOn = cx2.scheduleOn ? Promise.all([cx2.scheduleOn, until]) : until;
            }
            this.parsedPos = to3;
            return new Tree(NodeType.none, [], [], to3 - from);
          },
          stoppedAt: null,
          stopAt() {
          }
        };
        return parser2;
      }
    }();
  }
  /**
  @internal
  */
  isDone(upto) {
    upto = Math.min(upto, this.state.doc.length);
    let frags = this.fragments;
    return this.treeLen >= upto && frags.length && frags[0].from == 0 && frags[0].to >= upto;
  }
  /**
  Get the context for the current parse, or `null` if no editor
  parse is in progress.
  */
  static get() {
    return currentContext;
  }
};
function cutFragments(fragments, from, to3) {
  return TreeFragment.applyChanges(fragments, [{ fromA: from, toA: to3, fromB: from, toB: to3 }]);
}
var LanguageState = class _LanguageState {
  constructor(context) {
    this.context = context;
    this.tree = context.tree;
  }
  apply(tr3) {
    if (!tr3.docChanged && this.tree == this.context.tree)
      return this;
    let newCx = this.context.changes(tr3.changes, tr3.state);
    let upto = this.context.treeLen == tr3.startState.doc.length ? void 0 : Math.max(tr3.changes.mapPos(this.context.treeLen), newCx.viewport.to);
    if (!newCx.work(20, upto))
      newCx.takeTree();
    return new _LanguageState(newCx);
  }
  static init(state) {
    let vpTo = Math.min(3e3, state.doc.length);
    let parseState = ParseContext.create(state.facet(language).parser, state, { from: 0, to: vpTo });
    if (!parseState.work(20, vpTo))
      parseState.takeTree();
    return new _LanguageState(parseState);
  }
};
Language.state = StateField.define({
  create: LanguageState.init,
  update(value, tr3) {
    for (let e2 of tr3.effects)
      if (e2.is(Language.setState))
        return e2.value;
    if (tr3.startState.facet(language) != tr3.state.facet(language))
      return LanguageState.init(tr3.state);
    return value.apply(tr3);
  }
});
var requestIdle = (callback) => {
  let timeout = setTimeout(
    () => callback(),
    500
    /* Work.MaxPause */
  );
  return () => clearTimeout(timeout);
};
if (typeof requestIdleCallback != "undefined")
  requestIdle = (callback) => {
    let idle = -1, timeout = setTimeout(
      () => {
        idle = requestIdleCallback(callback, {
          timeout: 500 - 100
          /* Work.MinPause */
        });
      },
      100
      /* Work.MinPause */
    );
    return () => idle < 0 ? clearTimeout(timeout) : cancelIdleCallback(idle);
  };
var isInputPending = typeof navigator != "undefined" && ((_a = navigator.scheduling) === null || _a === void 0 ? void 0 : _a.isInputPending) ? () => navigator.scheduling.isInputPending() : null;
var parseWorker = ViewPlugin.fromClass(class ParseWorker {
  constructor(view) {
    this.view = view;
    this.working = null;
    this.workScheduled = 0;
    this.chunkEnd = -1;
    this.chunkBudget = -1;
    this.work = this.work.bind(this);
    this.scheduleWork();
  }
  update(update) {
    let cx2 = this.view.state.field(Language.state).context;
    if (cx2.updateViewport(update.view.viewport) || this.view.viewport.to > cx2.treeLen)
      this.scheduleWork();
    if (update.docChanged || update.selectionSet) {
      if (this.view.hasFocus)
        this.chunkBudget += 50;
      this.scheduleWork();
    }
    this.checkAsyncSchedule(cx2);
  }
  scheduleWork() {
    if (this.working)
      return;
    let { state } = this.view, field = state.field(Language.state);
    if (field.tree != field.context.tree || !field.context.isDone(state.doc.length))
      this.working = requestIdle(this.work);
  }
  work(deadline) {
    this.working = null;
    let now = Date.now();
    if (this.chunkEnd < now && (this.chunkEnd < 0 || this.view.hasFocus)) {
      this.chunkEnd = now + 3e4;
      this.chunkBudget = 3e3;
    }
    if (this.chunkBudget <= 0)
      return;
    let { state, viewport: { to: vpTo } } = this.view, field = state.field(Language.state);
    if (field.tree == field.context.tree && field.context.isDone(
      vpTo + 1e5
      /* Work.MaxParseAhead */
    ))
      return;
    let endTime = Date.now() + Math.min(this.chunkBudget, 100, deadline && !isInputPending ? Math.max(25, deadline.timeRemaining() - 5) : 1e9);
    let viewportFirst = field.context.treeLen < vpTo && state.doc.length > vpTo + 1e3;
    let done = field.context.work(() => {
      return isInputPending && isInputPending() || Date.now() > endTime;
    }, vpTo + (viewportFirst ? 0 : 1e5));
    this.chunkBudget -= Date.now() - now;
    if (done || this.chunkBudget <= 0) {
      field.context.takeTree();
      this.view.dispatch({ effects: Language.setState.of(new LanguageState(field.context)) });
    }
    if (this.chunkBudget > 0 && !(done && !viewportFirst))
      this.scheduleWork();
    this.checkAsyncSchedule(field.context);
  }
  checkAsyncSchedule(cx2) {
    if (cx2.scheduleOn) {
      this.workScheduled++;
      cx2.scheduleOn.then(() => this.scheduleWork()).catch((err) => logException(this.view.state, err)).then(() => this.workScheduled--);
      cx2.scheduleOn = null;
    }
  }
  destroy() {
    if (this.working)
      this.working();
  }
  isWorking() {
    return !!(this.working || this.workScheduled > 0);
  }
}, {
  eventHandlers: { focus() {
    this.scheduleWork();
  } }
});
var language = Facet.define({
  combine(languages) {
    return languages.length ? languages[0] : null;
  },
  enables: (language2) => [
    Language.state,
    parseWorker,
    EditorView.contentAttributes.compute([language2], (state) => {
      let lang = state.facet(language2);
      return lang && lang.name ? { "data-language": lang.name } : {};
    })
  ]
});
var LanguageSupport = class {
  /**
  Create a language support object.
  */
  constructor(language2, support = []) {
    this.language = language2;
    this.support = support;
    this.extension = [language2, support];
  }
};
var indentService = Facet.define();
var indentUnit = Facet.define({
  combine: (values) => {
    if (!values.length)
      return "  ";
    let unit = values[0];
    if (!unit || /\S/.test(unit) || Array.from(unit).some((e2) => e2 != unit[0]))
      throw new Error("Invalid indent unit: " + JSON.stringify(values[0]));
    return unit;
  }
});
function getIndentUnit(state) {
  let unit = state.facet(indentUnit);
  return unit.charCodeAt(0) == 9 ? state.tabSize * unit.length : unit.length;
}
function indentString(state, cols) {
  let result = "", ts2 = state.tabSize, ch2 = state.facet(indentUnit)[0];
  if (ch2 == "	") {
    while (cols >= ts2) {
      result += "	";
      cols -= ts2;
    }
    ch2 = " ";
  }
  for (let i2 = 0; i2 < cols; i2++)
    result += ch2;
  return result;
}
function getIndentation(context, pos) {
  if (context instanceof EditorState)
    context = new IndentContext(context);
  for (let service of context.state.facet(indentService)) {
    let result = service(context, pos);
    if (result !== void 0)
      return result;
  }
  let tree = syntaxTree(context.state);
  return tree.length >= pos ? syntaxIndentation(context, tree, pos) : null;
}
var IndentContext = class {
  /**
  Create an indent context.
  */
  constructor(state, options = {}) {
    this.state = state;
    this.options = options;
    this.unit = getIndentUnit(state);
  }
  /**
  Get a description of the line at the given position, taking
  [simulated line
  breaks](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  into account. If there is such a break at `pos`, the `bias`
  argument determines whether the part of the line line before or
  after the break is used.
  */
  lineAt(pos, bias = 1) {
    let line = this.state.doc.lineAt(pos);
    let { simulateBreak, simulateDoubleBreak } = this.options;
    if (simulateBreak != null && simulateBreak >= line.from && simulateBreak <= line.to) {
      if (simulateDoubleBreak && simulateBreak == pos)
        return { text: "", from: pos };
      else if (bias < 0 ? simulateBreak < pos : simulateBreak <= pos)
        return { text: line.text.slice(simulateBreak - line.from), from: simulateBreak };
      else
        return { text: line.text.slice(0, simulateBreak - line.from), from: line.from };
    }
    return line;
  }
  /**
  Get the text directly after `pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  textAfterPos(pos, bias = 1) {
    if (this.options.simulateDoubleBreak && pos == this.options.simulateBreak)
      return "";
    let { text, from } = this.lineAt(pos, bias);
    return text.slice(pos - from, Math.min(text.length, pos + 100 - from));
  }
  /**
  Find the column for the given position.
  */
  column(pos, bias = 1) {
    let { text, from } = this.lineAt(pos, bias);
    let result = this.countColumn(text, pos - from);
    let override = this.options.overrideIndentation ? this.options.overrideIndentation(from) : -1;
    if (override > -1)
      result += override - this.countColumn(text, text.search(/\S|$/));
    return result;
  }
  /**
  Find the column position (taking tabs into account) of the given
  position in the given string.
  */
  countColumn(line, pos = line.length) {
    return countColumn(line, this.state.tabSize, pos);
  }
  /**
  Find the indentation column of the line at the given point.
  */
  lineIndent(pos, bias = 1) {
    let { text, from } = this.lineAt(pos, bias);
    let override = this.options.overrideIndentation;
    if (override) {
      let overriden = override(from);
      if (overriden > -1)
        return overriden;
    }
    return this.countColumn(text, text.search(/\S|$/));
  }
  /**
  Returns the [simulated line
  break](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  for this context, if any.
  */
  get simulatedBreak() {
    return this.options.simulateBreak || null;
  }
};
var indentNodeProp = new NodeProp();
function syntaxIndentation(cx2, ast, pos) {
  let stack = ast.resolveStack(pos);
  let inner = stack.node.enterUnfinishedNodesBefore(pos);
  if (inner != stack.node) {
    let add3 = [];
    for (let cur2 = inner; cur2 != stack.node; cur2 = cur2.parent)
      add3.push(cur2);
    for (let i2 = add3.length - 1; i2 >= 0; i2--)
      stack = { node: add3[i2], next: stack };
  }
  return indentFor(stack, cx2, pos);
}
function indentFor(stack, cx2, pos) {
  for (let cur2 = stack; cur2; cur2 = cur2.next) {
    let strategy = indentStrategy(cur2.node);
    if (strategy)
      return strategy(TreeIndentContext.create(cx2, pos, cur2));
  }
  return 0;
}
function ignoreClosed(cx2) {
  return cx2.pos == cx2.options.simulateBreak && cx2.options.simulateDoubleBreak;
}
function indentStrategy(tree) {
  let strategy = tree.type.prop(indentNodeProp);
  if (strategy)
    return strategy;
  let first = tree.firstChild, close;
  if (first && (close = first.type.prop(NodeProp.closedBy))) {
    let last2 = tree.lastChild, closed = last2 && close.indexOf(last2.name) > -1;
    return (cx2) => delimitedStrategy(cx2, true, 1, void 0, closed && !ignoreClosed(cx2) ? last2.from : void 0);
  }
  return tree.parent == null ? topIndent : null;
}
function topIndent() {
  return 0;
}
var TreeIndentContext = class _TreeIndentContext extends IndentContext {
  constructor(base2, pos, context) {
    super(base2.state, base2.options);
    this.base = base2;
    this.pos = pos;
    this.context = context;
  }
  /**
  The syntax tree node to which the indentation strategy
  applies.
  */
  get node() {
    return this.context.node;
  }
  /**
  @internal
  */
  static create(base2, pos, context) {
    return new _TreeIndentContext(base2, pos, context);
  }
  /**
  Get the text directly after `this.pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  get textAfter() {
    return this.textAfterPos(this.pos);
  }
  /**
  Get the indentation at the reference line for `this.node`, which
  is the line on which it starts, unless there is a node that is
  _not_ a parent of this node covering the start of that line. If
  so, the line at the start of that node is tried, again skipping
  on if it is covered by another such node.
  */
  get baseIndent() {
    return this.baseIndentFor(this.node);
  }
  /**
  Get the indentation for the reference line of the given node
  (see [`baseIndent`](https://codemirror.net/6/docs/ref/#language.TreeIndentContext.baseIndent)).
  */
  baseIndentFor(node) {
    let line = this.state.doc.lineAt(node.from);
    for (; ; ) {
      let atBreak = node.resolve(line.from);
      while (atBreak.parent && atBreak.parent.from == atBreak.from)
        atBreak = atBreak.parent;
      if (isParent(atBreak, node))
        break;
      line = this.state.doc.lineAt(atBreak.from);
    }
    return this.lineIndent(line.from);
  }
  /**
  Continue looking for indentations in the node's parent nodes,
  and return the result of that.
  */
  continue() {
    return indentFor(this.context.next, this.base, this.pos);
  }
};
function isParent(parent, of2) {
  for (let cur2 = of2; cur2; cur2 = cur2.parent)
    if (parent == cur2)
      return true;
  return false;
}
function bracketedAligned(context) {
  let tree = context.node;
  let openToken = tree.childAfter(tree.from), last2 = tree.lastChild;
  if (!openToken)
    return null;
  let sim = context.options.simulateBreak;
  let openLine = context.state.doc.lineAt(openToken.from);
  let lineEnd = sim == null || sim <= openLine.from ? openLine.to : Math.min(openLine.to, sim);
  for (let pos = openToken.to; ; ) {
    let next = tree.childAfter(pos);
    if (!next || next == last2)
      return null;
    if (!next.type.isSkipped) {
      if (next.from >= lineEnd)
        return null;
      let space = /^ */.exec(openLine.text.slice(openToken.to - openLine.from))[0].length;
      return { from: openToken.from, to: openToken.to + space };
    }
    pos = next.to;
  }
}
function delimitedStrategy(context, align, units, closing2, closedAt) {
  let after = context.textAfter, space = after.match(/^\s*/)[0].length;
  let closed = closing2 && after.slice(space, space + closing2.length) == closing2 || closedAt == context.pos + space;
  let aligned = align ? bracketedAligned(context) : null;
  if (aligned)
    return closed ? context.column(aligned.from) : context.column(aligned.to);
  return context.baseIndent + (closed ? 0 : context.unit * units);
}
function continuedIndent({ except, units = 1 } = {}) {
  return (context) => {
    let matchExcept = except && except.test(context.textAfter);
    return context.baseIndent + (matchExcept ? 0 : units * context.unit);
  };
}
var DontIndentBeyond = 200;
function indentOnInput() {
  return EditorState.transactionFilter.of((tr3) => {
    if (!tr3.docChanged || !tr3.isUserEvent("input.type") && !tr3.isUserEvent("input.complete"))
      return tr3;
    let rules = tr3.startState.languageDataAt("indentOnInput", tr3.startState.selection.main.head);
    if (!rules.length)
      return tr3;
    let doc2 = tr3.newDoc, { head } = tr3.newSelection.main, line = doc2.lineAt(head);
    if (head > line.from + DontIndentBeyond)
      return tr3;
    let lineStart = doc2.sliceString(line.from, head);
    if (!rules.some((r2) => r2.test(lineStart)))
      return tr3;
    let { state } = tr3, last2 = -1, changes = [];
    for (let { head: head2 } of state.selection.ranges) {
      let line2 = state.doc.lineAt(head2);
      if (line2.from == last2)
        continue;
      last2 = line2.from;
      let indent = getIndentation(state, line2.from);
      if (indent == null)
        continue;
      let cur2 = /^\s*/.exec(line2.text)[0];
      let norm = indentString(state, indent);
      if (cur2 != norm)
        changes.push({ from: line2.from, to: line2.from + cur2.length, insert: norm });
    }
    return changes.length ? [tr3, { changes, sequential: true }] : tr3;
  });
}
var foldService = Facet.define();
var foldNodeProp = new NodeProp();
function foldInside(node) {
  let first = node.firstChild, last2 = node.lastChild;
  return first && first.to < last2.from ? { from: first.to, to: last2.type.isError ? node.to : last2.from } : null;
}
function syntaxFolding(state, start, end) {
  let tree = syntaxTree(state);
  if (tree.length < end)
    return null;
  let stack = tree.resolveStack(end, 1);
  let found = null;
  for (let iter = stack; iter; iter = iter.next) {
    let cur2 = iter.node;
    if (cur2.to <= end || cur2.from > end)
      continue;
    if (found && cur2.from < start)
      break;
    let prop = cur2.type.prop(foldNodeProp);
    if (prop && (cur2.to < tree.length - 50 || tree.length == state.doc.length || !isUnfinished(cur2))) {
      let value = prop(cur2, state);
      if (value && value.from <= end && value.from >= start && value.to > end)
        found = value;
    }
  }
  return found;
}
function isUnfinished(node) {
  let ch2 = node.lastChild;
  return ch2 && ch2.to == node.to && ch2.type.isError;
}
function foldable(state, lineStart, lineEnd) {
  for (let service of state.facet(foldService)) {
    let result = service(state, lineStart, lineEnd);
    if (result)
      return result;
  }
  return syntaxFolding(state, lineStart, lineEnd);
}
function mapRange(range, mapping) {
  let from = mapping.mapPos(range.from, 1), to3 = mapping.mapPos(range.to, -1);
  return from >= to3 ? void 0 : { from, to: to3 };
}
var foldEffect = StateEffect.define({ map: mapRange });
var unfoldEffect = StateEffect.define({ map: mapRange });
function selectedLines(view) {
  let lines = [];
  for (let { head } of view.state.selection.ranges) {
    if (lines.some((l) => l.from <= head && l.to >= head))
      continue;
    lines.push(view.lineBlockAt(head));
  }
  return lines;
}
var foldState = StateField.define({
  create() {
    return Decoration.none;
  },
  update(folded, tr3) {
    folded = folded.map(tr3.changes);
    for (let e2 of tr3.effects) {
      if (e2.is(foldEffect) && !foldExists(folded, e2.value.from, e2.value.to)) {
        let { preparePlaceholder } = tr3.state.facet(foldConfig);
        let widget = !preparePlaceholder ? foldWidget : Decoration.replace({ widget: new PreparedFoldWidget(preparePlaceholder(tr3.state, e2.value)) });
        folded = folded.update({ add: [widget.range(e2.value.from, e2.value.to)] });
      } else if (e2.is(unfoldEffect)) {
        folded = folded.update({
          filter: (from, to3) => e2.value.from != from || e2.value.to != to3,
          filterFrom: e2.value.from,
          filterTo: e2.value.to
        });
      }
    }
    if (tr3.selection) {
      let onSelection = false, { head } = tr3.selection.main;
      folded.between(head, head, (a2, b2) => {
        if (a2 < head && b2 > head)
          onSelection = true;
      });
      if (onSelection)
        folded = folded.update({
          filterFrom: head,
          filterTo: head,
          filter: (a2, b2) => b2 <= head || a2 >= head
        });
    }
    return folded;
  },
  provide: (f) => EditorView.decorations.from(f),
  toJSON(folded, state) {
    let ranges = [];
    folded.between(0, state.doc.length, (from, to3) => {
      ranges.push(from, to3);
    });
    return ranges;
  },
  fromJSON(value) {
    if (!Array.isArray(value) || value.length % 2)
      throw new RangeError("Invalid JSON for fold state");
    let ranges = [];
    for (let i2 = 0; i2 < value.length; ) {
      let from = value[i2++], to3 = value[i2++];
      if (typeof from != "number" || typeof to3 != "number")
        throw new RangeError("Invalid JSON for fold state");
      ranges.push(foldWidget.range(from, to3));
    }
    return Decoration.set(ranges, true);
  }
});
function findFold(state, from, to3) {
  var _a4;
  let found = null;
  (_a4 = state.field(foldState, false)) === null || _a4 === void 0 ? void 0 : _a4.between(from, to3, (from2, to4) => {
    if (!found || found.from > from2)
      found = { from: from2, to: to4 };
  });
  return found;
}
function foldExists(folded, from, to3) {
  let found = false;
  folded.between(from, from, (a2, b2) => {
    if (a2 == from && b2 == to3)
      found = true;
  });
  return found;
}
function maybeEnable(state, other) {
  return state.field(foldState, false) ? other : other.concat(StateEffect.appendConfig.of(codeFolding()));
}
var foldCode = (view) => {
  for (let line of selectedLines(view)) {
    let range = foldable(view.state, line.from, line.to);
    if (range) {
      view.dispatch({ effects: maybeEnable(view.state, [foldEffect.of(range), announceFold(view, range)]) });
      return true;
    }
  }
  return false;
};
var unfoldCode = (view) => {
  if (!view.state.field(foldState, false))
    return false;
  let effects = [];
  for (let line of selectedLines(view)) {
    let folded = findFold(view.state, line.from, line.to);
    if (folded)
      effects.push(unfoldEffect.of(folded), announceFold(view, folded, false));
  }
  if (effects.length)
    view.dispatch({ effects });
  return effects.length > 0;
};
function announceFold(view, range, fold = true) {
  let lineFrom = view.state.doc.lineAt(range.from).number, lineTo = view.state.doc.lineAt(range.to).number;
  return EditorView.announce.of(`${view.state.phrase(fold ? "Folded lines" : "Unfolded lines")} ${lineFrom} ${view.state.phrase("to")} ${lineTo}.`);
}
var foldAll = (view) => {
  let { state } = view, effects = [];
  for (let pos = 0; pos < state.doc.length; ) {
    let line = view.lineBlockAt(pos), range = foldable(state, line.from, line.to);
    if (range)
      effects.push(foldEffect.of(range));
    pos = (range ? view.lineBlockAt(range.to) : line).to + 1;
  }
  if (effects.length)
    view.dispatch({ effects: maybeEnable(view.state, effects) });
  return !!effects.length;
};
var unfoldAll = (view) => {
  let field = view.state.field(foldState, false);
  if (!field || !field.size)
    return false;
  let effects = [];
  field.between(0, view.state.doc.length, (from, to3) => {
    effects.push(unfoldEffect.of({ from, to: to3 }));
  });
  view.dispatch({ effects });
  return true;
};
var foldKeymap = [
  { key: "Ctrl-Shift-[", mac: "Cmd-Alt-[", run: foldCode },
  { key: "Ctrl-Shift-]", mac: "Cmd-Alt-]", run: unfoldCode },
  { key: "Ctrl-Alt-[", run: foldAll },
  { key: "Ctrl-Alt-]", run: unfoldAll }
];
var defaultConfig = {
  placeholderDOM: null,
  preparePlaceholder: null,
  placeholderText: "…"
};
var foldConfig = Facet.define({
  combine(values) {
    return combineConfig(values, defaultConfig);
  }
});
function codeFolding(config2) {
  let result = [foldState, baseTheme$12];
  if (config2)
    result.push(foldConfig.of(config2));
  return result;
}
function widgetToDOM(view, prepared) {
  let { state } = view, conf = state.facet(foldConfig);
  let onclick = (event) => {
    let line = view.lineBlockAt(view.posAtDOM(event.target));
    let folded = findFold(view.state, line.from, line.to);
    if (folded)
      view.dispatch({ effects: unfoldEffect.of(folded) });
    event.preventDefault();
  };
  if (conf.placeholderDOM)
    return conf.placeholderDOM(view, onclick, prepared);
  let element = document.createElement("span");
  element.textContent = conf.placeholderText;
  element.setAttribute("aria-label", state.phrase("folded code"));
  element.title = state.phrase("unfold");
  element.className = "cm-foldPlaceholder";
  element.onclick = onclick;
  return element;
}
var foldWidget = Decoration.replace({ widget: new class extends WidgetType {
  toDOM(view) {
    return widgetToDOM(view, null);
  }
}() });
var PreparedFoldWidget = class extends WidgetType {
  constructor(value) {
    super();
    this.value = value;
  }
  eq(other) {
    return this.value == other.value;
  }
  toDOM(view) {
    return widgetToDOM(view, this.value);
  }
};
var foldGutterDefaults = {
  openText: "⌄",
  closedText: "›",
  markerDOM: null,
  domEventHandlers: {},
  foldingChanged: () => false
};
var FoldMarker = class extends GutterMarker {
  constructor(config2, open) {
    super();
    this.config = config2;
    this.open = open;
  }
  eq(other) {
    return this.config == other.config && this.open == other.open;
  }
  toDOM(view) {
    if (this.config.markerDOM)
      return this.config.markerDOM(this.open);
    let span = document.createElement("span");
    span.textContent = this.open ? this.config.openText : this.config.closedText;
    span.title = view.state.phrase(this.open ? "Fold line" : "Unfold line");
    return span;
  }
};
function foldGutter(config2 = {}) {
  let fullConfig = Object.assign(Object.assign({}, foldGutterDefaults), config2);
  let canFold = new FoldMarker(fullConfig, true), canUnfold = new FoldMarker(fullConfig, false);
  let markers = ViewPlugin.fromClass(class {
    constructor(view) {
      this.from = view.viewport.from;
      this.markers = this.buildMarkers(view);
    }
    update(update) {
      if (update.docChanged || update.viewportChanged || update.startState.facet(language) != update.state.facet(language) || update.startState.field(foldState, false) != update.state.field(foldState, false) || syntaxTree(update.startState) != syntaxTree(update.state) || fullConfig.foldingChanged(update))
        this.markers = this.buildMarkers(update.view);
    }
    buildMarkers(view) {
      let builder = new RangeSetBuilder();
      for (let line of view.viewportLineBlocks) {
        let mark = findFold(view.state, line.from, line.to) ? canUnfold : foldable(view.state, line.from, line.to) ? canFold : null;
        if (mark)
          builder.add(line.from, line.from, mark);
      }
      return builder.finish();
    }
  });
  let { domEventHandlers } = fullConfig;
  return [
    markers,
    gutter({
      class: "cm-foldGutter",
      markers(view) {
        var _a4;
        return ((_a4 = view.plugin(markers)) === null || _a4 === void 0 ? void 0 : _a4.markers) || RangeSet.empty;
      },
      initialSpacer() {
        return new FoldMarker(fullConfig, false);
      },
      domEventHandlers: Object.assign(Object.assign({}, domEventHandlers), { click: (view, line, event) => {
        if (domEventHandlers.click && domEventHandlers.click(view, line, event))
          return true;
        let folded = findFold(view.state, line.from, line.to);
        if (folded) {
          view.dispatch({ effects: unfoldEffect.of(folded) });
          return true;
        }
        let range = foldable(view.state, line.from, line.to);
        if (range) {
          view.dispatch({ effects: foldEffect.of(range) });
          return true;
        }
        return false;
      } })
    }),
    codeFolding()
  ];
}
var baseTheme$12 = EditorView.baseTheme({
  ".cm-foldPlaceholder": {
    backgroundColor: "#eee",
    border: "1px solid #ddd",
    color: "#888",
    borderRadius: ".2em",
    margin: "0 1px",
    padding: "0 1px",
    cursor: "pointer"
  },
  ".cm-foldGutter span": {
    padding: "0 1px",
    cursor: "pointer"
  }
});
var HighlightStyle = class _HighlightStyle {
  constructor(specs, options) {
    this.specs = specs;
    let modSpec;
    function def(spec) {
      let cls = StyleModule.newName();
      (modSpec || (modSpec = /* @__PURE__ */ Object.create(null)))["." + cls] = spec;
      return cls;
    }
    const all = typeof options.all == "string" ? options.all : options.all ? def(options.all) : void 0;
    const scopeOpt = options.scope;
    this.scope = scopeOpt instanceof Language ? (type) => type.prop(languageDataProp) == scopeOpt.data : scopeOpt ? (type) => type == scopeOpt : void 0;
    this.style = tagHighlighter(specs.map((style) => ({
      tag: style.tag,
      class: style.class || def(Object.assign({}, style, { tag: null }))
    })), {
      all
    }).style;
    this.module = modSpec ? new StyleModule(modSpec) : null;
    this.themeType = options.themeType;
  }
  /**
  Create a highlighter style that associates the given styles to
  the given tags. The specs must be objects that hold a style tag
  or array of tags in their `tag` property, and either a single
  `class` property providing a static CSS class (for highlighter
  that rely on external styling), or a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)-style
  set of CSS properties (which define the styling for those tags).
  
  The CSS rules created for a highlighter will be emitted in the
  order of the spec's properties. That means that for elements that
  have multiple tags associated with them, styles defined further
  down in the list will have a higher CSS precedence than styles
  defined earlier.
  */
  static define(specs, options) {
    return new _HighlightStyle(specs, options || {});
  }
};
var highlighterFacet = Facet.define();
var fallbackHighlighter = Facet.define({
  combine(values) {
    return values.length ? [values[0]] : null;
  }
});
function getHighlighters(state) {
  let main = state.facet(highlighterFacet);
  return main.length ? main : state.facet(fallbackHighlighter);
}
function syntaxHighlighting(highlighter, options) {
  let ext = [treeHighlighter], themeType;
  if (highlighter instanceof HighlightStyle) {
    if (highlighter.module)
      ext.push(EditorView.styleModule.of(highlighter.module));
    themeType = highlighter.themeType;
  }
  if (options === null || options === void 0 ? void 0 : options.fallback)
    ext.push(fallbackHighlighter.of(highlighter));
  else if (themeType)
    ext.push(highlighterFacet.computeN([EditorView.darkTheme], (state) => {
      return state.facet(EditorView.darkTheme) == (themeType == "dark") ? [highlighter] : [];
    }));
  else
    ext.push(highlighterFacet.of(highlighter));
  return ext;
}
var TreeHighlighter = class {
  constructor(view) {
    this.markCache = /* @__PURE__ */ Object.create(null);
    this.tree = syntaxTree(view.state);
    this.decorations = this.buildDeco(view, getHighlighters(view.state));
    this.decoratedTo = view.viewport.to;
  }
  update(update) {
    let tree = syntaxTree(update.state), highlighters = getHighlighters(update.state);
    let styleChange = highlighters != getHighlighters(update.startState);
    let { viewport } = update.view, decoratedToMapped = update.changes.mapPos(this.decoratedTo, 1);
    if (tree.length < viewport.to && !styleChange && tree.type == this.tree.type && decoratedToMapped >= viewport.to) {
      this.decorations = this.decorations.map(update.changes);
      this.decoratedTo = decoratedToMapped;
    } else if (tree != this.tree || update.viewportChanged || styleChange) {
      this.tree = tree;
      this.decorations = this.buildDeco(update.view, highlighters);
      this.decoratedTo = viewport.to;
    }
  }
  buildDeco(view, highlighters) {
    if (!highlighters || !this.tree.length)
      return Decoration.none;
    let builder = new RangeSetBuilder();
    for (let { from, to: to3 } of view.visibleRanges) {
      highlightTree(this.tree, highlighters, (from2, to4, style) => {
        builder.add(from2, to4, this.markCache[style] || (this.markCache[style] = Decoration.mark({ class: style })));
      }, from, to3);
    }
    return builder.finish();
  }
};
var treeHighlighter = Prec.high(ViewPlugin.fromClass(TreeHighlighter, {
  decorations: (v) => v.decorations
}));
var defaultHighlightStyle = HighlightStyle.define([
  {
    tag: tags.meta,
    color: "#404740"
  },
  {
    tag: tags.link,
    textDecoration: "underline"
  },
  {
    tag: tags.heading,
    textDecoration: "underline",
    fontWeight: "bold"
  },
  {
    tag: tags.emphasis,
    fontStyle: "italic"
  },
  {
    tag: tags.strong,
    fontWeight: "bold"
  },
  {
    tag: tags.strikethrough,
    textDecoration: "line-through"
  },
  {
    tag: tags.keyword,
    color: "#708"
  },
  {
    tag: [tags.atom, tags.bool, tags.url, tags.contentSeparator, tags.labelName],
    color: "#219"
  },
  {
    tag: [tags.literal, tags.inserted],
    color: "#164"
  },
  {
    tag: [tags.string, tags.deleted],
    color: "#a11"
  },
  {
    tag: [tags.regexp, tags.escape, tags.special(tags.string)],
    color: "#e40"
  },
  {
    tag: tags.definition(tags.variableName),
    color: "#00f"
  },
  {
    tag: tags.local(tags.variableName),
    color: "#30a"
  },
  {
    tag: [tags.typeName, tags.namespace],
    color: "#085"
  },
  {
    tag: tags.className,
    color: "#167"
  },
  {
    tag: [tags.special(tags.variableName), tags.macroName],
    color: "#256"
  },
  {
    tag: tags.definition(tags.propertyName),
    color: "#00c"
  },
  {
    tag: tags.comment,
    color: "#940"
  },
  {
    tag: tags.invalid,
    color: "#f00"
  }
]);
var baseTheme2 = EditorView.baseTheme({
  "&.cm-focused .cm-matchingBracket": { backgroundColor: "#328c8252" },
  "&.cm-focused .cm-nonmatchingBracket": { backgroundColor: "#bb555544" }
});
var DefaultScanDist = 1e4;
var DefaultBrackets = "()[]{}";
var bracketMatchingConfig = Facet.define({
  combine(configs) {
    return combineConfig(configs, {
      afterCursor: true,
      brackets: DefaultBrackets,
      maxScanDistance: DefaultScanDist,
      renderMatch: defaultRenderMatch
    });
  }
});
var matchingMark = Decoration.mark({ class: "cm-matchingBracket" });
var nonmatchingMark = Decoration.mark({ class: "cm-nonmatchingBracket" });
function defaultRenderMatch(match) {
  let decorations2 = [];
  let mark = match.matched ? matchingMark : nonmatchingMark;
  decorations2.push(mark.range(match.start.from, match.start.to));
  if (match.end)
    decorations2.push(mark.range(match.end.from, match.end.to));
  return decorations2;
}
var bracketMatchingState = StateField.define({
  create() {
    return Decoration.none;
  },
  update(deco, tr3) {
    if (!tr3.docChanged && !tr3.selection)
      return deco;
    let decorations2 = [];
    let config2 = tr3.state.facet(bracketMatchingConfig);
    for (let range of tr3.state.selection.ranges) {
      if (!range.empty)
        continue;
      let match = matchBrackets(tr3.state, range.head, -1, config2) || range.head > 0 && matchBrackets(tr3.state, range.head - 1, 1, config2) || config2.afterCursor && (matchBrackets(tr3.state, range.head, 1, config2) || range.head < tr3.state.doc.length && matchBrackets(tr3.state, range.head + 1, -1, config2));
      if (match)
        decorations2 = decorations2.concat(config2.renderMatch(match, tr3.state));
    }
    return Decoration.set(decorations2, true);
  },
  provide: (f) => EditorView.decorations.from(f)
});
var bracketMatchingUnique = [
  bracketMatchingState,
  baseTheme2
];
function bracketMatching(config2 = {}) {
  return [bracketMatchingConfig.of(config2), bracketMatchingUnique];
}
var bracketMatchingHandle = new NodeProp();
function matchingNodes(node, dir, brackets) {
  let byProp = node.prop(dir < 0 ? NodeProp.openedBy : NodeProp.closedBy);
  if (byProp)
    return byProp;
  if (node.name.length == 1) {
    let index2 = brackets.indexOf(node.name);
    if (index2 > -1 && index2 % 2 == (dir < 0 ? 1 : 0))
      return [brackets[index2 + dir]];
  }
  return null;
}
function findHandle(node) {
  let hasHandle = node.type.prop(bracketMatchingHandle);
  return hasHandle ? hasHandle(node.node) : node;
}
function matchBrackets(state, pos, dir, config2 = {}) {
  let maxScanDistance = config2.maxScanDistance || DefaultScanDist, brackets = config2.brackets || DefaultBrackets;
  let tree = syntaxTree(state), node = tree.resolveInner(pos, dir);
  for (let cur2 = node; cur2; cur2 = cur2.parent) {
    let matches = matchingNodes(cur2.type, dir, brackets);
    if (matches && cur2.from < cur2.to) {
      let handle = findHandle(cur2);
      if (handle && (dir > 0 ? pos >= handle.from && pos < handle.to : pos > handle.from && pos <= handle.to))
        return matchMarkedBrackets(state, pos, dir, cur2, handle, matches, brackets);
    }
  }
  return matchPlainBrackets(state, pos, dir, tree, node.type, maxScanDistance, brackets);
}
function matchMarkedBrackets(_state, _pos, dir, token, handle, matching, brackets) {
  let parent = token.parent, firstToken = { from: handle.from, to: handle.to };
  let depth2 = 0, cursor = parent === null || parent === void 0 ? void 0 : parent.cursor();
  if (cursor && (dir < 0 ? cursor.childBefore(token.from) : cursor.childAfter(token.to)))
    do {
      if (dir < 0 ? cursor.to <= token.from : cursor.from >= token.to) {
        if (depth2 == 0 && matching.indexOf(cursor.type.name) > -1 && cursor.from < cursor.to) {
          let endHandle = findHandle(cursor);
          return { start: firstToken, end: endHandle ? { from: endHandle.from, to: endHandle.to } : void 0, matched: true };
        } else if (matchingNodes(cursor.type, dir, brackets)) {
          depth2++;
        } else if (matchingNodes(cursor.type, -dir, brackets)) {
          if (depth2 == 0) {
            let endHandle = findHandle(cursor);
            return {
              start: firstToken,
              end: endHandle && endHandle.from < endHandle.to ? { from: endHandle.from, to: endHandle.to } : void 0,
              matched: false
            };
          }
          depth2--;
        }
      }
    } while (dir < 0 ? cursor.prevSibling() : cursor.nextSibling());
  return { start: firstToken, matched: false };
}
function matchPlainBrackets(state, pos, dir, tree, tokenType, maxScanDistance, brackets) {
  let startCh = dir < 0 ? state.sliceDoc(pos - 1, pos) : state.sliceDoc(pos, pos + 1);
  let bracket2 = brackets.indexOf(startCh);
  if (bracket2 < 0 || bracket2 % 2 == 0 != dir > 0)
    return null;
  let startToken = { from: dir < 0 ? pos - 1 : pos, to: dir > 0 ? pos + 1 : pos };
  let iter = state.doc.iterRange(pos, dir > 0 ? state.doc.length : 0), depth2 = 0;
  for (let distance = 0; !iter.next().done && distance <= maxScanDistance; ) {
    let text = iter.value;
    if (dir < 0)
      distance += text.length;
    let basePos = pos + distance * dir;
    for (let pos2 = dir > 0 ? 0 : text.length - 1, end = dir > 0 ? text.length : -1; pos2 != end; pos2 += dir) {
      let found = brackets.indexOf(text[pos2]);
      if (found < 0 || tree.resolveInner(basePos + pos2, 1).type != tokenType)
        continue;
      if (found % 2 == 0 == dir > 0) {
        depth2++;
      } else if (depth2 == 1) {
        return { start: startToken, end: { from: basePos + pos2, to: basePos + pos2 + 1 }, matched: found >> 1 == bracket2 >> 1 };
      } else {
        depth2--;
      }
    }
    if (dir > 0)
      distance += text.length;
  }
  return iter.done ? { start: startToken, matched: false } : null;
}
var noTokens = /* @__PURE__ */ Object.create(null);
var typeArray = [NodeType.none];
var nodeSet = new NodeSet(typeArray);
var warned = [];
var byTag = /* @__PURE__ */ Object.create(null);
var defaultTable = /* @__PURE__ */ Object.create(null);
for (let [legacyName, name2] of [
  ["variable", "variableName"],
  ["variable-2", "variableName.special"],
  ["string-2", "string.special"],
  ["def", "variableName.definition"],
  ["tag", "tagName"],
  ["attribute", "attributeName"],
  ["type", "typeName"],
  ["builtin", "variableName.standard"],
  ["qualifier", "modifier"],
  ["error", "invalid"],
  ["header", "heading"],
  ["property", "propertyName"]
])
  defaultTable[legacyName] = createTokenType(noTokens, name2);
var TokenTable = class {
  constructor(extra) {
    this.extra = extra;
    this.table = Object.assign(/* @__PURE__ */ Object.create(null), defaultTable);
  }
  resolve(tag) {
    return !tag ? 0 : this.table[tag] || (this.table[tag] = createTokenType(this.extra, tag));
  }
};
var defaultTokenTable = new TokenTable(noTokens);
function warnForPart(part, msg) {
  if (warned.indexOf(part) > -1)
    return;
  warned.push(part);
  console.warn(msg);
}
function createTokenType(extra, tagStr) {
  let tags$1 = [];
  for (let name3 of tagStr.split(" ")) {
    let found = [];
    for (let part of name3.split(".")) {
      let value = extra[part] || tags[part];
      if (!value) {
        warnForPart(part, `Unknown highlighting tag ${part}`);
      } else if (typeof value == "function") {
        if (!found.length)
          warnForPart(part, `Modifier ${part} used at start of tag`);
        else
          found = found.map(value);
      } else {
        if (found.length)
          warnForPart(part, `Tag ${part} used as modifier`);
        else
          found = Array.isArray(value) ? value : [value];
      }
    }
    for (let tag of found)
      tags$1.push(tag);
  }
  if (!tags$1.length)
    return 0;
  let name2 = tagStr.replace(/ /g, "_"), key = name2 + " " + tags$1.map((t3) => t3.id);
  let known = byTag[key];
  if (known)
    return known.id;
  let type = byTag[key] = NodeType.define({
    id: typeArray.length,
    name: name2,
    props: [styleTags({ [name2]: tags$1 })]
  });
  typeArray.push(type);
  return type.id;
}
function buildForLine(line) {
  return line.length <= 4096 && /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/.test(line);
}
function textHasRTL(text) {
  for (let i2 = text.iter(); !i2.next().done; )
    if (buildForLine(i2.value))
      return true;
  return false;
}
function changeAddsRTL(change) {
  let added = false;
  change.iterChanges((fA, tA, fB, tB, ins) => {
    if (!added && textHasRTL(ins))
      added = true;
  });
  return added;
}
var alwaysIsolate = Facet.define({ combine: (values) => values.some((x) => x) });
var isolateMarks = ViewPlugin.fromClass(class {
  constructor(view) {
    this.always = view.state.facet(alwaysIsolate) || view.textDirection != Direction.LTR || view.state.facet(EditorView.perLineTextDirection);
    this.hasRTL = !this.always && textHasRTL(view.state.doc);
    this.tree = syntaxTree(view.state);
    this.decorations = this.always || this.hasRTL ? buildDeco(view, this.tree, this.always) : Decoration.none;
  }
  update(update) {
    let always = update.state.facet(alwaysIsolate) || update.view.textDirection != Direction.LTR || update.state.facet(EditorView.perLineTextDirection);
    if (!always && !this.hasRTL && changeAddsRTL(update.changes))
      this.hasRTL = true;
    if (!always && !this.hasRTL)
      return;
    let tree = syntaxTree(update.state);
    if (always != this.always || tree != this.tree || update.docChanged || update.viewportChanged) {
      this.tree = tree;
      this.always = always;
      this.decorations = buildDeco(update.view, tree, always);
    }
  }
}, {
  provide: (plugin3) => {
    function access(view) {
      var _a4, _b;
      return (_b = (_a4 = view.plugin(plugin3)) === null || _a4 === void 0 ? void 0 : _a4.decorations) !== null && _b !== void 0 ? _b : Decoration.none;
    }
    return [
      EditorView.outerDecorations.of(access),
      Prec.lowest(EditorView.bidiIsolatedRanges.of(access))
    ];
  }
});
function buildDeco(view, tree, always) {
  let deco = new RangeSetBuilder();
  let ranges = view.visibleRanges;
  if (!always)
    ranges = clipRTLLines(ranges, view.state.doc);
  for (let { from, to: to3 } of ranges) {
    tree.iterate({
      enter: (node) => {
        let iso = node.type.prop(NodeProp.isolate);
        if (iso)
          deco.add(node.from, node.to, marks[iso]);
      },
      from,
      to: to3
    });
  }
  return deco.finish();
}
function clipRTLLines(ranges, doc2) {
  let cur2 = doc2.iter(), pos = 0, result = [], last2 = null;
  for (let { from, to: to3 } of ranges) {
    if (last2 && last2.to > from) {
      from = last2.to;
      if (from >= to3)
        continue;
    }
    if (pos + cur2.value.length < from) {
      cur2.next(from - (pos + cur2.value.length));
      pos = from;
    }
    for (; ; ) {
      let start = pos, end = pos + cur2.value.length;
      if (!cur2.lineBreak && buildForLine(cur2.value)) {
        if (last2 && last2.to > start - 10)
          last2.to = Math.min(to3, end);
        else
          result.push(last2 = { from: start, to: Math.min(to3, end) });
      }
      if (end >= to3)
        break;
      pos = end;
      cur2.next();
    }
  }
  return result;
}
var marks = {
  rtl: Decoration.mark({ class: "cm-iso", inclusive: true, attributes: { dir: "rtl" }, bidiIsolate: Direction.RTL }),
  ltr: Decoration.mark({ class: "cm-iso", inclusive: true, attributes: { dir: "ltr" }, bidiIsolate: Direction.LTR }),
  auto: Decoration.mark({ class: "cm-iso", inclusive: true, attributes: { dir: "auto" }, bidiIsolate: null })
};

// node_modules/@codemirror/commands/dist/index.js
var toggleComment = (target) => {
  let { state } = target, line = state.doc.lineAt(state.selection.main.from), config2 = getConfig(target.state, line.from);
  return config2.line ? toggleLineComment(target) : config2.block ? toggleBlockCommentByLine(target) : false;
};
function command(f, option) {
  return ({ state, dispatch }) => {
    if (state.readOnly)
      return false;
    let tr3 = f(option, state);
    if (!tr3)
      return false;
    dispatch(state.update(tr3));
    return true;
  };
}
var toggleLineComment = command(
  changeLineComment,
  0
  /* CommentOption.Toggle */
);
var lineComment = command(
  changeLineComment,
  1
  /* CommentOption.Comment */
);
var lineUncomment = command(
  changeLineComment,
  2
  /* CommentOption.Uncomment */
);
var toggleBlockComment = command(
  changeBlockComment,
  0
  /* CommentOption.Toggle */
);
var blockComment = command(
  changeBlockComment,
  1
  /* CommentOption.Comment */
);
var blockUncomment = command(
  changeBlockComment,
  2
  /* CommentOption.Uncomment */
);
var toggleBlockCommentByLine = command(
  (o2, s2) => changeBlockComment(o2, s2, selectedLineRanges(s2)),
  0
  /* CommentOption.Toggle */
);
function getConfig(state, pos) {
  let data = state.languageDataAt("commentTokens", pos);
  return data.length ? data[0] : {};
}
var SearchMargin = 50;
function findBlockComment(state, { open, close }, from, to3) {
  let textBefore = state.sliceDoc(from - SearchMargin, from);
  let textAfter = state.sliceDoc(to3, to3 + SearchMargin);
  let spaceBefore = /\s*$/.exec(textBefore)[0].length, spaceAfter = /^\s*/.exec(textAfter)[0].length;
  let beforeOff = textBefore.length - spaceBefore;
  if (textBefore.slice(beforeOff - open.length, beforeOff) == open && textAfter.slice(spaceAfter, spaceAfter + close.length) == close) {
    return {
      open: { pos: from - spaceBefore, margin: spaceBefore && 1 },
      close: { pos: to3 + spaceAfter, margin: spaceAfter && 1 }
    };
  }
  let startText, endText;
  if (to3 - from <= 2 * SearchMargin) {
    startText = endText = state.sliceDoc(from, to3);
  } else {
    startText = state.sliceDoc(from, from + SearchMargin);
    endText = state.sliceDoc(to3 - SearchMargin, to3);
  }
  let startSpace = /^\s*/.exec(startText)[0].length, endSpace = /\s*$/.exec(endText)[0].length;
  let endOff = endText.length - endSpace - close.length;
  if (startText.slice(startSpace, startSpace + open.length) == open && endText.slice(endOff, endOff + close.length) == close) {
    return {
      open: {
        pos: from + startSpace + open.length,
        margin: /\s/.test(startText.charAt(startSpace + open.length)) ? 1 : 0
      },
      close: {
        pos: to3 - endSpace - close.length,
        margin: /\s/.test(endText.charAt(endOff - 1)) ? 1 : 0
      }
    };
  }
  return null;
}
function selectedLineRanges(state) {
  let ranges = [];
  for (let r2 of state.selection.ranges) {
    let fromLine = state.doc.lineAt(r2.from);
    let toLine = r2.to <= fromLine.to ? fromLine : state.doc.lineAt(r2.to);
    let last2 = ranges.length - 1;
    if (last2 >= 0 && ranges[last2].to > fromLine.from)
      ranges[last2].to = toLine.to;
    else
      ranges.push({ from: fromLine.from + /^\s*/.exec(fromLine.text)[0].length, to: toLine.to });
  }
  return ranges;
}
function changeBlockComment(option, state, ranges = state.selection.ranges) {
  let tokens = ranges.map((r2) => getConfig(state, r2.from).block);
  if (!tokens.every((c) => c))
    return null;
  let comments = ranges.map((r2, i2) => findBlockComment(state, tokens[i2], r2.from, r2.to));
  if (option != 2 && !comments.every((c) => c)) {
    return { changes: state.changes(ranges.map((range, i2) => {
      if (comments[i2])
        return [];
      return [{ from: range.from, insert: tokens[i2].open + " " }, { from: range.to, insert: " " + tokens[i2].close }];
    })) };
  } else if (option != 1 && comments.some((c) => c)) {
    let changes = [];
    for (let i2 = 0, comment2; i2 < comments.length; i2++)
      if (comment2 = comments[i2]) {
        let token = tokens[i2], { open, close } = comment2;
        changes.push({ from: open.pos - token.open.length, to: open.pos + open.margin }, { from: close.pos - close.margin, to: close.pos + token.close.length });
      }
    return { changes };
  }
  return null;
}
function changeLineComment(option, state, ranges = state.selection.ranges) {
  let lines = [];
  let prevLine = -1;
  for (let { from, to: to3 } of ranges) {
    let startI = lines.length, minIndent = 1e9;
    let token = getConfig(state, from).line;
    if (!token)
      continue;
    for (let pos = from; pos <= to3; ) {
      let line = state.doc.lineAt(pos);
      if (line.from > prevLine && (from == to3 || to3 > line.from)) {
        prevLine = line.from;
        let indent = /^\s*/.exec(line.text)[0].length;
        let empty2 = indent == line.length;
        let comment2 = line.text.slice(indent, indent + token.length) == token ? indent : -1;
        if (indent < line.text.length && indent < minIndent)
          minIndent = indent;
        lines.push({ line, comment: comment2, token, indent, empty: empty2, single: false });
      }
      pos = line.to + 1;
    }
    if (minIndent < 1e9) {
      for (let i2 = startI; i2 < lines.length; i2++)
        if (lines[i2].indent < lines[i2].line.text.length)
          lines[i2].indent = minIndent;
    }
    if (lines.length == startI + 1)
      lines[startI].single = true;
  }
  if (option != 2 && lines.some((l) => l.comment < 0 && (!l.empty || l.single))) {
    let changes = [];
    for (let { line, token, indent, empty: empty2, single } of lines)
      if (single || !empty2)
        changes.push({ from: line.from + indent, insert: token + " " });
    let changeSet = state.changes(changes);
    return { changes: changeSet, selection: state.selection.map(changeSet, 1) };
  } else if (option != 1 && lines.some((l) => l.comment >= 0)) {
    let changes = [];
    for (let { line, comment: comment2, token } of lines)
      if (comment2 >= 0) {
        let from = line.from + comment2, to3 = from + token.length;
        if (line.text[to3 - line.from] == " ")
          to3++;
        changes.push({ from, to: to3 });
      }
    return { changes };
  }
  return null;
}
var fromHistory = Annotation.define();
var isolateHistory = Annotation.define();
var invertedEffects = Facet.define();
var historyConfig = Facet.define({
  combine(configs) {
    return combineConfig(configs, {
      minDepth: 100,
      newGroupDelay: 500,
      joinToEvent: (_t3, isAdjacent2) => isAdjacent2
    }, {
      minDepth: Math.max,
      newGroupDelay: Math.min,
      joinToEvent: (a2, b2) => (tr3, adj) => a2(tr3, adj) || b2(tr3, adj)
    });
  }
});
var historyField_ = StateField.define({
  create() {
    return HistoryState.empty;
  },
  update(state, tr3) {
    let config2 = tr3.state.facet(historyConfig);
    let fromHist = tr3.annotation(fromHistory);
    if (fromHist) {
      let item = HistEvent.fromTransaction(tr3, fromHist.selection), from = fromHist.side;
      let other = from == 0 ? state.undone : state.done;
      if (item)
        other = updateBranch(other, other.length, config2.minDepth, item);
      else
        other = addSelection(other, tr3.startState.selection);
      return new HistoryState(from == 0 ? fromHist.rest : other, from == 0 ? other : fromHist.rest);
    }
    let isolate = tr3.annotation(isolateHistory);
    if (isolate == "full" || isolate == "before")
      state = state.isolate();
    if (tr3.annotation(Transaction.addToHistory) === false)
      return !tr3.changes.empty ? state.addMapping(tr3.changes.desc) : state;
    let event = HistEvent.fromTransaction(tr3);
    let time = tr3.annotation(Transaction.time), userEvent = tr3.annotation(Transaction.userEvent);
    if (event)
      state = state.addChanges(event, time, userEvent, config2, tr3);
    else if (tr3.selection)
      state = state.addSelection(tr3.startState.selection, time, userEvent, config2.newGroupDelay);
    if (isolate == "full" || isolate == "after")
      state = state.isolate();
    return state;
  },
  toJSON(value) {
    return { done: value.done.map((e2) => e2.toJSON()), undone: value.undone.map((e2) => e2.toJSON()) };
  },
  fromJSON(json2) {
    return new HistoryState(json2.done.map(HistEvent.fromJSON), json2.undone.map(HistEvent.fromJSON));
  }
});
function history(config2 = {}) {
  return [
    historyField_,
    historyConfig.of(config2),
    EditorView.domEventHandlers({
      beforeinput(e2, view) {
        let command2 = e2.inputType == "historyUndo" ? undo : e2.inputType == "historyRedo" ? redo : null;
        if (!command2)
          return false;
        e2.preventDefault();
        return command2(view);
      }
    })
  ];
}
function cmd(side, selection) {
  return function({ state, dispatch }) {
    if (!selection && state.readOnly)
      return false;
    let historyState = state.field(historyField_, false);
    if (!historyState)
      return false;
    let tr3 = historyState.pop(side, state, selection);
    if (!tr3)
      return false;
    dispatch(tr3);
    return true;
  };
}
var undo = cmd(0, false);
var redo = cmd(1, false);
var undoSelection = cmd(0, true);
var redoSelection = cmd(1, true);
function depth(side) {
  return function(state) {
    let histState = state.field(historyField_, false);
    if (!histState)
      return 0;
    let branch = side == 0 ? histState.done : histState.undone;
    return branch.length - (branch.length && !branch[0].changes ? 1 : 0);
  };
}
var undoDepth = depth(
  0
  /* BranchName.Done */
);
var redoDepth = depth(
  1
  /* BranchName.Undone */
);
var HistEvent = class _HistEvent {
  constructor(changes, effects, mapped, startSelection, selectionsAfter) {
    this.changes = changes;
    this.effects = effects;
    this.mapped = mapped;
    this.startSelection = startSelection;
    this.selectionsAfter = selectionsAfter;
  }
  setSelAfter(after) {
    return new _HistEvent(this.changes, this.effects, this.mapped, this.startSelection, after);
  }
  toJSON() {
    var _a4, _b, _c2;
    return {
      changes: (_a4 = this.changes) === null || _a4 === void 0 ? void 0 : _a4.toJSON(),
      mapped: (_b = this.mapped) === null || _b === void 0 ? void 0 : _b.toJSON(),
      startSelection: (_c2 = this.startSelection) === null || _c2 === void 0 ? void 0 : _c2.toJSON(),
      selectionsAfter: this.selectionsAfter.map((s2) => s2.toJSON())
    };
  }
  static fromJSON(json2) {
    return new _HistEvent(json2.changes && ChangeSet.fromJSON(json2.changes), [], json2.mapped && ChangeDesc.fromJSON(json2.mapped), json2.startSelection && EditorSelection.fromJSON(json2.startSelection), json2.selectionsAfter.map(EditorSelection.fromJSON));
  }
  // This does not check `addToHistory` and such, it assumes the
  // transaction needs to be converted to an item. Returns null when
  // there are no changes or effects in the transaction.
  static fromTransaction(tr3, selection) {
    let effects = none2;
    for (let invert of tr3.startState.facet(invertedEffects)) {
      let result = invert(tr3);
      if (result.length)
        effects = effects.concat(result);
    }
    if (!effects.length && tr3.changes.empty)
      return null;
    return new _HistEvent(tr3.changes.invert(tr3.startState.doc), effects, void 0, selection || tr3.startState.selection, none2);
  }
  static selection(selections) {
    return new _HistEvent(void 0, none2, void 0, void 0, selections);
  }
};
function updateBranch(branch, to3, maxLen, newEvent) {
  let start = to3 + 1 > maxLen + 20 ? to3 - maxLen - 1 : 0;
  let newBranch = branch.slice(start, to3);
  newBranch.push(newEvent);
  return newBranch;
}
function isAdjacent(a2, b2) {
  let ranges = [], isAdjacent2 = false;
  a2.iterChangedRanges((f, t3) => ranges.push(f, t3));
  b2.iterChangedRanges((_f2, _t3, f, t3) => {
    for (let i2 = 0; i2 < ranges.length; ) {
      let from = ranges[i2++], to3 = ranges[i2++];
      if (t3 >= from && f <= to3)
        isAdjacent2 = true;
    }
  });
  return isAdjacent2;
}
function eqSelectionShape(a2, b2) {
  return a2.ranges.length == b2.ranges.length && a2.ranges.filter((r2, i2) => r2.empty != b2.ranges[i2].empty).length === 0;
}
function conc(a2, b2) {
  return !a2.length ? b2 : !b2.length ? a2 : a2.concat(b2);
}
var none2 = [];
var MaxSelectionsPerEvent = 200;
function addSelection(branch, selection) {
  if (!branch.length) {
    return [HistEvent.selection([selection])];
  } else {
    let lastEvent = branch[branch.length - 1];
    let sels = lastEvent.selectionsAfter.slice(Math.max(0, lastEvent.selectionsAfter.length - MaxSelectionsPerEvent));
    if (sels.length && sels[sels.length - 1].eq(selection))
      return branch;
    sels.push(selection);
    return updateBranch(branch, branch.length - 1, 1e9, lastEvent.setSelAfter(sels));
  }
}
function popSelection(branch) {
  let last2 = branch[branch.length - 1];
  let newBranch = branch.slice();
  newBranch[branch.length - 1] = last2.setSelAfter(last2.selectionsAfter.slice(0, last2.selectionsAfter.length - 1));
  return newBranch;
}
function addMappingToBranch(branch, mapping) {
  if (!branch.length)
    return branch;
  let length = branch.length, selections = none2;
  while (length) {
    let event = mapEvent(branch[length - 1], mapping, selections);
    if (event.changes && !event.changes.empty || event.effects.length) {
      let result = branch.slice(0, length);
      result[length - 1] = event;
      return result;
    } else {
      mapping = event.mapped;
      length--;
      selections = event.selectionsAfter;
    }
  }
  return selections.length ? [HistEvent.selection(selections)] : none2;
}
function mapEvent(event, mapping, extraSelections) {
  let selections = conc(event.selectionsAfter.length ? event.selectionsAfter.map((s2) => s2.map(mapping)) : none2, extraSelections);
  if (!event.changes)
    return HistEvent.selection(selections);
  let mappedChanges = event.changes.map(mapping), before = mapping.mapDesc(event.changes, true);
  let fullMapping = event.mapped ? event.mapped.composeDesc(before) : before;
  return new HistEvent(mappedChanges, StateEffect.mapEffects(event.effects, mapping), fullMapping, event.startSelection.map(before), selections);
}
var joinableUserEvent = /^(input\.type|delete)($|\.)/;
var HistoryState = class _HistoryState {
  constructor(done, undone, prevTime = 0, prevUserEvent = void 0) {
    this.done = done;
    this.undone = undone;
    this.prevTime = prevTime;
    this.prevUserEvent = prevUserEvent;
  }
  isolate() {
    return this.prevTime ? new _HistoryState(this.done, this.undone) : this;
  }
  addChanges(event, time, userEvent, config2, tr3) {
    let done = this.done, lastEvent = done[done.length - 1];
    if (lastEvent && lastEvent.changes && !lastEvent.changes.empty && event.changes && (!userEvent || joinableUserEvent.test(userEvent)) && (!lastEvent.selectionsAfter.length && time - this.prevTime < config2.newGroupDelay && config2.joinToEvent(tr3, isAdjacent(lastEvent.changes, event.changes)) || // For compose (but not compose.start) events, always join with previous event
    userEvent == "input.type.compose")) {
      done = updateBranch(done, done.length - 1, config2.minDepth, new HistEvent(event.changes.compose(lastEvent.changes), conc(StateEffect.mapEffects(event.effects, lastEvent.changes), lastEvent.effects), lastEvent.mapped, lastEvent.startSelection, none2));
    } else {
      done = updateBranch(done, done.length, config2.minDepth, event);
    }
    return new _HistoryState(done, none2, time, userEvent);
  }
  addSelection(selection, time, userEvent, newGroupDelay) {
    let last2 = this.done.length ? this.done[this.done.length - 1].selectionsAfter : none2;
    if (last2.length > 0 && time - this.prevTime < newGroupDelay && userEvent == this.prevUserEvent && userEvent && /^select($|\.)/.test(userEvent) && eqSelectionShape(last2[last2.length - 1], selection))
      return this;
    return new _HistoryState(addSelection(this.done, selection), this.undone, time, userEvent);
  }
  addMapping(mapping) {
    return new _HistoryState(addMappingToBranch(this.done, mapping), addMappingToBranch(this.undone, mapping), this.prevTime, this.prevUserEvent);
  }
  pop(side, state, onlySelection) {
    let branch = side == 0 ? this.done : this.undone;
    if (branch.length == 0)
      return null;
    let event = branch[branch.length - 1], selection = event.selectionsAfter[0] || state.selection;
    if (onlySelection && event.selectionsAfter.length) {
      return state.update({
        selection: event.selectionsAfter[event.selectionsAfter.length - 1],
        annotations: fromHistory.of({ side, rest: popSelection(branch), selection }),
        userEvent: side == 0 ? "select.undo" : "select.redo",
        scrollIntoView: true
      });
    } else if (!event.changes) {
      return null;
    } else {
      let rest = branch.length == 1 ? none2 : branch.slice(0, branch.length - 1);
      if (event.mapped)
        rest = addMappingToBranch(rest, event.mapped);
      return state.update({
        changes: event.changes,
        selection: event.startSelection,
        effects: event.effects,
        annotations: fromHistory.of({ side, rest, selection }),
        filter: false,
        userEvent: side == 0 ? "undo" : "redo",
        scrollIntoView: true
      });
    }
  }
};
HistoryState.empty = new HistoryState(none2, none2);
var historyKeymap = [
  { key: "Mod-z", run: undo, preventDefault: true },
  { key: "Mod-y", mac: "Mod-Shift-z", run: redo, preventDefault: true },
  { linux: "Ctrl-Shift-z", run: redo, preventDefault: true },
  { key: "Mod-u", run: undoSelection, preventDefault: true },
  { key: "Alt-u", mac: "Mod-Shift-u", run: redoSelection, preventDefault: true }
];
function updateSel(sel, by) {
  return EditorSelection.create(sel.ranges.map(by), sel.mainIndex);
}
function setSel(state, selection) {
  return state.update({ selection, scrollIntoView: true, userEvent: "select" });
}
function moveSel({ state, dispatch }, how) {
  let selection = updateSel(state.selection, how);
  if (selection.eq(state.selection, true))
    return false;
  dispatch(setSel(state, selection));
  return true;
}
function rangeEnd(range, forward) {
  return EditorSelection.cursor(forward ? range.to : range.from);
}
function cursorByChar(view, forward) {
  return moveSel(view, (range) => range.empty ? view.moveByChar(range, forward) : rangeEnd(range, forward));
}
function ltrAtCursor(view) {
  return view.textDirectionAt(view.state.selection.main.head) == Direction.LTR;
}
var cursorCharLeft = (view) => cursorByChar(view, !ltrAtCursor(view));
var cursorCharRight = (view) => cursorByChar(view, ltrAtCursor(view));
function cursorByGroup(view, forward) {
  return moveSel(view, (range) => range.empty ? view.moveByGroup(range, forward) : rangeEnd(range, forward));
}
var cursorGroupLeft = (view) => cursorByGroup(view, !ltrAtCursor(view));
var cursorGroupRight = (view) => cursorByGroup(view, ltrAtCursor(view));
var segmenter = typeof Intl != "undefined" && Intl.Segmenter ? new Intl.Segmenter(void 0, { granularity: "word" }) : null;
function interestingNode(state, node, bracketProp) {
  if (node.type.prop(bracketProp))
    return true;
  let len = node.to - node.from;
  return len && (len > 2 || /[^\s,.;:]/.test(state.sliceDoc(node.from, node.to))) || node.firstChild;
}
function moveBySyntax(state, start, forward) {
  let pos = syntaxTree(state).resolveInner(start.head);
  let bracketProp = forward ? NodeProp.closedBy : NodeProp.openedBy;
  for (let at2 = start.head; ; ) {
    let next = forward ? pos.childAfter(at2) : pos.childBefore(at2);
    if (!next)
      break;
    if (interestingNode(state, next, bracketProp))
      pos = next;
    else
      at2 = forward ? next.to : next.from;
  }
  let bracket2 = pos.type.prop(bracketProp), match, newPos;
  if (bracket2 && (match = forward ? matchBrackets(state, pos.from, 1) : matchBrackets(state, pos.to, -1)) && match.matched)
    newPos = forward ? match.end.to : match.end.from;
  else
    newPos = forward ? pos.to : pos.from;
  return EditorSelection.cursor(newPos, forward ? -1 : 1);
}
var cursorSyntaxLeft = (view) => moveSel(view, (range) => moveBySyntax(view.state, range, !ltrAtCursor(view)));
var cursorSyntaxRight = (view) => moveSel(view, (range) => moveBySyntax(view.state, range, ltrAtCursor(view)));
function cursorByLine(view, forward) {
  return moveSel(view, (range) => {
    if (!range.empty)
      return rangeEnd(range, forward);
    let moved = view.moveVertically(range, forward);
    return moved.head != range.head ? moved : view.moveToLineBoundary(range, forward);
  });
}
var cursorLineUp = (view) => cursorByLine(view, false);
var cursorLineDown = (view) => cursorByLine(view, true);
function pageInfo(view) {
  let selfScroll = view.scrollDOM.clientHeight < view.scrollDOM.scrollHeight - 2;
  let marginTop = 0, marginBottom = 0, height;
  if (selfScroll) {
    for (let source of view.state.facet(EditorView.scrollMargins)) {
      let margins = source(view);
      if (margins === null || margins === void 0 ? void 0 : margins.top)
        marginTop = Math.max(margins === null || margins === void 0 ? void 0 : margins.top, marginTop);
      if (margins === null || margins === void 0 ? void 0 : margins.bottom)
        marginBottom = Math.max(margins === null || margins === void 0 ? void 0 : margins.bottom, marginBottom);
    }
    height = view.scrollDOM.clientHeight - marginTop - marginBottom;
  } else {
    height = (view.dom.ownerDocument.defaultView || window).innerHeight;
  }
  return {
    marginTop,
    marginBottom,
    selfScroll,
    height: Math.max(view.defaultLineHeight, height - 5)
  };
}
function cursorByPage(view, forward) {
  let page = pageInfo(view);
  let { state } = view, selection = updateSel(state.selection, (range) => {
    return range.empty ? view.moveVertically(range, forward, page.height) : rangeEnd(range, forward);
  });
  if (selection.eq(state.selection))
    return false;
  let effect;
  if (page.selfScroll) {
    let startPos = view.coordsAtPos(state.selection.main.head);
    let scrollRect = view.scrollDOM.getBoundingClientRect();
    let scrollTop = scrollRect.top + page.marginTop, scrollBottom = scrollRect.bottom - page.marginBottom;
    if (startPos && startPos.top > scrollTop && startPos.bottom < scrollBottom)
      effect = EditorView.scrollIntoView(selection.main.head, { y: "start", yMargin: startPos.top - scrollTop });
  }
  view.dispatch(setSel(state, selection), { effects: effect });
  return true;
}
var cursorPageUp = (view) => cursorByPage(view, false);
var cursorPageDown = (view) => cursorByPage(view, true);
function moveByLineBoundary(view, start, forward) {
  let line = view.lineBlockAt(start.head), moved = view.moveToLineBoundary(start, forward);
  if (moved.head == start.head && moved.head != (forward ? line.to : line.from))
    moved = view.moveToLineBoundary(start, forward, false);
  if (!forward && moved.head == line.from && line.length) {
    let space = /^\s*/.exec(view.state.sliceDoc(line.from, Math.min(line.from + 100, line.to)))[0].length;
    if (space && start.head != line.from + space)
      moved = EditorSelection.cursor(line.from + space);
  }
  return moved;
}
var cursorLineBoundaryForward = (view) => moveSel(view, (range) => moveByLineBoundary(view, range, true));
var cursorLineBoundaryBackward = (view) => moveSel(view, (range) => moveByLineBoundary(view, range, false));
var cursorLineBoundaryLeft = (view) => moveSel(view, (range) => moveByLineBoundary(view, range, !ltrAtCursor(view)));
var cursorLineBoundaryRight = (view) => moveSel(view, (range) => moveByLineBoundary(view, range, ltrAtCursor(view)));
var cursorLineStart = (view) => moveSel(view, (range) => EditorSelection.cursor(view.lineBlockAt(range.head).from, 1));
var cursorLineEnd = (view) => moveSel(view, (range) => EditorSelection.cursor(view.lineBlockAt(range.head).to, -1));
function toMatchingBracket(state, dispatch, extend2) {
  let found = false, selection = updateSel(state.selection, (range) => {
    let matching = matchBrackets(state, range.head, -1) || matchBrackets(state, range.head, 1) || range.head > 0 && matchBrackets(state, range.head - 1, 1) || range.head < state.doc.length && matchBrackets(state, range.head + 1, -1);
    if (!matching || !matching.end)
      return range;
    found = true;
    let head = matching.start.from == range.head ? matching.end.to : matching.end.from;
    return extend2 ? EditorSelection.range(range.anchor, head) : EditorSelection.cursor(head);
  });
  if (!found)
    return false;
  dispatch(setSel(state, selection));
  return true;
}
var cursorMatchingBracket = ({ state, dispatch }) => toMatchingBracket(state, dispatch, false);
function extendSel(target, how) {
  let selection = updateSel(target.state.selection, (range) => {
    let head = how(range);
    return EditorSelection.range(range.anchor, head.head, head.goalColumn, head.bidiLevel || void 0);
  });
  if (selection.eq(target.state.selection))
    return false;
  target.dispatch(setSel(target.state, selection));
  return true;
}
function selectByChar(view, forward) {
  return extendSel(view, (range) => view.moveByChar(range, forward));
}
var selectCharLeft = (view) => selectByChar(view, !ltrAtCursor(view));
var selectCharRight = (view) => selectByChar(view, ltrAtCursor(view));
function selectByGroup(view, forward) {
  return extendSel(view, (range) => view.moveByGroup(range, forward));
}
var selectGroupLeft = (view) => selectByGroup(view, !ltrAtCursor(view));
var selectGroupRight = (view) => selectByGroup(view, ltrAtCursor(view));
var selectSyntaxLeft = (view) => extendSel(view, (range) => moveBySyntax(view.state, range, !ltrAtCursor(view)));
var selectSyntaxRight = (view) => extendSel(view, (range) => moveBySyntax(view.state, range, ltrAtCursor(view)));
function selectByLine(view, forward) {
  return extendSel(view, (range) => view.moveVertically(range, forward));
}
var selectLineUp = (view) => selectByLine(view, false);
var selectLineDown = (view) => selectByLine(view, true);
function selectByPage(view, forward) {
  return extendSel(view, (range) => view.moveVertically(range, forward, pageInfo(view).height));
}
var selectPageUp = (view) => selectByPage(view, false);
var selectPageDown = (view) => selectByPage(view, true);
var selectLineBoundaryForward = (view) => extendSel(view, (range) => moveByLineBoundary(view, range, true));
var selectLineBoundaryBackward = (view) => extendSel(view, (range) => moveByLineBoundary(view, range, false));
var selectLineBoundaryLeft = (view) => extendSel(view, (range) => moveByLineBoundary(view, range, !ltrAtCursor(view)));
var selectLineBoundaryRight = (view) => extendSel(view, (range) => moveByLineBoundary(view, range, ltrAtCursor(view)));
var selectLineStart = (view) => extendSel(view, (range) => EditorSelection.cursor(view.lineBlockAt(range.head).from));
var selectLineEnd = (view) => extendSel(view, (range) => EditorSelection.cursor(view.lineBlockAt(range.head).to));
var cursorDocStart = ({ state, dispatch }) => {
  dispatch(setSel(state, { anchor: 0 }));
  return true;
};
var cursorDocEnd = ({ state, dispatch }) => {
  dispatch(setSel(state, { anchor: state.doc.length }));
  return true;
};
var selectDocStart = ({ state, dispatch }) => {
  dispatch(setSel(state, { anchor: state.selection.main.anchor, head: 0 }));
  return true;
};
var selectDocEnd = ({ state, dispatch }) => {
  dispatch(setSel(state, { anchor: state.selection.main.anchor, head: state.doc.length }));
  return true;
};
var selectAll = ({ state, dispatch }) => {
  dispatch(state.update({ selection: { anchor: 0, head: state.doc.length }, userEvent: "select" }));
  return true;
};
var selectLine = ({ state, dispatch }) => {
  let ranges = selectedLineBlocks(state).map(({ from, to: to3 }) => EditorSelection.range(from, Math.min(to3 + 1, state.doc.length)));
  dispatch(state.update({ selection: EditorSelection.create(ranges), userEvent: "select" }));
  return true;
};
var selectParentSyntax = ({ state, dispatch }) => {
  let selection = updateSel(state.selection, (range) => {
    let tree = syntaxTree(state), stack = tree.resolveStack(range.from, 1);
    if (range.empty) {
      let stackBefore = tree.resolveStack(range.from, -1);
      if (stackBefore.node.from >= stack.node.from && stackBefore.node.to <= stack.node.to)
        stack = stackBefore;
    }
    for (let cur2 = stack; cur2; cur2 = cur2.next) {
      let { node } = cur2;
      if ((node.from < range.from && node.to >= range.to || node.to > range.to && node.from <= range.from) && cur2.next)
        return EditorSelection.range(node.to, node.from);
    }
    return range;
  });
  if (selection.eq(state.selection))
    return false;
  dispatch(setSel(state, selection));
  return true;
};
var simplifySelection = ({ state, dispatch }) => {
  let cur2 = state.selection, selection = null;
  if (cur2.ranges.length > 1)
    selection = EditorSelection.create([cur2.main]);
  else if (!cur2.main.empty)
    selection = EditorSelection.create([EditorSelection.cursor(cur2.main.head)]);
  if (!selection)
    return false;
  dispatch(setSel(state, selection));
  return true;
};
function deleteBy(target, by) {
  if (target.state.readOnly)
    return false;
  let event = "delete.selection", { state } = target;
  let changes = state.changeByRange((range) => {
    let { from, to: to3 } = range;
    if (from == to3) {
      let towards = by(range);
      if (towards < from) {
        event = "delete.backward";
        towards = skipAtomic(target, towards, false);
      } else if (towards > from) {
        event = "delete.forward";
        towards = skipAtomic(target, towards, true);
      }
      from = Math.min(from, towards);
      to3 = Math.max(to3, towards);
    } else {
      from = skipAtomic(target, from, false);
      to3 = skipAtomic(target, to3, true);
    }
    return from == to3 ? { range } : { changes: { from, to: to3 }, range: EditorSelection.cursor(from, from < range.head ? -1 : 1) };
  });
  if (changes.changes.empty)
    return false;
  target.dispatch(state.update(changes, {
    scrollIntoView: true,
    userEvent: event,
    effects: event == "delete.selection" ? EditorView.announce.of(state.phrase("Selection deleted")) : void 0
  }));
  return true;
}
function skipAtomic(target, pos, forward) {
  if (target instanceof EditorView)
    for (let ranges of target.state.facet(EditorView.atomicRanges).map((f) => f(target)))
      ranges.between(pos, pos, (from, to3) => {
        if (from < pos && to3 > pos)
          pos = forward ? to3 : from;
      });
  return pos;
}
var deleteByChar = (target, forward, byIndentUnit) => deleteBy(target, (range) => {
  let pos = range.from, { state } = target, line = state.doc.lineAt(pos), before, targetPos;
  if (byIndentUnit && !forward && pos > line.from && pos < line.from + 200 && !/[^ \t]/.test(before = line.text.slice(0, pos - line.from))) {
    if (before[before.length - 1] == "	")
      return pos - 1;
    let col = countColumn(before, state.tabSize), drop = col % getIndentUnit(state) || getIndentUnit(state);
    for (let i2 = 0; i2 < drop && before[before.length - 1 - i2] == " "; i2++)
      pos--;
    targetPos = pos;
  } else {
    targetPos = findClusterBreak(line.text, pos - line.from, forward, forward) + line.from;
    if (targetPos == pos && line.number != (forward ? state.doc.lines : 1))
      targetPos += forward ? 1 : -1;
    else if (!forward && /[\ufe00-\ufe0f]/.test(line.text.slice(targetPos - line.from, pos - line.from)))
      targetPos = findClusterBreak(line.text, targetPos - line.from, false, false) + line.from;
  }
  return targetPos;
});
var deleteCharBackward = (view) => deleteByChar(view, false, true);
var deleteCharForward = (view) => deleteByChar(view, true, false);
var deleteByGroup = (target, forward) => deleteBy(target, (range) => {
  let pos = range.head, { state } = target, line = state.doc.lineAt(pos);
  let categorize = state.charCategorizer(pos);
  for (let cat = null; ; ) {
    if (pos == (forward ? line.to : line.from)) {
      if (pos == range.head && line.number != (forward ? state.doc.lines : 1))
        pos += forward ? 1 : -1;
      break;
    }
    let next = findClusterBreak(line.text, pos - line.from, forward) + line.from;
    let nextChar2 = line.text.slice(Math.min(pos, next) - line.from, Math.max(pos, next) - line.from);
    let nextCat = categorize(nextChar2);
    if (cat != null && nextCat != cat)
      break;
    if (nextChar2 != " " || pos != range.head)
      cat = nextCat;
    pos = next;
  }
  return pos;
});
var deleteGroupBackward = (target) => deleteByGroup(target, false);
var deleteGroupForward = (target) => deleteByGroup(target, true);
var deleteToLineEnd = (view) => deleteBy(view, (range) => {
  let lineEnd = view.lineBlockAt(range.head).to;
  return range.head < lineEnd ? lineEnd : Math.min(view.state.doc.length, range.head + 1);
});
var deleteLineBoundaryBackward = (view) => deleteBy(view, (range) => {
  let lineStart = view.moveToLineBoundary(range, false).head;
  return range.head > lineStart ? lineStart : Math.max(0, range.head - 1);
});
var deleteLineBoundaryForward = (view) => deleteBy(view, (range) => {
  let lineStart = view.moveToLineBoundary(range, true).head;
  return range.head < lineStart ? lineStart : Math.min(view.state.doc.length, range.head + 1);
});
var splitLine = ({ state, dispatch }) => {
  if (state.readOnly)
    return false;
  let changes = state.changeByRange((range) => {
    return {
      changes: { from: range.from, to: range.to, insert: Text.of(["", ""]) },
      range: EditorSelection.cursor(range.from)
    };
  });
  dispatch(state.update(changes, { scrollIntoView: true, userEvent: "input" }));
  return true;
};
var transposeChars = ({ state, dispatch }) => {
  if (state.readOnly)
    return false;
  let changes = state.changeByRange((range) => {
    if (!range.empty || range.from == 0 || range.from == state.doc.length)
      return { range };
    let pos = range.from, line = state.doc.lineAt(pos);
    let from = pos == line.from ? pos - 1 : findClusterBreak(line.text, pos - line.from, false) + line.from;
    let to3 = pos == line.to ? pos + 1 : findClusterBreak(line.text, pos - line.from, true) + line.from;
    return {
      changes: { from, to: to3, insert: state.doc.slice(pos, to3).append(state.doc.slice(from, pos)) },
      range: EditorSelection.cursor(to3)
    };
  });
  if (changes.changes.empty)
    return false;
  dispatch(state.update(changes, { scrollIntoView: true, userEvent: "move.character" }));
  return true;
};
function selectedLineBlocks(state) {
  let blocks = [], upto = -1;
  for (let range of state.selection.ranges) {
    let startLine = state.doc.lineAt(range.from), endLine = state.doc.lineAt(range.to);
    if (!range.empty && range.to == endLine.from)
      endLine = state.doc.lineAt(range.to - 1);
    if (upto >= startLine.number) {
      let prev = blocks[blocks.length - 1];
      prev.to = endLine.to;
      prev.ranges.push(range);
    } else {
      blocks.push({ from: startLine.from, to: endLine.to, ranges: [range] });
    }
    upto = endLine.number + 1;
  }
  return blocks;
}
function moveLine(state, dispatch, forward) {
  if (state.readOnly)
    return false;
  let changes = [], ranges = [];
  for (let block of selectedLineBlocks(state)) {
    if (forward ? block.to == state.doc.length : block.from == 0)
      continue;
    let nextLine = state.doc.lineAt(forward ? block.to + 1 : block.from - 1);
    let size = nextLine.length + 1;
    if (forward) {
      changes.push({ from: block.to, to: nextLine.to }, { from: block.from, insert: nextLine.text + state.lineBreak });
      for (let r2 of block.ranges)
        ranges.push(EditorSelection.range(Math.min(state.doc.length, r2.anchor + size), Math.min(state.doc.length, r2.head + size)));
    } else {
      changes.push({ from: nextLine.from, to: block.from }, { from: block.to, insert: state.lineBreak + nextLine.text });
      for (let r2 of block.ranges)
        ranges.push(EditorSelection.range(r2.anchor - size, r2.head - size));
    }
  }
  if (!changes.length)
    return false;
  dispatch(state.update({
    changes,
    scrollIntoView: true,
    selection: EditorSelection.create(ranges, state.selection.mainIndex),
    userEvent: "move.line"
  }));
  return true;
}
var moveLineUp = ({ state, dispatch }) => moveLine(state, dispatch, false);
var moveLineDown = ({ state, dispatch }) => moveLine(state, dispatch, true);
function copyLine(state, dispatch, forward) {
  if (state.readOnly)
    return false;
  let changes = [];
  for (let block of selectedLineBlocks(state)) {
    if (forward)
      changes.push({ from: block.from, insert: state.doc.slice(block.from, block.to) + state.lineBreak });
    else
      changes.push({ from: block.to, insert: state.lineBreak + state.doc.slice(block.from, block.to) });
  }
  dispatch(state.update({ changes, scrollIntoView: true, userEvent: "input.copyline" }));
  return true;
}
var copyLineUp = ({ state, dispatch }) => copyLine(state, dispatch, false);
var copyLineDown = ({ state, dispatch }) => copyLine(state, dispatch, true);
var deleteLine = (view) => {
  if (view.state.readOnly)
    return false;
  let { state } = view, changes = state.changes(selectedLineBlocks(state).map(({ from, to: to3 }) => {
    if (from > 0)
      from--;
    else if (to3 < state.doc.length)
      to3++;
    return { from, to: to3 };
  }));
  let selection = updateSel(state.selection, (range) => {
    let dist2 = void 0;
    if (view.lineWrapping) {
      let block = view.lineBlockAt(range.head), pos = view.coordsAtPos(range.head, range.assoc || 1);
      if (pos)
        dist2 = block.bottom + view.documentTop - pos.bottom + view.defaultLineHeight / 2;
    }
    return view.moveVertically(range, true, dist2);
  }).map(changes);
  view.dispatch({ changes, selection, scrollIntoView: true, userEvent: "delete.line" });
  return true;
};
function isBetweenBrackets(state, pos) {
  if (/\(\)|\[\]|\{\}/.test(state.sliceDoc(pos - 1, pos + 1)))
    return { from: pos, to: pos };
  let context = syntaxTree(state).resolveInner(pos);
  let before = context.childBefore(pos), after = context.childAfter(pos), closedBy;
  if (before && after && before.to <= pos && after.from >= pos && (closedBy = before.type.prop(NodeProp.closedBy)) && closedBy.indexOf(after.name) > -1 && state.doc.lineAt(before.to).from == state.doc.lineAt(after.from).from && !/\S/.test(state.sliceDoc(before.to, after.from)))
    return { from: before.to, to: after.from };
  return null;
}
var insertNewlineAndIndent = newlineAndIndent(false);
var insertBlankLine = newlineAndIndent(true);
function newlineAndIndent(atEof) {
  return ({ state, dispatch }) => {
    if (state.readOnly)
      return false;
    let changes = state.changeByRange((range) => {
      let { from, to: to3 } = range, line = state.doc.lineAt(from);
      let explode = !atEof && from == to3 && isBetweenBrackets(state, from);
      if (atEof)
        from = to3 = (to3 <= line.to ? line : state.doc.lineAt(to3)).to;
      let cx2 = new IndentContext(state, { simulateBreak: from, simulateDoubleBreak: !!explode });
      let indent = getIndentation(cx2, from);
      if (indent == null)
        indent = countColumn(/^\s*/.exec(state.doc.lineAt(from).text)[0], state.tabSize);
      while (to3 < line.to && /\s/.test(line.text[to3 - line.from]))
        to3++;
      if (explode)
        ({ from, to: to3 } = explode);
      else if (from > line.from && from < line.from + 100 && !/\S/.test(line.text.slice(0, from)))
        from = line.from;
      let insert2 = ["", indentString(state, indent)];
      if (explode)
        insert2.push(indentString(state, cx2.lineIndent(line.from, -1)));
      return {
        changes: { from, to: to3, insert: Text.of(insert2) },
        range: EditorSelection.cursor(from + 1 + insert2[1].length)
      };
    });
    dispatch(state.update(changes, { scrollIntoView: true, userEvent: "input" }));
    return true;
  };
}
function changeBySelectedLine(state, f) {
  let atLine = -1;
  return state.changeByRange((range) => {
    let changes = [];
    for (let pos = range.from; pos <= range.to; ) {
      let line = state.doc.lineAt(pos);
      if (line.number > atLine && (range.empty || range.to > line.from)) {
        f(line, changes, range);
        atLine = line.number;
      }
      pos = line.to + 1;
    }
    let changeSet = state.changes(changes);
    return {
      changes,
      range: EditorSelection.range(changeSet.mapPos(range.anchor, 1), changeSet.mapPos(range.head, 1))
    };
  });
}
var indentSelection = ({ state, dispatch }) => {
  if (state.readOnly)
    return false;
  let updated = /* @__PURE__ */ Object.create(null);
  let context = new IndentContext(state, { overrideIndentation: (start) => {
    let found = updated[start];
    return found == null ? -1 : found;
  } });
  let changes = changeBySelectedLine(state, (line, changes2, range) => {
    let indent = getIndentation(context, line.from);
    if (indent == null)
      return;
    if (!/\S/.test(line.text))
      indent = 0;
    let cur2 = /^\s*/.exec(line.text)[0];
    let norm = indentString(state, indent);
    if (cur2 != norm || range.from < line.from + cur2.length) {
      updated[line.from] = indent;
      changes2.push({ from: line.from, to: line.from + cur2.length, insert: norm });
    }
  });
  if (!changes.changes.empty)
    dispatch(state.update(changes, { userEvent: "indent" }));
  return true;
};
var indentMore = ({ state, dispatch }) => {
  if (state.readOnly)
    return false;
  dispatch(state.update(changeBySelectedLine(state, (line, changes) => {
    changes.push({ from: line.from, insert: state.facet(indentUnit) });
  }), { userEvent: "input.indent" }));
  return true;
};
var indentLess = ({ state, dispatch }) => {
  if (state.readOnly)
    return false;
  dispatch(state.update(changeBySelectedLine(state, (line, changes) => {
    let space = /^\s*/.exec(line.text)[0];
    if (!space)
      return;
    let col = countColumn(space, state.tabSize), keep = 0;
    let insert2 = indentString(state, Math.max(0, col - getIndentUnit(state)));
    while (keep < space.length && keep < insert2.length && space.charCodeAt(keep) == insert2.charCodeAt(keep))
      keep++;
    changes.push({ from: line.from + keep, to: line.from + space.length, insert: insert2.slice(keep) });
  }), { userEvent: "delete.dedent" }));
  return true;
};
var toggleTabFocusMode = (view) => {
  view.setTabFocusMode();
  return true;
};
var emacsStyleKeymap = [
  { key: "Ctrl-b", run: cursorCharLeft, shift: selectCharLeft, preventDefault: true },
  { key: "Ctrl-f", run: cursorCharRight, shift: selectCharRight },
  { key: "Ctrl-p", run: cursorLineUp, shift: selectLineUp },
  { key: "Ctrl-n", run: cursorLineDown, shift: selectLineDown },
  { key: "Ctrl-a", run: cursorLineStart, shift: selectLineStart },
  { key: "Ctrl-e", run: cursorLineEnd, shift: selectLineEnd },
  { key: "Ctrl-d", run: deleteCharForward },
  { key: "Ctrl-h", run: deleteCharBackward },
  { key: "Ctrl-k", run: deleteToLineEnd },
  { key: "Ctrl-Alt-h", run: deleteGroupBackward },
  { key: "Ctrl-o", run: splitLine },
  { key: "Ctrl-t", run: transposeChars },
  { key: "Ctrl-v", run: cursorPageDown }
];
var standardKeymap = [
  { key: "ArrowLeft", run: cursorCharLeft, shift: selectCharLeft, preventDefault: true },
  { key: "Mod-ArrowLeft", mac: "Alt-ArrowLeft", run: cursorGroupLeft, shift: selectGroupLeft, preventDefault: true },
  { mac: "Cmd-ArrowLeft", run: cursorLineBoundaryLeft, shift: selectLineBoundaryLeft, preventDefault: true },
  { key: "ArrowRight", run: cursorCharRight, shift: selectCharRight, preventDefault: true },
  { key: "Mod-ArrowRight", mac: "Alt-ArrowRight", run: cursorGroupRight, shift: selectGroupRight, preventDefault: true },
  { mac: "Cmd-ArrowRight", run: cursorLineBoundaryRight, shift: selectLineBoundaryRight, preventDefault: true },
  { key: "ArrowUp", run: cursorLineUp, shift: selectLineUp, preventDefault: true },
  { mac: "Cmd-ArrowUp", run: cursorDocStart, shift: selectDocStart },
  { mac: "Ctrl-ArrowUp", run: cursorPageUp, shift: selectPageUp },
  { key: "ArrowDown", run: cursorLineDown, shift: selectLineDown, preventDefault: true },
  { mac: "Cmd-ArrowDown", run: cursorDocEnd, shift: selectDocEnd },
  { mac: "Ctrl-ArrowDown", run: cursorPageDown, shift: selectPageDown },
  { key: "PageUp", run: cursorPageUp, shift: selectPageUp },
  { key: "PageDown", run: cursorPageDown, shift: selectPageDown },
  { key: "Home", run: cursorLineBoundaryBackward, shift: selectLineBoundaryBackward, preventDefault: true },
  { key: "Mod-Home", run: cursorDocStart, shift: selectDocStart },
  { key: "End", run: cursorLineBoundaryForward, shift: selectLineBoundaryForward, preventDefault: true },
  { key: "Mod-End", run: cursorDocEnd, shift: selectDocEnd },
  { key: "Enter", run: insertNewlineAndIndent, shift: insertNewlineAndIndent },
  { key: "Mod-a", run: selectAll },
  { key: "Backspace", run: deleteCharBackward, shift: deleteCharBackward },
  { key: "Delete", run: deleteCharForward },
  { key: "Mod-Backspace", mac: "Alt-Backspace", run: deleteGroupBackward },
  { key: "Mod-Delete", mac: "Alt-Delete", run: deleteGroupForward },
  { mac: "Mod-Backspace", run: deleteLineBoundaryBackward },
  { mac: "Mod-Delete", run: deleteLineBoundaryForward }
].concat(emacsStyleKeymap.map((b2) => ({ mac: b2.key, run: b2.run, shift: b2.shift })));
var defaultKeymap = [
  { key: "Alt-ArrowLeft", mac: "Ctrl-ArrowLeft", run: cursorSyntaxLeft, shift: selectSyntaxLeft },
  { key: "Alt-ArrowRight", mac: "Ctrl-ArrowRight", run: cursorSyntaxRight, shift: selectSyntaxRight },
  { key: "Alt-ArrowUp", run: moveLineUp },
  { key: "Shift-Alt-ArrowUp", run: copyLineUp },
  { key: "Alt-ArrowDown", run: moveLineDown },
  { key: "Shift-Alt-ArrowDown", run: copyLineDown },
  { key: "Escape", run: simplifySelection },
  { key: "Mod-Enter", run: insertBlankLine },
  { key: "Alt-l", mac: "Ctrl-l", run: selectLine },
  { key: "Mod-i", run: selectParentSyntax, preventDefault: true },
  { key: "Mod-[", run: indentLess },
  { key: "Mod-]", run: indentMore },
  { key: "Mod-Alt-\\", run: indentSelection },
  { key: "Shift-Mod-k", run: deleteLine },
  { key: "Shift-Mod-\\", run: cursorMatchingBracket },
  { key: "Mod-/", run: toggleComment },
  { key: "Alt-A", run: toggleBlockComment },
  { key: "Ctrl-m", mac: "Shift-Alt-m", run: toggleTabFocusMode }
].concat(standardKeymap);
var indentWithTab = { key: "Tab", run: indentMore, shift: indentLess };

// node_modules/crelt/index.js
function crelt() {
  var elt = arguments[0];
  if (typeof elt == "string") elt = document.createElement(elt);
  var i2 = 1, next = arguments[1];
  if (next && typeof next == "object" && next.nodeType == null && !Array.isArray(next)) {
    for (var name2 in next) if (Object.prototype.hasOwnProperty.call(next, name2)) {
      var value = next[name2];
      if (typeof value == "string") elt.setAttribute(name2, value);
      else if (value != null) elt[name2] = value;
    }
    i2++;
  }
  for (; i2 < arguments.length; i2++) add2(elt, arguments[i2]);
  return elt;
}
function add2(elt, child) {
  if (typeof child == "string") {
    elt.appendChild(document.createTextNode(child));
  } else if (child == null) {
  } else if (child.nodeType != null) {
    elt.appendChild(child);
  } else if (Array.isArray(child)) {
    for (var i2 = 0; i2 < child.length; i2++) add2(elt, child[i2]);
  } else {
    throw new RangeError("Unsupported child node: " + child);
  }
}

// node_modules/@codemirror/lint/dist/index.js
var SelectedDiagnostic = class {
  constructor(from, to3, diagnostic) {
    this.from = from;
    this.to = to3;
    this.diagnostic = diagnostic;
  }
};
var LintState = class _LintState {
  constructor(diagnostics, panel, selected) {
    this.diagnostics = diagnostics;
    this.panel = panel;
    this.selected = selected;
  }
  static init(diagnostics, panel, state) {
    let markedDiagnostics = diagnostics;
    let diagnosticFilter = state.facet(lintConfig).markerFilter;
    if (diagnosticFilter)
      markedDiagnostics = diagnosticFilter(markedDiagnostics, state);
    let ranges = Decoration.set(markedDiagnostics.map((d) => {
      return d.from == d.to || d.from == d.to - 1 && state.doc.lineAt(d.from).to == d.from ? Decoration.widget({
        widget: new DiagnosticWidget(d),
        diagnostic: d
      }).range(d.from) : Decoration.mark({
        attributes: { class: "cm-lintRange cm-lintRange-" + d.severity + (d.markClass ? " " + d.markClass : "") },
        diagnostic: d
      }).range(d.from, d.to);
    }), true);
    return new _LintState(ranges, panel, findDiagnostic(ranges));
  }
};
function findDiagnostic(diagnostics, diagnostic = null, after = 0) {
  let found = null;
  diagnostics.between(after, 1e9, (from, to3, { spec }) => {
    if (diagnostic && spec.diagnostic != diagnostic)
      return;
    found = new SelectedDiagnostic(from, to3, spec.diagnostic);
    return false;
  });
  return found;
}
function hideTooltip(tr3, tooltip) {
  let from = tooltip.pos, to3 = tooltip.end || from;
  let result = tr3.state.facet(lintConfig).hideOn(tr3, from, to3);
  if (result != null)
    return result;
  let line = tr3.startState.doc.lineAt(tooltip.pos);
  return !!(tr3.effects.some((e2) => e2.is(setDiagnosticsEffect)) || tr3.changes.touchesRange(line.from, Math.max(line.to, to3)));
}
function maybeEnableLint(state, effects) {
  return state.field(lintState, false) ? effects : effects.concat(StateEffect.appendConfig.of(lintExtensions));
}
function setDiagnostics(state, diagnostics) {
  return {
    effects: maybeEnableLint(state, [setDiagnosticsEffect.of(diagnostics)])
  };
}
var setDiagnosticsEffect = StateEffect.define();
var togglePanel = StateEffect.define();
var movePanelSelection = StateEffect.define();
var lintState = StateField.define({
  create() {
    return new LintState(Decoration.none, null, null);
  },
  update(value, tr3) {
    if (tr3.docChanged && value.diagnostics.size) {
      let mapped = value.diagnostics.map(tr3.changes), selected = null, panel = value.panel;
      if (value.selected) {
        let selPos = tr3.changes.mapPos(value.selected.from, 1);
        selected = findDiagnostic(mapped, value.selected.diagnostic, selPos) || findDiagnostic(mapped, null, selPos);
      }
      if (!mapped.size && panel && tr3.state.facet(lintConfig).autoPanel)
        panel = null;
      value = new LintState(mapped, panel, selected);
    }
    for (let effect of tr3.effects) {
      if (effect.is(setDiagnosticsEffect)) {
        let panel = !tr3.state.facet(lintConfig).autoPanel ? value.panel : effect.value.length ? LintPanel.open : null;
        value = LintState.init(effect.value, panel, tr3.state);
      } else if (effect.is(togglePanel)) {
        value = new LintState(value.diagnostics, effect.value ? LintPanel.open : null, value.selected);
      } else if (effect.is(movePanelSelection)) {
        value = new LintState(value.diagnostics, value.panel, effect.value);
      }
    }
    return value;
  },
  provide: (f) => [
    showPanel.from(f, (val) => val.panel),
    EditorView.decorations.from(f, (s2) => s2.diagnostics)
  ]
});
var activeMark = Decoration.mark({ class: "cm-lintRange cm-lintRange-active" });
function lintTooltip(view, pos, side) {
  let { diagnostics } = view.state.field(lintState);
  let found = [], stackStart = 2e8, stackEnd = 0;
  diagnostics.between(pos - (side < 0 ? 1 : 0), pos + (side > 0 ? 1 : 0), (from, to3, { spec }) => {
    if (pos >= from && pos <= to3 && (from == to3 || (pos > from || side > 0) && (pos < to3 || side < 0))) {
      found.push(spec.diagnostic);
      stackStart = Math.min(from, stackStart);
      stackEnd = Math.max(to3, stackEnd);
    }
  });
  let diagnosticFilter = view.state.facet(lintConfig).tooltipFilter;
  if (diagnosticFilter)
    found = diagnosticFilter(found, view.state);
  if (!found.length)
    return null;
  return {
    pos: stackStart,
    end: stackEnd,
    above: view.state.doc.lineAt(stackStart).to < stackEnd,
    create() {
      return { dom: diagnosticsTooltip(view, found) };
    }
  };
}
function diagnosticsTooltip(view, diagnostics) {
  return crelt("ul", { class: "cm-tooltip-lint" }, diagnostics.map((d) => renderDiagnostic(view, d, false)));
}
var openLintPanel = (view) => {
  let field = view.state.field(lintState, false);
  if (!field || !field.panel)
    view.dispatch({ effects: maybeEnableLint(view.state, [togglePanel.of(true)]) });
  let panel = getPanel(view, LintPanel.open);
  if (panel)
    panel.dom.querySelector(".cm-panel-lint ul").focus();
  return true;
};
var closeLintPanel = (view) => {
  let field = view.state.field(lintState, false);
  if (!field || !field.panel)
    return false;
  view.dispatch({ effects: togglePanel.of(false) });
  return true;
};
var nextDiagnostic = (view) => {
  let field = view.state.field(lintState, false);
  if (!field)
    return false;
  let sel = view.state.selection.main, next = field.diagnostics.iter(sel.to + 1);
  if (!next.value) {
    next = field.diagnostics.iter(0);
    if (!next.value || next.from == sel.from && next.to == sel.to)
      return false;
  }
  view.dispatch({ selection: { anchor: next.from, head: next.to }, scrollIntoView: true });
  return true;
};
var lintKeymap = [
  { key: "Mod-Shift-m", run: openLintPanel, preventDefault: true },
  { key: "F8", run: nextDiagnostic }
];
var lintPlugin = ViewPlugin.fromClass(class {
  constructor(view) {
    this.view = view;
    this.timeout = -1;
    this.set = true;
    let { delay } = view.state.facet(lintConfig);
    this.lintTime = Date.now() + delay;
    this.run = this.run.bind(this);
    this.timeout = setTimeout(this.run, delay);
  }
  run() {
    clearTimeout(this.timeout);
    let now = Date.now();
    if (now < this.lintTime - 10) {
      this.timeout = setTimeout(this.run, this.lintTime - now);
    } else {
      this.set = false;
      let { state } = this.view, { sources } = state.facet(lintConfig);
      if (sources.length)
        batchResults(sources.map((s2) => Promise.resolve(s2(this.view))), (annotations) => {
          if (this.view.state.doc == state.doc)
            this.view.dispatch(setDiagnostics(this.view.state, annotations.reduce((a2, b2) => a2.concat(b2))));
        }, (error) => {
          logException(this.view.state, error);
        });
    }
  }
  update(update) {
    let config2 = update.state.facet(lintConfig);
    if (update.docChanged || config2 != update.startState.facet(lintConfig) || config2.needsRefresh && config2.needsRefresh(update)) {
      this.lintTime = Date.now() + config2.delay;
      if (!this.set) {
        this.set = true;
        this.timeout = setTimeout(this.run, config2.delay);
      }
    }
  }
  force() {
    if (this.set) {
      this.lintTime = Date.now();
      this.run();
    }
  }
  destroy() {
    clearTimeout(this.timeout);
  }
});
function batchResults(promises, sink, error) {
  let collected = [], timeout = -1;
  for (let p of promises)
    p.then((value) => {
      collected.push(value);
      clearTimeout(timeout);
      if (collected.length == promises.length)
        sink(collected);
      else
        setTimeout(() => sink(collected), 200);
    }, error);
}
var lintConfig = Facet.define({
  combine(input) {
    return Object.assign({ sources: input.map((i2) => i2.source).filter((x) => x != null) }, combineConfig(input.map((i2) => i2.config), {
      delay: 750,
      markerFilter: null,
      tooltipFilter: null,
      needsRefresh: null,
      hideOn: () => null
    }, {
      needsRefresh: (a2, b2) => !a2 ? b2 : !b2 ? a2 : (u) => a2(u) || b2(u)
    }));
  }
});
function linter(source, config2 = {}) {
  return [
    lintConfig.of({ source, config: config2 }),
    lintPlugin,
    lintExtensions
  ];
}
function assignKeys(actions) {
  let assigned = [];
  if (actions)
    actions: for (let { name: name2 } of actions) {
      for (let i2 = 0; i2 < name2.length; i2++) {
        let ch2 = name2[i2];
        if (/[a-zA-Z]/.test(ch2) && !assigned.some((c) => c.toLowerCase() == ch2.toLowerCase())) {
          assigned.push(ch2);
          continue actions;
        }
      }
      assigned.push("");
    }
  return assigned;
}
function renderDiagnostic(view, diagnostic, inPanel) {
  var _a4;
  let keys2 = inPanel ? assignKeys(diagnostic.actions) : [];
  return crelt("li", { class: "cm-diagnostic cm-diagnostic-" + diagnostic.severity }, crelt("span", { class: "cm-diagnosticText" }, diagnostic.renderMessage ? diagnostic.renderMessage(view) : diagnostic.message), (_a4 = diagnostic.actions) === null || _a4 === void 0 ? void 0 : _a4.map((action, i2) => {
    let fired = false, click = (e2) => {
      e2.preventDefault();
      if (fired)
        return;
      fired = true;
      let found = findDiagnostic(view.state.field(lintState).diagnostics, diagnostic);
      if (found)
        action.apply(view, found.from, found.to);
    };
    let { name: name2 } = action, keyIndex = keys2[i2] ? name2.indexOf(keys2[i2]) : -1;
    let nameElt = keyIndex < 0 ? name2 : [
      name2.slice(0, keyIndex),
      crelt("u", name2.slice(keyIndex, keyIndex + 1)),
      name2.slice(keyIndex + 1)
    ];
    return crelt("button", {
      type: "button",
      class: "cm-diagnosticAction",
      onclick: click,
      onmousedown: click,
      "aria-label": ` Action: ${name2}${keyIndex < 0 ? "" : ` (access key "${keys2[i2]})"`}.`
    }, nameElt);
  }), diagnostic.source && crelt("div", { class: "cm-diagnosticSource" }, diagnostic.source));
}
var DiagnosticWidget = class extends WidgetType {
  constructor(diagnostic) {
    super();
    this.diagnostic = diagnostic;
  }
  eq(other) {
    return other.diagnostic == this.diagnostic;
  }
  toDOM() {
    return crelt("span", { class: "cm-lintPoint cm-lintPoint-" + this.diagnostic.severity });
  }
};
var PanelItem = class {
  constructor(view, diagnostic) {
    this.diagnostic = diagnostic;
    this.id = "item_" + Math.floor(Math.random() * 4294967295).toString(16);
    this.dom = renderDiagnostic(view, diagnostic, true);
    this.dom.id = this.id;
    this.dom.setAttribute("role", "option");
  }
};
var LintPanel = class _LintPanel {
  constructor(view) {
    this.view = view;
    this.items = [];
    let onkeydown = (event) => {
      if (event.keyCode == 27) {
        closeLintPanel(this.view);
        this.view.focus();
      } else if (event.keyCode == 38 || event.keyCode == 33) {
        this.moveSelection((this.selectedIndex - 1 + this.items.length) % this.items.length);
      } else if (event.keyCode == 40 || event.keyCode == 34) {
        this.moveSelection((this.selectedIndex + 1) % this.items.length);
      } else if (event.keyCode == 36) {
        this.moveSelection(0);
      } else if (event.keyCode == 35) {
        this.moveSelection(this.items.length - 1);
      } else if (event.keyCode == 13) {
        this.view.focus();
      } else if (event.keyCode >= 65 && event.keyCode <= 90 && this.selectedIndex >= 0) {
        let { diagnostic } = this.items[this.selectedIndex], keys2 = assignKeys(diagnostic.actions);
        for (let i2 = 0; i2 < keys2.length; i2++)
          if (keys2[i2].toUpperCase().charCodeAt(0) == event.keyCode) {
            let found = findDiagnostic(this.view.state.field(lintState).diagnostics, diagnostic);
            if (found)
              diagnostic.actions[i2].apply(view, found.from, found.to);
          }
      } else {
        return;
      }
      event.preventDefault();
    };
    let onclick = (event) => {
      for (let i2 = 0; i2 < this.items.length; i2++) {
        if (this.items[i2].dom.contains(event.target))
          this.moveSelection(i2);
      }
    };
    this.list = crelt("ul", {
      tabIndex: 0,
      role: "listbox",
      "aria-label": this.view.state.phrase("Diagnostics"),
      onkeydown,
      onclick
    });
    this.dom = crelt("div", { class: "cm-panel-lint" }, this.list, crelt("button", {
      type: "button",
      name: "close",
      "aria-label": this.view.state.phrase("close"),
      onclick: () => closeLintPanel(this.view)
    }, "×"));
    this.update();
  }
  get selectedIndex() {
    let selected = this.view.state.field(lintState).selected;
    if (!selected)
      return -1;
    for (let i2 = 0; i2 < this.items.length; i2++)
      if (this.items[i2].diagnostic == selected.diagnostic)
        return i2;
    return -1;
  }
  update() {
    let { diagnostics, selected } = this.view.state.field(lintState);
    let i2 = 0, needsSync = false, newSelectedItem = null;
    diagnostics.between(0, this.view.state.doc.length, (_start, _end, { spec }) => {
      let found = -1, item;
      for (let j = i2; j < this.items.length; j++)
        if (this.items[j].diagnostic == spec.diagnostic) {
          found = j;
          break;
        }
      if (found < 0) {
        item = new PanelItem(this.view, spec.diagnostic);
        this.items.splice(i2, 0, item);
        needsSync = true;
      } else {
        item = this.items[found];
        if (found > i2) {
          this.items.splice(i2, found - i2);
          needsSync = true;
        }
      }
      if (selected && item.diagnostic == selected.diagnostic) {
        if (!item.dom.hasAttribute("aria-selected")) {
          item.dom.setAttribute("aria-selected", "true");
          newSelectedItem = item;
        }
      } else if (item.dom.hasAttribute("aria-selected")) {
        item.dom.removeAttribute("aria-selected");
      }
      i2++;
    });
    while (i2 < this.items.length && !(this.items.length == 1 && this.items[0].diagnostic.from < 0)) {
      needsSync = true;
      this.items.pop();
    }
    if (this.items.length == 0) {
      this.items.push(new PanelItem(this.view, {
        from: -1,
        to: -1,
        severity: "info",
        message: this.view.state.phrase("No diagnostics")
      }));
      needsSync = true;
    }
    if (newSelectedItem) {
      this.list.setAttribute("aria-activedescendant", newSelectedItem.id);
      this.view.requestMeasure({
        key: this,
        read: () => ({ sel: newSelectedItem.dom.getBoundingClientRect(), panel: this.list.getBoundingClientRect() }),
        write: ({ sel, panel }) => {
          let scaleY = panel.height / this.list.offsetHeight;
          if (sel.top < panel.top)
            this.list.scrollTop -= (panel.top - sel.top) / scaleY;
          else if (sel.bottom > panel.bottom)
            this.list.scrollTop += (sel.bottom - panel.bottom) / scaleY;
        }
      });
    } else if (this.selectedIndex < 0) {
      this.list.removeAttribute("aria-activedescendant");
    }
    if (needsSync)
      this.sync();
  }
  sync() {
    let domPos = this.list.firstChild;
    function rm3() {
      let prev = domPos;
      domPos = prev.nextSibling;
      prev.remove();
    }
    for (let item of this.items) {
      if (item.dom.parentNode == this.list) {
        while (domPos != item.dom)
          rm3();
        domPos = item.dom.nextSibling;
      } else {
        this.list.insertBefore(item.dom, domPos);
      }
    }
    while (domPos)
      rm3();
  }
  moveSelection(selectedIndex) {
    if (this.selectedIndex < 0)
      return;
    let field = this.view.state.field(lintState);
    let selection = findDiagnostic(field.diagnostics, this.items[selectedIndex].diagnostic);
    if (!selection)
      return;
    this.view.dispatch({
      selection: { anchor: selection.from, head: selection.to },
      scrollIntoView: true,
      effects: movePanelSelection.of(selection)
    });
  }
  static open(view) {
    return new _LintPanel(view);
  }
};
function svg(content2, attrs = `viewBox="0 0 40 40"`) {
  return `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" ${attrs}>${encodeURIComponent(content2)}</svg>')`;
}
function underline(color) {
  return svg(`<path d="m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0" stroke="${color}" fill="none" stroke-width=".7"/>`, `width="6" height="3"`);
}
var baseTheme3 = EditorView.baseTheme({
  ".cm-diagnostic": {
    padding: "3px 6px 3px 8px",
    marginLeft: "-1px",
    display: "block",
    whiteSpace: "pre-wrap"
  },
  ".cm-diagnostic-error": { borderLeft: "5px solid #d11" },
  ".cm-diagnostic-warning": { borderLeft: "5px solid orange" },
  ".cm-diagnostic-info": { borderLeft: "5px solid #999" },
  ".cm-diagnostic-hint": { borderLeft: "5px solid #66d" },
  ".cm-diagnosticAction": {
    font: "inherit",
    border: "none",
    padding: "2px 4px",
    backgroundColor: "#444",
    color: "white",
    borderRadius: "3px",
    marginLeft: "8px",
    cursor: "pointer"
  },
  ".cm-diagnosticSource": {
    fontSize: "70%",
    opacity: 0.7
  },
  ".cm-lintRange": {
    backgroundPosition: "left bottom",
    backgroundRepeat: "repeat-x",
    paddingBottom: "0.7px"
  },
  ".cm-lintRange-error": { backgroundImage: underline("#d11") },
  ".cm-lintRange-warning": { backgroundImage: underline("orange") },
  ".cm-lintRange-info": { backgroundImage: underline("#999") },
  ".cm-lintRange-hint": { backgroundImage: underline("#66d") },
  ".cm-lintRange-active": { backgroundColor: "#ffdd9980" },
  ".cm-tooltip-lint": {
    padding: 0,
    margin: 0
  },
  ".cm-lintPoint": {
    position: "relative",
    "&:after": {
      content: '""',
      position: "absolute",
      bottom: 0,
      left: "-2px",
      borderLeft: "3px solid transparent",
      borderRight: "3px solid transparent",
      borderBottom: "4px solid #d11"
    }
  },
  ".cm-lintPoint-warning": {
    "&:after": { borderBottomColor: "orange" }
  },
  ".cm-lintPoint-info": {
    "&:after": { borderBottomColor: "#999" }
  },
  ".cm-lintPoint-hint": {
    "&:after": { borderBottomColor: "#66d" }
  },
  ".cm-panel.cm-panel-lint": {
    position: "relative",
    "& ul": {
      maxHeight: "100px",
      overflowY: "auto",
      "& [aria-selected]": {
        backgroundColor: "#ddd",
        "& u": { textDecoration: "underline" }
      },
      "&:focus [aria-selected]": {
        background_fallback: "#bdf",
        backgroundColor: "Highlight",
        color_fallback: "white",
        color: "HighlightText"
      },
      "& u": { textDecoration: "none" },
      padding: 0,
      margin: 0
    },
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "2px",
      background: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    }
  }
});
function severityWeight(sev) {
  return sev == "error" ? 4 : sev == "warning" ? 3 : sev == "info" ? 2 : 1;
}
var LintGutterMarker = class extends GutterMarker {
  constructor(diagnostics) {
    super();
    this.diagnostics = diagnostics;
    this.severity = diagnostics.reduce((max, d) => severityWeight(max) < severityWeight(d.severity) ? d.severity : max, "hint");
  }
  toDOM(view) {
    let elt = document.createElement("div");
    elt.className = "cm-lint-marker cm-lint-marker-" + this.severity;
    let diagnostics = this.diagnostics;
    let diagnosticsFilter = view.state.facet(lintGutterConfig).tooltipFilter;
    if (diagnosticsFilter)
      diagnostics = diagnosticsFilter(diagnostics, view.state);
    if (diagnostics.length)
      elt.onmouseover = () => gutterMarkerMouseOver(view, elt, diagnostics);
    return elt;
  }
};
function trackHoverOn(view, marker) {
  let mousemove = (event) => {
    let rect = marker.getBoundingClientRect();
    if (event.clientX > rect.left - 10 && event.clientX < rect.right + 10 && event.clientY > rect.top - 10 && event.clientY < rect.bottom + 10)
      return;
    for (let target = event.target; target; target = target.parentNode) {
      if (target.nodeType == 1 && target.classList.contains("cm-tooltip-lint"))
        return;
    }
    window.removeEventListener("mousemove", mousemove);
    if (view.state.field(lintGutterTooltip))
      view.dispatch({ effects: setLintGutterTooltip.of(null) });
  };
  window.addEventListener("mousemove", mousemove);
}
function gutterMarkerMouseOver(view, marker, diagnostics) {
  function hovered() {
    let line = view.elementAtHeight(marker.getBoundingClientRect().top + 5 - view.documentTop);
    const linePos = view.coordsAtPos(line.from);
    if (linePos) {
      view.dispatch({ effects: setLintGutterTooltip.of({
        pos: line.from,
        above: false,
        create() {
          return {
            dom: diagnosticsTooltip(view, diagnostics),
            getCoords: () => marker.getBoundingClientRect()
          };
        }
      }) });
    }
    marker.onmouseout = marker.onmousemove = null;
    trackHoverOn(view, marker);
  }
  let { hoverTime } = view.state.facet(lintGutterConfig);
  let hoverTimeout = setTimeout(hovered, hoverTime);
  marker.onmouseout = () => {
    clearTimeout(hoverTimeout);
    marker.onmouseout = marker.onmousemove = null;
  };
  marker.onmousemove = () => {
    clearTimeout(hoverTimeout);
    hoverTimeout = setTimeout(hovered, hoverTime);
  };
}
function markersForDiagnostics(doc2, diagnostics) {
  let byLine = /* @__PURE__ */ Object.create(null);
  for (let diagnostic of diagnostics) {
    let line = doc2.lineAt(diagnostic.from);
    (byLine[line.from] || (byLine[line.from] = [])).push(diagnostic);
  }
  let markers = [];
  for (let line in byLine) {
    markers.push(new LintGutterMarker(byLine[line]).range(+line));
  }
  return RangeSet.of(markers, true);
}
var lintGutterExtension = gutter({
  class: "cm-gutter-lint",
  markers: (view) => view.state.field(lintGutterMarkers),
  widgetMarker: (view, widget, block) => {
    let diagnostics = [];
    view.state.field(lintGutterMarkers).between(block.from, block.to, (from, to3, value) => {
      diagnostics.push(...value.diagnostics);
    });
    return diagnostics.length ? new LintGutterMarker(diagnostics) : null;
  }
});
var lintGutterMarkers = StateField.define({
  create() {
    return RangeSet.empty;
  },
  update(markers, tr3) {
    markers = markers.map(tr3.changes);
    let diagnosticFilter = tr3.state.facet(lintGutterConfig).markerFilter;
    for (let effect of tr3.effects) {
      if (effect.is(setDiagnosticsEffect)) {
        let diagnostics = effect.value;
        if (diagnosticFilter)
          diagnostics = diagnosticFilter(diagnostics || [], tr3.state);
        markers = markersForDiagnostics(tr3.state.doc, diagnostics.slice(0));
      }
    }
    return markers;
  }
});
var setLintGutterTooltip = StateEffect.define();
var lintGutterTooltip = StateField.define({
  create() {
    return null;
  },
  update(tooltip, tr3) {
    if (tooltip && tr3.docChanged)
      tooltip = hideTooltip(tr3, tooltip) ? null : Object.assign(Object.assign({}, tooltip), { pos: tr3.changes.mapPos(tooltip.pos) });
    return tr3.effects.reduce((t3, e2) => e2.is(setLintGutterTooltip) ? e2.value : t3, tooltip);
  },
  provide: (field) => showTooltip.from(field)
});
var lintGutterTheme = EditorView.baseTheme({
  ".cm-gutter-lint": {
    width: "1.4em",
    "& .cm-gutterElement": {
      padding: ".2em"
    }
  },
  ".cm-lint-marker": {
    width: "1em",
    height: "1em"
  },
  ".cm-lint-marker-info": {
    content: svg(`<path fill="#aaf" stroke="#77e" stroke-width="6" stroke-linejoin="round" d="M5 5L35 5L35 35L5 35Z"/>`)
  },
  ".cm-lint-marker-warning": {
    content: svg(`<path fill="#fe8" stroke="#fd7" stroke-width="6" stroke-linejoin="round" d="M20 6L37 35L3 35Z"/>`)
  },
  ".cm-lint-marker-error": {
    content: svg(`<circle cx="20" cy="20" r="15" fill="#f87" stroke="#f43" stroke-width="6"/>`)
  }
});
var lintExtensions = [
  lintState,
  EditorView.decorations.compute([lintState], (state) => {
    let { selected, panel } = state.field(lintState);
    return !selected || !panel || selected.from == selected.to ? Decoration.none : Decoration.set([
      activeMark.range(selected.from, selected.to)
    ]);
  }),
  hoverTooltip(lintTooltip, { hideOn: hideTooltip }),
  baseTheme3
];
var lintGutterConfig = Facet.define({
  combine(configs) {
    return combineConfig(configs, {
      hoverTime: 300,
      markerFilter: null,
      tooltipFilter: null
    });
  }
});
function lintGutter(config2 = {}) {
  return [lintGutterConfig.of(config2), lintGutterMarkers, lintGutterExtension, lintGutterTheme, lintGutterTooltip];
}

// node_modules/@lezer/lr/dist/index.js
var Stack = class _Stack {
  /**
  @internal
  */
  constructor(p, stack, state, reducePos, pos, score2, buffer, bufferBase, curContext, lookAhead = 0, parent) {
    this.p = p;
    this.stack = stack;
    this.state = state;
    this.reducePos = reducePos;
    this.pos = pos;
    this.score = score2;
    this.buffer = buffer;
    this.bufferBase = bufferBase;
    this.curContext = curContext;
    this.lookAhead = lookAhead;
    this.parent = parent;
  }
  /**
  @internal
  */
  toString() {
    return `[${this.stack.filter((_2, i2) => i2 % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? "!" + this.score : ""}`;
  }
  // Start an empty stack
  /**
  @internal
  */
  static start(p, state, pos = 0) {
    let cx2 = p.parser.context;
    return new _Stack(p, [], state, pos, pos, 0, [], 0, cx2 ? new StackContext(cx2, cx2.start) : null, 0, null);
  }
  /**
  The stack's current [context](#lr.ContextTracker) value, if
  any. Its type will depend on the context tracker's type
  parameter, or it will be `null` if there is no context
  tracker.
  */
  get context() {
    return this.curContext ? this.curContext.context : null;
  }
  // Push a state onto the stack, tracking its start position as well
  // as the buffer base at that point.
  /**
  @internal
  */
  pushState(state, start) {
    this.stack.push(this.state, start, this.bufferBase + this.buffer.length);
    this.state = state;
  }
  // Apply a reduce action
  /**
  @internal
  */
  reduce(action) {
    var _a4;
    let depth2 = action >> 19, type = action & 65535;
    let { parser: parser2 } = this.p;
    let lookaheadRecord = this.reducePos < this.pos - 25;
    if (lookaheadRecord)
      this.setLookAhead(this.pos);
    let dPrec = parser2.dynamicPrecedence(type);
    if (dPrec)
      this.score += dPrec;
    if (depth2 == 0) {
      this.pushState(parser2.getGoto(this.state, type, true), this.reducePos);
      if (type < parser2.minRepeatTerm)
        this.storeNode(type, this.reducePos, this.reducePos, lookaheadRecord ? 8 : 4, true);
      this.reduceContext(type, this.reducePos);
      return;
    }
    let base2 = this.stack.length - (depth2 - 1) * 3 - (action & 262144 ? 6 : 0);
    let start = base2 ? this.stack[base2 - 2] : this.p.ranges[0].from, size = this.reducePos - start;
    if (size >= 2e3 && !((_a4 = this.p.parser.nodeSet.types[type]) === null || _a4 === void 0 ? void 0 : _a4.isAnonymous)) {
      if (start == this.p.lastBigReductionStart) {
        this.p.bigReductionCount++;
        this.p.lastBigReductionSize = size;
      } else if (this.p.lastBigReductionSize < size) {
        this.p.bigReductionCount = 1;
        this.p.lastBigReductionStart = start;
        this.p.lastBigReductionSize = size;
      }
    }
    let bufferBase = base2 ? this.stack[base2 - 1] : 0, count = this.bufferBase + this.buffer.length - bufferBase;
    if (type < parser2.minRepeatTerm || action & 131072) {
      let pos = parser2.stateFlag(
        this.state,
        1
        /* StateFlag.Skipped */
      ) ? this.pos : this.reducePos;
      this.storeNode(type, start, pos, count + 4, true);
    }
    if (action & 262144) {
      this.state = this.stack[base2];
    } else {
      let baseStateID = this.stack[base2 - 3];
      this.state = parser2.getGoto(baseStateID, type, true);
    }
    while (this.stack.length > base2)
      this.stack.pop();
    this.reduceContext(type, start);
  }
  // Shift a value into the buffer
  /**
  @internal
  */
  storeNode(term, start, end, size = 4, mustSink = false) {
    if (term == 0 && (!this.stack.length || this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)) {
      let cur2 = this, top2 = this.buffer.length;
      if (top2 == 0 && cur2.parent) {
        top2 = cur2.bufferBase - cur2.parent.bufferBase;
        cur2 = cur2.parent;
      }
      if (top2 > 0 && cur2.buffer[top2 - 4] == 0 && cur2.buffer[top2 - 1] > -1) {
        if (start == end)
          return;
        if (cur2.buffer[top2 - 2] >= start) {
          cur2.buffer[top2 - 2] = end;
          return;
        }
      }
    }
    if (!mustSink || this.pos == end) {
      this.buffer.push(term, start, end, size);
    } else {
      let index2 = this.buffer.length;
      if (index2 > 0 && this.buffer[index2 - 4] != 0) {
        let mustMove = false;
        for (let scan = index2; scan > 0 && this.buffer[scan - 2] > end; scan -= 4) {
          if (this.buffer[scan - 1] >= 0) {
            mustMove = true;
            break;
          }
        }
        if (mustMove)
          while (index2 > 0 && this.buffer[index2 - 2] > end) {
            this.buffer[index2] = this.buffer[index2 - 4];
            this.buffer[index2 + 1] = this.buffer[index2 - 3];
            this.buffer[index2 + 2] = this.buffer[index2 - 2];
            this.buffer[index2 + 3] = this.buffer[index2 - 1];
            index2 -= 4;
            if (size > 4)
              size -= 4;
          }
      }
      this.buffer[index2] = term;
      this.buffer[index2 + 1] = start;
      this.buffer[index2 + 2] = end;
      this.buffer[index2 + 3] = size;
    }
  }
  // Apply a shift action
  /**
  @internal
  */
  shift(action, type, start, end) {
    if (action & 131072) {
      this.pushState(action & 65535, this.pos);
    } else if ((action & 262144) == 0) {
      let nextState = action, { parser: parser2 } = this.p;
      if (end > this.pos || type <= parser2.maxNode) {
        this.pos = end;
        if (!parser2.stateFlag(
          nextState,
          1
          /* StateFlag.Skipped */
        ))
          this.reducePos = end;
      }
      this.pushState(nextState, start);
      this.shiftContext(type, start);
      if (type <= parser2.maxNode)
        this.buffer.push(type, start, end, 4);
    } else {
      this.pos = end;
      this.shiftContext(type, start);
      if (type <= this.p.parser.maxNode)
        this.buffer.push(type, start, end, 4);
    }
  }
  // Apply an action
  /**
  @internal
  */
  apply(action, next, nextStart, nextEnd) {
    if (action & 65536)
      this.reduce(action);
    else
      this.shift(action, next, nextStart, nextEnd);
  }
  // Add a prebuilt (reused) node into the buffer.
  /**
  @internal
  */
  useNode(value, next) {
    let index2 = this.p.reused.length - 1;
    if (index2 < 0 || this.p.reused[index2] != value) {
      this.p.reused.push(value);
      index2++;
    }
    let start = this.pos;
    this.reducePos = this.pos = start + value.length;
    this.pushState(next, start);
    this.buffer.push(
      index2,
      start,
      this.reducePos,
      -1
      /* size == -1 means this is a reused value */
    );
    if (this.curContext)
      this.updateContext(this.curContext.tracker.reuse(this.curContext.context, value, this, this.p.stream.reset(this.pos - value.length)));
  }
  // Split the stack. Due to the buffer sharing and the fact
  // that `this.stack` tends to stay quite shallow, this isn't very
  // expensive.
  /**
  @internal
  */
  split() {
    let parent = this;
    let off = parent.buffer.length;
    while (off > 0 && parent.buffer[off - 2] > parent.reducePos)
      off -= 4;
    let buffer = parent.buffer.slice(off), base2 = parent.bufferBase + off;
    while (parent && base2 == parent.bufferBase)
      parent = parent.parent;
    return new _Stack(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, buffer, base2, this.curContext, this.lookAhead, parent);
  }
  // Try to recover from an error by 'deleting' (ignoring) one token.
  /**
  @internal
  */
  recoverByDelete(next, nextEnd) {
    let isNode = next <= this.p.parser.maxNode;
    if (isNode)
      this.storeNode(next, this.pos, nextEnd, 4);
    this.storeNode(0, this.pos, nextEnd, isNode ? 8 : 4);
    this.pos = this.reducePos = nextEnd;
    this.score -= 190;
  }
  /**
  Check if the given term would be able to be shifted (optionally
  after some reductions) on this stack. This can be useful for
  external tokenizers that want to make sure they only provide a
  given token when it applies.
  */
  canShift(term) {
    for (let sim = new SimulatedStack(this); ; ) {
      let action = this.p.parser.stateSlot(
        sim.state,
        4
        /* ParseState.DefaultReduce */
      ) || this.p.parser.hasAction(sim.state, term);
      if (action == 0)
        return false;
      if ((action & 65536) == 0)
        return true;
      sim.reduce(action);
    }
  }
  // Apply up to Recover.MaxNext recovery actions that conceptually
  // inserts some missing token or rule.
  /**
  @internal
  */
  recoverByInsert(next) {
    if (this.stack.length >= 300)
      return [];
    let nextStates = this.p.parser.nextStates(this.state);
    if (nextStates.length > 4 << 1 || this.stack.length >= 120) {
      let best = [];
      for (let i2 = 0, s2; i2 < nextStates.length; i2 += 2) {
        if ((s2 = nextStates[i2 + 1]) != this.state && this.p.parser.hasAction(s2, next))
          best.push(nextStates[i2], s2);
      }
      if (this.stack.length < 120)
        for (let i2 = 0; best.length < 4 << 1 && i2 < nextStates.length; i2 += 2) {
          let s2 = nextStates[i2 + 1];
          if (!best.some((v, i3) => i3 & 1 && v == s2))
            best.push(nextStates[i2], s2);
        }
      nextStates = best;
    }
    let result = [];
    for (let i2 = 0; i2 < nextStates.length && result.length < 4; i2 += 2) {
      let s2 = nextStates[i2 + 1];
      if (s2 == this.state)
        continue;
      let stack = this.split();
      stack.pushState(s2, this.pos);
      stack.storeNode(0, stack.pos, stack.pos, 4, true);
      stack.shiftContext(nextStates[i2], this.pos);
      stack.reducePos = this.pos;
      stack.score -= 200;
      result.push(stack);
    }
    return result;
  }
  // Force a reduce, if possible. Return false if that can't
  // be done.
  /**
  @internal
  */
  forceReduce() {
    let { parser: parser2 } = this.p;
    let reduce = parser2.stateSlot(
      this.state,
      5
      /* ParseState.ForcedReduce */
    );
    if ((reduce & 65536) == 0)
      return false;
    if (!parser2.validAction(this.state, reduce)) {
      let depth2 = reduce >> 19, term = reduce & 65535;
      let target = this.stack.length - depth2 * 3;
      if (target < 0 || parser2.getGoto(this.stack[target], term, false) < 0) {
        let backup = this.findForcedReduction();
        if (backup == null)
          return false;
        reduce = backup;
      }
      this.storeNode(0, this.pos, this.pos, 4, true);
      this.score -= 100;
    }
    this.reducePos = this.pos;
    this.reduce(reduce);
    return true;
  }
  /**
  Try to scan through the automaton to find some kind of reduction
  that can be applied. Used when the regular ForcedReduce field
  isn't a valid action. @internal
  */
  findForcedReduction() {
    let { parser: parser2 } = this.p, seen = [];
    let explore = (state, depth2) => {
      if (seen.includes(state))
        return;
      seen.push(state);
      return parser2.allActions(state, (action) => {
        if (action & (262144 | 131072)) ;
        else if (action & 65536) {
          let rDepth = (action >> 19) - depth2;
          if (rDepth > 1) {
            let term = action & 65535, target = this.stack.length - rDepth * 3;
            if (target >= 0 && parser2.getGoto(this.stack[target], term, false) >= 0)
              return rDepth << 19 | 65536 | term;
          }
        } else {
          let found = explore(action, depth2 + 1);
          if (found != null)
            return found;
        }
      });
    };
    return explore(this.state, 0);
  }
  /**
  @internal
  */
  forceAll() {
    while (!this.p.parser.stateFlag(
      this.state,
      2
      /* StateFlag.Accepting */
    )) {
      if (!this.forceReduce()) {
        this.storeNode(0, this.pos, this.pos, 4, true);
        break;
      }
    }
    return this;
  }
  /**
  Check whether this state has no further actions (assumed to be a direct descendant of the
  top state, since any other states must be able to continue
  somehow). @internal
  */
  get deadEnd() {
    if (this.stack.length != 3)
      return false;
    let { parser: parser2 } = this.p;
    return parser2.data[parser2.stateSlot(
      this.state,
      1
      /* ParseState.Actions */
    )] == 65535 && !parser2.stateSlot(
      this.state,
      4
      /* ParseState.DefaultReduce */
    );
  }
  /**
  Restart the stack (put it back in its start state). Only safe
  when this.stack.length == 3 (state is directly below the top
  state). @internal
  */
  restart() {
    this.storeNode(0, this.pos, this.pos, 4, true);
    this.state = this.stack[0];
    this.stack.length = 0;
  }
  /**
  @internal
  */
  sameState(other) {
    if (this.state != other.state || this.stack.length != other.stack.length)
      return false;
    for (let i2 = 0; i2 < this.stack.length; i2 += 3)
      if (this.stack[i2] != other.stack[i2])
        return false;
    return true;
  }
  /**
  Get the parser used by this stack.
  */
  get parser() {
    return this.p.parser;
  }
  /**
  Test whether a given dialect (by numeric ID, as exported from
  the terms file) is enabled.
  */
  dialectEnabled(dialectID) {
    return this.p.parser.dialect.flags[dialectID];
  }
  shiftContext(term, start) {
    if (this.curContext)
      this.updateContext(this.curContext.tracker.shift(this.curContext.context, term, this, this.p.stream.reset(start)));
  }
  reduceContext(term, start) {
    if (this.curContext)
      this.updateContext(this.curContext.tracker.reduce(this.curContext.context, term, this, this.p.stream.reset(start)));
  }
  /**
  @internal
  */
  emitContext() {
    let last2 = this.buffer.length - 1;
    if (last2 < 0 || this.buffer[last2] != -3)
      this.buffer.push(this.curContext.hash, this.pos, this.pos, -3);
  }
  /**
  @internal
  */
  emitLookAhead() {
    let last2 = this.buffer.length - 1;
    if (last2 < 0 || this.buffer[last2] != -4)
      this.buffer.push(this.lookAhead, this.pos, this.pos, -4);
  }
  updateContext(context) {
    if (context != this.curContext.context) {
      let newCx = new StackContext(this.curContext.tracker, context);
      if (newCx.hash != this.curContext.hash)
        this.emitContext();
      this.curContext = newCx;
    }
  }
  /**
  @internal
  */
  setLookAhead(lookAhead) {
    if (lookAhead > this.lookAhead) {
      this.emitLookAhead();
      this.lookAhead = lookAhead;
    }
  }
  /**
  @internal
  */
  close() {
    if (this.curContext && this.curContext.tracker.strict)
      this.emitContext();
    if (this.lookAhead > 0)
      this.emitLookAhead();
  }
};
var StackContext = class {
  constructor(tracker, context) {
    this.tracker = tracker;
    this.context = context;
    this.hash = tracker.strict ? tracker.hash(context) : 0;
  }
};
var SimulatedStack = class {
  constructor(start) {
    this.start = start;
    this.state = start.state;
    this.stack = start.stack;
    this.base = this.stack.length;
  }
  reduce(action) {
    let term = action & 65535, depth2 = action >> 19;
    if (depth2 == 0) {
      if (this.stack == this.start.stack)
        this.stack = this.stack.slice();
      this.stack.push(this.state, 0, 0);
      this.base += 3;
    } else {
      this.base -= (depth2 - 1) * 3;
    }
    let goto = this.start.p.parser.getGoto(this.stack[this.base - 3], term, true);
    this.state = goto;
  }
};
var StackBufferCursor = class _StackBufferCursor {
  constructor(stack, pos, index2) {
    this.stack = stack;
    this.pos = pos;
    this.index = index2;
    this.buffer = stack.buffer;
    if (this.index == 0)
      this.maybeNext();
  }
  static create(stack, pos = stack.bufferBase + stack.buffer.length) {
    return new _StackBufferCursor(stack, pos, pos - stack.bufferBase);
  }
  maybeNext() {
    let next = this.stack.parent;
    if (next != null) {
      this.index = this.stack.bufferBase - next.bufferBase;
      this.stack = next;
      this.buffer = next.buffer;
    }
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  next() {
    this.index -= 4;
    this.pos -= 4;
    if (this.index == 0)
      this.maybeNext();
  }
  fork() {
    return new _StackBufferCursor(this.stack, this.pos, this.index);
  }
};
function decodeArray(input, Type = Uint16Array) {
  if (typeof input != "string")
    return input;
  let array = null;
  for (let pos = 0, out = 0; pos < input.length; ) {
    let value = 0;
    for (; ; ) {
      let next = input.charCodeAt(pos++), stop = false;
      if (next == 126) {
        value = 65535;
        break;
      }
      if (next >= 92)
        next--;
      if (next >= 34)
        next--;
      let digit = next - 32;
      if (digit >= 46) {
        digit -= 46;
        stop = true;
      }
      value += digit;
      if (stop)
        break;
      value *= 46;
    }
    if (array)
      array[out++] = value;
    else
      array = new Type(value);
  }
  return array;
}
var CachedToken = class {
  constructor() {
    this.start = -1;
    this.value = -1;
    this.end = -1;
    this.extended = -1;
    this.lookAhead = 0;
    this.mask = 0;
    this.context = 0;
  }
};
var nullToken = new CachedToken();
var InputStream = class {
  /**
  @internal
  */
  constructor(input, ranges) {
    this.input = input;
    this.ranges = ranges;
    this.chunk = "";
    this.chunkOff = 0;
    this.chunk2 = "";
    this.chunk2Pos = 0;
    this.next = -1;
    this.token = nullToken;
    this.rangeIndex = 0;
    this.pos = this.chunkPos = ranges[0].from;
    this.range = ranges[0];
    this.end = ranges[ranges.length - 1].to;
    this.readNext();
  }
  /**
  @internal
  */
  resolveOffset(offset, assoc) {
    let range = this.range, index2 = this.rangeIndex;
    let pos = this.pos + offset;
    while (pos < range.from) {
      if (!index2)
        return null;
      let next = this.ranges[--index2];
      pos -= range.from - next.to;
      range = next;
    }
    while (assoc < 0 ? pos > range.to : pos >= range.to) {
      if (index2 == this.ranges.length - 1)
        return null;
      let next = this.ranges[++index2];
      pos += next.from - range.to;
      range = next;
    }
    return pos;
  }
  /**
  @internal
  */
  clipPos(pos) {
    if (pos >= this.range.from && pos < this.range.to)
      return pos;
    for (let range of this.ranges)
      if (range.to > pos)
        return Math.max(pos, range.from);
    return this.end;
  }
  /**
  Look at a code unit near the stream position. `.peek(0)` equals
  `.next`, `.peek(-1)` gives you the previous character, and so
  on.
  
  Note that looking around during tokenizing creates dependencies
  on potentially far-away content, which may reduce the
  effectiveness incremental parsing—when looking forward—or even
  cause invalid reparses when looking backward more than 25 code
  units, since the library does not track lookbehind.
  */
  peek(offset) {
    let idx = this.chunkOff + offset, pos, result;
    if (idx >= 0 && idx < this.chunk.length) {
      pos = this.pos + offset;
      result = this.chunk.charCodeAt(idx);
    } else {
      let resolved = this.resolveOffset(offset, 1);
      if (resolved == null)
        return -1;
      pos = resolved;
      if (pos >= this.chunk2Pos && pos < this.chunk2Pos + this.chunk2.length) {
        result = this.chunk2.charCodeAt(pos - this.chunk2Pos);
      } else {
        let i2 = this.rangeIndex, range = this.range;
        while (range.to <= pos)
          range = this.ranges[++i2];
        this.chunk2 = this.input.chunk(this.chunk2Pos = pos);
        if (pos + this.chunk2.length > range.to)
          this.chunk2 = this.chunk2.slice(0, range.to - pos);
        result = this.chunk2.charCodeAt(0);
      }
    }
    if (pos >= this.token.lookAhead)
      this.token.lookAhead = pos + 1;
    return result;
  }
  /**
  Accept a token. By default, the end of the token is set to the
  current stream position, but you can pass an offset (relative to
  the stream position) to change that.
  */
  acceptToken(token, endOffset = 0) {
    let end = endOffset ? this.resolveOffset(endOffset, -1) : this.pos;
    if (end == null || end < this.token.start)
      throw new RangeError("Token end out of bounds");
    this.token.value = token;
    this.token.end = end;
  }
  /**
  Accept a token ending at a specific given position.
  */
  acceptTokenTo(token, endPos) {
    this.token.value = token;
    this.token.end = endPos;
  }
  getChunk() {
    if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {
      let { chunk, chunkPos } = this;
      this.chunk = this.chunk2;
      this.chunkPos = this.chunk2Pos;
      this.chunk2 = chunk;
      this.chunk2Pos = chunkPos;
      this.chunkOff = this.pos - this.chunkPos;
    } else {
      this.chunk2 = this.chunk;
      this.chunk2Pos = this.chunkPos;
      let nextChunk = this.input.chunk(this.pos);
      let end = this.pos + nextChunk.length;
      this.chunk = end > this.range.to ? nextChunk.slice(0, this.range.to - this.pos) : nextChunk;
      this.chunkPos = this.pos;
      this.chunkOff = 0;
    }
  }
  readNext() {
    if (this.chunkOff >= this.chunk.length) {
      this.getChunk();
      if (this.chunkOff == this.chunk.length)
        return this.next = -1;
    }
    return this.next = this.chunk.charCodeAt(this.chunkOff);
  }
  /**
  Move the stream forward N (defaults to 1) code units. Returns
  the new value of [`next`](#lr.InputStream.next).
  */
  advance(n2 = 1) {
    this.chunkOff += n2;
    while (this.pos + n2 >= this.range.to) {
      if (this.rangeIndex == this.ranges.length - 1)
        return this.setDone();
      n2 -= this.range.to - this.pos;
      this.range = this.ranges[++this.rangeIndex];
      this.pos = this.range.from;
    }
    this.pos += n2;
    if (this.pos >= this.token.lookAhead)
      this.token.lookAhead = this.pos + 1;
    return this.readNext();
  }
  setDone() {
    this.pos = this.chunkPos = this.end;
    this.range = this.ranges[this.rangeIndex = this.ranges.length - 1];
    this.chunk = "";
    return this.next = -1;
  }
  /**
  @internal
  */
  reset(pos, token) {
    if (token) {
      this.token = token;
      token.start = pos;
      token.lookAhead = pos + 1;
      token.value = token.extended = -1;
    } else {
      this.token = nullToken;
    }
    if (this.pos != pos) {
      this.pos = pos;
      if (pos == this.end) {
        this.setDone();
        return this;
      }
      while (pos < this.range.from)
        this.range = this.ranges[--this.rangeIndex];
      while (pos >= this.range.to)
        this.range = this.ranges[++this.rangeIndex];
      if (pos >= this.chunkPos && pos < this.chunkPos + this.chunk.length) {
        this.chunkOff = pos - this.chunkPos;
      } else {
        this.chunk = "";
        this.chunkOff = 0;
      }
      this.readNext();
    }
    return this;
  }
  /**
  @internal
  */
  read(from, to3) {
    if (from >= this.chunkPos && to3 <= this.chunkPos + this.chunk.length)
      return this.chunk.slice(from - this.chunkPos, to3 - this.chunkPos);
    if (from >= this.chunk2Pos && to3 <= this.chunk2Pos + this.chunk2.length)
      return this.chunk2.slice(from - this.chunk2Pos, to3 - this.chunk2Pos);
    if (from >= this.range.from && to3 <= this.range.to)
      return this.input.read(from, to3);
    let result = "";
    for (let r2 of this.ranges) {
      if (r2.from >= to3)
        break;
      if (r2.to > from)
        result += this.input.read(Math.max(r2.from, from), Math.min(r2.to, to3));
    }
    return result;
  }
};
var TokenGroup = class {
  constructor(data, id2) {
    this.data = data;
    this.id = id2;
  }
  token(input, stack) {
    let { parser: parser2 } = stack.p;
    readToken(this.data, input, stack, this.id, parser2.data, parser2.tokenPrecTable);
  }
};
TokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;
var LocalTokenGroup = class {
  constructor(data, precTable, elseToken) {
    this.precTable = precTable;
    this.elseToken = elseToken;
    this.data = typeof data == "string" ? decodeArray(data) : data;
  }
  token(input, stack) {
    let start = input.pos, skipped = 0;
    for (; ; ) {
      let atEof = input.next < 0, nextPos = input.resolveOffset(1, 1);
      readToken(this.data, input, stack, 0, this.data, this.precTable);
      if (input.token.value > -1)
        break;
      if (this.elseToken == null)
        return;
      if (!atEof)
        skipped++;
      if (nextPos == null)
        break;
      input.reset(nextPos, input.token);
    }
    if (skipped) {
      input.reset(start, input.token);
      input.acceptToken(this.elseToken, skipped);
    }
  }
};
LocalTokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;
function readToken(data, input, stack, group, precTable, precOffset) {
  let state = 0, groupMask = 1 << group, { dialect } = stack.p.parser;
  scan: for (; ; ) {
    if ((groupMask & data[state]) == 0)
      break;
    let accEnd = data[state + 1];
    for (let i2 = state + 3; i2 < accEnd; i2 += 2)
      if ((data[i2 + 1] & groupMask) > 0) {
        let term = data[i2];
        if (dialect.allows(term) && (input.token.value == -1 || input.token.value == term || overrides(term, input.token.value, precTable, precOffset))) {
          input.acceptToken(term);
          break;
        }
      }
    let next = input.next, low = 0, high = data[state + 2];
    if (input.next < 0 && high > low && data[accEnd + high * 3 - 3] == 65535) {
      state = data[accEnd + high * 3 - 1];
      continue scan;
    }
    for (; low < high; ) {
      let mid = low + high >> 1;
      let index2 = accEnd + mid + (mid << 1);
      let from = data[index2], to3 = data[index2 + 1] || 65536;
      if (next < from)
        high = mid;
      else if (next >= to3)
        low = mid + 1;
      else {
        state = data[index2 + 2];
        input.advance();
        continue scan;
      }
    }
    break;
  }
}
function findOffset(data, start, term) {
  for (let i2 = start, next; (next = data[i2]) != 65535; i2++)
    if (next == term)
      return i2 - start;
  return -1;
}
function overrides(token, prev, tableData, tableOffset) {
  let iPrev = findOffset(tableData, tableOffset, prev);
  return iPrev < 0 || findOffset(tableData, tableOffset, token) < iPrev;
}
var verbose = typeof process != "undefined" && process.env && /\bparse\b/.test(process.env.LOG);
var stackIDs = null;
function cutAt(tree, pos, side) {
  let cursor = tree.cursor(IterMode.IncludeAnonymous);
  cursor.moveTo(pos);
  for (; ; ) {
    if (!(side < 0 ? cursor.childBefore(pos) : cursor.childAfter(pos)))
      for (; ; ) {
        if ((side < 0 ? cursor.to < pos : cursor.from > pos) && !cursor.type.isError)
          return side < 0 ? Math.max(0, Math.min(
            cursor.to - 1,
            pos - 25
            /* Lookahead.Margin */
          )) : Math.min(tree.length, Math.max(
            cursor.from + 1,
            pos + 25
            /* Lookahead.Margin */
          ));
        if (side < 0 ? cursor.prevSibling() : cursor.nextSibling())
          break;
        if (!cursor.parent())
          return side < 0 ? 0 : tree.length;
      }
  }
}
var FragmentCursor = class {
  constructor(fragments, nodeSet2) {
    this.fragments = fragments;
    this.nodeSet = nodeSet2;
    this.i = 0;
    this.fragment = null;
    this.safeFrom = -1;
    this.safeTo = -1;
    this.trees = [];
    this.start = [];
    this.index = [];
    this.nextFragment();
  }
  nextFragment() {
    let fr3 = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];
    if (fr3) {
      this.safeFrom = fr3.openStart ? cutAt(fr3.tree, fr3.from + fr3.offset, 1) - fr3.offset : fr3.from;
      this.safeTo = fr3.openEnd ? cutAt(fr3.tree, fr3.to + fr3.offset, -1) - fr3.offset : fr3.to;
      while (this.trees.length) {
        this.trees.pop();
        this.start.pop();
        this.index.pop();
      }
      this.trees.push(fr3.tree);
      this.start.push(-fr3.offset);
      this.index.push(0);
      this.nextStart = this.safeFrom;
    } else {
      this.nextStart = 1e9;
    }
  }
  // `pos` must be >= any previously given `pos` for this cursor
  nodeAt(pos) {
    if (pos < this.nextStart)
      return null;
    while (this.fragment && this.safeTo <= pos)
      this.nextFragment();
    if (!this.fragment)
      return null;
    for (; ; ) {
      let last2 = this.trees.length - 1;
      if (last2 < 0) {
        this.nextFragment();
        return null;
      }
      let top2 = this.trees[last2], index2 = this.index[last2];
      if (index2 == top2.children.length) {
        this.trees.pop();
        this.start.pop();
        this.index.pop();
        continue;
      }
      let next = top2.children[index2];
      let start = this.start[last2] + top2.positions[index2];
      if (start > pos) {
        this.nextStart = start;
        return null;
      }
      if (next instanceof Tree) {
        if (start == pos) {
          if (start < this.safeFrom)
            return null;
          let end = start + next.length;
          if (end <= this.safeTo) {
            let lookAhead = next.prop(NodeProp.lookAhead);
            if (!lookAhead || end + lookAhead < this.fragment.to)
              return next;
          }
        }
        this.index[last2]++;
        if (start + next.length >= Math.max(this.safeFrom, pos)) {
          this.trees.push(next);
          this.start.push(start);
          this.index.push(0);
        }
      } else {
        this.index[last2]++;
        this.nextStart = start + next.length;
      }
    }
  }
};
var TokenCache = class {
  constructor(parser2, stream) {
    this.stream = stream;
    this.tokens = [];
    this.mainToken = null;
    this.actions = [];
    this.tokens = parser2.tokenizers.map((_2) => new CachedToken());
  }
  getActions(stack) {
    let actionIndex = 0;
    let main = null;
    let { parser: parser2 } = stack.p, { tokenizers } = parser2;
    let mask = parser2.stateSlot(
      stack.state,
      3
      /* ParseState.TokenizerMask */
    );
    let context = stack.curContext ? stack.curContext.hash : 0;
    let lookAhead = 0;
    for (let i2 = 0; i2 < tokenizers.length; i2++) {
      if ((1 << i2 & mask) == 0)
        continue;
      let tokenizer = tokenizers[i2], token = this.tokens[i2];
      if (main && !tokenizer.fallback)
        continue;
      if (tokenizer.contextual || token.start != stack.pos || token.mask != mask || token.context != context) {
        this.updateCachedToken(token, tokenizer, stack);
        token.mask = mask;
        token.context = context;
      }
      if (token.lookAhead > token.end + 25)
        lookAhead = Math.max(token.lookAhead, lookAhead);
      if (token.value != 0) {
        let startIndex = actionIndex;
        if (token.extended > -1)
          actionIndex = this.addActions(stack, token.extended, token.end, actionIndex);
        actionIndex = this.addActions(stack, token.value, token.end, actionIndex);
        if (!tokenizer.extend) {
          main = token;
          if (actionIndex > startIndex)
            break;
        }
      }
    }
    while (this.actions.length > actionIndex)
      this.actions.pop();
    if (lookAhead)
      stack.setLookAhead(lookAhead);
    if (!main && stack.pos == this.stream.end) {
      main = new CachedToken();
      main.value = stack.p.parser.eofTerm;
      main.start = main.end = stack.pos;
      actionIndex = this.addActions(stack, main.value, main.end, actionIndex);
    }
    this.mainToken = main;
    return this.actions;
  }
  getMainToken(stack) {
    if (this.mainToken)
      return this.mainToken;
    let main = new CachedToken(), { pos, p } = stack;
    main.start = pos;
    main.end = Math.min(pos + 1, p.stream.end);
    main.value = pos == p.stream.end ? p.parser.eofTerm : 0;
    return main;
  }
  updateCachedToken(token, tokenizer, stack) {
    let start = this.stream.clipPos(stack.pos);
    tokenizer.token(this.stream.reset(start, token), stack);
    if (token.value > -1) {
      let { parser: parser2 } = stack.p;
      for (let i2 = 0; i2 < parser2.specialized.length; i2++)
        if (parser2.specialized[i2] == token.value) {
          let result = parser2.specializers[i2](this.stream.read(token.start, token.end), stack);
          if (result >= 0 && stack.p.parser.dialect.allows(result >> 1)) {
            if ((result & 1) == 0)
              token.value = result >> 1;
            else
              token.extended = result >> 1;
            break;
          }
        }
    } else {
      token.value = 0;
      token.end = this.stream.clipPos(start + 1);
    }
  }
  putAction(action, token, end, index2) {
    for (let i2 = 0; i2 < index2; i2 += 3)
      if (this.actions[i2] == action)
        return index2;
    this.actions[index2++] = action;
    this.actions[index2++] = token;
    this.actions[index2++] = end;
    return index2;
  }
  addActions(stack, token, end, index2) {
    let { state } = stack, { parser: parser2 } = stack.p, { data } = parser2;
    for (let set = 0; set < 2; set++) {
      for (let i2 = parser2.stateSlot(
        state,
        set ? 2 : 1
        /* ParseState.Actions */
      ); ; i2 += 3) {
        if (data[i2] == 65535) {
          if (data[i2 + 1] == 1) {
            i2 = pair(data, i2 + 2);
          } else {
            if (index2 == 0 && data[i2 + 1] == 2)
              index2 = this.putAction(pair(data, i2 + 2), token, end, index2);
            break;
          }
        }
        if (data[i2] == token)
          index2 = this.putAction(pair(data, i2 + 1), token, end, index2);
      }
    }
    return index2;
  }
};
var Parse = class {
  constructor(parser2, input, fragments, ranges) {
    this.parser = parser2;
    this.input = input;
    this.ranges = ranges;
    this.recovering = 0;
    this.nextStackID = 9812;
    this.minStackPos = 0;
    this.reused = [];
    this.stoppedAt = null;
    this.lastBigReductionStart = -1;
    this.lastBigReductionSize = 0;
    this.bigReductionCount = 0;
    this.stream = new InputStream(input, ranges);
    this.tokens = new TokenCache(parser2, this.stream);
    this.topTerm = parser2.top[1];
    let { from } = ranges[0];
    this.stacks = [Stack.start(this, parser2.top[0], from)];
    this.fragments = fragments.length && this.stream.end - from > parser2.bufferLength * 4 ? new FragmentCursor(fragments, parser2.nodeSet) : null;
  }
  get parsedPos() {
    return this.minStackPos;
  }
  // Move the parser forward. This will process all parse stacks at
  // `this.pos` and try to advance them to a further position. If no
  // stack for such a position is found, it'll start error-recovery.
  //
  // When the parse is finished, this will return a syntax tree. When
  // not, it returns `null`.
  advance() {
    let stacks = this.stacks, pos = this.minStackPos;
    let newStacks = this.stacks = [];
    let stopped, stoppedTokens;
    if (this.bigReductionCount > 300 && stacks.length == 1) {
      let [s2] = stacks;
      while (s2.forceReduce() && s2.stack.length && s2.stack[s2.stack.length - 2] >= this.lastBigReductionStart) {
      }
      this.bigReductionCount = this.lastBigReductionSize = 0;
    }
    for (let i2 = 0; i2 < stacks.length; i2++) {
      let stack = stacks[i2];
      for (; ; ) {
        this.tokens.mainToken = null;
        if (stack.pos > pos) {
          newStacks.push(stack);
        } else if (this.advanceStack(stack, newStacks, stacks)) {
          continue;
        } else {
          if (!stopped) {
            stopped = [];
            stoppedTokens = [];
          }
          stopped.push(stack);
          let tok = this.tokens.getMainToken(stack);
          stoppedTokens.push(tok.value, tok.end);
        }
        break;
      }
    }
    if (!newStacks.length) {
      let finished = stopped && findFinished(stopped);
      if (finished) {
        if (verbose)
          console.log("Finish with " + this.stackID(finished));
        return this.stackToTree(finished);
      }
      if (this.parser.strict) {
        if (verbose && stopped)
          console.log("Stuck with token " + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : "none"));
        throw new SyntaxError("No parse at " + pos);
      }
      if (!this.recovering)
        this.recovering = 5;
    }
    if (this.recovering && stopped) {
      let finished = this.stoppedAt != null && stopped[0].pos > this.stoppedAt ? stopped[0] : this.runRecovery(stopped, stoppedTokens, newStacks);
      if (finished) {
        if (verbose)
          console.log("Force-finish " + this.stackID(finished));
        return this.stackToTree(finished.forceAll());
      }
    }
    if (this.recovering) {
      let maxRemaining = this.recovering == 1 ? 1 : this.recovering * 3;
      if (newStacks.length > maxRemaining) {
        newStacks.sort((a2, b2) => b2.score - a2.score);
        while (newStacks.length > maxRemaining)
          newStacks.pop();
      }
      if (newStacks.some((s2) => s2.reducePos > pos))
        this.recovering--;
    } else if (newStacks.length > 1) {
      outer: for (let i2 = 0; i2 < newStacks.length - 1; i2++) {
        let stack = newStacks[i2];
        for (let j = i2 + 1; j < newStacks.length; j++) {
          let other = newStacks[j];
          if (stack.sameState(other) || stack.buffer.length > 500 && other.buffer.length > 500) {
            if ((stack.score - other.score || stack.buffer.length - other.buffer.length) > 0) {
              newStacks.splice(j--, 1);
            } else {
              newStacks.splice(i2--, 1);
              continue outer;
            }
          }
        }
      }
      if (newStacks.length > 12)
        newStacks.splice(
          12,
          newStacks.length - 12
          /* Rec.MaxStackCount */
        );
    }
    this.minStackPos = newStacks[0].pos;
    for (let i2 = 1; i2 < newStacks.length; i2++)
      if (newStacks[i2].pos < this.minStackPos)
        this.minStackPos = newStacks[i2].pos;
    return null;
  }
  stopAt(pos) {
    if (this.stoppedAt != null && this.stoppedAt < pos)
      throw new RangeError("Can't move stoppedAt forward");
    this.stoppedAt = pos;
  }
  // Returns an updated version of the given stack, or null if the
  // stack can't advance normally. When `split` and `stacks` are
  // given, stacks split off by ambiguous operations will be pushed to
  // `split`, or added to `stacks` if they move `pos` forward.
  advanceStack(stack, stacks, split) {
    let start = stack.pos, { parser: parser2 } = this;
    let base2 = verbose ? this.stackID(stack) + " -> " : "";
    if (this.stoppedAt != null && start > this.stoppedAt)
      return stack.forceReduce() ? stack : null;
    if (this.fragments) {
      let strictCx = stack.curContext && stack.curContext.tracker.strict, cxHash = strictCx ? stack.curContext.hash : 0;
      for (let cached = this.fragments.nodeAt(start); cached; ) {
        let match = this.parser.nodeSet.types[cached.type.id] == cached.type ? parser2.getGoto(stack.state, cached.type.id) : -1;
        if (match > -1 && cached.length && (!strictCx || (cached.prop(NodeProp.contextHash) || 0) == cxHash)) {
          stack.useNode(cached, match);
          if (verbose)
            console.log(base2 + this.stackID(stack) + ` (via reuse of ${parser2.getName(cached.type.id)})`);
          return true;
        }
        if (!(cached instanceof Tree) || cached.children.length == 0 || cached.positions[0] > 0)
          break;
        let inner = cached.children[0];
        if (inner instanceof Tree && cached.positions[0] == 0)
          cached = inner;
        else
          break;
      }
    }
    let defaultReduce = parser2.stateSlot(
      stack.state,
      4
      /* ParseState.DefaultReduce */
    );
    if (defaultReduce > 0) {
      stack.reduce(defaultReduce);
      if (verbose)
        console.log(base2 + this.stackID(stack) + ` (via always-reduce ${parser2.getName(
          defaultReduce & 65535
          /* Action.ValueMask */
        )})`);
      return true;
    }
    if (stack.stack.length >= 8400) {
      while (stack.stack.length > 6e3 && stack.forceReduce()) {
      }
    }
    let actions = this.tokens.getActions(stack);
    for (let i2 = 0; i2 < actions.length; ) {
      let action = actions[i2++], term = actions[i2++], end = actions[i2++];
      let last2 = i2 == actions.length || !split;
      let localStack = last2 ? stack : stack.split();
      let main = this.tokens.mainToken;
      localStack.apply(action, term, main ? main.start : localStack.pos, end);
      if (verbose)
        console.log(base2 + this.stackID(localStack) + ` (via ${(action & 65536) == 0 ? "shift" : `reduce of ${parser2.getName(
          action & 65535
          /* Action.ValueMask */
        )}`} for ${parser2.getName(term)} @ ${start}${localStack == stack ? "" : ", split"})`);
      if (last2)
        return true;
      else if (localStack.pos > start)
        stacks.push(localStack);
      else
        split.push(localStack);
    }
    return false;
  }
  // Advance a given stack forward as far as it will go. Returns the
  // (possibly updated) stack if it got stuck, or null if it moved
  // forward and was given to `pushStackDedup`.
  advanceFully(stack, newStacks) {
    let pos = stack.pos;
    for (; ; ) {
      if (!this.advanceStack(stack, null, null))
        return false;
      if (stack.pos > pos) {
        pushStackDedup(stack, newStacks);
        return true;
      }
    }
  }
  runRecovery(stacks, tokens, newStacks) {
    let finished = null, restarted = false;
    for (let i2 = 0; i2 < stacks.length; i2++) {
      let stack = stacks[i2], token = tokens[i2 << 1], tokenEnd = tokens[(i2 << 1) + 1];
      let base2 = verbose ? this.stackID(stack) + " -> " : "";
      if (stack.deadEnd) {
        if (restarted)
          continue;
        restarted = true;
        stack.restart();
        if (verbose)
          console.log(base2 + this.stackID(stack) + " (restarted)");
        let done = this.advanceFully(stack, newStacks);
        if (done)
          continue;
      }
      let force = stack.split(), forceBase = base2;
      for (let j = 0; force.forceReduce() && j < 10; j++) {
        if (verbose)
          console.log(forceBase + this.stackID(force) + " (via force-reduce)");
        let done = this.advanceFully(force, newStacks);
        if (done)
          break;
        if (verbose)
          forceBase = this.stackID(force) + " -> ";
      }
      for (let insert2 of stack.recoverByInsert(token)) {
        if (verbose)
          console.log(base2 + this.stackID(insert2) + " (via recover-insert)");
        this.advanceFully(insert2, newStacks);
      }
      if (this.stream.end > stack.pos) {
        if (tokenEnd == stack.pos) {
          tokenEnd++;
          token = 0;
        }
        stack.recoverByDelete(token, tokenEnd);
        if (verbose)
          console.log(base2 + this.stackID(stack) + ` (via recover-delete ${this.parser.getName(token)})`);
        pushStackDedup(stack, newStacks);
      } else if (!finished || finished.score < stack.score) {
        finished = stack;
      }
    }
    return finished;
  }
  // Convert the stack's buffer to a syntax tree.
  stackToTree(stack) {
    stack.close();
    return Tree.build({
      buffer: StackBufferCursor.create(stack),
      nodeSet: this.parser.nodeSet,
      topID: this.topTerm,
      maxBufferLength: this.parser.bufferLength,
      reused: this.reused,
      start: this.ranges[0].from,
      length: stack.pos - this.ranges[0].from,
      minRepeatType: this.parser.minRepeatTerm
    });
  }
  stackID(stack) {
    let id2 = (stackIDs || (stackIDs = /* @__PURE__ */ new WeakMap())).get(stack);
    if (!id2)
      stackIDs.set(stack, id2 = String.fromCodePoint(this.nextStackID++));
    return id2 + stack;
  }
};
function pushStackDedup(stack, newStacks) {
  for (let i2 = 0; i2 < newStacks.length; i2++) {
    let other = newStacks[i2];
    if (other.pos == stack.pos && other.sameState(stack)) {
      if (newStacks[i2].score < stack.score)
        newStacks[i2] = stack;
      return;
    }
  }
  newStacks.push(stack);
}
var Dialect = class {
  constructor(source, flags, disabled) {
    this.source = source;
    this.flags = flags;
    this.disabled = disabled;
  }
  allows(term) {
    return !this.disabled || this.disabled[term] == 0;
  }
};
var LRParser = class _LRParser extends Parser {
  /**
  @internal
  */
  constructor(spec) {
    super();
    this.wrappers = [];
    if (spec.version != 14)
      throw new RangeError(`Parser version (${spec.version}) doesn't match runtime version (${14})`);
    let nodeNames = spec.nodeNames.split(" ");
    this.minRepeatTerm = nodeNames.length;
    for (let i2 = 0; i2 < spec.repeatNodeCount; i2++)
      nodeNames.push("");
    let topTerms = Object.keys(spec.topRules).map((r2) => spec.topRules[r2][1]);
    let nodeProps = [];
    for (let i2 = 0; i2 < nodeNames.length; i2++)
      nodeProps.push([]);
    function setProp(nodeID, prop, value) {
      nodeProps[nodeID].push([prop, prop.deserialize(String(value))]);
    }
    if (spec.nodeProps)
      for (let propSpec of spec.nodeProps) {
        let prop = propSpec[0];
        if (typeof prop == "string")
          prop = NodeProp[prop];
        for (let i2 = 1; i2 < propSpec.length; ) {
          let next = propSpec[i2++];
          if (next >= 0) {
            setProp(next, prop, propSpec[i2++]);
          } else {
            let value = propSpec[i2 + -next];
            for (let j = -next; j > 0; j--)
              setProp(propSpec[i2++], prop, value);
            i2++;
          }
        }
      }
    this.nodeSet = new NodeSet(nodeNames.map((name2, i2) => NodeType.define({
      name: i2 >= this.minRepeatTerm ? void 0 : name2,
      id: i2,
      props: nodeProps[i2],
      top: topTerms.indexOf(i2) > -1,
      error: i2 == 0,
      skipped: spec.skippedNodes && spec.skippedNodes.indexOf(i2) > -1
    })));
    if (spec.propSources)
      this.nodeSet = this.nodeSet.extend(...spec.propSources);
    this.strict = false;
    this.bufferLength = DefaultBufferLength;
    let tokenArray = decodeArray(spec.tokenData);
    this.context = spec.context;
    this.specializerSpecs = spec.specialized || [];
    this.specialized = new Uint16Array(this.specializerSpecs.length);
    for (let i2 = 0; i2 < this.specializerSpecs.length; i2++)
      this.specialized[i2] = this.specializerSpecs[i2].term;
    this.specializers = this.specializerSpecs.map(getSpecializer);
    this.states = decodeArray(spec.states, Uint32Array);
    this.data = decodeArray(spec.stateData);
    this.goto = decodeArray(spec.goto);
    this.maxTerm = spec.maxTerm;
    this.tokenizers = spec.tokenizers.map((value) => typeof value == "number" ? new TokenGroup(tokenArray, value) : value);
    this.topRules = spec.topRules;
    this.dialects = spec.dialects || {};
    this.dynamicPrecedences = spec.dynamicPrecedences || null;
    this.tokenPrecTable = spec.tokenPrec;
    this.termNames = spec.termNames || null;
    this.maxNode = this.nodeSet.types.length - 1;
    this.dialect = this.parseDialect();
    this.top = this.topRules[Object.keys(this.topRules)[0]];
  }
  createParse(input, fragments, ranges) {
    let parse = new Parse(this, input, fragments, ranges);
    for (let w of this.wrappers)
      parse = w(parse, input, fragments, ranges);
    return parse;
  }
  /**
  Get a goto table entry @internal
  */
  getGoto(state, term, loose = false) {
    let table = this.goto;
    if (term >= table[0])
      return -1;
    for (let pos = table[term + 1]; ; ) {
      let groupTag = table[pos++], last2 = groupTag & 1;
      let target = table[pos++];
      if (last2 && loose)
        return target;
      for (let end = pos + (groupTag >> 1); pos < end; pos++)
        if (table[pos] == state)
          return target;
      if (last2)
        return -1;
    }
  }
  /**
  Check if this state has an action for a given terminal @internal
  */
  hasAction(state, terminal) {
    let data = this.data;
    for (let set = 0; set < 2; set++) {
      for (let i2 = this.stateSlot(
        state,
        set ? 2 : 1
        /* ParseState.Actions */
      ), next; ; i2 += 3) {
        if ((next = data[i2]) == 65535) {
          if (data[i2 + 1] == 1)
            next = data[i2 = pair(data, i2 + 2)];
          else if (data[i2 + 1] == 2)
            return pair(data, i2 + 2);
          else
            break;
        }
        if (next == terminal || next == 0)
          return pair(data, i2 + 1);
      }
    }
    return 0;
  }
  /**
  @internal
  */
  stateSlot(state, slot) {
    return this.states[state * 6 + slot];
  }
  /**
  @internal
  */
  stateFlag(state, flag) {
    return (this.stateSlot(
      state,
      0
      /* ParseState.Flags */
    ) & flag) > 0;
  }
  /**
  @internal
  */
  validAction(state, action) {
    return !!this.allActions(state, (a2) => a2 == action ? true : null);
  }
  /**
  @internal
  */
  allActions(state, action) {
    let deflt = this.stateSlot(
      state,
      4
      /* ParseState.DefaultReduce */
    );
    let result = deflt ? action(deflt) : void 0;
    for (let i2 = this.stateSlot(
      state,
      1
      /* ParseState.Actions */
    ); result == null; i2 += 3) {
      if (this.data[i2] == 65535) {
        if (this.data[i2 + 1] == 1)
          i2 = pair(this.data, i2 + 2);
        else
          break;
      }
      result = action(pair(this.data, i2 + 1));
    }
    return result;
  }
  /**
  Get the states that can follow this one through shift actions or
  goto jumps. @internal
  */
  nextStates(state) {
    let result = [];
    for (let i2 = this.stateSlot(
      state,
      1
      /* ParseState.Actions */
    ); ; i2 += 3) {
      if (this.data[i2] == 65535) {
        if (this.data[i2 + 1] == 1)
          i2 = pair(this.data, i2 + 2);
        else
          break;
      }
      if ((this.data[i2 + 2] & 65536 >> 16) == 0) {
        let value = this.data[i2 + 1];
        if (!result.some((v, i3) => i3 & 1 && v == value))
          result.push(this.data[i2], value);
      }
    }
    return result;
  }
  /**
  Configure the parser. Returns a new parser instance that has the
  given settings modified. Settings not provided in `config` are
  kept from the original parser.
  */
  configure(config2) {
    let copy2 = Object.assign(Object.create(_LRParser.prototype), this);
    if (config2.props)
      copy2.nodeSet = this.nodeSet.extend(...config2.props);
    if (config2.top) {
      let info = this.topRules[config2.top];
      if (!info)
        throw new RangeError(`Invalid top rule name ${config2.top}`);
      copy2.top = info;
    }
    if (config2.tokenizers)
      copy2.tokenizers = this.tokenizers.map((t3) => {
        let found = config2.tokenizers.find((r2) => r2.from == t3);
        return found ? found.to : t3;
      });
    if (config2.specializers) {
      copy2.specializers = this.specializers.slice();
      copy2.specializerSpecs = this.specializerSpecs.map((s2, i2) => {
        let found = config2.specializers.find((r2) => r2.from == s2.external);
        if (!found)
          return s2;
        let spec = Object.assign(Object.assign({}, s2), { external: found.to });
        copy2.specializers[i2] = getSpecializer(spec);
        return spec;
      });
    }
    if (config2.contextTracker)
      copy2.context = config2.contextTracker;
    if (config2.dialect)
      copy2.dialect = this.parseDialect(config2.dialect);
    if (config2.strict != null)
      copy2.strict = config2.strict;
    if (config2.wrap)
      copy2.wrappers = copy2.wrappers.concat(config2.wrap);
    if (config2.bufferLength != null)
      copy2.bufferLength = config2.bufferLength;
    return copy2;
  }
  /**
  Tells you whether any [parse wrappers](#lr.ParserConfig.wrap)
  are registered for this parser.
  */
  hasWrappers() {
    return this.wrappers.length > 0;
  }
  /**
  Returns the name associated with a given term. This will only
  work for all terms when the parser was generated with the
  `--names` option. By default, only the names of tagged terms are
  stored.
  */
  getName(term) {
    return this.termNames ? this.termNames[term] : String(term <= this.maxNode && this.nodeSet.types[term].name || term);
  }
  /**
  The eof term id is always allocated directly after the node
  types. @internal
  */
  get eofTerm() {
    return this.maxNode + 1;
  }
  /**
  The type of top node produced by the parser.
  */
  get topNode() {
    return this.nodeSet.types[this.top[1]];
  }
  /**
  @internal
  */
  dynamicPrecedence(term) {
    let prec2 = this.dynamicPrecedences;
    return prec2 == null ? 0 : prec2[term] || 0;
  }
  /**
  @internal
  */
  parseDialect(dialect) {
    let values = Object.keys(this.dialects), flags = values.map(() => false);
    if (dialect)
      for (let part of dialect.split(" ")) {
        let id2 = values.indexOf(part);
        if (id2 >= 0)
          flags[id2] = true;
      }
    let disabled = null;
    for (let i2 = 0; i2 < values.length; i2++)
      if (!flags[i2]) {
        for (let j = this.dialects[values[i2]], id2; (id2 = this.data[j++]) != 65535; )
          (disabled || (disabled = new Uint8Array(this.maxTerm + 1)))[id2] = 1;
      }
    return new Dialect(dialect, flags, disabled);
  }
  /**
  Used by the output of the parser generator. Not available to
  user code. @hide
  */
  static deserialize(spec) {
    return new _LRParser(spec);
  }
};
function pair(data, off) {
  return data[off] | data[off + 1] << 16;
}
function findFinished(stacks) {
  let best = null;
  for (let stack of stacks) {
    let stopped = stack.p.stoppedAt;
    if ((stack.pos == stack.p.stream.end || stopped != null && stack.pos > stopped) && stack.p.parser.stateFlag(
      stack.state,
      2
      /* StateFlag.Accepting */
    ) && (!best || best.score < stack.score))
      best = stack;
  }
  return best;
}
function getSpecializer(spec) {
  if (spec.external) {
    let mask = spec.extend ? 1 : 0;
    return (value, stack) => spec.external(value, stack) << 1 | mask;
  }
  return spec.get;
}

// node_modules/@lezer/json/dist/index.js
var jsonHighlighting = styleTags({
  String: tags.string,
  Number: tags.number,
  "True False": tags.bool,
  PropertyName: tags.propertyName,
  Null: tags.null,
  ",": tags.separator,
  "[ ]": tags.squareBracket,
  "{ }": tags.brace
});
var parser = LRParser.deserialize({
  version: 14,
  states: "$bOVQPOOOOQO'#Cb'#CbOnQPO'#CeOvQPO'#CjOOQO'#Cp'#CpQOQPOOOOQO'#Cg'#CgO}QPO'#CfO!SQPO'#CrOOQO,59P,59PO![QPO,59PO!aQPO'#CuOOQO,59U,59UO!iQPO,59UOVQPO,59QOqQPO'#CkO!nQPO,59^OOQO1G.k1G.kOVQPO'#ClO!vQPO,59aOOQO1G.p1G.pOOQO1G.l1G.lOOQO,59V,59VOOQO-E6i-E6iOOQO,59W,59WOOQO-E6j-E6j",
  stateData: "#O~OcOS~OQSORSOSSOTSOWQO]ROePO~OVXOeUO~O[[O~PVOg^O~Oh_OVfX~OVaO~OhbO[iX~O[dO~Oh_OVfa~OhbO[ia~O",
  goto: "!kjPPPPPPkPPkqwPPk{!RPPP!XP!ePP!hXSOR^bQWQRf_TVQ_Q`WRg`QcZRicQTOQZRQe^RhbRYQR]R",
  nodeNames: "⚠ JsonText True False Null Number String } { Object Property PropertyName ] [ Array",
  maxTerm: 25,
  nodeProps: [
    ["isolate", -2, 6, 11, ""],
    ["openedBy", 7, "{", 12, "["],
    ["closedBy", 8, "}", 13, "]"]
  ],
  propSources: [jsonHighlighting],
  skippedNodes: [0],
  repeatNodeCount: 2,
  tokenData: "(|~RaXY!WYZ!W]^!Wpq!Wrs!]|}$u}!O$z!Q!R%T!R![&c![!]&t!}#O&y#P#Q'O#Y#Z'T#b#c'r#h#i(Z#o#p(r#q#r(w~!]Oc~~!`Wpq!]qr!]rs!xs#O!]#O#P!}#P;'S!];'S;=`$o<%lO!]~!}Oe~~#QXrs!]!P!Q!]#O#P!]#U#V!]#Y#Z!]#b#c!]#f#g!]#h#i!]#i#j#m~#pR!Q![#y!c!i#y#T#Z#y~#|R!Q![$V!c!i$V#T#Z$V~$YR!Q![$c!c!i$c#T#Z$c~$fR!Q![!]!c!i!]#T#Z!]~$rP;=`<%l!]~$zOh~~$}Q!Q!R%T!R![&c~%YRT~!O!P%c!g!h%w#X#Y%w~%fP!Q![%i~%nRT~!Q![%i!g!h%w#X#Y%w~%zR{|&T}!O&T!Q![&Z~&WP!Q![&Z~&`PT~!Q![&Z~&hST~!O!P%c!Q![&c!g!h%w#X#Y%w~&yOg~~'OO]~~'TO[~~'WP#T#U'Z~'^P#`#a'a~'dP#g#h'g~'jP#X#Y'm~'rOR~~'uP#i#j'x~'{P#`#a(O~(RP#`#a(U~(ZOS~~(^P#f#g(a~(dP#i#j(g~(jP#X#Y(m~(rOQ~~(wOW~~(|OV~",
  tokenizers: [0],
  topRules: { "JsonText": [0, 1] },
  tokenPrec: 0
});

// node_modules/@codemirror/lang-json/dist/index.js
var jsonLanguage = LRLanguage.define({
  name: "json",
  parser: parser.configure({
    props: [
      indentNodeProp.add({
        Object: continuedIndent({ except: /^\s*\}/ }),
        Array: continuedIndent({ except: /^\s*\]/ })
      }),
      foldNodeProp.add({
        "Object Array": foldInside
      })
    ]
  }),
  languageData: {
    closeBrackets: { brackets: ["[", "{", '"'] },
    indentOnInput: /^\s*[\}\]]$/
  }
});
function json() {
  return new LanguageSupport(jsonLanguage);
}

// node_modules/@codemirror/search/dist/index.js
var basicNormalize = typeof String.prototype.normalize == "function" ? (x) => x.normalize("NFKD") : (x) => x;
var SearchCursor = class {
  /**
  Create a text cursor. The query is the search string, `from` to
  `to` provides the region to search.
  
  When `normalize` is given, it will be called, on both the query
  string and the content it is matched against, before comparing.
  You can, for example, create a case-insensitive search by
  passing `s => s.toLowerCase()`.
  
  Text is always normalized with
  [`.normalize("NFKD")`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)
  (when supported).
  */
  constructor(text, query, from = 0, to3 = text.length, normalize, test2) {
    this.test = test2;
    this.value = { from: 0, to: 0 };
    this.done = false;
    this.matches = [];
    this.buffer = "";
    this.bufferPos = 0;
    this.iter = text.iterRange(from, to3);
    this.bufferStart = from;
    this.normalize = normalize ? (x) => normalize(basicNormalize(x)) : basicNormalize;
    this.query = this.normalize(query);
  }
  peek() {
    if (this.bufferPos == this.buffer.length) {
      this.bufferStart += this.buffer.length;
      this.iter.next();
      if (this.iter.done)
        return -1;
      this.bufferPos = 0;
      this.buffer = this.iter.value;
    }
    return codePointAt(this.buffer, this.bufferPos);
  }
  /**
  Look for the next match. Updates the iterator's
  [`value`](https://codemirror.net/6/docs/ref/#search.SearchCursor.value) and
  [`done`](https://codemirror.net/6/docs/ref/#search.SearchCursor.done) properties. Should be called
  at least once before using the cursor.
  */
  next() {
    while (this.matches.length)
      this.matches.pop();
    return this.nextOverlapping();
  }
  /**
  The `next` method will ignore matches that partially overlap a
  previous match. This method behaves like `next`, but includes
  such matches.
  */
  nextOverlapping() {
    for (; ; ) {
      let next = this.peek();
      if (next < 0) {
        this.done = true;
        return this;
      }
      let str = fromCodePoint(next), start = this.bufferStart + this.bufferPos;
      this.bufferPos += codePointSize(next);
      let norm = this.normalize(str);
      for (let i2 = 0, pos = start; ; i2++) {
        let code = norm.charCodeAt(i2);
        let match = this.match(code, pos, this.bufferPos + this.bufferStart);
        if (i2 == norm.length - 1) {
          if (match) {
            this.value = match;
            return this;
          }
          break;
        }
        if (pos == start && i2 < str.length && str.charCodeAt(i2) == code)
          pos++;
      }
    }
  }
  match(code, pos, end) {
    let match = null;
    for (let i2 = 0; i2 < this.matches.length; i2 += 2) {
      let index2 = this.matches[i2], keep = false;
      if (this.query.charCodeAt(index2) == code) {
        if (index2 == this.query.length - 1) {
          match = { from: this.matches[i2 + 1], to: end };
        } else {
          this.matches[i2]++;
          keep = true;
        }
      }
      if (!keep) {
        this.matches.splice(i2, 2);
        i2 -= 2;
      }
    }
    if (this.query.charCodeAt(0) == code) {
      if (this.query.length == 1)
        match = { from: pos, to: end };
      else
        this.matches.push(1, pos);
    }
    if (match && this.test && !this.test(match.from, match.to, this.buffer, this.bufferStart))
      match = null;
    return match;
  }
};
if (typeof Symbol != "undefined")
  SearchCursor.prototype[Symbol.iterator] = function() {
    return this;
  };
var empty = { from: -1, to: -1, match: /.*/.exec("") };
var baseFlags = "gm" + (/x/.unicode == null ? "" : "u");
var RegExpCursor = class {
  /**
  Create a cursor that will search the given range in the given
  document. `query` should be the raw pattern (as you'd pass it to
  `new RegExp`).
  */
  constructor(text, query, options, from = 0, to3 = text.length) {
    this.text = text;
    this.to = to3;
    this.curLine = "";
    this.done = false;
    this.value = empty;
    if (/\\[sWDnr]|\n|\r|\[\^/.test(query))
      return new MultilineRegExpCursor(text, query, options, from, to3);
    this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? "i" : ""));
    this.test = options === null || options === void 0 ? void 0 : options.test;
    this.iter = text.iter();
    let startLine = text.lineAt(from);
    this.curLineStart = startLine.from;
    this.matchPos = toCharEnd(text, from);
    this.getLine(this.curLineStart);
  }
  getLine(skip) {
    this.iter.next(skip);
    if (this.iter.lineBreak) {
      this.curLine = "";
    } else {
      this.curLine = this.iter.value;
      if (this.curLineStart + this.curLine.length > this.to)
        this.curLine = this.curLine.slice(0, this.to - this.curLineStart);
      this.iter.next();
    }
  }
  nextLine() {
    this.curLineStart = this.curLineStart + this.curLine.length + 1;
    if (this.curLineStart > this.to)
      this.curLine = "";
    else
      this.getLine(0);
  }
  /**
  Move to the next match, if there is one.
  */
  next() {
    for (let off = this.matchPos - this.curLineStart; ; ) {
      this.re.lastIndex = off;
      let match = this.matchPos <= this.to && this.re.exec(this.curLine);
      if (match) {
        let from = this.curLineStart + match.index, to3 = from + match[0].length;
        this.matchPos = toCharEnd(this.text, to3 + (from == to3 ? 1 : 0));
        if (from == this.curLineStart + this.curLine.length)
          this.nextLine();
        if ((from < to3 || from > this.value.to) && (!this.test || this.test(from, to3, match))) {
          this.value = { from, to: to3, match };
          return this;
        }
        off = this.matchPos - this.curLineStart;
      } else if (this.curLineStart + this.curLine.length < this.to) {
        this.nextLine();
        off = 0;
      } else {
        this.done = true;
        return this;
      }
    }
  }
};
var flattened = /* @__PURE__ */ new WeakMap();
var FlattenedDoc = class _FlattenedDoc {
  constructor(from, text) {
    this.from = from;
    this.text = text;
  }
  get to() {
    return this.from + this.text.length;
  }
  static get(doc2, from, to3) {
    let cached = flattened.get(doc2);
    if (!cached || cached.from >= to3 || cached.to <= from) {
      let flat = new _FlattenedDoc(from, doc2.sliceString(from, to3));
      flattened.set(doc2, flat);
      return flat;
    }
    if (cached.from == from && cached.to == to3)
      return cached;
    let { text, from: cachedFrom } = cached;
    if (cachedFrom > from) {
      text = doc2.sliceString(from, cachedFrom) + text;
      cachedFrom = from;
    }
    if (cached.to < to3)
      text += doc2.sliceString(cached.to, to3);
    flattened.set(doc2, new _FlattenedDoc(cachedFrom, text));
    return new _FlattenedDoc(from, text.slice(from - cachedFrom, to3 - cachedFrom));
  }
};
var MultilineRegExpCursor = class {
  constructor(text, query, options, from, to3) {
    this.text = text;
    this.to = to3;
    this.done = false;
    this.value = empty;
    this.matchPos = toCharEnd(text, from);
    this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? "i" : ""));
    this.test = options === null || options === void 0 ? void 0 : options.test;
    this.flat = FlattenedDoc.get(text, from, this.chunkEnd(
      from + 5e3
      /* Chunk.Base */
    ));
  }
  chunkEnd(pos) {
    return pos >= this.to ? this.to : this.text.lineAt(pos).to;
  }
  next() {
    for (; ; ) {
      let off = this.re.lastIndex = this.matchPos - this.flat.from;
      let match = this.re.exec(this.flat.text);
      if (match && !match[0] && match.index == off) {
        this.re.lastIndex = off + 1;
        match = this.re.exec(this.flat.text);
      }
      if (match) {
        let from = this.flat.from + match.index, to3 = from + match[0].length;
        if ((this.flat.to >= this.to || match.index + match[0].length <= this.flat.text.length - 10) && (!this.test || this.test(from, to3, match))) {
          this.value = { from, to: to3, match };
          this.matchPos = toCharEnd(this.text, to3 + (from == to3 ? 1 : 0));
          return this;
        }
      }
      if (this.flat.to == this.to) {
        this.done = true;
        return this;
      }
      this.flat = FlattenedDoc.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));
    }
  }
};
if (typeof Symbol != "undefined") {
  RegExpCursor.prototype[Symbol.iterator] = MultilineRegExpCursor.prototype[Symbol.iterator] = function() {
    return this;
  };
}
function validRegExp(source) {
  try {
    new RegExp(source, baseFlags);
    return true;
  } catch (_a4) {
    return false;
  }
}
function toCharEnd(text, pos) {
  if (pos >= text.length)
    return pos;
  let line = text.lineAt(pos), next;
  while (pos < line.to && (next = line.text.charCodeAt(pos - line.from)) >= 56320 && next < 57344)
    pos++;
  return pos;
}
function createLineDialog(view) {
  let line = String(view.state.doc.lineAt(view.state.selection.main.head).number);
  let input = crelt("input", { class: "cm-textfield", name: "line", value: line });
  let dom = crelt("form", {
    class: "cm-gotoLine",
    onkeydown: (event) => {
      if (event.keyCode == 27) {
        event.preventDefault();
        view.dispatch({ effects: dialogEffect.of(false) });
        view.focus();
      } else if (event.keyCode == 13) {
        event.preventDefault();
        go3();
      }
    },
    onsubmit: (event) => {
      event.preventDefault();
      go3();
    }
  }, crelt("label", view.state.phrase("Go to line"), ": ", input), " ", crelt("button", { class: "cm-button", type: "submit" }, view.state.phrase("go")));
  function go3() {
    let match = /^([+-])?(\d+)?(:\d+)?(%)?$/.exec(input.value);
    if (!match)
      return;
    let { state } = view, startLine = state.doc.lineAt(state.selection.main.head);
    let [, sign, ln2, cl2, percent] = match;
    let col = cl2 ? +cl2.slice(1) : 0;
    let line2 = ln2 ? +ln2 : startLine.number;
    if (ln2 && percent) {
      let pc2 = line2 / 100;
      if (sign)
        pc2 = pc2 * (sign == "-" ? -1 : 1) + startLine.number / state.doc.lines;
      line2 = Math.round(state.doc.lines * pc2);
    } else if (ln2 && sign) {
      line2 = line2 * (sign == "-" ? -1 : 1) + startLine.number;
    }
    let docLine = state.doc.line(Math.max(1, Math.min(state.doc.lines, line2)));
    let selection = EditorSelection.cursor(docLine.from + Math.max(0, Math.min(col, docLine.length)));
    view.dispatch({
      effects: [dialogEffect.of(false), EditorView.scrollIntoView(selection.from, { y: "center" })],
      selection
    });
    view.focus();
  }
  return { dom };
}
var dialogEffect = StateEffect.define();
var dialogField = StateField.define({
  create() {
    return true;
  },
  update(value, tr3) {
    for (let e2 of tr3.effects)
      if (e2.is(dialogEffect))
        value = e2.value;
    return value;
  },
  provide: (f) => showPanel.from(f, (val) => val ? createLineDialog : null)
});
var gotoLine = (view) => {
  let panel = getPanel(view, createLineDialog);
  if (!panel) {
    let effects = [dialogEffect.of(true)];
    if (view.state.field(dialogField, false) == null)
      effects.push(StateEffect.appendConfig.of([dialogField, baseTheme$13]));
    view.dispatch({ effects });
    panel = getPanel(view, createLineDialog);
  }
  if (panel)
    panel.dom.querySelector("input").select();
  return true;
};
var baseTheme$13 = EditorView.baseTheme({
  ".cm-panel.cm-gotoLine": {
    padding: "2px 6px 4px",
    "& label": { fontSize: "80%" }
  }
});
var defaultHighlightOptions = {
  highlightWordAroundCursor: false,
  minSelectionLength: 1,
  maxMatches: 100,
  wholeWords: false
};
var highlightConfig = Facet.define({
  combine(options) {
    return combineConfig(options, defaultHighlightOptions, {
      highlightWordAroundCursor: (a2, b2) => a2 || b2,
      minSelectionLength: Math.min,
      maxMatches: Math.min
    });
  }
});
function highlightSelectionMatches(options) {
  let ext = [defaultTheme, matchHighlighter];
  if (options)
    ext.push(highlightConfig.of(options));
  return ext;
}
var matchDeco = Decoration.mark({ class: "cm-selectionMatch" });
var mainMatchDeco = Decoration.mark({ class: "cm-selectionMatch cm-selectionMatch-main" });
function insideWordBoundaries(check, state, from, to3) {
  return (from == 0 || check(state.sliceDoc(from - 1, from)) != CharCategory.Word) && (to3 == state.doc.length || check(state.sliceDoc(to3, to3 + 1)) != CharCategory.Word);
}
function insideWord(check, state, from, to3) {
  return check(state.sliceDoc(from, from + 1)) == CharCategory.Word && check(state.sliceDoc(to3 - 1, to3)) == CharCategory.Word;
}
var matchHighlighter = ViewPlugin.fromClass(class {
  constructor(view) {
    this.decorations = this.getDeco(view);
  }
  update(update) {
    if (update.selectionSet || update.docChanged || update.viewportChanged)
      this.decorations = this.getDeco(update.view);
  }
  getDeco(view) {
    let conf = view.state.facet(highlightConfig);
    let { state } = view, sel = state.selection;
    if (sel.ranges.length > 1)
      return Decoration.none;
    let range = sel.main, query, check = null;
    if (range.empty) {
      if (!conf.highlightWordAroundCursor)
        return Decoration.none;
      let word = state.wordAt(range.head);
      if (!word)
        return Decoration.none;
      check = state.charCategorizer(range.head);
      query = state.sliceDoc(word.from, word.to);
    } else {
      let len = range.to - range.from;
      if (len < conf.minSelectionLength || len > 200)
        return Decoration.none;
      if (conf.wholeWords) {
        query = state.sliceDoc(range.from, range.to);
        check = state.charCategorizer(range.head);
        if (!(insideWordBoundaries(check, state, range.from, range.to) && insideWord(check, state, range.from, range.to)))
          return Decoration.none;
      } else {
        query = state.sliceDoc(range.from, range.to);
        if (!query)
          return Decoration.none;
      }
    }
    let deco = [];
    for (let part of view.visibleRanges) {
      let cursor = new SearchCursor(state.doc, query, part.from, part.to);
      while (!cursor.next().done) {
        let { from, to: to3 } = cursor.value;
        if (!check || insideWordBoundaries(check, state, from, to3)) {
          if (range.empty && from <= range.from && to3 >= range.to)
            deco.push(mainMatchDeco.range(from, to3));
          else if (from >= range.to || to3 <= range.from)
            deco.push(matchDeco.range(from, to3));
          if (deco.length > conf.maxMatches)
            return Decoration.none;
        }
      }
    }
    return Decoration.set(deco);
  }
}, {
  decorations: (v) => v.decorations
});
var defaultTheme = EditorView.baseTheme({
  ".cm-selectionMatch": { backgroundColor: "#99ff7780" },
  ".cm-searchMatch .cm-selectionMatch": { backgroundColor: "transparent" }
});
var selectWord = ({ state, dispatch }) => {
  let { selection } = state;
  let newSel = EditorSelection.create(selection.ranges.map((range) => state.wordAt(range.head) || EditorSelection.cursor(range.head)), selection.mainIndex);
  if (newSel.eq(selection))
    return false;
  dispatch(state.update({ selection: newSel }));
  return true;
};
function findNextOccurrence(state, query) {
  let { main, ranges } = state.selection;
  let word = state.wordAt(main.head), fullWord = word && word.from == main.from && word.to == main.to;
  for (let cycled = false, cursor = new SearchCursor(state.doc, query, ranges[ranges.length - 1].to); ; ) {
    cursor.next();
    if (cursor.done) {
      if (cycled)
        return null;
      cursor = new SearchCursor(state.doc, query, 0, Math.max(0, ranges[ranges.length - 1].from - 1));
      cycled = true;
    } else {
      if (cycled && ranges.some((r2) => r2.from == cursor.value.from))
        continue;
      if (fullWord) {
        let word2 = state.wordAt(cursor.value.from);
        if (!word2 || word2.from != cursor.value.from || word2.to != cursor.value.to)
          continue;
      }
      return cursor.value;
    }
  }
}
var selectNextOccurrence = ({ state, dispatch }) => {
  let { ranges } = state.selection;
  if (ranges.some((sel) => sel.from === sel.to))
    return selectWord({ state, dispatch });
  let searchedText = state.sliceDoc(ranges[0].from, ranges[0].to);
  if (state.selection.ranges.some((r2) => state.sliceDoc(r2.from, r2.to) != searchedText))
    return false;
  let range = findNextOccurrence(state, searchedText);
  if (!range)
    return false;
  dispatch(state.update({
    selection: state.selection.addRange(EditorSelection.range(range.from, range.to), false),
    effects: EditorView.scrollIntoView(range.to)
  }));
  return true;
};
var searchConfigFacet = Facet.define({
  combine(configs) {
    return combineConfig(configs, {
      top: false,
      caseSensitive: false,
      literal: false,
      regexp: false,
      wholeWord: false,
      createPanel: (view) => new SearchPanel(view),
      scrollToMatch: (range) => EditorView.scrollIntoView(range)
    });
  }
});
function search(config2) {
  return config2 ? [searchConfigFacet.of(config2), searchExtensions] : searchExtensions;
}
var SearchQuery = class {
  /**
  Create a query object.
  */
  constructor(config2) {
    this.search = config2.search;
    this.caseSensitive = !!config2.caseSensitive;
    this.literal = !!config2.literal;
    this.regexp = !!config2.regexp;
    this.replace = config2.replace || "";
    this.valid = !!this.search && (!this.regexp || validRegExp(this.search));
    this.unquoted = this.unquote(this.search);
    this.wholeWord = !!config2.wholeWord;
  }
  /**
  @internal
  */
  unquote(text) {
    return this.literal ? text : text.replace(/\\([nrt\\])/g, (_2, ch2) => ch2 == "n" ? "\n" : ch2 == "r" ? "\r" : ch2 == "t" ? "	" : "\\");
  }
  /**
  Compare this query to another query.
  */
  eq(other) {
    return this.search == other.search && this.replace == other.replace && this.caseSensitive == other.caseSensitive && this.regexp == other.regexp && this.wholeWord == other.wholeWord;
  }
  /**
  @internal
  */
  create() {
    return this.regexp ? new RegExpQuery(this) : new StringQuery(this);
  }
  /**
  Get a search cursor for this query, searching through the given
  range in the given state.
  */
  getCursor(state, from = 0, to3) {
    let st2 = state.doc ? state : EditorState.create({ doc: state });
    if (to3 == null)
      to3 = st2.doc.length;
    return this.regexp ? regexpCursor(this, st2, from, to3) : stringCursor(this, st2, from, to3);
  }
};
var QueryType2 = class {
  constructor(spec) {
    this.spec = spec;
  }
};
function stringCursor(spec, state, from, to3) {
  return new SearchCursor(state.doc, spec.unquoted, from, to3, spec.caseSensitive ? void 0 : (x) => x.toLowerCase(), spec.wholeWord ? stringWordTest(state.doc, state.charCategorizer(state.selection.main.head)) : void 0);
}
function stringWordTest(doc2, categorizer) {
  return (from, to3, buf, bufPos) => {
    if (bufPos > from || bufPos + buf.length < to3) {
      bufPos = Math.max(0, from - 2);
      buf = doc2.sliceString(bufPos, Math.min(doc2.length, to3 + 2));
    }
    return (categorizer(charBefore(buf, from - bufPos)) != CharCategory.Word || categorizer(charAfter(buf, from - bufPos)) != CharCategory.Word) && (categorizer(charAfter(buf, to3 - bufPos)) != CharCategory.Word || categorizer(charBefore(buf, to3 - bufPos)) != CharCategory.Word);
  };
}
var StringQuery = class extends QueryType2 {
  constructor(spec) {
    super(spec);
  }
  nextMatch(state, curFrom, curTo) {
    let cursor = stringCursor(this.spec, state, curTo, state.doc.length).nextOverlapping();
    if (cursor.done)
      cursor = stringCursor(this.spec, state, 0, curFrom).nextOverlapping();
    return cursor.done ? null : cursor.value;
  }
  // Searching in reverse is, rather than implementing an inverted search
  // cursor, done by scanning chunk after chunk forward.
  prevMatchInRange(state, from, to3) {
    for (let pos = to3; ; ) {
      let start = Math.max(from, pos - 1e4 - this.spec.unquoted.length);
      let cursor = stringCursor(this.spec, state, start, pos), range = null;
      while (!cursor.nextOverlapping().done)
        range = cursor.value;
      if (range)
        return range;
      if (start == from)
        return null;
      pos -= 1e4;
    }
  }
  prevMatch(state, curFrom, curTo) {
    return this.prevMatchInRange(state, 0, curFrom) || this.prevMatchInRange(state, curTo, state.doc.length);
  }
  getReplacement(_result) {
    return this.spec.unquote(this.spec.replace);
  }
  matchAll(state, limit) {
    let cursor = stringCursor(this.spec, state, 0, state.doc.length), ranges = [];
    while (!cursor.next().done) {
      if (ranges.length >= limit)
        return null;
      ranges.push(cursor.value);
    }
    return ranges;
  }
  highlight(state, from, to3, add3) {
    let cursor = stringCursor(this.spec, state, Math.max(0, from - this.spec.unquoted.length), Math.min(to3 + this.spec.unquoted.length, state.doc.length));
    while (!cursor.next().done)
      add3(cursor.value.from, cursor.value.to);
  }
};
function regexpCursor(spec, state, from, to3) {
  return new RegExpCursor(state.doc, spec.search, {
    ignoreCase: !spec.caseSensitive,
    test: spec.wholeWord ? regexpWordTest(state.charCategorizer(state.selection.main.head)) : void 0
  }, from, to3);
}
function charBefore(str, index2) {
  return str.slice(findClusterBreak(str, index2, false), index2);
}
function charAfter(str, index2) {
  return str.slice(index2, findClusterBreak(str, index2));
}
function regexpWordTest(categorizer) {
  return (_from, _to, match) => !match[0].length || (categorizer(charBefore(match.input, match.index)) != CharCategory.Word || categorizer(charAfter(match.input, match.index)) != CharCategory.Word) && (categorizer(charAfter(match.input, match.index + match[0].length)) != CharCategory.Word || categorizer(charBefore(match.input, match.index + match[0].length)) != CharCategory.Word);
}
var RegExpQuery = class extends QueryType2 {
  nextMatch(state, curFrom, curTo) {
    let cursor = regexpCursor(this.spec, state, curTo, state.doc.length).next();
    if (cursor.done)
      cursor = regexpCursor(this.spec, state, 0, curFrom).next();
    return cursor.done ? null : cursor.value;
  }
  prevMatchInRange(state, from, to3) {
    for (let size = 1; ; size++) {
      let start = Math.max(
        from,
        to3 - size * 1e4
        /* FindPrev.ChunkSize */
      );
      let cursor = regexpCursor(this.spec, state, start, to3), range = null;
      while (!cursor.next().done)
        range = cursor.value;
      if (range && (start == from || range.from > start + 10))
        return range;
      if (start == from)
        return null;
    }
  }
  prevMatch(state, curFrom, curTo) {
    return this.prevMatchInRange(state, 0, curFrom) || this.prevMatchInRange(state, curTo, state.doc.length);
  }
  getReplacement(result) {
    return this.spec.unquote(this.spec.replace).replace(/\$([$&\d+])/g, (m3, i2) => i2 == "$" ? "$" : i2 == "&" ? result.match[0] : i2 != "0" && +i2 < result.match.length ? result.match[i2] : m3);
  }
  matchAll(state, limit) {
    let cursor = regexpCursor(this.spec, state, 0, state.doc.length), ranges = [];
    while (!cursor.next().done) {
      if (ranges.length >= limit)
        return null;
      ranges.push(cursor.value);
    }
    return ranges;
  }
  highlight(state, from, to3, add3) {
    let cursor = regexpCursor(this.spec, state, Math.max(
      0,
      from - 250
      /* RegExp.HighlightMargin */
    ), Math.min(to3 + 250, state.doc.length));
    while (!cursor.next().done)
      add3(cursor.value.from, cursor.value.to);
  }
};
var setSearchQuery = StateEffect.define();
var togglePanel2 = StateEffect.define();
var searchState = StateField.define({
  create(state) {
    return new SearchState(defaultQuery(state).create(), null);
  },
  update(value, tr3) {
    for (let effect of tr3.effects) {
      if (effect.is(setSearchQuery))
        value = new SearchState(effect.value.create(), value.panel);
      else if (effect.is(togglePanel2))
        value = new SearchState(value.query, effect.value ? createSearchPanel : null);
    }
    return value;
  },
  provide: (f) => showPanel.from(f, (val) => val.panel)
});
var SearchState = class {
  constructor(query, panel) {
    this.query = query;
    this.panel = panel;
  }
};
var matchMark = Decoration.mark({ class: "cm-searchMatch" });
var selectedMatchMark = Decoration.mark({ class: "cm-searchMatch cm-searchMatch-selected" });
var searchHighlighter = ViewPlugin.fromClass(class {
  constructor(view) {
    this.view = view;
    this.decorations = this.highlight(view.state.field(searchState));
  }
  update(update) {
    let state = update.state.field(searchState);
    if (state != update.startState.field(searchState) || update.docChanged || update.selectionSet || update.viewportChanged)
      this.decorations = this.highlight(state);
  }
  highlight({ query, panel }) {
    if (!panel || !query.spec.valid)
      return Decoration.none;
    let { view } = this;
    let builder = new RangeSetBuilder();
    for (let i2 = 0, ranges = view.visibleRanges, l = ranges.length; i2 < l; i2++) {
      let { from, to: to3 } = ranges[i2];
      while (i2 < l - 1 && to3 > ranges[i2 + 1].from - 2 * 250)
        to3 = ranges[++i2].to;
      query.highlight(view.state, from, to3, (from2, to4) => {
        let selected = view.state.selection.ranges.some((r2) => r2.from == from2 && r2.to == to4);
        builder.add(from2, to4, selected ? selectedMatchMark : matchMark);
      });
    }
    return builder.finish();
  }
}, {
  decorations: (v) => v.decorations
});
function searchCommand(f) {
  return (view) => {
    let state = view.state.field(searchState, false);
    return state && state.query.spec.valid ? f(view, state) : openSearchPanel(view);
  };
}
var findNext = searchCommand((view, { query }) => {
  let { to: to3 } = view.state.selection.main;
  let next = query.nextMatch(view.state, to3, to3);
  if (!next)
    return false;
  let selection = EditorSelection.single(next.from, next.to);
  let config2 = view.state.facet(searchConfigFacet);
  view.dispatch({
    selection,
    effects: [announceMatch(view, next), config2.scrollToMatch(selection.main, view)],
    userEvent: "select.search"
  });
  selectSearchInput(view);
  return true;
});
var findPrevious = searchCommand((view, { query }) => {
  let { state } = view, { from } = state.selection.main;
  let prev = query.prevMatch(state, from, from);
  if (!prev)
    return false;
  let selection = EditorSelection.single(prev.from, prev.to);
  let config2 = view.state.facet(searchConfigFacet);
  view.dispatch({
    selection,
    effects: [announceMatch(view, prev), config2.scrollToMatch(selection.main, view)],
    userEvent: "select.search"
  });
  selectSearchInput(view);
  return true;
});
var selectMatches = searchCommand((view, { query }) => {
  let ranges = query.matchAll(view.state, 1e3);
  if (!ranges || !ranges.length)
    return false;
  view.dispatch({
    selection: EditorSelection.create(ranges.map((r2) => EditorSelection.range(r2.from, r2.to))),
    userEvent: "select.search.matches"
  });
  return true;
});
var selectSelectionMatches = ({ state, dispatch }) => {
  let sel = state.selection;
  if (sel.ranges.length > 1 || sel.main.empty)
    return false;
  let { from, to: to3 } = sel.main;
  let ranges = [], main = 0;
  for (let cur2 = new SearchCursor(state.doc, state.sliceDoc(from, to3)); !cur2.next().done; ) {
    if (ranges.length > 1e3)
      return false;
    if (cur2.value.from == from)
      main = ranges.length;
    ranges.push(EditorSelection.range(cur2.value.from, cur2.value.to));
  }
  dispatch(state.update({
    selection: EditorSelection.create(ranges, main),
    userEvent: "select.search.matches"
  }));
  return true;
};
var replaceNext = searchCommand((view, { query }) => {
  let { state } = view, { from, to: to3 } = state.selection.main;
  if (state.readOnly)
    return false;
  let next = query.nextMatch(state, from, from);
  if (!next)
    return false;
  let changes = [], selection, replacement;
  let effects = [];
  if (next.from == from && next.to == to3) {
    replacement = state.toText(query.getReplacement(next));
    changes.push({ from: next.from, to: next.to, insert: replacement });
    next = query.nextMatch(state, next.from, next.to);
    effects.push(EditorView.announce.of(state.phrase("replaced match on line $", state.doc.lineAt(from).number) + "."));
  }
  if (next) {
    let off = changes.length == 0 || changes[0].from >= next.to ? 0 : next.to - next.from - replacement.length;
    selection = EditorSelection.single(next.from - off, next.to - off);
    effects.push(announceMatch(view, next));
    effects.push(state.facet(searchConfigFacet).scrollToMatch(selection.main, view));
  }
  view.dispatch({
    changes,
    selection,
    effects,
    userEvent: "input.replace"
  });
  return true;
});
var replaceAll = searchCommand((view, { query }) => {
  if (view.state.readOnly)
    return false;
  let changes = query.matchAll(view.state, 1e9).map((match) => {
    let { from, to: to3 } = match;
    return { from, to: to3, insert: query.getReplacement(match) };
  });
  if (!changes.length)
    return false;
  let announceText = view.state.phrase("replaced $ matches", changes.length) + ".";
  view.dispatch({
    changes,
    effects: EditorView.announce.of(announceText),
    userEvent: "input.replace.all"
  });
  return true;
});
function createSearchPanel(view) {
  return view.state.facet(searchConfigFacet).createPanel(view);
}
function defaultQuery(state, fallback) {
  var _a4, _b, _c2, _d2, _e2;
  let sel = state.selection.main;
  let selText = sel.empty || sel.to > sel.from + 100 ? "" : state.sliceDoc(sel.from, sel.to);
  if (fallback && !selText)
    return fallback;
  let config2 = state.facet(searchConfigFacet);
  return new SearchQuery({
    search: ((_a4 = fallback === null || fallback === void 0 ? void 0 : fallback.literal) !== null && _a4 !== void 0 ? _a4 : config2.literal) ? selText : selText.replace(/\n/g, "\\n"),
    caseSensitive: (_b = fallback === null || fallback === void 0 ? void 0 : fallback.caseSensitive) !== null && _b !== void 0 ? _b : config2.caseSensitive,
    literal: (_c2 = fallback === null || fallback === void 0 ? void 0 : fallback.literal) !== null && _c2 !== void 0 ? _c2 : config2.literal,
    regexp: (_d2 = fallback === null || fallback === void 0 ? void 0 : fallback.regexp) !== null && _d2 !== void 0 ? _d2 : config2.regexp,
    wholeWord: (_e2 = fallback === null || fallback === void 0 ? void 0 : fallback.wholeWord) !== null && _e2 !== void 0 ? _e2 : config2.wholeWord
  });
}
function getSearchInput(view) {
  let panel = getPanel(view, createSearchPanel);
  return panel && panel.dom.querySelector("[main-field]");
}
function selectSearchInput(view) {
  let input = getSearchInput(view);
  if (input && input == view.root.activeElement)
    input.select();
}
var openSearchPanel = (view) => {
  let state = view.state.field(searchState, false);
  if (state && state.panel) {
    let searchInput = getSearchInput(view);
    if (searchInput && searchInput != view.root.activeElement) {
      let query = defaultQuery(view.state, state.query.spec);
      if (query.valid)
        view.dispatch({ effects: setSearchQuery.of(query) });
      searchInput.focus();
      searchInput.select();
    }
  } else {
    view.dispatch({ effects: [
      togglePanel2.of(true),
      state ? setSearchQuery.of(defaultQuery(view.state, state.query.spec)) : StateEffect.appendConfig.of(searchExtensions)
    ] });
  }
  return true;
};
var closeSearchPanel = (view) => {
  let state = view.state.field(searchState, false);
  if (!state || !state.panel)
    return false;
  let panel = getPanel(view, createSearchPanel);
  if (panel && panel.dom.contains(view.root.activeElement))
    view.focus();
  view.dispatch({ effects: togglePanel2.of(false) });
  return true;
};
var searchKeymap = [
  { key: "Mod-f", run: openSearchPanel, scope: "editor search-panel" },
  { key: "F3", run: findNext, shift: findPrevious, scope: "editor search-panel", preventDefault: true },
  { key: "Mod-g", run: findNext, shift: findPrevious, scope: "editor search-panel", preventDefault: true },
  { key: "Escape", run: closeSearchPanel, scope: "editor search-panel" },
  { key: "Mod-Shift-l", run: selectSelectionMatches },
  { key: "Mod-Alt-g", run: gotoLine },
  { key: "Mod-d", run: selectNextOccurrence, preventDefault: true }
];
var SearchPanel = class {
  constructor(view) {
    this.view = view;
    let query = this.query = view.state.field(searchState).query.spec;
    this.commit = this.commit.bind(this);
    this.searchField = crelt("input", {
      value: query.search,
      placeholder: phrase(view, "Find"),
      "aria-label": phrase(view, "Find"),
      class: "cm-textfield",
      name: "search",
      form: "",
      "main-field": "true",
      onchange: this.commit,
      onkeyup: this.commit
    });
    this.replaceField = crelt("input", {
      value: query.replace,
      placeholder: phrase(view, "Replace"),
      "aria-label": phrase(view, "Replace"),
      class: "cm-textfield",
      name: "replace",
      form: "",
      onchange: this.commit,
      onkeyup: this.commit
    });
    this.caseField = crelt("input", {
      type: "checkbox",
      name: "case",
      form: "",
      checked: query.caseSensitive,
      onchange: this.commit
    });
    this.reField = crelt("input", {
      type: "checkbox",
      name: "re",
      form: "",
      checked: query.regexp,
      onchange: this.commit
    });
    this.wordField = crelt("input", {
      type: "checkbox",
      name: "word",
      form: "",
      checked: query.wholeWord,
      onchange: this.commit
    });
    function button(name2, onclick, content2) {
      return crelt("button", { class: "cm-button", name: name2, onclick, type: "button" }, content2);
    }
    this.dom = crelt("div", { onkeydown: (e2) => this.keydown(e2), class: "cm-search" }, [
      this.searchField,
      button("next", () => findNext(view), [phrase(view, "next")]),
      button("prev", () => findPrevious(view), [phrase(view, "previous")]),
      button("select", () => selectMatches(view), [phrase(view, "all")]),
      crelt("label", null, [this.caseField, phrase(view, "match case")]),
      crelt("label", null, [this.reField, phrase(view, "regexp")]),
      crelt("label", null, [this.wordField, phrase(view, "by word")]),
      ...view.state.readOnly ? [] : [
        crelt("br"),
        this.replaceField,
        button("replace", () => replaceNext(view), [phrase(view, "replace")]),
        button("replaceAll", () => replaceAll(view), [phrase(view, "replace all")])
      ],
      crelt("button", {
        name: "close",
        onclick: () => closeSearchPanel(view),
        "aria-label": phrase(view, "close"),
        type: "button"
      }, ["×"])
    ]);
  }
  commit() {
    let query = new SearchQuery({
      search: this.searchField.value,
      caseSensitive: this.caseField.checked,
      regexp: this.reField.checked,
      wholeWord: this.wordField.checked,
      replace: this.replaceField.value
    });
    if (!query.eq(this.query)) {
      this.query = query;
      this.view.dispatch({ effects: setSearchQuery.of(query) });
    }
  }
  keydown(e2) {
    if (runScopeHandlers(this.view, e2, "search-panel")) {
      e2.preventDefault();
    } else if (e2.keyCode == 13 && e2.target == this.searchField) {
      e2.preventDefault();
      (e2.shiftKey ? findPrevious : findNext)(this.view);
    } else if (e2.keyCode == 13 && e2.target == this.replaceField) {
      e2.preventDefault();
      replaceNext(this.view);
    }
  }
  update(update) {
    for (let tr3 of update.transactions)
      for (let effect of tr3.effects) {
        if (effect.is(setSearchQuery) && !effect.value.eq(this.query))
          this.setQuery(effect.value);
      }
  }
  setQuery(query) {
    this.query = query;
    this.searchField.value = query.search;
    this.replaceField.value = query.replace;
    this.caseField.checked = query.caseSensitive;
    this.reField.checked = query.regexp;
    this.wordField.checked = query.wholeWord;
  }
  mount() {
    this.searchField.select();
  }
  get pos() {
    return 80;
  }
  get top() {
    return this.view.state.facet(searchConfigFacet).top;
  }
};
function phrase(view, phrase2) {
  return view.state.phrase(phrase2);
}
var AnnounceMargin = 30;
var Break = /[\s\.,:;?!]/;
function announceMatch(view, { from, to: to3 }) {
  let line = view.state.doc.lineAt(from), lineEnd = view.state.doc.lineAt(to3).to;
  let start = Math.max(line.from, from - AnnounceMargin), end = Math.min(lineEnd, to3 + AnnounceMargin);
  let text = view.state.sliceDoc(start, end);
  if (start != line.from) {
    for (let i2 = 0; i2 < AnnounceMargin; i2++)
      if (!Break.test(text[i2 + 1]) && Break.test(text[i2])) {
        text = text.slice(i2);
        break;
      }
  }
  if (end != lineEnd) {
    for (let i2 = text.length - 1; i2 > text.length - AnnounceMargin; i2--)
      if (!Break.test(text[i2 - 1]) && Break.test(text[i2])) {
        text = text.slice(0, i2);
        break;
      }
  }
  return EditorView.announce.of(`${view.state.phrase("current match")}. ${text} ${view.state.phrase("on line")} ${line.number}.`);
}
var baseTheme4 = EditorView.baseTheme({
  ".cm-panel.cm-search": {
    padding: "2px 6px 4px",
    position: "relative",
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "4px",
      backgroundColor: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    },
    "& input, & button, & label": {
      margin: ".2em .6em .2em 0"
    },
    "& input[type=checkbox]": {
      marginRight: ".2em"
    },
    "& label": {
      fontSize: "80%",
      whiteSpace: "pre"
    }
  },
  "&light .cm-searchMatch": { backgroundColor: "#ffff0054" },
  "&dark .cm-searchMatch": { backgroundColor: "#00ffff8a" },
  "&light .cm-searchMatch-selected": { backgroundColor: "#ff6a0054" },
  "&dark .cm-searchMatch-selected": { backgroundColor: "#ff00ff8a" }
});
var searchExtensions = [
  searchState,
  Prec.low(searchHighlighter),
  baseTheme4
];

// node_modules/@codemirror/autocomplete/dist/index.js
var CompletionContext = class {
  /**
  Create a new completion context. (Mostly useful for testing
  completion sources—in the editor, the extension will create
  these for you.)
  */
  constructor(state, pos, explicit, view) {
    this.state = state;
    this.pos = pos;
    this.explicit = explicit;
    this.view = view;
    this.abortListeners = [];
    this.abortOnDocChange = false;
  }
  /**
  Get the extent, content, and (if there is a token) type of the
  token before `this.pos`.
  */
  tokenBefore(types2) {
    let token = syntaxTree(this.state).resolveInner(this.pos, -1);
    while (token && types2.indexOf(token.name) < 0)
      token = token.parent;
    return token ? {
      from: token.from,
      to: this.pos,
      text: this.state.sliceDoc(token.from, this.pos),
      type: token.type
    } : null;
  }
  /**
  Get the match of the given expression directly before the
  cursor.
  */
  matchBefore(expr) {
    let line = this.state.doc.lineAt(this.pos);
    let start = Math.max(line.from, this.pos - 250);
    let str = line.text.slice(start - line.from, this.pos - line.from);
    let found = str.search(ensureAnchor(expr, false));
    return found < 0 ? null : { from: start + found, to: this.pos, text: str.slice(found) };
  }
  /**
  Yields true when the query has been aborted. Can be useful in
  asynchronous queries to avoid doing work that will be ignored.
  */
  get aborted() {
    return this.abortListeners == null;
  }
  /**
  Allows you to register abort handlers, which will be called when
  the query is
  [aborted](https://codemirror.net/6/docs/ref/#autocomplete.CompletionContext.aborted).
  
  By default, running queries will not be aborted for regular
  typing or backspacing, on the assumption that they are likely to
  return a result with a
  [`validFor`](https://codemirror.net/6/docs/ref/#autocomplete.CompletionResult.validFor) field that
  allows the result to be used after all. Passing `onDocChange:
  true` will cause this query to be aborted for any document
  change.
  */
  addEventListener(type, listener, options) {
    if (type == "abort" && this.abortListeners) {
      this.abortListeners.push(listener);
      if (options && options.onDocChange)
        this.abortOnDocChange = true;
    }
  }
};
function toSet(chars) {
  let flat = Object.keys(chars).join("");
  let words = /\w/.test(flat);
  if (words)
    flat = flat.replace(/\w/g, "");
  return `[${words ? "\\w" : ""}${flat.replace(/[^\w\s]/g, "\\$&")}]`;
}
function prefixMatch(options) {
  let first = /* @__PURE__ */ Object.create(null), rest = /* @__PURE__ */ Object.create(null);
  for (let { label } of options) {
    first[label[0]] = true;
    for (let i2 = 1; i2 < label.length; i2++)
      rest[label[i2]] = true;
  }
  let source = toSet(first) + toSet(rest) + "*$";
  return [new RegExp("^" + source), new RegExp(source)];
}
function completeFromList(list) {
  let options = list.map((o2) => typeof o2 == "string" ? { label: o2 } : o2);
  let [validFor, match] = options.every((o2) => /^\w+$/.test(o2.label)) ? [/\w*$/, /\w+$/] : prefixMatch(options);
  return (context) => {
    let token = context.matchBefore(match);
    return token || context.explicit ? { from: token ? token.from : context.pos, options, validFor } : null;
  };
}
var Option = class {
  constructor(completion, source, match, score2) {
    this.completion = completion;
    this.source = source;
    this.match = match;
    this.score = score2;
  }
};
function cur(state) {
  return state.selection.main.from;
}
function ensureAnchor(expr, start) {
  var _a4;
  let { source } = expr;
  let addStart = start && source[0] != "^", addEnd = source[source.length - 1] != "$";
  if (!addStart && !addEnd)
    return expr;
  return new RegExp(`${addStart ? "^" : ""}(?:${source})${addEnd ? "$" : ""}`, (_a4 = expr.flags) !== null && _a4 !== void 0 ? _a4 : expr.ignoreCase ? "i" : "");
}
var pickedCompletion = Annotation.define();
function insertCompletionText(state, text, from, to3) {
  let { main } = state.selection, fromOff = from - main.from, toOff = to3 - main.from;
  return Object.assign(Object.assign({}, state.changeByRange((range) => {
    if (range != main && from != to3 && state.sliceDoc(range.from + fromOff, range.from + toOff) != state.sliceDoc(from, to3))
      return { range };
    let lines = state.toText(text);
    return {
      changes: { from: range.from + fromOff, to: to3 == main.from ? range.to : range.from + toOff, insert: lines },
      range: EditorSelection.cursor(range.from + fromOff + lines.length)
    };
  })), { scrollIntoView: true, userEvent: "input.complete" });
}
var SourceCache = /* @__PURE__ */ new WeakMap();
function asSource(source) {
  if (!Array.isArray(source))
    return source;
  let known = SourceCache.get(source);
  if (!known)
    SourceCache.set(source, known = completeFromList(source));
  return known;
}
var startCompletionEffect = StateEffect.define();
var closeCompletionEffect = StateEffect.define();
var FuzzyMatcher = class {
  constructor(pattern) {
    this.pattern = pattern;
    this.chars = [];
    this.folded = [];
    this.any = [];
    this.precise = [];
    this.byWord = [];
    this.score = 0;
    this.matched = [];
    for (let p = 0; p < pattern.length; ) {
      let char = codePointAt(pattern, p), size = codePointSize(char);
      this.chars.push(char);
      let part = pattern.slice(p, p + size), upper = part.toUpperCase();
      this.folded.push(codePointAt(upper == part ? part.toLowerCase() : upper, 0));
      p += size;
    }
    this.astral = pattern.length != this.chars.length;
  }
  ret(score2, matched) {
    this.score = score2;
    this.matched = matched;
    return this;
  }
  // Matches a given word (completion) against the pattern (input).
  // Will return a boolean indicating whether there was a match and,
  // on success, set `this.score` to the score, `this.matched` to an
  // array of `from, to` pairs indicating the matched parts of `word`.
  //
  // The score is a number that is more negative the worse the match
  // is. See `Penalty` above.
  match(word) {
    if (this.pattern.length == 0)
      return this.ret(-100, []);
    if (word.length < this.pattern.length)
      return null;
    let { chars, folded, any, precise, byWord } = this;
    if (chars.length == 1) {
      let first = codePointAt(word, 0), firstSize = codePointSize(first);
      let score2 = firstSize == word.length ? 0 : -100;
      if (first == chars[0]) ;
      else if (first == folded[0])
        score2 += -200;
      else
        return null;
      return this.ret(score2, [0, firstSize]);
    }
    let direct = word.indexOf(this.pattern);
    if (direct == 0)
      return this.ret(word.length == this.pattern.length ? 0 : -100, [0, this.pattern.length]);
    let len = chars.length, anyTo = 0;
    if (direct < 0) {
      for (let i2 = 0, e2 = Math.min(word.length, 200); i2 < e2 && anyTo < len; ) {
        let next = codePointAt(word, i2);
        if (next == chars[anyTo] || next == folded[anyTo])
          any[anyTo++] = i2;
        i2 += codePointSize(next);
      }
      if (anyTo < len)
        return null;
    }
    let preciseTo = 0;
    let byWordTo = 0, byWordFolded = false;
    let adjacentTo = 0, adjacentStart = -1, adjacentEnd = -1;
    let hasLower = /[a-z]/.test(word), wordAdjacent = true;
    for (let i2 = 0, e2 = Math.min(word.length, 200), prevType = 0; i2 < e2 && byWordTo < len; ) {
      let next = codePointAt(word, i2);
      if (direct < 0) {
        if (preciseTo < len && next == chars[preciseTo])
          precise[preciseTo++] = i2;
        if (adjacentTo < len) {
          if (next == chars[adjacentTo] || next == folded[adjacentTo]) {
            if (adjacentTo == 0)
              adjacentStart = i2;
            adjacentEnd = i2 + 1;
            adjacentTo++;
          } else {
            adjacentTo = 0;
          }
        }
      }
      let ch2, type = next < 255 ? next >= 48 && next <= 57 || next >= 97 && next <= 122 ? 2 : next >= 65 && next <= 90 ? 1 : 0 : (ch2 = fromCodePoint(next)) != ch2.toLowerCase() ? 1 : ch2 != ch2.toUpperCase() ? 2 : 0;
      if (!i2 || type == 1 && hasLower || prevType == 0 && type != 0) {
        if (chars[byWordTo] == next || folded[byWordTo] == next && (byWordFolded = true))
          byWord[byWordTo++] = i2;
        else if (byWord.length)
          wordAdjacent = false;
      }
      prevType = type;
      i2 += codePointSize(next);
    }
    if (byWordTo == len && byWord[0] == 0 && wordAdjacent)
      return this.result(-100 + (byWordFolded ? -200 : 0), byWord, word);
    if (adjacentTo == len && adjacentStart == 0)
      return this.ret(-200 - word.length + (adjacentEnd == word.length ? 0 : -100), [0, adjacentEnd]);
    if (direct > -1)
      return this.ret(-700 - word.length, [direct, direct + this.pattern.length]);
    if (adjacentTo == len)
      return this.ret(-200 + -700 - word.length, [adjacentStart, adjacentEnd]);
    if (byWordTo == len)
      return this.result(-100 + (byWordFolded ? -200 : 0) + -700 + (wordAdjacent ? 0 : -1100), byWord, word);
    return chars.length == 2 ? null : this.result((any[0] ? -700 : 0) + -200 + -1100, any, word);
  }
  result(score2, positions, word) {
    let result = [], i2 = 0;
    for (let pos of positions) {
      let to3 = pos + (this.astral ? codePointSize(codePointAt(word, pos)) : 1);
      if (i2 && result[i2 - 1] == pos)
        result[i2 - 1] = to3;
      else {
        result[i2++] = pos;
        result[i2++] = to3;
      }
    }
    return this.ret(score2 - word.length, result);
  }
};
var StrictMatcher = class {
  constructor(pattern) {
    this.pattern = pattern;
    this.matched = [];
    this.score = 0;
    this.folded = pattern.toLowerCase();
  }
  match(word) {
    if (word.length < this.pattern.length)
      return null;
    let start = word.slice(0, this.pattern.length);
    let match = start == this.pattern ? 0 : start.toLowerCase() == this.folded ? -200 : null;
    if (match == null)
      return null;
    this.matched = [0, start.length];
    this.score = match + (word.length == this.pattern.length ? 0 : -100);
    return this;
  }
};
var completionConfig = Facet.define({
  combine(configs) {
    return combineConfig(configs, {
      activateOnTyping: true,
      activateOnCompletion: () => false,
      activateOnTypingDelay: 100,
      selectOnOpen: true,
      override: null,
      closeOnBlur: true,
      maxRenderedOptions: 100,
      defaultKeymap: true,
      tooltipClass: () => "",
      optionClass: () => "",
      aboveCursor: false,
      icons: true,
      addToOptions: [],
      positionInfo: defaultPositionInfo,
      filterStrict: false,
      compareCompletions: (a2, b2) => a2.label.localeCompare(b2.label),
      interactionDelay: 75,
      updateSyncTime: 100
    }, {
      defaultKeymap: (a2, b2) => a2 && b2,
      closeOnBlur: (a2, b2) => a2 && b2,
      icons: (a2, b2) => a2 && b2,
      tooltipClass: (a2, b2) => (c) => joinClass(a2(c), b2(c)),
      optionClass: (a2, b2) => (c) => joinClass(a2(c), b2(c)),
      addToOptions: (a2, b2) => a2.concat(b2),
      filterStrict: (a2, b2) => a2 || b2
    });
  }
});
function joinClass(a2, b2) {
  return a2 ? b2 ? a2 + " " + b2 : a2 : b2;
}
function defaultPositionInfo(view, list, option, info, space, tooltip) {
  let rtl = view.textDirection == Direction.RTL, left = rtl, narrow = false;
  let side = "top", offset, maxWidth;
  let spaceLeft = list.left - space.left, spaceRight = space.right - list.right;
  let infoWidth = info.right - info.left, infoHeight = info.bottom - info.top;
  if (left && spaceLeft < Math.min(infoWidth, spaceRight))
    left = false;
  else if (!left && spaceRight < Math.min(infoWidth, spaceLeft))
    left = true;
  if (infoWidth <= (left ? spaceLeft : spaceRight)) {
    offset = Math.max(space.top, Math.min(option.top, space.bottom - infoHeight)) - list.top;
    maxWidth = Math.min(400, left ? spaceLeft : spaceRight);
  } else {
    narrow = true;
    maxWidth = Math.min(
      400,
      (rtl ? list.right : space.right - list.left) - 30
      /* Info.Margin */
    );
    let spaceBelow = space.bottom - list.bottom;
    if (spaceBelow >= infoHeight || spaceBelow > list.top) {
      offset = option.bottom - list.top;
    } else {
      side = "bottom";
      offset = list.bottom - option.top;
    }
  }
  let scaleY = (list.bottom - list.top) / tooltip.offsetHeight;
  let scaleX = (list.right - list.left) / tooltip.offsetWidth;
  return {
    style: `${side}: ${offset / scaleY}px; max-width: ${maxWidth / scaleX}px`,
    class: "cm-completionInfo-" + (narrow ? rtl ? "left-narrow" : "right-narrow" : left ? "left" : "right")
  };
}
function optionContent(config2) {
  let content2 = config2.addToOptions.slice();
  if (config2.icons)
    content2.push({
      render(completion) {
        let icon = document.createElement("div");
        icon.classList.add("cm-completionIcon");
        if (completion.type)
          icon.classList.add(...completion.type.split(/\s+/g).map((cls) => "cm-completionIcon-" + cls));
        icon.setAttribute("aria-hidden", "true");
        return icon;
      },
      position: 20
    });
  content2.push({
    render(completion, _s2, _v2, match) {
      let labelElt = document.createElement("span");
      labelElt.className = "cm-completionLabel";
      let label = completion.displayLabel || completion.label, off = 0;
      for (let j = 0; j < match.length; ) {
        let from = match[j++], to3 = match[j++];
        if (from > off)
          labelElt.appendChild(document.createTextNode(label.slice(off, from)));
        let span = labelElt.appendChild(document.createElement("span"));
        span.appendChild(document.createTextNode(label.slice(from, to3)));
        span.className = "cm-completionMatchedText";
        off = to3;
      }
      if (off < label.length)
        labelElt.appendChild(document.createTextNode(label.slice(off)));
      return labelElt;
    },
    position: 50
  }, {
    render(completion) {
      if (!completion.detail)
        return null;
      let detailElt = document.createElement("span");
      detailElt.className = "cm-completionDetail";
      detailElt.textContent = completion.detail;
      return detailElt;
    },
    position: 80
  });
  return content2.sort((a2, b2) => a2.position - b2.position).map((a2) => a2.render);
}
function rangeAroundSelected(total, selected, max) {
  if (total <= max)
    return { from: 0, to: total };
  if (selected < 0)
    selected = 0;
  if (selected <= total >> 1) {
    let off2 = Math.floor(selected / max);
    return { from: off2 * max, to: (off2 + 1) * max };
  }
  let off = Math.floor((total - selected) / max);
  return { from: total - (off + 1) * max, to: total - off * max };
}
var CompletionTooltip = class {
  constructor(view, stateField, applyCompletion2) {
    this.view = view;
    this.stateField = stateField;
    this.applyCompletion = applyCompletion2;
    this.info = null;
    this.infoDestroy = null;
    this.placeInfoReq = {
      read: () => this.measureInfo(),
      write: (pos) => this.placeInfo(pos),
      key: this
    };
    this.space = null;
    this.currentClass = "";
    let cState = view.state.field(stateField);
    let { options, selected } = cState.open;
    let config2 = view.state.facet(completionConfig);
    this.optionContent = optionContent(config2);
    this.optionClass = config2.optionClass;
    this.tooltipClass = config2.tooltipClass;
    this.range = rangeAroundSelected(options.length, selected, config2.maxRenderedOptions);
    this.dom = document.createElement("div");
    this.dom.className = "cm-tooltip-autocomplete";
    this.updateTooltipClass(view.state);
    this.dom.addEventListener("mousedown", (e2) => {
      let { options: options2 } = view.state.field(stateField).open;
      for (let dom = e2.target, match; dom && dom != this.dom; dom = dom.parentNode) {
        if (dom.nodeName == "LI" && (match = /-(\d+)$/.exec(dom.id)) && +match[1] < options2.length) {
          this.applyCompletion(view, options2[+match[1]]);
          e2.preventDefault();
          return;
        }
      }
    });
    this.dom.addEventListener("focusout", (e2) => {
      let state = view.state.field(this.stateField, false);
      if (state && state.tooltip && view.state.facet(completionConfig).closeOnBlur && e2.relatedTarget != view.contentDOM)
        view.dispatch({ effects: closeCompletionEffect.of(null) });
    });
    this.showOptions(options, cState.id);
  }
  mount() {
    this.updateSel();
  }
  showOptions(options, id2) {
    if (this.list)
      this.list.remove();
    this.list = this.dom.appendChild(this.createListBox(options, id2, this.range));
    this.list.addEventListener("scroll", () => {
      if (this.info)
        this.view.requestMeasure(this.placeInfoReq);
    });
  }
  update(update) {
    var _a4;
    let cState = update.state.field(this.stateField);
    let prevState = update.startState.field(this.stateField);
    this.updateTooltipClass(update.state);
    if (cState != prevState) {
      let { options, selected, disabled } = cState.open;
      if (!prevState.open || prevState.open.options != options) {
        this.range = rangeAroundSelected(options.length, selected, update.state.facet(completionConfig).maxRenderedOptions);
        this.showOptions(options, cState.id);
      }
      this.updateSel();
      if (disabled != ((_a4 = prevState.open) === null || _a4 === void 0 ? void 0 : _a4.disabled))
        this.dom.classList.toggle("cm-tooltip-autocomplete-disabled", !!disabled);
    }
  }
  updateTooltipClass(state) {
    let cls = this.tooltipClass(state);
    if (cls != this.currentClass) {
      for (let c of this.currentClass.split(" "))
        if (c)
          this.dom.classList.remove(c);
      for (let c of cls.split(" "))
        if (c)
          this.dom.classList.add(c);
      this.currentClass = cls;
    }
  }
  positioned(space) {
    this.space = space;
    if (this.info)
      this.view.requestMeasure(this.placeInfoReq);
  }
  updateSel() {
    let cState = this.view.state.field(this.stateField), open = cState.open;
    if (open.selected > -1 && open.selected < this.range.from || open.selected >= this.range.to) {
      this.range = rangeAroundSelected(open.options.length, open.selected, this.view.state.facet(completionConfig).maxRenderedOptions);
      this.showOptions(open.options, cState.id);
    }
    if (this.updateSelectedOption(open.selected)) {
      this.destroyInfo();
      let { completion } = open.options[open.selected];
      let { info } = completion;
      if (!info)
        return;
      let infoResult = typeof info === "string" ? document.createTextNode(info) : info(completion);
      if (!infoResult)
        return;
      if ("then" in infoResult) {
        infoResult.then((obj) => {
          if (obj && this.view.state.field(this.stateField, false) == cState)
            this.addInfoPane(obj, completion);
        }).catch((e2) => logException(this.view.state, e2, "completion info"));
      } else {
        this.addInfoPane(infoResult, completion);
      }
    }
  }
  addInfoPane(content2, completion) {
    this.destroyInfo();
    let wrap = this.info = document.createElement("div");
    wrap.className = "cm-tooltip cm-completionInfo";
    if (content2.nodeType != null) {
      wrap.appendChild(content2);
      this.infoDestroy = null;
    } else {
      let { dom, destroy } = content2;
      wrap.appendChild(dom);
      this.infoDestroy = destroy || null;
    }
    this.dom.appendChild(wrap);
    this.view.requestMeasure(this.placeInfoReq);
  }
  updateSelectedOption(selected) {
    let set = null;
    for (let opt = this.list.firstChild, i2 = this.range.from; opt; opt = opt.nextSibling, i2++) {
      if (opt.nodeName != "LI" || !opt.id) {
        i2--;
      } else if (i2 == selected) {
        if (!opt.hasAttribute("aria-selected")) {
          opt.setAttribute("aria-selected", "true");
          set = opt;
        }
      } else {
        if (opt.hasAttribute("aria-selected"))
          opt.removeAttribute("aria-selected");
      }
    }
    if (set)
      scrollIntoView2(this.list, set);
    return set;
  }
  measureInfo() {
    let sel = this.dom.querySelector("[aria-selected]");
    if (!sel || !this.info)
      return null;
    let listRect = this.dom.getBoundingClientRect();
    let infoRect = this.info.getBoundingClientRect();
    let selRect = sel.getBoundingClientRect();
    let space = this.space;
    if (!space) {
      let win = this.dom.ownerDocument.defaultView || window;
      space = { left: 0, top: 0, right: win.innerWidth, bottom: win.innerHeight };
    }
    if (selRect.top > Math.min(space.bottom, listRect.bottom) - 10 || selRect.bottom < Math.max(space.top, listRect.top) + 10)
      return null;
    return this.view.state.facet(completionConfig).positionInfo(this.view, listRect, selRect, infoRect, space, this.dom);
  }
  placeInfo(pos) {
    if (this.info) {
      if (pos) {
        if (pos.style)
          this.info.style.cssText = pos.style;
        this.info.className = "cm-tooltip cm-completionInfo " + (pos.class || "");
      } else {
        this.info.style.cssText = "top: -1e6px";
      }
    }
  }
  createListBox(options, id2, range) {
    const ul2 = document.createElement("ul");
    ul2.id = id2;
    ul2.setAttribute("role", "listbox");
    ul2.setAttribute("aria-expanded", "true");
    ul2.setAttribute("aria-label", this.view.state.phrase("Completions"));
    let curSection = null;
    for (let i2 = range.from; i2 < range.to; i2++) {
      let { completion, match } = options[i2], { section } = completion;
      if (section) {
        let name2 = typeof section == "string" ? section : section.name;
        if (name2 != curSection && (i2 > range.from || range.from == 0)) {
          curSection = name2;
          if (typeof section != "string" && section.header) {
            ul2.appendChild(section.header(section));
          } else {
            let header = ul2.appendChild(document.createElement("completion-section"));
            header.textContent = name2;
          }
        }
      }
      const li3 = ul2.appendChild(document.createElement("li"));
      li3.id = id2 + "-" + i2;
      li3.setAttribute("role", "option");
      let cls = this.optionClass(completion);
      if (cls)
        li3.className = cls;
      for (let source of this.optionContent) {
        let node = source(completion, this.view.state, this.view, match);
        if (node)
          li3.appendChild(node);
      }
    }
    if (range.from)
      ul2.classList.add("cm-completionListIncompleteTop");
    if (range.to < options.length)
      ul2.classList.add("cm-completionListIncompleteBottom");
    return ul2;
  }
  destroyInfo() {
    if (this.info) {
      if (this.infoDestroy)
        this.infoDestroy();
      this.info.remove();
      this.info = null;
    }
  }
  destroy() {
    this.destroyInfo();
  }
};
function completionTooltip(stateField, applyCompletion2) {
  return (view) => new CompletionTooltip(view, stateField, applyCompletion2);
}
function scrollIntoView2(container, element) {
  let parent = container.getBoundingClientRect();
  let self2 = element.getBoundingClientRect();
  let scaleY = parent.height / container.offsetHeight;
  if (self2.top < parent.top)
    container.scrollTop -= (parent.top - self2.top) / scaleY;
  else if (self2.bottom > parent.bottom)
    container.scrollTop += (self2.bottom - parent.bottom) / scaleY;
}
function score(option) {
  return (option.boost || 0) * 100 + (option.apply ? 10 : 0) + (option.info ? 5 : 0) + (option.type ? 1 : 0);
}
function sortOptions(active, state) {
  let options = [];
  let sections = null;
  let addOption = (option) => {
    options.push(option);
    let { section } = option.completion;
    if (section) {
      if (!sections)
        sections = [];
      let name2 = typeof section == "string" ? section : section.name;
      if (!sections.some((s2) => s2.name == name2))
        sections.push(typeof section == "string" ? { name: name2 } : section);
    }
  };
  let conf = state.facet(completionConfig);
  for (let a2 of active)
    if (a2.hasResult()) {
      let getMatch = a2.result.getMatch;
      if (a2.result.filter === false) {
        for (let option of a2.result.options) {
          addOption(new Option(option, a2.source, getMatch ? getMatch(option) : [], 1e9 - options.length));
        }
      } else {
        let pattern = state.sliceDoc(a2.from, a2.to), match;
        let matcher2 = conf.filterStrict ? new StrictMatcher(pattern) : new FuzzyMatcher(pattern);
        for (let option of a2.result.options)
          if (match = matcher2.match(option.label)) {
            let matched = !option.displayLabel ? match.matched : getMatch ? getMatch(option, match.matched) : [];
            addOption(new Option(option, a2.source, matched, match.score + (option.boost || 0)));
          }
      }
    }
  if (sections) {
    let sectionOrder = /* @__PURE__ */ Object.create(null), pos = 0;
    let cmp = (a2, b2) => {
      var _a4, _b;
      return ((_a4 = a2.rank) !== null && _a4 !== void 0 ? _a4 : 1e9) - ((_b = b2.rank) !== null && _b !== void 0 ? _b : 1e9) || (a2.name < b2.name ? -1 : 1);
    };
    for (let s2 of sections.sort(cmp)) {
      pos -= 1e5;
      sectionOrder[s2.name] = pos;
    }
    for (let option of options) {
      let { section } = option.completion;
      if (section)
        option.score += sectionOrder[typeof section == "string" ? section : section.name];
    }
  }
  let result = [], prev = null;
  let compare2 = conf.compareCompletions;
  for (let opt of options.sort((a2, b2) => b2.score - a2.score || compare2(a2.completion, b2.completion))) {
    let cur2 = opt.completion;
    if (!prev || prev.label != cur2.label || prev.detail != cur2.detail || prev.type != null && cur2.type != null && prev.type != cur2.type || prev.apply != cur2.apply || prev.boost != cur2.boost)
      result.push(opt);
    else if (score(opt.completion) > score(prev))
      result[result.length - 1] = opt;
    prev = opt.completion;
  }
  return result;
}
var CompletionDialog = class _CompletionDialog {
  constructor(options, attrs, tooltip, timestamp, selected, disabled) {
    this.options = options;
    this.attrs = attrs;
    this.tooltip = tooltip;
    this.timestamp = timestamp;
    this.selected = selected;
    this.disabled = disabled;
  }
  setSelected(selected, id2) {
    return selected == this.selected || selected >= this.options.length ? this : new _CompletionDialog(this.options, makeAttrs(id2, selected), this.tooltip, this.timestamp, selected, this.disabled);
  }
  static build(active, state, id2, prev, conf) {
    let options = sortOptions(active, state);
    if (!options.length) {
      return prev && active.some(
        (a2) => a2.state == 1
        /* State.Pending */
      ) ? new _CompletionDialog(prev.options, prev.attrs, prev.tooltip, prev.timestamp, prev.selected, true) : null;
    }
    let selected = state.facet(completionConfig).selectOnOpen ? 0 : -1;
    if (prev && prev.selected != selected && prev.selected != -1) {
      let selectedValue = prev.options[prev.selected].completion;
      for (let i2 = 0; i2 < options.length; i2++)
        if (options[i2].completion == selectedValue) {
          selected = i2;
          break;
        }
    }
    return new _CompletionDialog(options, makeAttrs(id2, selected), {
      pos: active.reduce((a2, b2) => b2.hasResult() ? Math.min(a2, b2.from) : a2, 1e8),
      create: createTooltip,
      above: conf.aboveCursor
    }, prev ? prev.timestamp : Date.now(), selected, false);
  }
  map(changes) {
    return new _CompletionDialog(this.options, this.attrs, Object.assign(Object.assign({}, this.tooltip), { pos: changes.mapPos(this.tooltip.pos) }), this.timestamp, this.selected, this.disabled);
  }
};
var CompletionState = class _CompletionState {
  constructor(active, id2, open) {
    this.active = active;
    this.id = id2;
    this.open = open;
  }
  static start() {
    return new _CompletionState(none3, "cm-ac-" + Math.floor(Math.random() * 2e6).toString(36), null);
  }
  update(tr3) {
    let { state } = tr3, conf = state.facet(completionConfig);
    let sources = conf.override || state.languageDataAt("autocomplete", cur(state)).map(asSource);
    let active = sources.map((source) => {
      let value = this.active.find((s2) => s2.source == source) || new ActiveSource(
        source,
        this.active.some(
          (a2) => a2.state != 0
          /* State.Inactive */
        ) ? 1 : 0
        /* State.Inactive */
      );
      return value.update(tr3, conf);
    });
    if (active.length == this.active.length && active.every((a2, i2) => a2 == this.active[i2]))
      active = this.active;
    let open = this.open;
    if (open && tr3.docChanged)
      open = open.map(tr3.changes);
    if (tr3.selection || active.some((a2) => a2.hasResult() && tr3.changes.touchesRange(a2.from, a2.to)) || !sameResults(active, this.active))
      open = CompletionDialog.build(active, state, this.id, open, conf);
    else if (open && open.disabled && !active.some(
      (a2) => a2.state == 1
      /* State.Pending */
    ))
      open = null;
    if (!open && active.every(
      (a2) => a2.state != 1
      /* State.Pending */
    ) && active.some((a2) => a2.hasResult()))
      active = active.map((a2) => a2.hasResult() ? new ActiveSource(
        a2.source,
        0
        /* State.Inactive */
      ) : a2);
    for (let effect of tr3.effects)
      if (effect.is(setSelectedEffect))
        open = open && open.setSelected(effect.value, this.id);
    return active == this.active && open == this.open ? this : new _CompletionState(active, this.id, open);
  }
  get tooltip() {
    return this.open ? this.open.tooltip : null;
  }
  get attrs() {
    return this.open ? this.open.attrs : this.active.length ? baseAttrs : noAttrs2;
  }
};
function sameResults(a2, b2) {
  if (a2 == b2)
    return true;
  for (let iA = 0, iB = 0; ; ) {
    while (iA < a2.length && !a2[iA].hasResult)
      iA++;
    while (iB < b2.length && !b2[iB].hasResult)
      iB++;
    let endA = iA == a2.length, endB = iB == b2.length;
    if (endA || endB)
      return endA == endB;
    if (a2[iA++].result != b2[iB++].result)
      return false;
  }
}
var baseAttrs = {
  "aria-autocomplete": "list"
};
var noAttrs2 = {};
function makeAttrs(id2, selected) {
  let result = {
    "aria-autocomplete": "list",
    "aria-haspopup": "listbox",
    "aria-controls": id2
  };
  if (selected > -1)
    result["aria-activedescendant"] = id2 + "-" + selected;
  return result;
}
var none3 = [];
function getUpdateType(tr3, conf) {
  if (tr3.isUserEvent("input.complete")) {
    let completion = tr3.annotation(pickedCompletion);
    if (completion && conf.activateOnCompletion(completion))
      return 4 | 8;
  }
  let typing = tr3.isUserEvent("input.type");
  return typing && conf.activateOnTyping ? 4 | 1 : typing ? 1 : tr3.isUserEvent("delete.backward") ? 2 : tr3.selection ? 8 : tr3.docChanged ? 16 : 0;
}
var ActiveSource = class _ActiveSource {
  constructor(source, state, explicitPos = -1) {
    this.source = source;
    this.state = state;
    this.explicitPos = explicitPos;
  }
  hasResult() {
    return false;
  }
  update(tr3, conf) {
    let type = getUpdateType(tr3, conf), value = this;
    if (type & 8 || type & 16 && this.touches(tr3))
      value = new _ActiveSource(
        value.source,
        0
        /* State.Inactive */
      );
    if (type & 4 && value.state == 0)
      value = new _ActiveSource(
        this.source,
        1
        /* State.Pending */
      );
    value = value.updateFor(tr3, type);
    for (let effect of tr3.effects) {
      if (effect.is(startCompletionEffect))
        value = new _ActiveSource(value.source, 1, effect.value ? cur(tr3.state) : -1);
      else if (effect.is(closeCompletionEffect))
        value = new _ActiveSource(
          value.source,
          0
          /* State.Inactive */
        );
      else if (effect.is(setActiveEffect)) {
        for (let active of effect.value)
          if (active.source == value.source)
            value = active;
      }
    }
    return value;
  }
  updateFor(tr3, type) {
    return this.map(tr3.changes);
  }
  map(changes) {
    return changes.empty || this.explicitPos < 0 ? this : new _ActiveSource(this.source, this.state, changes.mapPos(this.explicitPos));
  }
  touches(tr3) {
    return tr3.changes.touchesRange(cur(tr3.state));
  }
};
var ActiveResult = class _ActiveResult extends ActiveSource {
  constructor(source, explicitPos, result, from, to3) {
    super(source, 2, explicitPos);
    this.result = result;
    this.from = from;
    this.to = to3;
  }
  hasResult() {
    return true;
  }
  updateFor(tr3, type) {
    var _a4;
    if (!(type & 3))
      return this.map(tr3.changes);
    let result = this.result;
    if (result.map && !tr3.changes.empty)
      result = result.map(result, tr3.changes);
    let from = tr3.changes.mapPos(this.from), to3 = tr3.changes.mapPos(this.to, 1);
    let pos = cur(tr3.state);
    if ((this.explicitPos < 0 ? pos <= from : pos < this.from) || pos > to3 || !result || type & 2 && cur(tr3.startState) == this.from)
      return new ActiveSource(
        this.source,
        type & 4 ? 1 : 0
        /* State.Inactive */
      );
    let explicitPos = this.explicitPos < 0 ? -1 : tr3.changes.mapPos(this.explicitPos);
    if (checkValid(result.validFor, tr3.state, from, to3))
      return new _ActiveResult(this.source, explicitPos, result, from, to3);
    if (result.update && (result = result.update(result, from, to3, new CompletionContext(tr3.state, pos, explicitPos >= 0))))
      return new _ActiveResult(this.source, explicitPos, result, result.from, (_a4 = result.to) !== null && _a4 !== void 0 ? _a4 : cur(tr3.state));
    return new ActiveSource(this.source, 1, explicitPos);
  }
  map(mapping) {
    if (mapping.empty)
      return this;
    let result = this.result.map ? this.result.map(this.result, mapping) : this.result;
    if (!result)
      return new ActiveSource(
        this.source,
        0
        /* State.Inactive */
      );
    return new _ActiveResult(this.source, this.explicitPos < 0 ? -1 : mapping.mapPos(this.explicitPos), this.result, mapping.mapPos(this.from), mapping.mapPos(this.to, 1));
  }
  touches(tr3) {
    return tr3.changes.touchesRange(this.from, this.to);
  }
};
function checkValid(validFor, state, from, to3) {
  if (!validFor)
    return false;
  let text = state.sliceDoc(from, to3);
  return typeof validFor == "function" ? validFor(text, from, to3, state) : ensureAnchor(validFor, true).test(text);
}
var setActiveEffect = StateEffect.define({
  map(sources, mapping) {
    return sources.map((s2) => s2.map(mapping));
  }
});
var setSelectedEffect = StateEffect.define();
var completionState = StateField.define({
  create() {
    return CompletionState.start();
  },
  update(value, tr3) {
    return value.update(tr3);
  },
  provide: (f) => [
    showTooltip.from(f, (val) => val.tooltip),
    EditorView.contentAttributes.from(f, (state) => state.attrs)
  ]
});
function applyCompletion(view, option) {
  const apply = option.completion.apply || option.completion.label;
  let result = view.state.field(completionState).active.find((a2) => a2.source == option.source);
  if (!(result instanceof ActiveResult))
    return false;
  if (typeof apply == "string")
    view.dispatch(Object.assign(Object.assign({}, insertCompletionText(view.state, apply, result.from, result.to)), { annotations: pickedCompletion.of(option.completion) }));
  else
    apply(view, option.completion, result.from, result.to);
  return true;
}
var createTooltip = completionTooltip(completionState, applyCompletion);
function moveCompletionSelection(forward, by = "option") {
  return (view) => {
    let cState = view.state.field(completionState, false);
    if (!cState || !cState.open || cState.open.disabled || Date.now() - cState.open.timestamp < view.state.facet(completionConfig).interactionDelay)
      return false;
    let step = 1, tooltip;
    if (by == "page" && (tooltip = getTooltip(view, cState.open.tooltip)))
      step = Math.max(2, Math.floor(tooltip.dom.offsetHeight / tooltip.dom.querySelector("li").offsetHeight) - 1);
    let { length } = cState.open.options;
    let selected = cState.open.selected > -1 ? cState.open.selected + step * (forward ? 1 : -1) : forward ? 0 : length - 1;
    if (selected < 0)
      selected = by == "page" ? 0 : length - 1;
    else if (selected >= length)
      selected = by == "page" ? length - 1 : 0;
    view.dispatch({ effects: setSelectedEffect.of(selected) });
    return true;
  };
}
var acceptCompletion = (view) => {
  let cState = view.state.field(completionState, false);
  if (view.state.readOnly || !cState || !cState.open || cState.open.selected < 0 || cState.open.disabled || Date.now() - cState.open.timestamp < view.state.facet(completionConfig).interactionDelay)
    return false;
  return applyCompletion(view, cState.open.options[cState.open.selected]);
};
var startCompletion = (view) => {
  let cState = view.state.field(completionState, false);
  if (!cState)
    return false;
  view.dispatch({ effects: startCompletionEffect.of(true) });
  return true;
};
var closeCompletion = (view) => {
  let cState = view.state.field(completionState, false);
  if (!cState || !cState.active.some(
    (a2) => a2.state != 0
    /* State.Inactive */
  ))
    return false;
  view.dispatch({ effects: closeCompletionEffect.of(null) });
  return true;
};
var RunningQuery = class {
  constructor(active, context) {
    this.active = active;
    this.context = context;
    this.time = Date.now();
    this.updates = [];
    this.done = void 0;
  }
};
var MaxUpdateCount = 50;
var MinAbortTime = 1e3;
var completionPlugin = ViewPlugin.fromClass(class {
  constructor(view) {
    this.view = view;
    this.debounceUpdate = -1;
    this.running = [];
    this.debounceAccept = -1;
    this.pendingStart = false;
    this.composing = 0;
    for (let active of view.state.field(completionState).active)
      if (active.state == 1)
        this.startQuery(active);
  }
  update(update) {
    let cState = update.state.field(completionState);
    let conf = update.state.facet(completionConfig);
    if (!update.selectionSet && !update.docChanged && update.startState.field(completionState) == cState)
      return;
    let doesReset = update.transactions.some((tr3) => {
      let type = getUpdateType(tr3, conf);
      return type & 8 || (tr3.selection || tr3.docChanged) && !(type & 3);
    });
    for (let i2 = 0; i2 < this.running.length; i2++) {
      let query = this.running[i2];
      if (doesReset || query.context.abortOnDocChange && update.docChanged || query.updates.length + update.transactions.length > MaxUpdateCount && Date.now() - query.time > MinAbortTime) {
        for (let handler of query.context.abortListeners) {
          try {
            handler();
          } catch (e2) {
            logException(this.view.state, e2);
          }
        }
        query.context.abortListeners = null;
        this.running.splice(i2--, 1);
      } else {
        query.updates.push(...update.transactions);
      }
    }
    if (this.debounceUpdate > -1)
      clearTimeout(this.debounceUpdate);
    if (update.transactions.some((tr3) => tr3.effects.some((e2) => e2.is(startCompletionEffect))))
      this.pendingStart = true;
    let delay = this.pendingStart ? 50 : conf.activateOnTypingDelay;
    this.debounceUpdate = cState.active.some((a2) => a2.state == 1 && !this.running.some((q2) => q2.active.source == a2.source)) ? setTimeout(() => this.startUpdate(), delay) : -1;
    if (this.composing != 0)
      for (let tr3 of update.transactions) {
        if (tr3.isUserEvent("input.type"))
          this.composing = 2;
        else if (this.composing == 2 && tr3.selection)
          this.composing = 3;
      }
  }
  startUpdate() {
    this.debounceUpdate = -1;
    this.pendingStart = false;
    let { state } = this.view, cState = state.field(completionState);
    for (let active of cState.active) {
      if (active.state == 1 && !this.running.some((r2) => r2.active.source == active.source))
        this.startQuery(active);
    }
  }
  startQuery(active) {
    let { state } = this.view, pos = cur(state);
    let context = new CompletionContext(state, pos, active.explicitPos == pos, this.view);
    let pending = new RunningQuery(active, context);
    this.running.push(pending);
    Promise.resolve(active.source(context)).then((result) => {
      if (!pending.context.aborted) {
        pending.done = result || null;
        this.scheduleAccept();
      }
    }, (err) => {
      this.view.dispatch({ effects: closeCompletionEffect.of(null) });
      logException(this.view.state, err);
    });
  }
  scheduleAccept() {
    if (this.running.every((q2) => q2.done !== void 0))
      this.accept();
    else if (this.debounceAccept < 0)
      this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(completionConfig).updateSyncTime);
  }
  // For each finished query in this.running, try to create a result
  // or, if appropriate, restart the query.
  accept() {
    var _a4;
    if (this.debounceAccept > -1)
      clearTimeout(this.debounceAccept);
    this.debounceAccept = -1;
    let updated = [];
    let conf = this.view.state.facet(completionConfig);
    for (let i2 = 0; i2 < this.running.length; i2++) {
      let query = this.running[i2];
      if (query.done === void 0)
        continue;
      this.running.splice(i2--, 1);
      if (query.done) {
        let active = new ActiveResult(query.active.source, query.active.explicitPos, query.done, query.done.from, (_a4 = query.done.to) !== null && _a4 !== void 0 ? _a4 : cur(query.updates.length ? query.updates[0].startState : this.view.state));
        for (let tr3 of query.updates)
          active = active.update(tr3, conf);
        if (active.hasResult()) {
          updated.push(active);
          continue;
        }
      }
      let current = this.view.state.field(completionState).active.find((a2) => a2.source == query.active.source);
      if (current && current.state == 1) {
        if (query.done == null) {
          let active = new ActiveSource(
            query.active.source,
            0
            /* State.Inactive */
          );
          for (let tr3 of query.updates)
            active = active.update(tr3, conf);
          if (active.state != 1)
            updated.push(active);
        } else {
          this.startQuery(current);
        }
      }
    }
    if (updated.length)
      this.view.dispatch({ effects: setActiveEffect.of(updated) });
  }
}, {
  eventHandlers: {
    blur(event) {
      let state = this.view.state.field(completionState, false);
      if (state && state.tooltip && this.view.state.facet(completionConfig).closeOnBlur) {
        let dialog = state.open && getTooltip(this.view, state.open.tooltip);
        if (!dialog || !dialog.dom.contains(event.relatedTarget))
          setTimeout(() => this.view.dispatch({ effects: closeCompletionEffect.of(null) }), 10);
      }
    },
    compositionstart() {
      this.composing = 1;
    },
    compositionend() {
      if (this.composing == 3) {
        setTimeout(() => this.view.dispatch({ effects: startCompletionEffect.of(false) }), 20);
      }
      this.composing = 0;
    }
  }
});
var windows = typeof navigator == "object" && /Win/.test(navigator.platform);
var commitCharacters = Prec.highest(EditorView.domEventHandlers({
  keydown(event, view) {
    let field = view.state.field(completionState, false);
    if (!field || !field.open || field.open.disabled || field.open.selected < 0 || event.key.length > 1 || event.ctrlKey && !(windows && event.altKey) || event.metaKey)
      return false;
    let option = field.open.options[field.open.selected];
    let result = field.active.find((a2) => a2.source == option.source);
    let commitChars = option.completion.commitCharacters || result.result.commitCharacters;
    if (commitChars && commitChars.indexOf(event.key) > -1)
      applyCompletion(view, option);
    return false;
  }
}));
var baseTheme5 = EditorView.baseTheme({
  ".cm-tooltip.cm-tooltip-autocomplete": {
    "& > ul": {
      fontFamily: "monospace",
      whiteSpace: "nowrap",
      overflow: "hidden auto",
      maxWidth_fallback: "700px",
      maxWidth: "min(700px, 95vw)",
      minWidth: "250px",
      maxHeight: "10em",
      height: "100%",
      listStyle: "none",
      margin: 0,
      padding: 0,
      "& > li, & > completion-section": {
        padding: "1px 3px",
        lineHeight: 1.2
      },
      "& > li": {
        overflowX: "hidden",
        textOverflow: "ellipsis",
        cursor: "pointer"
      },
      "& > completion-section": {
        display: "list-item",
        borderBottom: "1px solid silver",
        paddingLeft: "0.5em",
        opacity: 0.7
      }
    }
  },
  "&light .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#17c",
    color: "white"
  },
  "&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#777"
  },
  "&dark .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#347",
    color: "white"
  },
  "&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#444"
  },
  ".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after": {
    content: '"···"',
    opacity: 0.5,
    display: "block",
    textAlign: "center"
  },
  ".cm-tooltip.cm-completionInfo": {
    position: "absolute",
    padding: "3px 9px",
    width: "max-content",
    maxWidth: `${400}px`,
    boxSizing: "border-box",
    whiteSpace: "pre-line"
  },
  ".cm-completionInfo.cm-completionInfo-left": { right: "100%" },
  ".cm-completionInfo.cm-completionInfo-right": { left: "100%" },
  ".cm-completionInfo.cm-completionInfo-left-narrow": { right: `${30}px` },
  ".cm-completionInfo.cm-completionInfo-right-narrow": { left: `${30}px` },
  "&light .cm-snippetField": { backgroundColor: "#00000022" },
  "&dark .cm-snippetField": { backgroundColor: "#ffffff22" },
  ".cm-snippetFieldPosition": {
    verticalAlign: "text-top",
    width: 0,
    height: "1.15em",
    display: "inline-block",
    margin: "0 -0.7px -.7em",
    borderLeft: "1.4px dotted #888"
  },
  ".cm-completionMatchedText": {
    textDecoration: "underline"
  },
  ".cm-completionDetail": {
    marginLeft: "0.5em",
    fontStyle: "italic"
  },
  ".cm-completionIcon": {
    fontSize: "90%",
    width: ".8em",
    display: "inline-block",
    textAlign: "center",
    paddingRight: ".6em",
    opacity: "0.6",
    boxSizing: "content-box"
  },
  ".cm-completionIcon-function, .cm-completionIcon-method": {
    "&:after": { content: "'ƒ'" }
  },
  ".cm-completionIcon-class": {
    "&:after": { content: "'○'" }
  },
  ".cm-completionIcon-interface": {
    "&:after": { content: "'◌'" }
  },
  ".cm-completionIcon-variable": {
    "&:after": { content: "'𝑥'" }
  },
  ".cm-completionIcon-constant": {
    "&:after": { content: "'𝐶'" }
  },
  ".cm-completionIcon-type": {
    "&:after": { content: "'𝑡'" }
  },
  ".cm-completionIcon-enum": {
    "&:after": { content: "'∪'" }
  },
  ".cm-completionIcon-property": {
    "&:after": { content: "'□'" }
  },
  ".cm-completionIcon-keyword": {
    "&:after": { content: "'🔑︎'" }
    // Disable emoji rendering
  },
  ".cm-completionIcon-namespace": {
    "&:after": { content: "'▢'" }
  },
  ".cm-completionIcon-text": {
    "&:after": { content: "'abc'", fontSize: "50%", verticalAlign: "middle" }
  }
});
var fieldMarker = Decoration.widget({ widget: new class extends WidgetType {
  toDOM() {
    let span = document.createElement("span");
    span.className = "cm-snippetFieldPosition";
    return span;
  }
  ignoreEvent() {
    return false;
  }
}() });
var fieldRange = Decoration.mark({ class: "cm-snippetField" });
var ActiveSnippet = class _ActiveSnippet {
  constructor(ranges, active) {
    this.ranges = ranges;
    this.active = active;
    this.deco = Decoration.set(ranges.map((r2) => (r2.from == r2.to ? fieldMarker : fieldRange).range(r2.from, r2.to)));
  }
  map(changes) {
    let ranges = [];
    for (let r2 of this.ranges) {
      let mapped = r2.map(changes);
      if (!mapped)
        return null;
      ranges.push(mapped);
    }
    return new _ActiveSnippet(ranges, this.active);
  }
  selectionInsideField(sel) {
    return sel.ranges.every((range) => this.ranges.some((r2) => r2.field == this.active && r2.from <= range.from && r2.to >= range.to));
  }
};
var setActive = StateEffect.define({
  map(value, changes) {
    return value && value.map(changes);
  }
});
var moveToField = StateEffect.define();
var snippetState = StateField.define({
  create() {
    return null;
  },
  update(value, tr3) {
    for (let effect of tr3.effects) {
      if (effect.is(setActive))
        return effect.value;
      if (effect.is(moveToField) && value)
        return new ActiveSnippet(value.ranges, effect.value);
    }
    if (value && tr3.docChanged)
      value = value.map(tr3.changes);
    if (value && tr3.selection && !value.selectionInsideField(tr3.selection))
      value = null;
    return value;
  },
  provide: (f) => EditorView.decorations.from(f, (val) => val ? val.deco : Decoration.none)
});
function fieldSelection(ranges, field) {
  return EditorSelection.create(ranges.filter((r2) => r2.field == field).map((r2) => EditorSelection.range(r2.from, r2.to)));
}
function moveField(dir) {
  return ({ state, dispatch }) => {
    let active = state.field(snippetState, false);
    if (!active || dir < 0 && active.active == 0)
      return false;
    let next = active.active + dir, last2 = dir > 0 && !active.ranges.some((r2) => r2.field == next + dir);
    dispatch(state.update({
      selection: fieldSelection(active.ranges, next),
      effects: setActive.of(last2 ? null : new ActiveSnippet(active.ranges, next)),
      scrollIntoView: true
    }));
    return true;
  };
}
var clearSnippet = ({ state, dispatch }) => {
  let active = state.field(snippetState, false);
  if (!active)
    return false;
  dispatch(state.update({ effects: setActive.of(null) }));
  return true;
};
var nextSnippetField = moveField(1);
var prevSnippetField = moveField(-1);
var defaultSnippetKeymap = [
  { key: "Tab", run: nextSnippetField, shift: prevSnippetField },
  { key: "Escape", run: clearSnippet }
];
var snippetKeymap = Facet.define({
  combine(maps) {
    return maps.length ? maps[0] : defaultSnippetKeymap;
  }
});
var addSnippetKeymap = Prec.highest(keymap.compute([snippetKeymap], (state) => state.facet(snippetKeymap)));
var snippetPointerHandler = EditorView.domEventHandlers({
  mousedown(event, view) {
    let active = view.state.field(snippetState, false), pos;
    if (!active || (pos = view.posAtCoords({ x: event.clientX, y: event.clientY })) == null)
      return false;
    let match = active.ranges.find((r2) => r2.from <= pos && r2.to >= pos);
    if (!match || match.field == active.active)
      return false;
    view.dispatch({
      selection: fieldSelection(active.ranges, match.field),
      effects: setActive.of(active.ranges.some((r2) => r2.field > match.field) ? new ActiveSnippet(active.ranges, match.field) : null),
      scrollIntoView: true
    });
    return true;
  }
});
var defaults2 = {
  brackets: ["(", "[", "{", "'", '"'],
  before: ")]}:;>",
  stringPrefixes: []
};
var closeBracketEffect = StateEffect.define({
  map(value, mapping) {
    let mapped = mapping.mapPos(value, -1, MapMode.TrackAfter);
    return mapped == null ? void 0 : mapped;
  }
});
var closedBracket = new class extends RangeValue {
}();
closedBracket.startSide = 1;
closedBracket.endSide = -1;
var bracketState = StateField.define({
  create() {
    return RangeSet.empty;
  },
  update(value, tr3) {
    value = value.map(tr3.changes);
    if (tr3.selection) {
      let line = tr3.state.doc.lineAt(tr3.selection.main.head);
      value = value.update({ filter: (from) => from >= line.from && from <= line.to });
    }
    for (let effect of tr3.effects)
      if (effect.is(closeBracketEffect))
        value = value.update({ add: [closedBracket.range(effect.value, effect.value + 1)] });
    return value;
  }
});
function closeBrackets() {
  return [inputHandler2, bracketState];
}
var definedClosing = "()[]{}<>";
function closing(ch2) {
  for (let i2 = 0; i2 < definedClosing.length; i2 += 2)
    if (definedClosing.charCodeAt(i2) == ch2)
      return definedClosing.charAt(i2 + 1);
  return fromCodePoint(ch2 < 128 ? ch2 : ch2 + 1);
}
function config(state, pos) {
  return state.languageDataAt("closeBrackets", pos)[0] || defaults2;
}
var android = typeof navigator == "object" && /Android\b/.test(navigator.userAgent);
var inputHandler2 = EditorView.inputHandler.of((view, from, to3, insert2) => {
  if ((android ? view.composing : view.compositionStarted) || view.state.readOnly)
    return false;
  let sel = view.state.selection.main;
  if (insert2.length > 2 || insert2.length == 2 && codePointSize(codePointAt(insert2, 0)) == 1 || from != sel.from || to3 != sel.to)
    return false;
  let tr3 = insertBracket(view.state, insert2);
  if (!tr3)
    return false;
  view.dispatch(tr3);
  return true;
});
var deleteBracketPair = ({ state, dispatch }) => {
  if (state.readOnly)
    return false;
  let conf = config(state, state.selection.main.head);
  let tokens = conf.brackets || defaults2.brackets;
  let dont = null, changes = state.changeByRange((range) => {
    if (range.empty) {
      let before = prevChar(state.doc, range.head);
      for (let token of tokens) {
        if (token == before && nextChar(state.doc, range.head) == closing(codePointAt(token, 0)))
          return {
            changes: { from: range.head - token.length, to: range.head + token.length },
            range: EditorSelection.cursor(range.head - token.length)
          };
      }
    }
    return { range: dont = range };
  });
  if (!dont)
    dispatch(state.update(changes, { scrollIntoView: true, userEvent: "delete.backward" }));
  return !dont;
};
var closeBracketsKeymap = [
  { key: "Backspace", run: deleteBracketPair }
];
function insertBracket(state, bracket2) {
  let conf = config(state, state.selection.main.head);
  let tokens = conf.brackets || defaults2.brackets;
  for (let tok of tokens) {
    let closed = closing(codePointAt(tok, 0));
    if (bracket2 == tok)
      return closed == tok ? handleSame(state, tok, tokens.indexOf(tok + tok + tok) > -1, conf) : handleOpen(state, tok, closed, conf.before || defaults2.before);
    if (bracket2 == closed && closedBracketAt(state, state.selection.main.from))
      return handleClose(state, tok, closed);
  }
  return null;
}
function closedBracketAt(state, pos) {
  let found = false;
  state.field(bracketState).between(0, state.doc.length, (from) => {
    if (from == pos)
      found = true;
  });
  return found;
}
function nextChar(doc2, pos) {
  let next = doc2.sliceString(pos, pos + 2);
  return next.slice(0, codePointSize(codePointAt(next, 0)));
}
function prevChar(doc2, pos) {
  let prev = doc2.sliceString(pos - 2, pos);
  return codePointSize(codePointAt(prev, 0)) == prev.length ? prev : prev.slice(1);
}
function handleOpen(state, open, close, closeBefore) {
  let dont = null, changes = state.changeByRange((range) => {
    if (!range.empty)
      return {
        changes: [{ insert: open, from: range.from }, { insert: close, from: range.to }],
        effects: closeBracketEffect.of(range.to + open.length),
        range: EditorSelection.range(range.anchor + open.length, range.head + open.length)
      };
    let next = nextChar(state.doc, range.head);
    if (!next || /\s/.test(next) || closeBefore.indexOf(next) > -1)
      return {
        changes: { insert: open + close, from: range.head },
        effects: closeBracketEffect.of(range.head + open.length),
        range: EditorSelection.cursor(range.head + open.length)
      };
    return { range: dont = range };
  });
  return dont ? null : state.update(changes, {
    scrollIntoView: true,
    userEvent: "input.type"
  });
}
function handleClose(state, _open, close) {
  let dont = null, changes = state.changeByRange((range) => {
    if (range.empty && nextChar(state.doc, range.head) == close)
      return {
        changes: { from: range.head, to: range.head + close.length, insert: close },
        range: EditorSelection.cursor(range.head + close.length)
      };
    return dont = { range };
  });
  return dont ? null : state.update(changes, {
    scrollIntoView: true,
    userEvent: "input.type"
  });
}
function handleSame(state, token, allowTriple, config2) {
  let stringPrefixes = config2.stringPrefixes || defaults2.stringPrefixes;
  let dont = null, changes = state.changeByRange((range) => {
    if (!range.empty)
      return {
        changes: [{ insert: token, from: range.from }, { insert: token, from: range.to }],
        effects: closeBracketEffect.of(range.to + token.length),
        range: EditorSelection.range(range.anchor + token.length, range.head + token.length)
      };
    let pos = range.head, next = nextChar(state.doc, pos), start;
    if (next == token) {
      if (nodeStart(state, pos)) {
        return {
          changes: { insert: token + token, from: pos },
          effects: closeBracketEffect.of(pos + token.length),
          range: EditorSelection.cursor(pos + token.length)
        };
      } else if (closedBracketAt(state, pos)) {
        let isTriple = allowTriple && state.sliceDoc(pos, pos + token.length * 3) == token + token + token;
        let content2 = isTriple ? token + token + token : token;
        return {
          changes: { from: pos, to: pos + content2.length, insert: content2 },
          range: EditorSelection.cursor(pos + content2.length)
        };
      }
    } else if (allowTriple && state.sliceDoc(pos - 2 * token.length, pos) == token + token && (start = canStartStringAt(state, pos - 2 * token.length, stringPrefixes)) > -1 && nodeStart(state, start)) {
      return {
        changes: { insert: token + token + token + token, from: pos },
        effects: closeBracketEffect.of(pos + token.length),
        range: EditorSelection.cursor(pos + token.length)
      };
    } else if (state.charCategorizer(pos)(next) != CharCategory.Word) {
      if (canStartStringAt(state, pos, stringPrefixes) > -1 && !probablyInString(state, pos, token, stringPrefixes))
        return {
          changes: { insert: token + token, from: pos },
          effects: closeBracketEffect.of(pos + token.length),
          range: EditorSelection.cursor(pos + token.length)
        };
    }
    return { range: dont = range };
  });
  return dont ? null : state.update(changes, {
    scrollIntoView: true,
    userEvent: "input.type"
  });
}
function nodeStart(state, pos) {
  let tree = syntaxTree(state).resolveInner(pos + 1);
  return tree.parent && tree.from == pos;
}
function probablyInString(state, pos, quoteToken, prefixes) {
  let node = syntaxTree(state).resolveInner(pos, -1);
  let maxPrefix = prefixes.reduce((m3, p) => Math.max(m3, p.length), 0);
  for (let i2 = 0; i2 < 5; i2++) {
    let start = state.sliceDoc(node.from, Math.min(node.to, node.from + quoteToken.length + maxPrefix));
    let quotePos = start.indexOf(quoteToken);
    if (!quotePos || quotePos > -1 && prefixes.indexOf(start.slice(0, quotePos)) > -1) {
      let first = node.firstChild;
      while (first && first.from == node.from && first.to - first.from > quoteToken.length + quotePos) {
        if (state.sliceDoc(first.to - quoteToken.length, first.to) == quoteToken)
          return false;
        first = first.firstChild;
      }
      return true;
    }
    let parent = node.to == pos && node.parent;
    if (!parent)
      break;
    node = parent;
  }
  return false;
}
function canStartStringAt(state, pos, prefixes) {
  let charCat = state.charCategorizer(pos);
  if (charCat(state.sliceDoc(pos - 1, pos)) != CharCategory.Word)
    return pos;
  for (let prefix of prefixes) {
    let start = pos - prefix.length;
    if (state.sliceDoc(start, pos) == prefix && charCat(state.sliceDoc(start - 1, start)) != CharCategory.Word)
      return start;
  }
  return -1;
}
function autocompletion(config2 = {}) {
  return [
    commitCharacters,
    completionState,
    completionConfig.of(config2),
    completionPlugin,
    completionKeymapExt,
    baseTheme5
  ];
}
var completionKeymap = [
  { key: "Ctrl-Space", run: startCompletion },
  { mac: "Alt-`", run: startCompletion },
  { key: "Escape", run: closeCompletion },
  { key: "ArrowDown", run: moveCompletionSelection(true) },
  { key: "ArrowUp", run: moveCompletionSelection(false) },
  { key: "PageDown", run: moveCompletionSelection(true, "page") },
  { key: "PageUp", run: moveCompletionSelection(false, "page") },
  { key: "Enter", run: acceptCompletion }
];
var completionKeymapExt = Prec.highest(keymap.computeN([completionConfig], (state) => state.facet(completionConfig).defaultKeymap ? [completionKeymap] : []));

// node_modules/@replit/codemirror-indentation-markers/dist/index.js
function getVisibleLines(view, state = view.state) {
  const lines = /* @__PURE__ */ new Set();
  for (const { from, to: to3 } of view.visibleRanges) {
    let pos = from;
    while (pos <= to3) {
      const line = state.doc.lineAt(pos);
      if (!lines.has(line)) {
        lines.add(line);
      }
      pos = line.to + 1;
    }
  }
  return lines;
}
function getCurrentLine(state) {
  const currentPos = state.selection.main.head;
  return state.doc.lineAt(currentPos);
}
function numColumns(str, tabSize) {
  let col = 0;
  loop: for (let i2 = 0; i2 < str.length; i2++) {
    switch (str[i2]) {
      case " ":
      case " ": {
        col += 1;
        continue loop;
      }
      case "	": {
        col += tabSize - col % tabSize;
        continue loop;
      }
      case "\r": {
        continue loop;
      }
      default: {
        break loop;
      }
    }
  }
  return col;
}
var indentationMarkerConfig = Facet.define({
  combine(configs) {
    return combineConfig(configs, {
      highlightActiveBlock: true,
      hideFirstIndent: false,
      markerType: "fullScope",
      thickness: 1
    });
  }
});
var IndentationMap = class {
  /**
   * @param lines - The set of lines to get the indentation map for.
   * @param state - The {@link EditorState} to derive the indentation map from.
   * @param unitWidth - The width of the editor's indent unit.
   * @param markerType - The type of indentation to use (terminate at end of scope vs last line of code in scope)
   */
  constructor(lines, state, unitWidth, markerType) {
    this.lines = lines;
    this.state = state;
    this.map = /* @__PURE__ */ new Map();
    this.unitWidth = unitWidth;
    this.markerType = markerType;
    for (const line of this.lines) {
      this.add(line);
    }
    if (this.state.facet(indentationMarkerConfig).highlightActiveBlock) {
      this.findAndSetActiveLines();
    }
  }
  /**
   * Checks if the indentation map has an entry for the given line.
   *
   * @param line - The {@link Line} or line number to check for.
   */
  has(line) {
    return this.map.has(typeof line === "number" ? line : line.number);
  }
  /**
   * Returns the {@link IndentEntry} for the given line.
   *
   * Note that this function will throw an error if the line does not exist in the map.
   *
   * @param line - The {@link Line} or line number to get the entry for.
   */
  get(line) {
    const entry = this.map.get(typeof line === "number" ? line : line.number);
    if (!entry) {
      throw new Error("Line not found in indentation map");
    }
    return entry;
  }
  /**
   * Sets the {@link IndentEntry} for the given line.
   *
   * @param line - The {@link Line} to set the entry for.
   * @param col - The visual beginning whitespace width of the line.
   * @param level - The indentation level of the line.
   */
  set(line, col, level) {
    const empty2 = !line.text.trim().length;
    const entry = { line, col, level, empty: empty2 };
    this.map.set(entry.line.number, entry);
    return entry;
  }
  /**
   * Adds a line to the indentation map.
   *
   * @param line - The {@link Line} to add to the map.
   */
  add(line) {
    if (this.has(line)) {
      return this.get(line);
    }
    if (!line.length || !line.text.trim().length) {
      if (line.number === 1) {
        return this.set(line, 0, 0);
      }
      if (line.number === this.state.doc.lines) {
        const prev2 = this.closestNonEmpty(line, -1);
        return this.set(line, 0, prev2.level);
      }
      const prev = this.closestNonEmpty(line, -1);
      const next = this.closestNonEmpty(line, 1);
      if (prev.level >= next.level && this.markerType !== "codeOnly") {
        return this.set(line, 0, prev.level);
      }
      if (prev.empty && prev.level === 0 && next.level !== 0) {
        return this.set(line, 0, 0);
      }
      if (next.level > prev.level) {
        return this.set(line, 0, prev.level + 1);
      }
      return this.set(line, 0, next.level);
    }
    const col = numColumns(line.text, this.state.tabSize);
    const level = Math.floor(col / this.unitWidth);
    return this.set(line, col, level);
  }
  /**
   * Finds the closest non-empty line, starting from the given line.
   *
   * @param from - The {@link Line} to start from.
   * @param dir - The direction to search in. Either `1` or `-1`.
   */
  closestNonEmpty(from, dir) {
    let lineNo = from.number + dir;
    while (dir === -1 ? lineNo >= 1 : lineNo <= this.state.doc.lines) {
      if (this.has(lineNo)) {
        const entry = this.get(lineNo);
        if (!entry.empty) {
          return entry;
        }
      }
      const line2 = this.state.doc.line(lineNo);
      if (line2.text.trim().length) {
        const col = numColumns(line2.text, this.state.tabSize);
        const level = Math.floor(col / this.unitWidth);
        return this.set(line2, col, level);
      }
      lineNo += dir;
    }
    const line = this.state.doc.line(dir === -1 ? 1 : this.state.doc.lines);
    return this.set(line, 0, 0);
  }
  /**
   * Finds the state's active block (via the current selection) and sets all
   * the active indent level for the lines in the block.
   */
  findAndSetActiveLines() {
    const currentLine = getCurrentLine(this.state);
    if (!this.has(currentLine)) {
      return;
    }
    let current = this.get(currentLine);
    if (this.has(current.line.number + 1)) {
      const next = this.get(current.line.number + 1);
      if (next.level > current.level) {
        current = next;
      }
    }
    if (this.has(current.line.number - 1)) {
      const prev = this.get(current.line.number - 1);
      if (prev.level > current.level) {
        current = prev;
      }
    }
    if (current.level === 0) {
      return;
    }
    current.active = current.level;
    let start;
    let end;
    for (start = current.line.number; start > 1; start--) {
      if (!this.has(start - 1)) {
        continue;
      }
      const prev = this.get(start - 1);
      if (prev.level < current.level) {
        break;
      }
      prev.active = current.level;
    }
    for (end = current.line.number; end < this.state.doc.lines; end++) {
      if (!this.has(end + 1)) {
        continue;
      }
      const next = this.get(end + 1);
      if (next.level < current.level) {
        break;
      }
      next.active = current.level;
    }
  }
};
function indentTheme(colorOptions) {
  const defaultColors = {
    light: "#F0F1F2",
    dark: "#2B3245",
    activeLight: "#E4E5E6",
    activeDark: "#3C445C"
  };
  let colors = defaultColors;
  if (colorOptions) {
    colors = Object.assign(Object.assign({}, defaultColors), colorOptions);
  }
  return EditorView.baseTheme({
    "&light": {
      "--indent-marker-bg-color": colors.light,
      "--indent-marker-active-bg-color": colors.activeLight
    },
    "&dark": {
      "--indent-marker-bg-color": colors.dark,
      "--indent-marker-active-bg-color": colors.activeDark
    },
    ".cm-line": {
      position: "relative"
    },
    // this pseudo-element is used to draw the indent markers,
    // while still allowing the line to have its own background.
    ".cm-indent-markers::before": {
      content: '""',
      position: "absolute",
      top: 0,
      // .cm-line has a padding of 2px 
      // https://github.com/codemirror/view/blob/1c0a0880fc904714339f059658f3ba3a88bb8e6e/src/theme.ts#L85
      left: `2px`,
      right: 0,
      bottom: 0,
      background: "var(--indent-markers)",
      pointerEvents: "none",
      zIndex: "-1"
    }
  });
}
function createGradient(markerCssProperty, thickness, indentWidth, startOffset, columns) {
  const gradient = `repeating-linear-gradient(to right, var(${markerCssProperty}) 0 ${thickness}px, transparent ${thickness}px ${indentWidth}ch)`;
  return `${gradient} ${startOffset * indentWidth}.5ch/calc(${indentWidth * columns}ch - 1px) no-repeat`;
}
function makeBackgroundCSS(entry, indentWidth, hideFirstIndent, thickness, activeThickness) {
  const { level, active } = entry;
  activeThickness = activeThickness !== null && activeThickness !== void 0 ? activeThickness : thickness;
  if (hideFirstIndent && level === 0) {
    return [];
  }
  const startAt = hideFirstIndent ? 1 : 0;
  const backgrounds = [];
  if (active !== void 0) {
    const markersBeforeActive = active - startAt - 1;
    if (markersBeforeActive > 0) {
      backgrounds.push(createGradient("--indent-marker-bg-color", thickness, indentWidth, startAt, markersBeforeActive));
    }
    backgrounds.push(createGradient("--indent-marker-active-bg-color", activeThickness, indentWidth, active - 1, 1));
    if (active !== level) {
      backgrounds.push(createGradient("--indent-marker-bg-color", thickness, indentWidth, active, level - active));
    }
  } else {
    backgrounds.push(createGradient("--indent-marker-bg-color", thickness, indentWidth, startAt, level - startAt));
  }
  return backgrounds.join(",");
}
var IndentMarkersClass = class {
  constructor(view) {
    this.view = view;
    this.unitWidth = getIndentUnit(view.state);
    this.currentLineNumber = getCurrentLine(view.state).number;
    this.generate(view.state);
  }
  update(update) {
    const unitWidth = getIndentUnit(update.state);
    const unitWidthChanged = unitWidth !== this.unitWidth;
    if (unitWidthChanged) {
      this.unitWidth = unitWidth;
    }
    const lineNumber = getCurrentLine(update.state).number;
    const lineNumberChanged = lineNumber !== this.currentLineNumber;
    this.currentLineNumber = lineNumber;
    const activeBlockUpdateRequired = update.state.facet(indentationMarkerConfig).highlightActiveBlock && lineNumberChanged;
    if (update.docChanged || update.viewportChanged || unitWidthChanged || activeBlockUpdateRequired) {
      this.generate(update.state);
    }
  }
  generate(state) {
    const builder = new RangeSetBuilder();
    const lines = getVisibleLines(this.view, state);
    const { hideFirstIndent, markerType, thickness, activeThickness } = state.facet(indentationMarkerConfig);
    const map = new IndentationMap(lines, state, this.unitWidth, markerType);
    for (const line of lines) {
      const entry = map.get(line.number);
      if (!(entry === null || entry === void 0 ? void 0 : entry.level)) {
        continue;
      }
      const backgrounds = makeBackgroundCSS(entry, this.unitWidth, hideFirstIndent, thickness, activeThickness);
      builder.add(line.from, line.from, Decoration.line({
        class: "cm-indent-markers",
        attributes: {
          style: `--indent-markers: ${backgrounds}`
        }
      }));
    }
    this.decorations = builder.finish();
  }
};
function indentationMarkers(config2 = {}) {
  return [
    indentationMarkerConfig.of(config2),
    indentTheme(config2.colors),
    ViewPlugin.fromClass(IndentMarkersClass, {
      decorations: (v) => v.decorations
    })
  ];
}

// node_modules/codemirror-wrapped-line-indent/dist/index.js
var WrappedLineIndent = class {
  constructor(view) {
    this.view = view;
    this.indentUnit = getIndentUnit(view.state);
    this.initialPaddingLeft = null;
    this.isChrome = window === null || window === void 0 ? void 0 : window.navigator.userAgent.includes("Chrome");
    this.generate(view.state);
  }
  update(update) {
    const indentUnit2 = getIndentUnit(update.state);
    if (indentUnit2 !== this.indentUnit || update.docChanged || update.viewportChanged) {
      this.indentUnit = indentUnit2;
      this.generate(update.state);
    }
  }
  generate(state) {
    const builder = new RangeSetBuilder();
    if (this.initialPaddingLeft) {
      this.addStyleToBuilder(builder, state, this.initialPaddingLeft);
    } else {
      this.view.requestMeasure({
        read: (view) => {
          const lineElement = view.contentDOM.querySelector(".cm-line");
          if (lineElement) {
            this.initialPaddingLeft = window.getComputedStyle(lineElement).getPropertyValue("padding-left");
            this.addStyleToBuilder(builder, view.state, this.initialPaddingLeft);
          }
          this.decorations = builder.finish();
        }
      });
    }
    this.decorations = builder.finish();
  }
  addStyleToBuilder(builder, state, initialPaddingLeft) {
    const visibleLines = this.getVisibleLines(state);
    for (const line of visibleLines) {
      const { numColumns: numColumns2, containsTab } = this.numColumns(line.text, state.tabSize);
      const paddingValue = `calc(${numColumns2 + this.indentUnit}ch + ${initialPaddingLeft})`;
      const textIndentValue = this.isChrome ? `calc(-${numColumns2 + this.indentUnit}ch - ${containsTab ? 1 : 0}px)` : `-${numColumns2 + this.indentUnit}ch`;
      builder.add(line.from, line.from, Decoration.line({
        attributes: {
          style: `padding-left: ${paddingValue}; text-indent: ${textIndentValue};`
        }
      }));
    }
  }
  // Get all lines that are currently visible in the viewport.
  getVisibleLines(state) {
    const lines = /* @__PURE__ */ new Set();
    let lastLine = null;
    for (const { from, to: to3 } of this.view.visibleRanges) {
      let pos = from;
      while (pos <= to3) {
        const line = state.doc.lineAt(pos);
        if (lastLine !== line) {
          lines.add(line);
          lastLine = line;
        }
        pos = line.to + 1;
      }
    }
    return lines;
  }
  numColumns(str, tabSize) {
    let cols = 0;
    let containsTab = false;
    loop: for (let i2 = 0; i2 < str.length; i2++) {
      switch (str[i2]) {
        case " ": {
          cols += 1;
          continue loop;
        }
        case "	": {
          cols += tabSize - cols % tabSize;
          containsTab = true;
          continue loop;
        }
        case "\r": {
          continue loop;
        }
        default: {
          break loop;
        }
      }
    }
    return { numColumns: cols, containsTab };
  }
};
var wrappedLineIndent = [
  ViewPlugin.fromClass(WrappedLineIndent, {
    decorations: (v) => v.decorations
  })
];

// node_modules/vanilla-jsoneditor/index.js
var import_ajv = __toESM(require_ajv());
var import_jmespath = __toESM(require_jmespath());

// node_modules/jsonpath-plus/dist/index-browser-esm.js
var Hooks = class {
  /**
   * @callback HookCallback
   * @this {*|Jsep} this
   * @param {Jsep} env
   * @returns: void
   */
  /**
   * Adds the given callback to the list of callbacks for the given hook.
   *
   * The callback will be invoked when the hook it is registered for is run.
   *
   * One callback function can be registered to multiple hooks and the same hook multiple times.
   *
   * @param {string|object} name The name of the hook, or an object of callbacks keyed by name
   * @param {HookCallback|boolean} callback The callback function which is given environment variables.
   * @param {?boolean} [first=false] Will add the hook to the top of the list (defaults to the bottom)
   * @public
   */
  add(name2, callback, first) {
    if (typeof arguments[0] != "string") {
      for (let name3 in arguments[0]) {
        this.add(name3, arguments[0][name3], arguments[1]);
      }
    } else {
      (Array.isArray(name2) ? name2 : [name2]).forEach(function(name3) {
        this[name3] = this[name3] || [];
        if (callback) {
          this[name3][first ? "unshift" : "push"](callback);
        }
      }, this);
    }
  }
  /**
   * Runs a hook invoking all registered callbacks with the given environment variables.
   *
   * Callbacks will be invoked synchronously and in the order in which they were registered.
   *
   * @param {string} name The name of the hook.
   * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.
   * @public
   */
  run(name2, env) {
    this[name2] = this[name2] || [];
    this[name2].forEach(function(callback) {
      callback.call(env && env.context ? env.context : env, env);
    });
  }
};
var Plugins = class {
  constructor(jsep2) {
    this.jsep = jsep2;
    this.registered = {};
  }
  /**
   * @callback PluginSetup
   * @this {Jsep} jsep
   * @returns: void
   */
  /**
   * Adds the given plugin(s) to the registry
   *
   * @param {object} plugins
   * @param {string} plugins.name The name of the plugin
   * @param {PluginSetup} plugins.init The init function
   * @public
   */
  register() {
    for (var _len = arguments.length, plugins = new Array(_len), _key = 0; _key < _len; _key++) {
      plugins[_key] = arguments[_key];
    }
    plugins.forEach((plugin3) => {
      if (typeof plugin3 !== "object" || !plugin3.name || !plugin3.init) {
        throw new Error("Invalid JSEP plugin format");
      }
      if (this.registered[plugin3.name]) {
        return;
      }
      plugin3.init(this.jsep);
      this.registered[plugin3.name] = plugin3;
    });
  }
};
var Jsep = class _Jsep {
  /**
   * @returns {string}
   */
  static get version() {
    return "1.3.9";
  }
  /**
   * @returns {string}
   */
  static toString() {
    return "JavaScript Expression Parser (JSEP) v" + _Jsep.version;
  }
  // ==================== CONFIG ================================
  /**
   * @method addUnaryOp
   * @param {string} op_name The name of the unary op to add
   * @returns {Jsep}
   */
  static addUnaryOp(op_name) {
    _Jsep.max_unop_len = Math.max(op_name.length, _Jsep.max_unop_len);
    _Jsep.unary_ops[op_name] = 1;
    return _Jsep;
  }
  /**
   * @method jsep.addBinaryOp
   * @param {string} op_name The name of the binary op to add
   * @param {number} precedence The precedence of the binary op (can be a float). Higher number = higher precedence
   * @param {boolean} [isRightAssociative=false] whether operator is right-associative
   * @returns {Jsep}
   */
  static addBinaryOp(op_name, precedence, isRightAssociative) {
    _Jsep.max_binop_len = Math.max(op_name.length, _Jsep.max_binop_len);
    _Jsep.binary_ops[op_name] = precedence;
    if (isRightAssociative) {
      _Jsep.right_associative.add(op_name);
    } else {
      _Jsep.right_associative.delete(op_name);
    }
    return _Jsep;
  }
  /**
   * @method addIdentifierChar
   * @param {string} char The additional character to treat as a valid part of an identifier
   * @returns {Jsep}
   */
  static addIdentifierChar(char) {
    _Jsep.additional_identifier_chars.add(char);
    return _Jsep;
  }
  /**
   * @method addLiteral
   * @param {string} literal_name The name of the literal to add
   * @param {*} literal_value The value of the literal
   * @returns {Jsep}
   */
  static addLiteral(literal_name, literal_value) {
    _Jsep.literals[literal_name] = literal_value;
    return _Jsep;
  }
  /**
   * @method removeUnaryOp
   * @param {string} op_name The name of the unary op to remove
   * @returns {Jsep}
   */
  static removeUnaryOp(op_name) {
    delete _Jsep.unary_ops[op_name];
    if (op_name.length === _Jsep.max_unop_len) {
      _Jsep.max_unop_len = _Jsep.getMaxKeyLen(_Jsep.unary_ops);
    }
    return _Jsep;
  }
  /**
   * @method removeAllUnaryOps
   * @returns {Jsep}
   */
  static removeAllUnaryOps() {
    _Jsep.unary_ops = {};
    _Jsep.max_unop_len = 0;
    return _Jsep;
  }
  /**
   * @method removeIdentifierChar
   * @param {string} char The additional character to stop treating as a valid part of an identifier
   * @returns {Jsep}
   */
  static removeIdentifierChar(char) {
    _Jsep.additional_identifier_chars.delete(char);
    return _Jsep;
  }
  /**
   * @method removeBinaryOp
   * @param {string} op_name The name of the binary op to remove
   * @returns {Jsep}
   */
  static removeBinaryOp(op_name) {
    delete _Jsep.binary_ops[op_name];
    if (op_name.length === _Jsep.max_binop_len) {
      _Jsep.max_binop_len = _Jsep.getMaxKeyLen(_Jsep.binary_ops);
    }
    _Jsep.right_associative.delete(op_name);
    return _Jsep;
  }
  /**
   * @method removeAllBinaryOps
   * @returns {Jsep}
   */
  static removeAllBinaryOps() {
    _Jsep.binary_ops = {};
    _Jsep.max_binop_len = 0;
    return _Jsep;
  }
  /**
   * @method removeLiteral
   * @param {string} literal_name The name of the literal to remove
   * @returns {Jsep}
   */
  static removeLiteral(literal_name) {
    delete _Jsep.literals[literal_name];
    return _Jsep;
  }
  /**
   * @method removeAllLiterals
   * @returns {Jsep}
   */
  static removeAllLiterals() {
    _Jsep.literals = {};
    return _Jsep;
  }
  // ==================== END CONFIG ============================
  /**
   * @returns {string}
   */
  get char() {
    return this.expr.charAt(this.index);
  }
  /**
   * @returns {number}
   */
  get code() {
    return this.expr.charCodeAt(this.index);
  }
  /**
   * @param {string} expr a string with the passed in express
   * @returns Jsep
   */
  constructor(expr) {
    this.expr = expr;
    this.index = 0;
  }
  /**
   * static top-level parser
   * @returns {jsep.Expression}
   */
  static parse(expr) {
    return new _Jsep(expr).parse();
  }
  /**
   * Get the longest key length of any object
   * @param {object} obj
   * @returns {number}
   */
  static getMaxKeyLen(obj) {
    return Math.max(0, ...Object.keys(obj).map((k2) => k2.length));
  }
  /**
   * `ch` is a character code in the next three functions
   * @param {number} ch
   * @returns {boolean}
   */
  static isDecimalDigit(ch2) {
    return ch2 >= 48 && ch2 <= 57;
  }
  /**
   * Returns the precedence of a binary operator or `0` if it isn't a binary operator. Can be float.
   * @param {string} op_val
   * @returns {number}
   */
  static binaryPrecedence(op_val) {
    return _Jsep.binary_ops[op_val] || 0;
  }
  /**
   * Looks for start of identifier
   * @param {number} ch
   * @returns {boolean}
   */
  static isIdentifierStart(ch2) {
    return ch2 >= 65 && ch2 <= 90 || // A...Z
    ch2 >= 97 && ch2 <= 122 || // a...z
    ch2 >= 128 && !_Jsep.binary_ops[String.fromCharCode(ch2)] || // any non-ASCII that is not an operator
    _Jsep.additional_identifier_chars.has(String.fromCharCode(ch2));
  }
  /**
   * @param {number} ch
   * @returns {boolean}
   */
  static isIdentifierPart(ch2) {
    return _Jsep.isIdentifierStart(ch2) || _Jsep.isDecimalDigit(ch2);
  }
  /**
   * throw error at index of the expression
   * @param {string} message
   * @throws
   */
  throwError(message) {
    const error = new Error(message + " at character " + this.index);
    error.index = this.index;
    error.description = message;
    throw error;
  }
  /**
   * Run a given hook
   * @param {string} name
   * @param {jsep.Expression|false} [node]
   * @returns {?jsep.Expression}
   */
  runHook(name2, node) {
    if (_Jsep.hooks[name2]) {
      const env = {
        context: this,
        node
      };
      _Jsep.hooks.run(name2, env);
      return env.node;
    }
    return node;
  }
  /**
   * Runs a given hook until one returns a node
   * @param {string} name
   * @returns {?jsep.Expression}
   */
  searchHook(name2) {
    if (_Jsep.hooks[name2]) {
      const env = {
        context: this
      };
      _Jsep.hooks[name2].find(function(callback) {
        callback.call(env.context, env);
        return env.node;
      });
      return env.node;
    }
  }
  /**
   * Push `index` up to the next non-space character
   */
  gobbleSpaces() {
    let ch2 = this.code;
    while (ch2 === _Jsep.SPACE_CODE || ch2 === _Jsep.TAB_CODE || ch2 === _Jsep.LF_CODE || ch2 === _Jsep.CR_CODE) {
      ch2 = this.expr.charCodeAt(++this.index);
    }
    this.runHook("gobble-spaces");
  }
  /**
   * Top-level method to parse all expressions and returns compound or single node
   * @returns {jsep.Expression}
   */
  parse() {
    this.runHook("before-all");
    const nodes = this.gobbleExpressions();
    const node = nodes.length === 1 ? nodes[0] : {
      type: _Jsep.COMPOUND,
      body: nodes
    };
    return this.runHook("after-all", node);
  }
  /**
   * top-level parser (but can be reused within as well)
   * @param {number} [untilICode]
   * @returns {jsep.Expression[]}
   */
  gobbleExpressions(untilICode) {
    let nodes = [], ch_i, node;
    while (this.index < this.expr.length) {
      ch_i = this.code;
      if (ch_i === _Jsep.SEMCOL_CODE || ch_i === _Jsep.COMMA_CODE) {
        this.index++;
      } else {
        if (node = this.gobbleExpression()) {
          nodes.push(node);
        } else if (this.index < this.expr.length) {
          if (ch_i === untilICode) {
            break;
          }
          this.throwError('Unexpected "' + this.char + '"');
        }
      }
    }
    return nodes;
  }
  /**
   * The main parsing function.
   * @returns {?jsep.Expression}
   */
  gobbleExpression() {
    const node = this.searchHook("gobble-expression") || this.gobbleBinaryExpression();
    this.gobbleSpaces();
    return this.runHook("after-expression", node);
  }
  /**
   * Search for the operation portion of the string (e.g. `+`, `===`)
   * Start by taking the longest possible binary operations (3 characters: `===`, `!==`, `>>>`)
   * and move down from 3 to 2 to 1 character until a matching binary operation is found
   * then, return that binary operation
   * @returns {string|boolean}
   */
  gobbleBinaryOp() {
    this.gobbleSpaces();
    let to_check = this.expr.substr(this.index, _Jsep.max_binop_len);
    let tc_len = to_check.length;
    while (tc_len > 0) {
      if (_Jsep.binary_ops.hasOwnProperty(to_check) && (!_Jsep.isIdentifierStart(this.code) || this.index + to_check.length < this.expr.length && !_Jsep.isIdentifierPart(this.expr.charCodeAt(this.index + to_check.length)))) {
        this.index += tc_len;
        return to_check;
      }
      to_check = to_check.substr(0, --tc_len);
    }
    return false;
  }
  /**
   * This function is responsible for gobbling an individual expression,
   * e.g. `1`, `1+2`, `a+(b*2)-Math.sqrt(2)`
   * @returns {?jsep.BinaryExpression}
   */
  gobbleBinaryExpression() {
    let node, biop, prec2, stack, biop_info, left, right, i2, cur_biop;
    left = this.gobbleToken();
    if (!left) {
      return left;
    }
    biop = this.gobbleBinaryOp();
    if (!biop) {
      return left;
    }
    biop_info = {
      value: biop,
      prec: _Jsep.binaryPrecedence(biop),
      right_a: _Jsep.right_associative.has(biop)
    };
    right = this.gobbleToken();
    if (!right) {
      this.throwError("Expected expression after " + biop);
    }
    stack = [left, biop_info, right];
    while (biop = this.gobbleBinaryOp()) {
      prec2 = _Jsep.binaryPrecedence(biop);
      if (prec2 === 0) {
        this.index -= biop.length;
        break;
      }
      biop_info = {
        value: biop,
        prec: prec2,
        right_a: _Jsep.right_associative.has(biop)
      };
      cur_biop = biop;
      const comparePrev = (prev) => biop_info.right_a && prev.right_a ? prec2 > prev.prec : prec2 <= prev.prec;
      while (stack.length > 2 && comparePrev(stack[stack.length - 2])) {
        right = stack.pop();
        biop = stack.pop().value;
        left = stack.pop();
        node = {
          type: _Jsep.BINARY_EXP,
          operator: biop,
          left,
          right
        };
        stack.push(node);
      }
      node = this.gobbleToken();
      if (!node) {
        this.throwError("Expected expression after " + cur_biop);
      }
      stack.push(biop_info, node);
    }
    i2 = stack.length - 1;
    node = stack[i2];
    while (i2 > 1) {
      node = {
        type: _Jsep.BINARY_EXP,
        operator: stack[i2 - 1].value,
        left: stack[i2 - 2],
        right: node
      };
      i2 -= 2;
    }
    return node;
  }
  /**
   * An individual part of a binary expression:
   * e.g. `foo.bar(baz)`, `1`, `"abc"`, `(a % 2)` (because it's in parenthesis)
   * @returns {boolean|jsep.Expression}
   */
  gobbleToken() {
    let ch2, to_check, tc_len, node;
    this.gobbleSpaces();
    node = this.searchHook("gobble-token");
    if (node) {
      return this.runHook("after-token", node);
    }
    ch2 = this.code;
    if (_Jsep.isDecimalDigit(ch2) || ch2 === _Jsep.PERIOD_CODE) {
      return this.gobbleNumericLiteral();
    }
    if (ch2 === _Jsep.SQUOTE_CODE || ch2 === _Jsep.DQUOTE_CODE) {
      node = this.gobbleStringLiteral();
    } else if (ch2 === _Jsep.OBRACK_CODE) {
      node = this.gobbleArray();
    } else {
      to_check = this.expr.substr(this.index, _Jsep.max_unop_len);
      tc_len = to_check.length;
      while (tc_len > 0) {
        if (_Jsep.unary_ops.hasOwnProperty(to_check) && (!_Jsep.isIdentifierStart(this.code) || this.index + to_check.length < this.expr.length && !_Jsep.isIdentifierPart(this.expr.charCodeAt(this.index + to_check.length)))) {
          this.index += tc_len;
          const argument = this.gobbleToken();
          if (!argument) {
            this.throwError("missing unaryOp argument");
          }
          return this.runHook("after-token", {
            type: _Jsep.UNARY_EXP,
            operator: to_check,
            argument,
            prefix: true
          });
        }
        to_check = to_check.substr(0, --tc_len);
      }
      if (_Jsep.isIdentifierStart(ch2)) {
        node = this.gobbleIdentifier();
        if (_Jsep.literals.hasOwnProperty(node.name)) {
          node = {
            type: _Jsep.LITERAL,
            value: _Jsep.literals[node.name],
            raw: node.name
          };
        } else if (node.name === _Jsep.this_str) {
          node = {
            type: _Jsep.THIS_EXP
          };
        }
      } else if (ch2 === _Jsep.OPAREN_CODE) {
        node = this.gobbleGroup();
      }
    }
    if (!node) {
      return this.runHook("after-token", false);
    }
    node = this.gobbleTokenProperty(node);
    return this.runHook("after-token", node);
  }
  /**
   * Gobble properties of of identifiers/strings/arrays/groups.
   * e.g. `foo`, `bar.baz`, `foo['bar'].baz`
   * It also gobbles function calls:
   * e.g. `Math.acos(obj.angle)`
   * @param {jsep.Expression} node
   * @returns {jsep.Expression}
   */
  gobbleTokenProperty(node) {
    this.gobbleSpaces();
    let ch2 = this.code;
    while (ch2 === _Jsep.PERIOD_CODE || ch2 === _Jsep.OBRACK_CODE || ch2 === _Jsep.OPAREN_CODE || ch2 === _Jsep.QUMARK_CODE) {
      let optional;
      if (ch2 === _Jsep.QUMARK_CODE) {
        if (this.expr.charCodeAt(this.index + 1) !== _Jsep.PERIOD_CODE) {
          break;
        }
        optional = true;
        this.index += 2;
        this.gobbleSpaces();
        ch2 = this.code;
      }
      this.index++;
      if (ch2 === _Jsep.OBRACK_CODE) {
        node = {
          type: _Jsep.MEMBER_EXP,
          computed: true,
          object: node,
          property: this.gobbleExpression()
        };
        if (!node.property) {
          this.throwError('Unexpected "' + this.char + '"');
        }
        this.gobbleSpaces();
        ch2 = this.code;
        if (ch2 !== _Jsep.CBRACK_CODE) {
          this.throwError("Unclosed [");
        }
        this.index++;
      } else if (ch2 === _Jsep.OPAREN_CODE) {
        node = {
          type: _Jsep.CALL_EXP,
          "arguments": this.gobbleArguments(_Jsep.CPAREN_CODE),
          callee: node
        };
      } else if (ch2 === _Jsep.PERIOD_CODE || optional) {
        if (optional) {
          this.index--;
        }
        this.gobbleSpaces();
        node = {
          type: _Jsep.MEMBER_EXP,
          computed: false,
          object: node,
          property: this.gobbleIdentifier()
        };
      }
      if (optional) {
        node.optional = true;
      }
      this.gobbleSpaces();
      ch2 = this.code;
    }
    return node;
  }
  /**
   * Parse simple numeric literals: `12`, `3.4`, `.5`. Do this by using a string to
   * keep track of everything in the numeric literal and then calling `parseFloat` on that string
   * @returns {jsep.Literal}
   */
  gobbleNumericLiteral() {
    let number2 = "", ch2, chCode;
    while (_Jsep.isDecimalDigit(this.code)) {
      number2 += this.expr.charAt(this.index++);
    }
    if (this.code === _Jsep.PERIOD_CODE) {
      number2 += this.expr.charAt(this.index++);
      while (_Jsep.isDecimalDigit(this.code)) {
        number2 += this.expr.charAt(this.index++);
      }
    }
    ch2 = this.char;
    if (ch2 === "e" || ch2 === "E") {
      number2 += this.expr.charAt(this.index++);
      ch2 = this.char;
      if (ch2 === "+" || ch2 === "-") {
        number2 += this.expr.charAt(this.index++);
      }
      while (_Jsep.isDecimalDigit(this.code)) {
        number2 += this.expr.charAt(this.index++);
      }
      if (!_Jsep.isDecimalDigit(this.expr.charCodeAt(this.index - 1))) {
        this.throwError("Expected exponent (" + number2 + this.char + ")");
      }
    }
    chCode = this.code;
    if (_Jsep.isIdentifierStart(chCode)) {
      this.throwError("Variable names cannot start with a number (" + number2 + this.char + ")");
    } else if (chCode === _Jsep.PERIOD_CODE || number2.length === 1 && number2.charCodeAt(0) === _Jsep.PERIOD_CODE) {
      this.throwError("Unexpected period");
    }
    return {
      type: _Jsep.LITERAL,
      value: parseFloat(number2),
      raw: number2
    };
  }
  /**
   * Parses a string literal, staring with single or double quotes with basic support for escape codes
   * e.g. `"hello world"`, `'this is\nJSEP'`
   * @returns {jsep.Literal}
   */
  gobbleStringLiteral() {
    let str = "";
    const startIndex = this.index;
    const quote = this.expr.charAt(this.index++);
    let closed = false;
    while (this.index < this.expr.length) {
      let ch2 = this.expr.charAt(this.index++);
      if (ch2 === quote) {
        closed = true;
        break;
      } else if (ch2 === "\\") {
        ch2 = this.expr.charAt(this.index++);
        switch (ch2) {
          case "n":
            str += "\n";
            break;
          case "r":
            str += "\r";
            break;
          case "t":
            str += "	";
            break;
          case "b":
            str += "\b";
            break;
          case "f":
            str += "\f";
            break;
          case "v":
            str += "\v";
            break;
          default:
            str += ch2;
        }
      } else {
        str += ch2;
      }
    }
    if (!closed) {
      this.throwError('Unclosed quote after "' + str + '"');
    }
    return {
      type: _Jsep.LITERAL,
      value: str,
      raw: this.expr.substring(startIndex, this.index)
    };
  }
  /**
   * Gobbles only identifiers
   * e.g.: `foo`, `_value`, `$x1`
   * Also, this function checks if that identifier is a literal:
   * (e.g. `true`, `false`, `null`) or `this`
   * @returns {jsep.Identifier}
   */
  gobbleIdentifier() {
    let ch2 = this.code, start = this.index;
    if (_Jsep.isIdentifierStart(ch2)) {
      this.index++;
    } else {
      this.throwError("Unexpected " + this.char);
    }
    while (this.index < this.expr.length) {
      ch2 = this.code;
      if (_Jsep.isIdentifierPart(ch2)) {
        this.index++;
      } else {
        break;
      }
    }
    return {
      type: _Jsep.IDENTIFIER,
      name: this.expr.slice(start, this.index)
    };
  }
  /**
   * Gobbles a list of arguments within the context of a function call
   * or array literal. This function also assumes that the opening character
   * `(` or `[` has already been gobbled, and gobbles expressions and commas
   * until the terminator character `)` or `]` is encountered.
   * e.g. `foo(bar, baz)`, `my_func()`, or `[bar, baz]`
   * @param {number} termination
   * @returns {jsep.Expression[]}
   */
  gobbleArguments(termination) {
    const args = [];
    let closed = false;
    let separator_count = 0;
    while (this.index < this.expr.length) {
      this.gobbleSpaces();
      let ch_i = this.code;
      if (ch_i === termination) {
        closed = true;
        this.index++;
        if (termination === _Jsep.CPAREN_CODE && separator_count && separator_count >= args.length) {
          this.throwError("Unexpected token " + String.fromCharCode(termination));
        }
        break;
      } else if (ch_i === _Jsep.COMMA_CODE) {
        this.index++;
        separator_count++;
        if (separator_count !== args.length) {
          if (termination === _Jsep.CPAREN_CODE) {
            this.throwError("Unexpected token ,");
          } else if (termination === _Jsep.CBRACK_CODE) {
            for (let arg = args.length; arg < separator_count; arg++) {
              args.push(null);
            }
          }
        }
      } else if (args.length !== separator_count && separator_count !== 0) {
        this.throwError("Expected comma");
      } else {
        const node = this.gobbleExpression();
        if (!node || node.type === _Jsep.COMPOUND) {
          this.throwError("Expected comma");
        }
        args.push(node);
      }
    }
    if (!closed) {
      this.throwError("Expected " + String.fromCharCode(termination));
    }
    return args;
  }
  /**
   * Responsible for parsing a group of things within parentheses `()`
   * that have no identifier in front (so not a function call)
   * This function assumes that it needs to gobble the opening parenthesis
   * and then tries to gobble everything within that parenthesis, assuming
   * that the next thing it should see is the close parenthesis. If not,
   * then the expression probably doesn't have a `)`
   * @returns {boolean|jsep.Expression}
   */
  gobbleGroup() {
    this.index++;
    let nodes = this.gobbleExpressions(_Jsep.CPAREN_CODE);
    if (this.code === _Jsep.CPAREN_CODE) {
      this.index++;
      if (nodes.length === 1) {
        return nodes[0];
      } else if (!nodes.length) {
        return false;
      } else {
        return {
          type: _Jsep.SEQUENCE_EXP,
          expressions: nodes
        };
      }
    } else {
      this.throwError("Unclosed (");
    }
  }
  /**
   * Responsible for parsing Array literals `[1, 2, 3]`
   * This function assumes that it needs to gobble the opening bracket
   * and then tries to gobble the expressions as arguments.
   * @returns {jsep.ArrayExpression}
   */
  gobbleArray() {
    this.index++;
    return {
      type: _Jsep.ARRAY_EXP,
      elements: this.gobbleArguments(_Jsep.CBRACK_CODE)
    };
  }
};
var hooks = new Hooks();
Object.assign(Jsep, {
  hooks,
  plugins: new Plugins(Jsep),
  // Node Types
  // ----------
  // This is the full set of types that any JSEP node can be.
  // Store them here to save space when minified
  COMPOUND: "Compound",
  SEQUENCE_EXP: "SequenceExpression",
  IDENTIFIER: "Identifier",
  MEMBER_EXP: "MemberExpression",
  LITERAL: "Literal",
  THIS_EXP: "ThisExpression",
  CALL_EXP: "CallExpression",
  UNARY_EXP: "UnaryExpression",
  BINARY_EXP: "BinaryExpression",
  ARRAY_EXP: "ArrayExpression",
  TAB_CODE: 9,
  LF_CODE: 10,
  CR_CODE: 13,
  SPACE_CODE: 32,
  PERIOD_CODE: 46,
  // '.'
  COMMA_CODE: 44,
  // ','
  SQUOTE_CODE: 39,
  // single quote
  DQUOTE_CODE: 34,
  // double quotes
  OPAREN_CODE: 40,
  // (
  CPAREN_CODE: 41,
  // )
  OBRACK_CODE: 91,
  // [
  CBRACK_CODE: 93,
  // ]
  QUMARK_CODE: 63,
  // ?
  SEMCOL_CODE: 59,
  // ;
  COLON_CODE: 58,
  // :
  // Operations
  // ----------
  // Use a quickly-accessible map to store all of the unary operators
  // Values are set to `1` (it really doesn't matter)
  unary_ops: {
    "-": 1,
    "!": 1,
    "~": 1,
    "+": 1
  },
  // Also use a map for the binary operations but set their values to their
  // binary precedence for quick reference (higher number = higher precedence)
  // see [Order of operations](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence)
  binary_ops: {
    "||": 1,
    "&&": 2,
    "|": 3,
    "^": 4,
    "&": 5,
    "==": 6,
    "!=": 6,
    "===": 6,
    "!==": 6,
    "<": 7,
    ">": 7,
    "<=": 7,
    ">=": 7,
    "<<": 8,
    ">>": 8,
    ">>>": 8,
    "+": 9,
    "-": 9,
    "*": 10,
    "/": 10,
    "%": 10
  },
  // sets specific binary_ops as right-associative
  right_associative: /* @__PURE__ */ new Set(),
  // Additional valid identifier chars, apart from a-z, A-Z and 0-9 (except on the starting char)
  additional_identifier_chars: /* @__PURE__ */ new Set(["$", "_"]),
  // Literals
  // ----------
  // Store the values to return for the various literals we may encounter
  literals: {
    "true": true,
    "false": false,
    "null": null
  },
  // Except for `this`, which is special. This could be changed to something like `'self'` as well
  this_str: "this"
});
Jsep.max_unop_len = Jsep.getMaxKeyLen(Jsep.unary_ops);
Jsep.max_binop_len = Jsep.getMaxKeyLen(Jsep.binary_ops);
var jsep = (expr) => new Jsep(expr).parse();
var stdClassProps = Object.getOwnPropertyNames(class Test {
});
Object.getOwnPropertyNames(Jsep).filter((prop) => !stdClassProps.includes(prop) && jsep[prop] === void 0).forEach((m3) => {
  jsep[m3] = Jsep[m3];
});
jsep.Jsep = Jsep;
var CONDITIONAL_EXP = "ConditionalExpression";
var ternary = {
  name: "ternary",
  init(jsep2) {
    jsep2.hooks.add("after-expression", function gobbleTernary(env) {
      if (env.node && this.code === jsep2.QUMARK_CODE) {
        this.index++;
        const test2 = env.node;
        const consequent = this.gobbleExpression();
        if (!consequent) {
          this.throwError("Expected expression");
        }
        this.gobbleSpaces();
        if (this.code === jsep2.COLON_CODE) {
          this.index++;
          const alternate = this.gobbleExpression();
          if (!alternate) {
            this.throwError("Expected expression");
          }
          env.node = {
            type: CONDITIONAL_EXP,
            test: test2,
            consequent,
            alternate
          };
          if (test2.operator && jsep2.binary_ops[test2.operator] <= 0.9) {
            let newTest = test2;
            while (newTest.right.operator && jsep2.binary_ops[newTest.right.operator] <= 0.9) {
              newTest = newTest.right;
            }
            env.node.test = newTest.right;
            newTest.right = env.node;
            env.node = test2;
          }
        } else {
          this.throwError("Expected :");
        }
      }
    });
  }
};
jsep.plugins.register(ternary);
var FSLASH_CODE = 47;
var BSLASH_CODE = 92;
var index = {
  name: "regex",
  init(jsep2) {
    jsep2.hooks.add("gobble-token", function gobbleRegexLiteral(env) {
      if (this.code === FSLASH_CODE) {
        const patternIndex = ++this.index;
        let inCharSet = false;
        while (this.index < this.expr.length) {
          if (this.code === FSLASH_CODE && !inCharSet) {
            const pattern = this.expr.slice(patternIndex, this.index);
            let flags = "";
            while (++this.index < this.expr.length) {
              const code = this.code;
              if (code >= 97 && code <= 122 || code >= 65 && code <= 90 || code >= 48 && code <= 57) {
                flags += this.char;
              } else {
                break;
              }
            }
            let value;
            try {
              value = new RegExp(pattern, flags);
            } catch (e2) {
              this.throwError(e2.message);
            }
            env.node = {
              type: jsep2.LITERAL,
              value,
              raw: this.expr.slice(patternIndex - 1, this.index)
            };
            env.node = this.gobbleTokenProperty(env.node);
            return env.node;
          }
          if (this.code === jsep2.OBRACK_CODE) {
            inCharSet = true;
          } else if (inCharSet && this.code === jsep2.CBRACK_CODE) {
            inCharSet = false;
          }
          this.index += this.code === BSLASH_CODE ? 2 : 1;
        }
        this.throwError("Unclosed Regex");
      }
    });
  }
};
var PLUS_CODE = 43;
var MINUS_CODE = 45;
var plugin2 = {
  name: "assignment",
  assignmentOperators: /* @__PURE__ */ new Set(["=", "*=", "**=", "/=", "%=", "+=", "-=", "<<=", ">>=", ">>>=", "&=", "^=", "|="]),
  updateOperators: [PLUS_CODE, MINUS_CODE],
  assignmentPrecedence: 0.9,
  init(jsep2) {
    const updateNodeTypes = [jsep2.IDENTIFIER, jsep2.MEMBER_EXP];
    plugin2.assignmentOperators.forEach((op2) => jsep2.addBinaryOp(op2, plugin2.assignmentPrecedence, true));
    jsep2.hooks.add("gobble-token", function gobbleUpdatePrefix(env) {
      const code = this.code;
      if (plugin2.updateOperators.some((c) => c === code && c === this.expr.charCodeAt(this.index + 1))) {
        this.index += 2;
        env.node = {
          type: "UpdateExpression",
          operator: code === PLUS_CODE ? "++" : "--",
          argument: this.gobbleTokenProperty(this.gobbleIdentifier()),
          prefix: true
        };
        if (!env.node.argument || !updateNodeTypes.includes(env.node.argument.type)) {
          this.throwError(`Unexpected ${env.node.operator}`);
        }
      }
    });
    jsep2.hooks.add("after-token", function gobbleUpdatePostfix(env) {
      if (env.node) {
        const code = this.code;
        if (plugin2.updateOperators.some((c) => c === code && c === this.expr.charCodeAt(this.index + 1))) {
          if (!updateNodeTypes.includes(env.node.type)) {
            this.throwError(`Unexpected ${env.node.operator}`);
          }
          this.index += 2;
          env.node = {
            type: "UpdateExpression",
            operator: code === PLUS_CODE ? "++" : "--",
            argument: env.node,
            prefix: false
          };
        }
      }
    });
    jsep2.hooks.add("after-expression", function gobbleAssignment(env) {
      if (env.node) {
        updateBinariesToAssignments(env.node);
      }
    });
    function updateBinariesToAssignments(node) {
      if (plugin2.assignmentOperators.has(node.operator)) {
        node.type = "AssignmentExpression";
        updateBinariesToAssignments(node.left);
        updateBinariesToAssignments(node.right);
      } else if (!node.operator) {
        Object.values(node).forEach((val) => {
          if (val && typeof val === "object") {
            updateBinariesToAssignments(val);
          }
        });
      }
    }
  }
};
jsep.plugins.register(index, plugin2);
var SafeEval = {
  /**
   * @param {jsep.Expression} ast
   * @param {Record<string, any>} subs
   */
  evalAst(ast, subs) {
    switch (ast.type) {
      case "BinaryExpression":
      case "LogicalExpression":
        return SafeEval.evalBinaryExpression(ast, subs);
      case "Compound":
        return SafeEval.evalCompound(ast, subs);
      case "ConditionalExpression":
        return SafeEval.evalConditionalExpression(ast, subs);
      case "Identifier":
        return SafeEval.evalIdentifier(ast, subs);
      case "Literal":
        return SafeEval.evalLiteral(ast, subs);
      case "MemberExpression":
        return SafeEval.evalMemberExpression(ast, subs);
      case "UnaryExpression":
        return SafeEval.evalUnaryExpression(ast, subs);
      case "ArrayExpression":
        return SafeEval.evalArrayExpression(ast, subs);
      case "CallExpression":
        return SafeEval.evalCallExpression(ast, subs);
      case "AssignmentExpression":
        return SafeEval.evalAssignmentExpression(ast, subs);
      default:
        throw SyntaxError("Unexpected expression", ast);
    }
  },
  evalBinaryExpression(ast, subs) {
    const result = {
      "||": (a2, b2) => a2 || b2(),
      "&&": (a2, b2) => a2 && b2(),
      "|": (a2, b2) => a2 | b2(),
      "^": (a2, b2) => a2 ^ b2(),
      "&": (a2, b2) => a2 & b2(),
      // eslint-disable-next-line eqeqeq -- API
      "==": (a2, b2) => a2 == b2(),
      // eslint-disable-next-line eqeqeq -- API
      "!=": (a2, b2) => a2 != b2(),
      "===": (a2, b2) => a2 === b2(),
      "!==": (a2, b2) => a2 !== b2(),
      "<": (a2, b2) => a2 < b2(),
      ">": (a2, b2) => a2 > b2(),
      "<=": (a2, b2) => a2 <= b2(),
      ">=": (a2, b2) => a2 >= b2(),
      "<<": (a2, b2) => a2 << b2(),
      ">>": (a2, b2) => a2 >> b2(),
      ">>>": (a2, b2) => a2 >>> b2(),
      "+": (a2, b2) => a2 + b2(),
      "-": (a2, b2) => a2 - b2(),
      "*": (a2, b2) => a2 * b2(),
      "/": (a2, b2) => a2 / b2(),
      "%": (a2, b2) => a2 % b2()
    }[ast.operator](SafeEval.evalAst(ast.left, subs), () => SafeEval.evalAst(ast.right, subs));
    return result;
  },
  evalCompound(ast, subs) {
    let last2;
    for (let i2 = 0; i2 < ast.body.length; i2++) {
      if (ast.body[i2].type === "Identifier" && ["var", "let", "const"].includes(ast.body[i2].name) && ast.body[i2 + 1] && ast.body[i2 + 1].type === "AssignmentExpression") {
        i2 += 1;
      }
      const expr = ast.body[i2];
      last2 = SafeEval.evalAst(expr, subs);
    }
    return last2;
  },
  evalConditionalExpression(ast, subs) {
    if (SafeEval.evalAst(ast.test, subs)) {
      return SafeEval.evalAst(ast.consequent, subs);
    }
    return SafeEval.evalAst(ast.alternate, subs);
  },
  evalIdentifier(ast, subs) {
    if (ast.name in subs) {
      return subs[ast.name];
    }
    throw ReferenceError(`${ast.name} is not defined`);
  },
  evalLiteral(ast) {
    return ast.value;
  },
  evalMemberExpression(ast, subs) {
    if (ast.property.type === "Identifier" && ast.property.name === "constructor" || ast.object.type === "Identifier" && ast.object.name === "constructor") {
      throw new Error("'constructor' property is disabled");
    }
    const prop = ast.computed ? SafeEval.evalAst(ast.property) : ast.property.name;
    const obj = SafeEval.evalAst(ast.object, subs);
    const result = obj[prop];
    if (typeof result === "function") {
      if (obj === Function && prop === "bind") {
        throw new Error("Function.prototype.bind is disabled");
      }
      if (obj === Function && (prop === "call" || prop === "apply")) {
        throw new Error("Function.prototype.call and Function.prototype.apply are disabled");
      }
      if (result === Function) {
        return result;
      }
      return result.bind(obj);
    }
    return result;
  },
  evalUnaryExpression(ast, subs) {
    const result = {
      "-": (a2) => -SafeEval.evalAst(a2, subs),
      "!": (a2) => !SafeEval.evalAst(a2, subs),
      "~": (a2) => ~SafeEval.evalAst(a2, subs),
      // eslint-disable-next-line no-implicit-coercion -- API
      "+": (a2) => +SafeEval.evalAst(a2, subs)
    }[ast.operator](ast.argument);
    return result;
  },
  evalArrayExpression(ast, subs) {
    return ast.elements.map((el2) => SafeEval.evalAst(el2, subs));
  },
  evalCallExpression(ast, subs) {
    const args = ast.arguments.map((arg) => SafeEval.evalAst(arg, subs));
    const func = SafeEval.evalAst(ast.callee, subs);
    if (func === Function) {
      throw new Error("Function constructor is disabled");
    }
    return func(...args);
  },
  evalAssignmentExpression(ast, subs) {
    if (ast.left.type !== "Identifier") {
      throw SyntaxError("Invalid left-hand side in assignment");
    }
    const id2 = ast.left.name;
    if (id2 === "__proto__") {
      throw new Error("Assignment to __proto__ is disabled");
    }
    const value = SafeEval.evalAst(ast.right, subs);
    subs[id2] = value;
    return subs[id2];
  }
};
var SafeScript = class {
  /**
   * @param {string} expr Expression to evaluate
   */
  constructor(expr) {
    this.code = expr;
    this.ast = jsep(this.code);
  }
  /**
   * @param {object} context Object whose items will be added
   *   to evaluation
   * @returns {EvaluatedResult} Result of evaluated code
   */
  runInNewContext(context) {
    const keyMap = {
      ...context
    };
    return SafeEval.evalAst(this.ast, keyMap);
  }
};
function push(arr, item) {
  arr = arr.slice();
  arr.push(item);
  return arr;
}
function unshift(item, arr) {
  arr = arr.slice();
  arr.unshift(item);
  return arr;
}
var NewError = class extends Error {
  /**
   * @param {AnyResult} value The evaluated scalar value
   */
  constructor(value) {
    super('JSONPath should not be called with "new" (it prevents return of (unwrapped) scalar values)');
    this.avoidNew = true;
    this.value = value;
    this.name = "NewError";
  }
};
function JSONPath(opts, expr, obj, callback, otherTypeCallback) {
  if (!(this instanceof JSONPath)) {
    try {
      return new JSONPath(opts, expr, obj, callback, otherTypeCallback);
    } catch (e2) {
      if (!e2.avoidNew) {
        throw e2;
      }
      return e2.value;
    }
  }
  if (typeof opts === "string") {
    otherTypeCallback = callback;
    callback = obj;
    obj = expr;
    expr = opts;
    opts = null;
  }
  const optObj = opts && typeof opts === "object";
  opts = opts || {};
  this.json = opts.json || obj;
  this.path = opts.path || expr;
  this.resultType = opts.resultType || "value";
  this.flatten = opts.flatten || false;
  this.wrap = Object.hasOwn(opts, "wrap") ? opts.wrap : true;
  this.sandbox = opts.sandbox || {};
  this.eval = opts.eval === void 0 ? "safe" : opts.eval;
  this.ignoreEvalErrors = typeof opts.ignoreEvalErrors === "undefined" ? false : opts.ignoreEvalErrors;
  this.parent = opts.parent || null;
  this.parentProperty = opts.parentProperty || null;
  this.callback = opts.callback || callback || null;
  this.otherTypeCallback = opts.otherTypeCallback || otherTypeCallback || function() {
    throw new TypeError("You must supply an otherTypeCallback callback option with the @other() operator.");
  };
  if (opts.autostart !== false) {
    const args = {
      path: optObj ? opts.path : expr
    };
    if (!optObj) {
      args.json = obj;
    } else if ("json" in opts) {
      args.json = opts.json;
    }
    const ret = this.evaluate(args);
    if (!ret || typeof ret !== "object") {
      throw new NewError(ret);
    }
    return ret;
  }
}
JSONPath.prototype.evaluate = function(expr, json2, callback, otherTypeCallback) {
  let currParent = this.parent, currParentProperty = this.parentProperty;
  let {
    flatten: flatten2,
    wrap
  } = this;
  this.currResultType = this.resultType;
  this.currEval = this.eval;
  this.currSandbox = this.sandbox;
  callback = callback || this.callback;
  this.currOtherTypeCallback = otherTypeCallback || this.otherTypeCallback;
  json2 = json2 || this.json;
  expr = expr || this.path;
  if (expr && typeof expr === "object" && !Array.isArray(expr)) {
    if (!expr.path && expr.path !== "") {
      throw new TypeError('You must supply a "path" property when providing an object argument to JSONPath.evaluate().');
    }
    if (!Object.hasOwn(expr, "json")) {
      throw new TypeError('You must supply a "json" property when providing an object argument to JSONPath.evaluate().');
    }
    ({
      json: json2
    } = expr);
    flatten2 = Object.hasOwn(expr, "flatten") ? expr.flatten : flatten2;
    this.currResultType = Object.hasOwn(expr, "resultType") ? expr.resultType : this.currResultType;
    this.currSandbox = Object.hasOwn(expr, "sandbox") ? expr.sandbox : this.currSandbox;
    wrap = Object.hasOwn(expr, "wrap") ? expr.wrap : wrap;
    this.currEval = Object.hasOwn(expr, "eval") ? expr.eval : this.currEval;
    callback = Object.hasOwn(expr, "callback") ? expr.callback : callback;
    this.currOtherTypeCallback = Object.hasOwn(expr, "otherTypeCallback") ? expr.otherTypeCallback : this.currOtherTypeCallback;
    currParent = Object.hasOwn(expr, "parent") ? expr.parent : currParent;
    currParentProperty = Object.hasOwn(expr, "parentProperty") ? expr.parentProperty : currParentProperty;
    expr = expr.path;
  }
  currParent = currParent || null;
  currParentProperty = currParentProperty || null;
  if (Array.isArray(expr)) {
    expr = JSONPath.toPathString(expr);
  }
  if (!expr && expr !== "" || !json2) {
    return void 0;
  }
  const exprList = JSONPath.toPathArray(expr);
  if (exprList[0] === "$" && exprList.length > 1) {
    exprList.shift();
  }
  this._hasParentSelector = null;
  const result = this._trace(exprList, json2, ["$"], currParent, currParentProperty, callback).filter(function(ea3) {
    return ea3 && !ea3.isParentSelector;
  });
  if (!result.length) {
    return wrap ? [] : void 0;
  }
  if (!wrap && result.length === 1 && !result[0].hasArrExpr) {
    return this._getPreferredOutput(result[0]);
  }
  return result.reduce((rslt, ea3) => {
    const valOrPath = this._getPreferredOutput(ea3);
    if (flatten2 && Array.isArray(valOrPath)) {
      rslt = rslt.concat(valOrPath);
    } else {
      rslt.push(valOrPath);
    }
    return rslt;
  }, []);
};
JSONPath.prototype._getPreferredOutput = function(ea3) {
  const resultType = this.currResultType;
  switch (resultType) {
    case "all": {
      const path = Array.isArray(ea3.path) ? ea3.path : JSONPath.toPathArray(ea3.path);
      ea3.pointer = JSONPath.toPointer(path);
      ea3.path = typeof ea3.path === "string" ? ea3.path : JSONPath.toPathString(ea3.path);
      return ea3;
    }
    case "value":
    case "parent":
    case "parentProperty":
      return ea3[resultType];
    case "path":
      return JSONPath.toPathString(ea3[resultType]);
    case "pointer":
      return JSONPath.toPointer(ea3.path);
    default:
      throw new TypeError("Unknown result type");
  }
};
JSONPath.prototype._handleCallback = function(fullRetObj, callback, type) {
  if (callback) {
    const preferredOutput = this._getPreferredOutput(fullRetObj);
    fullRetObj.path = typeof fullRetObj.path === "string" ? fullRetObj.path : JSONPath.toPathString(fullRetObj.path);
    callback(preferredOutput, type, fullRetObj);
  }
};
JSONPath.prototype._trace = function(expr, val, path, parent, parentPropName, callback, hasArrExpr, literalPriority) {
  let retObj;
  if (!expr.length) {
    retObj = {
      path,
      value: val,
      parent,
      parentProperty: parentPropName,
      hasArrExpr
    };
    this._handleCallback(retObj, callback, "value");
    return retObj;
  }
  const loc = expr[0], x = expr.slice(1);
  const ret = [];
  function addRet(elems) {
    if (Array.isArray(elems)) {
      elems.forEach((t3) => {
        ret.push(t3);
      });
    } else {
      ret.push(elems);
    }
  }
  if ((typeof loc !== "string" || literalPriority) && val && Object.hasOwn(val, loc)) {
    addRet(this._trace(x, val[loc], push(path, loc), val, loc, callback, hasArrExpr));
  } else if (loc === "*") {
    this._walk(val, (m3) => {
      addRet(this._trace(x, val[m3], push(path, m3), val, m3, callback, true, true));
    });
  } else if (loc === "..") {
    addRet(this._trace(x, val, path, parent, parentPropName, callback, hasArrExpr));
    this._walk(val, (m3) => {
      if (typeof val[m3] === "object") {
        addRet(this._trace(expr.slice(), val[m3], push(path, m3), val, m3, callback, true));
      }
    });
  } else if (loc === "^") {
    this._hasParentSelector = true;
    return {
      path: path.slice(0, -1),
      expr: x,
      isParentSelector: true
    };
  } else if (loc === "~") {
    retObj = {
      path: push(path, loc),
      value: parentPropName,
      parent,
      parentProperty: null
    };
    this._handleCallback(retObj, callback, "property");
    return retObj;
  } else if (loc === "$") {
    addRet(this._trace(x, val, path, null, null, callback, hasArrExpr));
  } else if (/^(-?\d*):(-?\d*):?(\d*)$/u.test(loc)) {
    addRet(this._slice(loc, x, val, path, parent, parentPropName, callback));
  } else if (loc.indexOf("?(") === 0) {
    if (this.currEval === false) {
      throw new Error("Eval [?(expr)] prevented in JSONPath expression.");
    }
    const safeLoc = loc.replace(/^\?\((.*?)\)$/u, "$1");
    const nested = /@.?([^?]*)[['](\??\(.*?\))(?!.\)\])[\]']/gu.exec(safeLoc);
    if (nested) {
      this._walk(val, (m3) => {
        const npath = [nested[2]];
        const nvalue = nested[1] ? val[m3][nested[1]] : val[m3];
        const filterResults = this._trace(npath, nvalue, path, parent, parentPropName, callback, true);
        if (filterResults.length > 0) {
          addRet(this._trace(x, val[m3], push(path, m3), val, m3, callback, true));
        }
      });
    } else {
      this._walk(val, (m3) => {
        if (this._eval(safeLoc, val[m3], m3, path, parent, parentPropName)) {
          addRet(this._trace(x, val[m3], push(path, m3), val, m3, callback, true));
        }
      });
    }
  } else if (loc[0] === "(") {
    if (this.currEval === false) {
      throw new Error("Eval [(expr)] prevented in JSONPath expression.");
    }
    addRet(this._trace(unshift(this._eval(loc, val, path.at(-1), path.slice(0, -1), parent, parentPropName), x), val, path, parent, parentPropName, callback, hasArrExpr));
  } else if (loc[0] === "@") {
    let addType = false;
    const valueType = loc.slice(1, -2);
    switch (valueType) {
      case "scalar":
        if (!val || !["object", "function"].includes(typeof val)) {
          addType = true;
        }
        break;
      case "boolean":
      case "string":
      case "undefined":
      case "function":
        if (typeof val === valueType) {
          addType = true;
        }
        break;
      case "integer":
        if (Number.isFinite(val) && !(val % 1)) {
          addType = true;
        }
        break;
      case "number":
        if (Number.isFinite(val)) {
          addType = true;
        }
        break;
      case "nonFinite":
        if (typeof val === "number" && !Number.isFinite(val)) {
          addType = true;
        }
        break;
      case "object":
        if (val && typeof val === valueType) {
          addType = true;
        }
        break;
      case "array":
        if (Array.isArray(val)) {
          addType = true;
        }
        break;
      case "other":
        addType = this.currOtherTypeCallback(val, path, parent, parentPropName);
        break;
      case "null":
        if (val === null) {
          addType = true;
        }
        break;
      default:
        throw new TypeError("Unknown value type " + valueType);
    }
    if (addType) {
      retObj = {
        path,
        value: val,
        parent,
        parentProperty: parentPropName
      };
      this._handleCallback(retObj, callback, "value");
      return retObj;
    }
  } else if (loc[0] === "`" && val && Object.hasOwn(val, loc.slice(1))) {
    const locProp = loc.slice(1);
    addRet(this._trace(x, val[locProp], push(path, locProp), val, locProp, callback, hasArrExpr, true));
  } else if (loc.includes(",")) {
    const parts = loc.split(",");
    for (const part of parts) {
      addRet(this._trace(unshift(part, x), val, path, parent, parentPropName, callback, true));
    }
  } else if (!literalPriority && val && Object.hasOwn(val, loc)) {
    addRet(this._trace(x, val[loc], push(path, loc), val, loc, callback, hasArrExpr, true));
  }
  if (this._hasParentSelector) {
    for (let t3 = 0; t3 < ret.length; t3++) {
      const rett = ret[t3];
      if (rett && rett.isParentSelector) {
        const tmp = this._trace(rett.expr, val, rett.path, parent, parentPropName, callback, hasArrExpr);
        if (Array.isArray(tmp)) {
          ret[t3] = tmp[0];
          const tl2 = tmp.length;
          for (let tt2 = 1; tt2 < tl2; tt2++) {
            t3++;
            ret.splice(t3, 0, tmp[tt2]);
          }
        } else {
          ret[t3] = tmp;
        }
      }
    }
  }
  return ret;
};
JSONPath.prototype._walk = function(val, f) {
  if (Array.isArray(val)) {
    const n2 = val.length;
    for (let i2 = 0; i2 < n2; i2++) {
      f(i2);
    }
  } else if (val && typeof val === "object") {
    Object.keys(val).forEach((m3) => {
      f(m3);
    });
  }
};
JSONPath.prototype._slice = function(loc, expr, val, path, parent, parentPropName, callback) {
  if (!Array.isArray(val)) {
    return void 0;
  }
  const len = val.length, parts = loc.split(":"), step = parts[2] && Number.parseInt(parts[2]) || 1;
  let start = parts[0] && Number.parseInt(parts[0]) || 0, end = parts[1] && Number.parseInt(parts[1]) || len;
  start = start < 0 ? Math.max(0, start + len) : Math.min(len, start);
  end = end < 0 ? Math.max(0, end + len) : Math.min(len, end);
  const ret = [];
  for (let i2 = start; i2 < end; i2 += step) {
    const tmp = this._trace(unshift(i2, expr), val, path, parent, parentPropName, callback, true);
    tmp.forEach((t3) => {
      ret.push(t3);
    });
  }
  return ret;
};
JSONPath.prototype._eval = function(code, _v2, _vname, path, parent, parentPropName) {
  this.currSandbox._$_parentProperty = parentPropName;
  this.currSandbox._$_parent = parent;
  this.currSandbox._$_property = _vname;
  this.currSandbox._$_root = this.json;
  this.currSandbox._$_v = _v2;
  const containsPath = code.includes("@path");
  if (containsPath) {
    this.currSandbox._$_path = JSONPath.toPathString(path.concat([_vname]));
  }
  const scriptCacheKey = this.currEval + "Script:" + code;
  if (!JSONPath.cache[scriptCacheKey]) {
    let script = code.replaceAll("@parentProperty", "_$_parentProperty").replaceAll("@parent", "_$_parent").replaceAll("@property", "_$_property").replaceAll("@root", "_$_root").replaceAll(/@([.\s)[])/gu, "_$_v$1");
    if (containsPath) {
      script = script.replaceAll("@path", "_$_path");
    }
    if (this.currEval === "safe" || this.currEval === true || this.currEval === void 0) {
      JSONPath.cache[scriptCacheKey] = new this.safeVm.Script(script);
    } else if (this.currEval === "native") {
      JSONPath.cache[scriptCacheKey] = new this.vm.Script(script);
    } else if (typeof this.currEval === "function" && this.currEval.prototype && Object.hasOwn(this.currEval.prototype, "runInNewContext")) {
      const CurrEval = this.currEval;
      JSONPath.cache[scriptCacheKey] = new CurrEval(script);
    } else if (typeof this.currEval === "function") {
      JSONPath.cache[scriptCacheKey] = {
        runInNewContext: (context) => this.currEval(script, context)
      };
    } else {
      throw new TypeError(`Unknown "eval" property "${this.currEval}"`);
    }
  }
  try {
    return JSONPath.cache[scriptCacheKey].runInNewContext(this.currSandbox);
  } catch (e2) {
    if (this.ignoreEvalErrors) {
      return false;
    }
    throw new Error("jsonPath: " + e2.message + ": " + code);
  }
};
JSONPath.cache = {};
JSONPath.toPathString = function(pathArr) {
  const x = pathArr, n2 = x.length;
  let p = "$";
  for (let i2 = 1; i2 < n2; i2++) {
    if (!/^(~|\^|@.*?\(\))$/u.test(x[i2])) {
      p += /^[0-9*]+$/u.test(x[i2]) ? "[" + x[i2] + "]" : "['" + x[i2] + "']";
    }
  }
  return p;
};
JSONPath.toPointer = function(pointer) {
  const x = pointer, n2 = x.length;
  let p = "";
  for (let i2 = 1; i2 < n2; i2++) {
    if (!/^(~|\^|@.*?\(\))$/u.test(x[i2])) {
      p += "/" + x[i2].toString().replaceAll("~", "~0").replaceAll("/", "~1");
    }
  }
  return p;
};
JSONPath.toPathArray = function(expr) {
  const {
    cache
  } = JSONPath;
  if (cache[expr]) {
    return cache[expr].concat();
  }
  const subx = [];
  const normalized = expr.replaceAll(/@(?:null|boolean|number|string|integer|undefined|nonFinite|scalar|array|object|function|other)\(\)/gu, ";$&;").replaceAll(/[['](\??\(.*?\))[\]'](?!.\])/gu, function($0, $1) {
    return "[#" + (subx.push($1) - 1) + "]";
  }).replaceAll(/\[['"]([^'\]]*)['"]\]/gu, function($0, prop) {
    return "['" + prop.replaceAll(".", "%@%").replaceAll("~", "%%@@%%") + "']";
  }).replaceAll("~", ";~;").replaceAll(/['"]?\.['"]?(?![^[]*\])|\[['"]?/gu, ";").replaceAll("%@%", ".").replaceAll("%%@@%%", "~").replaceAll(/(?:;)?(\^+)(?:;)?/gu, function($0, ups) {
    return ";" + ups.split("").join(";") + ";";
  }).replaceAll(/;;;|;;/gu, ";..;").replaceAll(/;$|'?\]|'$/gu, "");
  const exprList = normalized.split(";").map(function(exp) {
    const match = exp.match(/#(\d+)/u);
    return !match || !match[1] ? exp : subx[match[1]];
  });
  cache[expr] = exprList;
  return cache[expr].concat();
};
JSONPath.prototype.safeVm = {
  Script: SafeScript
};
var moveToAnotherArray = function(source, target, conditionCb) {
  const il2 = source.length;
  for (let i2 = 0; i2 < il2; i2++) {
    const item = source[i2];
    if (conditionCb(item)) {
      target.push(source.splice(i2--, 1)[0]);
    }
  }
};
var Script = class {
  /**
   * @param {string} expr Expression to evaluate
   */
  constructor(expr) {
    this.code = expr;
  }
  /**
   * @param {object} context Object whose items will be added
   *   to evaluation
   * @returns {EvaluatedResult} Result of evaluated code
   */
  runInNewContext(context) {
    let expr = this.code;
    const keys2 = Object.keys(context);
    const funcs = [];
    moveToAnotherArray(keys2, funcs, (key) => {
      return typeof context[key] === "function";
    });
    const values = keys2.map((vr3) => {
      return context[vr3];
    });
    const funcString = funcs.reduce((s2, func) => {
      let fString = context[func].toString();
      if (!/function/u.test(fString)) {
        fString = "function " + fString;
      }
      return "var " + func + "=" + fString + ";" + s2;
    }, "");
    expr = funcString + expr;
    if (!/(['"])use strict\1/u.test(expr) && !keys2.includes("arguments")) {
      expr = "var arguments = undefined;" + expr;
    }
    expr = expr.replace(/;\s*$/u, "");
    const lastStatementEnd = expr.lastIndexOf(";");
    const code = lastStatementEnd > -1 ? expr.slice(0, lastStatementEnd + 1) + " return " + expr.slice(lastStatementEnd + 1) : " return " + expr;
    return new Function(...keys2, code)(...values);
  }
};
JSONPath.prototype.vm = {
  Script
};

// node_modules/vanilla-jsoneditor/index.js
var e = ["mainAxis", "crossAxis", "fallbackPlacements", "fallbackStrategy", "fallbackAxisSideDirection", "flipAlignment"];
var t2 = ["mainAxis", "crossAxis", "limiter"];
function n(e2, t3) {
  if (null == e2) return {};
  var n2, r2, o2 = function(e3, t4) {
    if (null == e3) return {};
    var n3 = {};
    for (var r3 in e3) if ({}.hasOwnProperty.call(e3, r3)) {
      if (t4.includes(r3)) continue;
      n3[r3] = e3[r3];
    }
    return n3;
  }(e2, t3);
  if (Object.getOwnPropertySymbols) {
    var a2 = Object.getOwnPropertySymbols(e2);
    for (r2 = 0; r2 < a2.length; r2++) n2 = a2[r2], t3.includes(n2) || {}.propertyIsEnumerable.call(e2, n2) && (o2[n2] = e2[n2]);
  }
  return o2;
}
function r(e2, t3, n2, r2, o2, a2, i2) {
  try {
    var s2 = e2[a2](i2), l = s2.value;
  } catch (e3) {
    return void n2(e3);
  }
  s2.done ? t3(l) : Promise.resolve(l).then(r2, o2);
}
function o(e2) {
  return function() {
    var t3 = this, n2 = arguments;
    return new Promise(function(o2, a2) {
      var i2 = e2.apply(t3, n2);
      function s2(e3) {
        r(i2, o2, a2, s2, l, "next", e3);
      }
      function l(e3) {
        r(i2, o2, a2, s2, l, "throw", e3);
      }
      s2(void 0);
    });
  };
}
function a(e2, t3) {
  var n2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var r2 = Object.getOwnPropertySymbols(e2);
    t3 && (r2 = r2.filter(function(t4) {
      return Object.getOwnPropertyDescriptor(e2, t4).enumerable;
    })), n2.push.apply(n2, r2);
  }
  return n2;
}
function i(e2) {
  for (var t3 = 1; t3 < arguments.length; t3++) {
    var n2 = null != arguments[t3] ? arguments[t3] : {};
    t3 % 2 ? a(Object(n2), true).forEach(function(t4) {
      s(e2, t4, n2[t4]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(n2)) : a(Object(n2)).forEach(function(t4) {
      Object.defineProperty(e2, t4, Object.getOwnPropertyDescriptor(n2, t4));
    });
  }
  return e2;
}
function s(e2, t3, n2) {
  return (t3 = function(e3) {
    var t4 = function(e4, t5) {
      if ("object" != typeof e4 || !e4) return e4;
      var n3 = e4[Symbol.toPrimitive];
      if (void 0 !== n3) {
        var r2 = n3.call(e4, t5 || "default");
        if ("object" != typeof r2) return r2;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === t5 ? String : Number)(e4);
    }(e3, "string");
    return "symbol" == typeof t4 ? t4 : t4 + "";
  }(t3)) in e2 ? Object.defineProperty(e2, t3, { value: n2, enumerable: true, configurable: true, writable: true }) : e2[t3] = n2, e2;
}
function Bt() {
}
function Ft(e2, t3) {
  for (var n2 in t3) e2[n2] = t3[n2];
  return e2;
}
function Ut(e2) {
  return e2();
}
function Lt() {
  return /* @__PURE__ */ Object.create(null);
}
function Dt(e2) {
  e2.forEach(Ut);
}
function Jt(e2) {
  return "function" == typeof e2;
}
function Vt(e2, t3) {
  return e2 != e2 ? t3 == t3 : e2 !== t3 || e2 && "object" == typeof e2 || "function" == typeof e2;
}
function Ht(e2, t3) {
  return e2 != e2 ? t3 == t3 : e2 !== t3;
}
function _t(e2, t3, n2, r2) {
  if (e2) {
    var o2 = Wt(e2, t3, n2, r2);
    return e2[0](o2);
  }
}
function Wt(e2, t3, n2, r2) {
  return e2[1] && r2 ? Ft(n2.ctx.slice(), e2[1](r2(t3))) : n2.ctx;
}
function Qt(e2, t3, n2, r2) {
  if (e2[2] && r2) {
    var o2 = e2[2](r2(n2));
    if (void 0 === t3.dirty) return o2;
    if ("object" == typeof o2) {
      for (var a2 = [], i2 = Math.max(t3.dirty.length, o2.length), s2 = 0; s2 < i2; s2 += 1) a2[s2] = t3.dirty[s2] | o2[s2];
      return a2;
    }
    return t3.dirty | o2;
  }
  return t3.dirty;
}
function Yt(e2, t3, n2, r2, o2, a2) {
  if (o2) {
    var i2 = Wt(t3, n2, r2, a2);
    e2.p(i2, o2);
  }
}
function Kt(e2) {
  if (e2.ctx.length > 32) {
    for (var t3 = [], n2 = e2.ctx.length / 32, r2 = 0; r2 < n2; r2++) t3[r2] = -1;
    return t3;
  }
  return -1;
}
function Zt(e2) {
  var t3 = {};
  for (var n2 in e2) "$" !== n2[0] && (t3[n2] = e2[n2]);
  return t3;
}
function Xt(e2, t3) {
  var n2 = {};
  for (var r2 in t3 = new Set(t3), e2) t3.has(r2) || "$" === r2[0] || (n2[r2] = e2[r2]);
  return n2;
}
function Gt(e2) {
  return null == e2 ? "" : e2;
}
function en(e2) {
  return e2 && Jt(e2.destroy) ? e2.destroy : Bt;
}
var tn = "undefined" != typeof window ? window : "undefined" != typeof globalThis ? globalThis : global;
function nn(e2, t3) {
  e2.appendChild(t3);
}
function rn(e2, t3, n2) {
  var r2 = function(e3) {
    if (!e3) return document;
    var t4 = e3.getRootNode ? e3.getRootNode() : e3.ownerDocument;
    if (t4 && t4.host) return t4;
    return e3.ownerDocument;
  }(e2);
  if (!r2.getElementById(t3)) {
    var o2 = ln("style");
    o2.id = t3, o2.textContent = n2, function(e3, t4) {
      nn(e3.head || e3, t4), t4.sheet;
    }(r2, o2);
  }
}
function on(e2, t3, n2) {
  e2.insertBefore(t3, n2 || null);
}
function an(e2) {
  e2.parentNode && e2.parentNode.removeChild(e2);
}
function sn(e2, t3) {
  for (var n2 = 0; n2 < e2.length; n2 += 1) e2[n2] && e2[n2].d(t3);
}
function ln(e2) {
  return document.createElement(e2);
}
function cn(e2) {
  return document.createElementNS("http://www.w3.org/2000/svg", e2);
}
function un(e2) {
  return document.createTextNode(e2);
}
function dn() {
  return un(" ");
}
function vn() {
  return un("");
}
function pn(e2, t3, n2, r2) {
  return e2.addEventListener(t3, n2, r2), () => e2.removeEventListener(t3, n2, r2);
}
function fn(e2) {
  return function(t3) {
    return t3.preventDefault(), e2.call(this, t3);
  };
}
function mn(e2) {
  return function(t3) {
    return t3.stopPropagation(), e2.call(this, t3);
  };
}
function hn(e2, t3, n2) {
  null == n2 ? e2.removeAttribute(t3) : e2.getAttribute(t3) !== n2 && e2.setAttribute(t3, n2);
}
var gn;
var jn = ["width", "height"];
function xn(e2, t3) {
  var n2 = Object.getOwnPropertyDescriptors(e2.__proto__);
  for (var r2 in t3) null == t3[r2] ? e2.removeAttribute(r2) : "style" === r2 ? e2.style.cssText = t3[r2] : "__value" === r2 ? e2.value = e2[r2] = t3[r2] : n2[r2] && n2[r2].set && -1 === jn.indexOf(r2) ? e2[r2] = t3[r2] : hn(e2, r2, t3[r2]);
}
function bn(e2, t3) {
  for (var n2 in t3) hn(e2, n2, t3[n2]);
}
function yn(e2, t3) {
  t3 = "" + t3, e2.data !== t3 && (e2.data = t3);
}
function $n(e2, t3) {
  e2.value = null == t3 ? "" : t3;
}
function wn(e2, t3, n2, r2) {
  null == n2 ? e2.style.removeProperty(t3) : e2.style.setProperty(t3, n2, "");
}
function kn(e2, t3, n2) {
  e2.classList.toggle(t3, !!n2);
}
function Sn(e2, t3) {
  return new e2(t3);
}
function On(e2) {
  gn = e2;
}
function zn() {
  if (!gn) throw new Error("Function called outside component initialization");
  return gn;
}
function qn(e2) {
  zn().$$.on_mount.push(e2);
}
function Mn(e2) {
  zn().$$.on_destroy.push(e2);
}
function Rn() {
  var e2 = zn();
  return function(t3, n2) {
    var { cancelable: r2 = false } = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, o2 = e2.$$.callbacks[t3];
    if (o2) {
      var a2 = function(e3, t4) {
        var { bubbles: n3 = false, cancelable: r3 = false } = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
        return new CustomEvent(e3, { detail: t4, bubbles: n3, cancelable: r3 });
      }(t3, n2, { cancelable: r2 });
      return o2.slice().forEach((t4) => {
        t4.call(e2, a2);
      }), !a2.defaultPrevented;
    }
    return true;
  };
}
function En(e2) {
  return zn().$$.context.get(e2);
}
function Pn(e2, t3) {
  var n2 = e2.$$.callbacks[t3.type];
  n2 && n2.slice().forEach((e3) => e3.call(this, t3));
}
var In = [];
var Tn = [];
var An = [];
var Nn = [];
var Bn = Promise.resolve();
var Fn = false;
function Un() {
  Fn || (Fn = true, Bn.then(_n));
}
function Ln() {
  return Un(), Bn;
}
function Dn(e2) {
  An.push(e2);
}
function Jn(e2) {
  Nn.push(e2);
}
var Vn = /* @__PURE__ */ new Set();
var Hn = 0;
function _n() {
  if (0 === Hn) {
    var e2 = gn;
    do {
      try {
        for (; Hn < In.length; ) {
          var t3 = In[Hn];
          Hn++, On(t3), Wn(t3.$$);
        }
      } catch (e3) {
        throw In.length = 0, Hn = 0, e3;
      }
      for (On(null), In.length = 0, Hn = 0; Tn.length; ) Tn.pop()();
      for (var n2 = 0; n2 < An.length; n2 += 1) {
        var r2 = An[n2];
        Vn.has(r2) || (Vn.add(r2), r2());
      }
      An.length = 0;
    } while (In.length);
    for (; Nn.length; ) Nn.pop()();
    Fn = false, Vn.clear(), On(e2);
  }
}
function Wn(e2) {
  if (null !== e2.fragment) {
    e2.update(), Dt(e2.before_update);
    var t3 = e2.dirty;
    e2.dirty = [-1], e2.fragment && e2.fragment.p(e2.ctx, t3), e2.after_update.forEach(Dn);
  }
}
var Qn;
var Yn = /* @__PURE__ */ new Set();
function Kn() {
  Qn = { r: 0, c: [], p: Qn };
}
function Zn() {
  Qn.r || Dt(Qn.c), Qn = Qn.p;
}
function Xn(e2, t3) {
  e2 && e2.i && (Yn.delete(e2), e2.i(t3));
}
function Gn(e2, t3, n2, r2) {
  if (e2 && e2.o) {
    if (Yn.has(e2)) return;
    Yn.add(e2), Qn.c.push(() => {
      Yn.delete(e2), r2 && (n2 && e2.d(1), r2());
    }), e2.o(t3);
  } else r2 && r2();
}
function er(e2) {
  return void 0 !== (null == e2 ? void 0 : e2.length) ? e2 : Array.from(e2);
}
function tr(e2, t3) {
  e2.d(1), t3.delete(e2.key);
}
function nr(e2, t3) {
  Gn(e2, 1, 1, () => {
    t3.delete(e2.key);
  });
}
function rr(e2, t3, n2, r2, o2, a2, i2, s2, l, c, u, d) {
  for (var v = e2.length, p = a2.length, f = v, m3 = {}; f--; ) m3[e2[f].key] = f;
  var h2 = [], g = /* @__PURE__ */ new Map(), j = /* @__PURE__ */ new Map(), x = [];
  f = p;
  for (var b2 = function() {
    var e3 = d(o2, a2, f), r3 = n2(e3), s3 = i2.get(r3);
    s3 ? x.push(() => s3.p(e3, t3)) : (s3 = c(r3, e3)).c(), g.set(r3, h2[f] = s3), r3 in m3 && j.set(r3, Math.abs(f - m3[r3]));
  }; f--; ) b2();
  var y = /* @__PURE__ */ new Set(), $2 = /* @__PURE__ */ new Set();
  function w(e3) {
    Xn(e3, 1), e3.m(s2, u), i2.set(e3.key, e3), u = e3.first, p--;
  }
  for (; v && p; ) {
    var C3 = h2[p - 1], k2 = e2[v - 1], S4 = C3.key, O = k2.key;
    C3 === k2 ? (u = C3.first, v--, p--) : g.has(O) ? !i2.has(S4) || y.has(S4) ? w(C3) : $2.has(O) ? v-- : j.get(S4) > j.get(O) ? ($2.add(S4), w(C3)) : (y.add(O), v--) : (l(k2, i2), v--);
  }
  for (; v--; ) {
    var z3 = e2[v];
    g.has(z3.key) || l(z3, i2);
  }
  for (; p; ) w(h2[p - 1]);
  return Dt(x), h2;
}
function or(e2, t3) {
  for (var n2 = {}, r2 = {}, o2 = { $$scope: 1 }, a2 = e2.length; a2--; ) {
    var i2 = e2[a2], s2 = t3[a2];
    if (s2) {
      for (var l in i2) l in s2 || (r2[l] = 1);
      for (var c in s2) o2[c] || (n2[c] = s2[c], o2[c] = 1);
      e2[a2] = s2;
    } else for (var u in i2) o2[u] = 1;
  }
  for (var d in r2) d in n2 || (n2[d] = void 0);
  return n2;
}
function ar(e2) {
  return "object" == typeof e2 && null !== e2 ? e2 : {};
}
function ir(e2, t3, n2) {
  var r2 = e2.$$.props[t3];
  void 0 !== r2 && (e2.$$.bound[r2] = n2, n2(e2.$$.ctx[r2]));
}
function sr(e2) {
  e2 && e2.c();
}
function lr(e2, t3, n2) {
  var { fragment: r2, after_update: o2 } = e2.$$;
  r2 && r2.m(t3, n2), Dn(() => {
    var t4 = e2.$$.on_mount.map(Ut).filter(Jt);
    e2.$$.on_destroy ? e2.$$.on_destroy.push(...t4) : Dt(t4), e2.$$.on_mount = [];
  }), o2.forEach(Dn);
}
function cr(e2, t3) {
  var n2, r2, o2, a2 = e2.$$;
  null !== a2.fragment && (n2 = a2.after_update, r2 = [], o2 = [], An.forEach((e3) => -1 === n2.indexOf(e3) ? r2.push(e3) : o2.push(e3)), o2.forEach((e3) => e3()), An = r2, Dt(a2.on_destroy), a2.fragment && a2.fragment.d(t3), a2.on_destroy = a2.fragment = null, a2.ctx = []);
}
function ur(e2, t3, n2, r2, o2, a2) {
  var i2 = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : null, s2 = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : [-1], l = gn;
  On(e2);
  var c = e2.$$ = { fragment: null, ctx: [], props: a2, update: Bt, not_equal: o2, bound: Lt(), on_mount: [], on_destroy: [], on_disconnect: [], before_update: [], after_update: [], context: new Map(t3.context || (l ? l.$$.context : [])), callbacks: Lt(), dirty: s2, skip_bound: false, root: t3.target || l.$$.root };
  i2 && i2(c.root);
  var u = false;
  if (c.ctx = n2 ? n2(e2, t3.props || {}, function(t4, n3) {
    var r3 = !(arguments.length <= 2) && arguments.length - 2 ? arguments.length <= 2 ? void 0 : arguments[2] : n3;
    return c.ctx && o2(c.ctx[t4], c.ctx[t4] = r3) && (!c.skip_bound && c.bound[t4] && c.bound[t4](r3), u && function(e3, t5) {
      -1 === e3.$$.dirty[0] && (In.push(e3), Un(), e3.$$.dirty.fill(0)), e3.$$.dirty[t5 / 31 | 0] |= 1 << t5 % 31;
    }(e2, t4)), n3;
  }) : [], c.update(), u = true, Dt(c.before_update), c.fragment = !!r2 && r2(c.ctx), t3.target) {
    if (t3.hydrate) {
      var d = function(e3) {
        return Array.from(e3.childNodes);
      }(t3.target);
      c.fragment && c.fragment.l(d), d.forEach(an);
    } else c.fragment && c.fragment.c();
    t3.intro && Xn(e2.$$.fragment), lr(e2, t3.target, t3.anchor), _n();
  }
  On(l);
}
var dr = class {
  constructor() {
    s(this, "$$", void 0), s(this, "$$set", void 0);
  }
  $destroy() {
    cr(this, 1), this.$destroy = Bt;
  }
  $on(e2, t3) {
    if (!Jt(t3)) return Bt;
    var n2 = this.$$.callbacks[e2] || (this.$$.callbacks[e2] = []);
    return n2.push(t3), () => {
      var e3 = n2.indexOf(t3);
      -1 !== e3 && n2.splice(e3, 1);
    };
  }
  $set(e2) {
    var t3;
    this.$$set && (t3 = e2, 0 !== Object.keys(t3).length) && (this.$$.skip_bound = true, this.$$set(e2), this.$$.skip_bound = false);
  }
};
function vr(e2) {
  var t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : function(e3) {
    var t4 = function(e4) {
      try {
        if ("undefined" != typeof window && void 0 !== window.localStorage) return window.localStorage[e4];
      } catch (e5) {
      }
      return;
    }("debug");
    return null != t4 && t4.endsWith("*") ? e3.startsWith(t4.slice(0, -1)) : e3 === t4;
  }(e2);
  if (!t3) return pr;
  var n2 = function(e3) {
    for (var t4 = 0, n3 = 0; n3 < e3.length; n3++) t4 = (t4 << 5) - t4 + e3.charCodeAt(n3), t4 |= 0;
    return fr[Math.abs(t4) % fr.length];
  }(e2);
  return function() {
    for (var t4 = arguments.length, r2 = new Array(t4), o2 = 0; o2 < t4; o2++) r2[o2] = arguments[o2];
    console.log("%c".concat(e2), "color:".concat(n2), ...r2);
  };
}
function pr() {
}
"undefined" != typeof window && (window.__svelte || (window.__svelte = { v: /* @__PURE__ */ new Set() })).v.add("4");
var fr = ["#0000CC", "#0099FF", "#009400", "#8dd200", "#CCCC00", "#CC9933", "#ae04e7", "#ff35d7", "#FF3333", "#FF6600", "#FF9933", "#FFCC33"];
var mr = 0;
function hr() {
  return ++mr;
}
function gr(e2) {
  return parseInt(e2, 10);
}
function jr(e2) {
  return xr.test(e2);
}
var xr = /^-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?$/;
function br(e2) {
  return "object" == typeof e2 && null !== e2 && (void 0 === e2.constructor || "Object" === e2.constructor.name);
}
function yr(e2) {
  return "object" == typeof e2 && null !== e2 && (void 0 === e2.constructor || "Object" === e2.constructor.name || "Array" === e2.constructor.name);
}
function $r(e2) {
  return true === e2 || false === e2;
}
function wr(e2) {
  if ("number" == typeof e2) return e2 > 9466848e5 && isFinite(e2) && Math.floor(e2) === e2 && !isNaN(new Date(e2).valueOf());
  if ("bigint" == typeof e2) return wr(Number(e2));
  try {
    var t3 = e2 ? e2.valueOf() : e2;
    if (t3 !== e2) return wr(t3);
  } catch (e3) {
    return false;
  }
  return false;
}
function Cr(e2) {
  (kr = kr || window.document.createElement("div")).style.color = "", kr.style.color = e2;
  var t3 = kr.style.color;
  return "" !== t3 ? t3.replace(/\s+/g, "").toLowerCase() : void 0;
}
var kr = void 0;
function Sr(e2) {
  return "string" == typeof e2 && e2.length < 99 && !!Cr(e2);
}
function Or(e2, t3) {
  if ("number" == typeof e2 || "string" == typeof e2 || "boolean" == typeof e2 || void 0 === e2) return typeof e2;
  if ("bigint" == typeof e2) return "number";
  if (null === e2) return "null";
  if (Array.isArray(e2)) return "array";
  if (br(e2)) return "object";
  var n2 = t3.stringify(e2);
  return n2 && jr(n2) ? "number" : "true" === n2 || "false" === n2 ? "boolean" : "null" === n2 ? "null" : "unknown";
}
var zr = /^https?:\/\/\S+$/;
function qr(e2) {
  return "string" == typeof e2 && zr.test(e2);
}
function Mr(e2, t3) {
  if ("" === e2) return "";
  var n2 = e2.trim();
  return "null" === n2 ? null : "true" === n2 || "false" !== n2 && (jr(n2) ? t3.parse(n2) : e2);
}
var Pr = 1e4;
var Ir = [];
function Tr(e2, t3) {
  if (e2.length !== t3.length) return false;
  for (var n2 = 0; n2 < e2.length; n2++) if (e2[n2] !== t3[n2]) return false;
  return true;
}
function Ar(e2) {
  var t3 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], n2 = {};
  if (!Array.isArray(e2)) throw new TypeError("Array expected");
  function r2(e3, o3) {
    (!Array.isArray(e3) && !br(e3) || t3 && o3.length > 0) && (n2[compileJSONPointer(o3)] = true), br(e3) && Object.keys(e3).forEach((t4) => {
      r2(e3[t4], o3.concat(t4));
    });
  }
  for (var o2 = Math.min(e2.length, Pr), a2 = 0; a2 < o2; a2++) {
    r2(e2[a2], Ir);
  }
  return Object.keys(n2).sort().map(parseJSONPointer);
}
function Nr(e2, t3, n2) {
  if (!(t3 <= e2)) for (var r2 = e2; r2 < t3; r2++) n2(r2);
}
function Br(e2, t3) {
  return e2.length > t3 ? e2.slice(0, t3) : e2;
}
function Fr(e2) {
  return i({}, e2);
}
function Ur(e2) {
  return Object.values(e2);
}
function Lr(e2, t3, n2, r2) {
  var o2 = e2.slice(0), a2 = o2.splice(t3, n2);
  return o2.splice.apply(o2, [t3 + r2, 0, ...a2]), o2;
}
function Dr(e2, t3, n2) {
  return e2.slice(0, t3).concat(n2).concat(e2.slice(t3));
}
function Jr(e2, t3) {
  try {
    return t3.parse(e2);
  } catch (n2) {
    return t3.parse(jsonrepair(e2));
  }
}
function Vr(e2, t3) {
  try {
    return Jr(e2, t3);
  } catch (e3) {
    return;
  }
}
function Hr(e2, t3) {
  e2 = e2.replace(Wr, "");
  try {
    return t3(e2);
  } catch (e3) {
  }
  try {
    return t3("[" + e2 + "]");
  } catch (e3) {
  }
  try {
    return t3("{" + e2 + "}");
  } catch (e3) {
  }
  throw new Error("Failed to parse partial JSON");
}
function _r(e2) {
  e2 = e2.replace(Wr, "");
  try {
    return jsonrepair(e2);
  } catch (e3) {
  }
  try {
    var t3 = jsonrepair("[" + e2 + "]");
    return t3.substring(1, t3.length - 1);
  } catch (e3) {
  }
  try {
    var n2 = jsonrepair("{" + e2 + "}");
    return n2.substring(1, n2.length - 1);
  } catch (e3) {
  }
  throw new Error("Failed to repair partial JSON");
}
var Wr = /,\s*$/;
function Qr(e2, t3) {
  var n2 = oo.exec(t3);
  if (n2) {
    var r2 = gr(n2[2]), o2 = function(e3, t4) {
      for (var n3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, r3 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : e3.length, o3 = 0, a3 = n3; a3 < r3; a3++) e3.charAt(a3) === t4 && o3++;
      return o3;
    }(e2, "\n", 0, r2), a2 = r2 - e2.lastIndexOf("\n", r2) - 1;
    return { position: r2, line: o2, column: a2, message: t3.replace(oo, () => "line ".concat(o2 + 1, " column ").concat(a2 + 1)) };
  }
  var i2 = ao.exec(t3), s2 = i2 ? gr(i2[1]) : void 0, l = void 0 !== s2 ? s2 - 1 : void 0, c = io.exec(t3), u = c ? gr(c[1]) : void 0, d = void 0 !== u ? u - 1 : void 0, v = void 0 !== l && void 0 !== d ? function(e3, t4, n3) {
    var r3 = e3.indexOf("\n"), o3 = 1;
    for (; o3 < t4 && -1 !== r3; ) r3 = e3.indexOf("\n", r3 + 1), o3++;
    return -1 !== r3 ? r3 + n3 + 1 : void 0;
  }(e2, l, d) : void 0;
  return { position: v, line: l, column: d, message: t3.replace(/^JSON.parse: /, "").replace(/ of the JSON data$/, "") };
}
function Yr(e2) {
  return br(e2) ? void 0 !== e2.json ? void 0 !== e2.text ? 'Content must contain either a property "json" or a property "text" but not both' : void 0 : void 0 === e2.text ? 'Content must contain either a property "json" or a property "text"' : "string" != typeof e2.text ? 'Content "text" property must be a string containing a JSON document. Did you mean to use the "json" property instead?' : void 0 : "Content must be an object";
}
function Zr(e2) {
  return br(e2) && "string" == typeof e2.text;
}
function Xr(e2) {
  return br(e2) && void 0 !== e2.json;
}
function Gr(e2) {
  var t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : void 0, n2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : JSON;
  return Zr(e2) ? e2 : { text: n2.stringify(e2.json, null, t3) };
}
function eo(e2) {
  var t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : JSON;
  return Xr(e2) ? e2 : { json: t3.parse(e2.text) };
}
function to(e2, t3, n2) {
  return Gr(e2, t3, n2).text;
}
function no(e2, t3) {
  return ro(e2, t3) > t3;
}
function ro(e2) {
  var t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1 / 0;
  if (Zr(e2)) return e2.text.length;
  var n2 = e2.json, r2 = 0;
  return function e3(n3) {
    if (Array.isArray(n3)) {
      if ((r2 += n3.length - 1 + 2) > t3) return;
      for (var o2 = 0; o2 < n3.length; o2++) {
        if (e3(n3[o2]), r2 > t3) return;
      }
    } else if (br(n3)) {
      var a2 = Object.keys(n3);
      r2 += 2 + a2.length + (a2.length - 1);
      for (var i2 = 0; i2 < a2.length; i2++) {
        var s2 = a2[i2], l = n3[s2];
        r2 += s2.length + 2, e3(l);
      }
    } else r2 += "string" == typeof n3 ? n3.length + 2 : String(n3).length;
  }(n2), r2;
}
var oo = /(position|char) (\d+)/;
var ao = /line (\d+)/;
var io = /column (\d+)/;
function so(e2, t3) {
  return e2.parse === t3.parse && e2.stringify === t3.stringify;
}
function lo(e2) {
  var t3 = e2.substring(0, 999).trim();
  return !t3.includes("\n") && go.test(t3);
}
var co;
var uo;
var vo;
var po;
var fo;
var mo;
var ho;
var go = /[,:]\S/;
function jo(e2) {
  var { escapeControlCharacters: t3, escapeUnicodeCharacters: n2 } = e2;
  return t3 ? n2 ? xo : bo : n2 ? yo : $o;
}
!function(e2) {
  e2.text = "text", e2.tree = "tree", e2.table = "table";
}(co || (co = {})), function(e2) {
  e2.after = "after", e2.inside = "inside", e2.key = "key", e2.value = "value", e2.multi = "multi", e2.text = "text";
}(uo || (uo = {})), function(e2) {
  e2.after = "after", e2.key = "key", e2.value = "value", e2.inside = "inside";
}(vo || (vo = {})), function(e2) {
  e2.info = "info", e2.warning = "warning", e2.error = "error";
}(po || (po = {})), function(e2) {
  e2.key = "key", e2.value = "value";
}(fo || (fo = {})), function(e2) {
  e2.asc = "asc", e2.desc = "desc";
}(mo || (mo = {})), function(e2) {
  e2.no = "no", e2.self = "self", e2.nextInside = "nextInside";
}(ho || (ho = {}));
var xo = { escapeValue: (e2) => wo(Oo(String(e2))), unescapeValue: (e2) => zo(Co(e2)) };
var bo = { escapeValue: (e2) => Oo(String(e2)), unescapeValue: (e2) => zo(e2) };
var yo = { escapeValue: (e2) => wo(String(e2)), unescapeValue: (e2) => Co(e2) };
var $o = { escapeValue: (e2) => String(e2), unescapeValue: (e2) => e2 };
function wo(e2) {
  return e2.replace(/[^\x20-\x7F]/g, (e3) => {
    var t3;
    return "\b" === e3 || "\f" === e3 || "\n" === e3 || "\r" === e3 || "	" === e3 ? e3 : "\\u" + ("000" + (null === (t3 = e3.codePointAt(0)) || void 0 === t3 ? void 0 : t3.toString(16))).slice(-4);
  });
}
function Co(e2) {
  return e2.replace(/\\u[a-fA-F0-9]{4}/g, (e3) => {
    try {
      var t3 = JSON.parse('"' + e3 + '"');
      return ko[t3] || t3;
    } catch (t4) {
      return e3;
    }
  });
}
var ko = { '"': '\\"', "\\": "\\\\", "\b": "\\b", "\f": "\\f", "\n": "\\n", "\r": "\\r", "	": "\\t" };
var So = { '\\"': '"', "\\\\": "\\", "\\/": "/", "\\b": "\b", "\\f": "\f", "\\n": "\n", "\\r": "\r", "\\t": "	" };
function Oo(e2) {
  return e2.replace(/["\b\f\n\r\t\\]/g, (e3) => ko[e3] || e3);
}
function zo(e2) {
  return e2.replace(/\\["bfnrt\\]/g, (e3) => So[e3] || e3);
}
function qo(e2) {
  return "string" != typeof e2 ? String(e2) : e2.endsWith("\n") ? e2 + "\n" : e2;
}
function Mo(e2, t3) {
  return Eo(e2, (e3) => e3.nodeName.toUpperCase() === t3.toUpperCase());
}
function Ro(e2, t3, n2) {
  return Eo(e2, (e3) => function(e4, t4, n3) {
    return "function" == typeof e4.getAttribute && e4.getAttribute(t4) === n3;
  }(e3, t3, n2));
}
function Eo(e2, t3) {
  return !!Po(e2, t3);
}
function Po(e2, t3) {
  for (var n2 = e2; n2 && !t3(n2); ) n2 = n2.parentNode;
  return n2;
}
function Io(e2) {
  var t3, n2;
  return null !== (t3 = null == e2 || null === (n2 = e2.ownerDocument) || void 0 === n2 ? void 0 : n2.defaultView) && void 0 !== t3 ? t3 : void 0;
}
function To(e2) {
  var t3 = Io(e2), n2 = null == t3 ? void 0 : t3.document.activeElement;
  return !!n2 && Eo(n2, (t4) => t4 === e2);
}
function Ao(e2, t3) {
  return Po(e2, (e3) => e3.nodeName === t3);
}
function No(e2) {
  return Ro(e2, "data-type", "selectable-key") ? uo.key : Ro(e2, "data-type", "selectable-value") ? uo.value : Ro(e2, "data-type", "insert-selection-area-inside") ? uo.inside : Ro(e2, "data-type", "insert-selection-area-after") ? uo.after : uo.multi;
}
function Bo(e2) {
  return encodeURIComponent(compileJSONPointer(e2));
}
function Fo(e2) {
  var t3, n2 = Po(e2, (e3) => !(null == e3 || !e3.hasAttribute) && e3.hasAttribute("data-path")), r2 = null !== (t3 = null == n2 ? void 0 : n2.getAttribute("data-path")) && void 0 !== t3 ? t3 : void 0;
  return r2 ? parseJSONPointer(decodeURIComponent(r2)) : void 0;
}
function Uo(e2) {
  var { allElements: t3, currentElement: n2, direction: r2, hasPrio: o2 = () => true, margin: a2 = 10 } = e2, i2 = map_default(t3.filter(function(e3) {
    var t4 = e3.getBoundingClientRect();
    return t4.width > 0 && t4.height > 0;
  }), l), s2 = l(n2);
  function l(e3) {
    var t4 = e3.getBoundingClientRect();
    return { x: t4.left + t4.width / 2, y: t4.top + t4.height / 2, rect: t4, element: e3 };
  }
  function c(e3, t4) {
    var n3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1, r3 = e3.x - t4.x, o3 = (e3.y - t4.y) * n3;
    return Math.sqrt(r3 * r3 + o3 * o3);
  }
  var u = (e3) => c(e3, s2);
  if ("Left" === r2 || "Right" === r2) {
    var d = "Left" === r2 ? i2.filter((e3) => {
      return t4 = s2, e3.rect.left + a2 < t4.rect.left;
      var t4;
    }) : i2.filter((e3) => {
      return t4 = s2, e3.rect.right > t4.rect.right + a2;
      var t4;
    }), v = d.filter((e3) => {
      return t4 = e3, n3 = s2, Math.abs(t4.y - n3.y) < a2;
      var t4, n3;
    }), p = minBy_default(v, u) || minBy_default(d, (e3) => c(e3, s2, 10));
    return null == p ? void 0 : p.element;
  }
  if ("Up" === r2 || "Down" === r2) {
    var f = "Up" === r2 ? i2.filter((e3) => {
      return t4 = s2, e3.y + a2 < t4.y;
      var t4;
    }) : i2.filter((e3) => {
      return t4 = s2, e3.y > t4.y + a2;
      var t4;
    }), m3 = f.filter((e3) => o2(e3.element)), h2 = minBy_default(m3, u) || minBy_default(f, u);
    return null == h2 ? void 0 : h2.element;
  }
}
function Lo() {
  var e2, t3, n2, r2;
  return "undefined" != typeof navigator && null !== (e2 = null !== (t3 = null === (n2 = navigator) || void 0 === n2 || null === (n2 = n2.platform) || void 0 === n2 ? void 0 : n2.toUpperCase().includes("MAC")) && void 0 !== t3 ? t3 : null === (r2 = navigator) || void 0 === r2 || null === (r2 = r2.userAgentData) || void 0 === r2 || null === (r2 = r2.platform) || void 0 === r2 ? void 0 : r2.toUpperCase().includes("MAC")) && void 0 !== e2 && e2;
}
function Do(e2) {
  var t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "+", n2 = [];
  Jo(e2, arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : Lo) && n2.push("Ctrl"), e2.altKey && n2.push("Alt"), e2.shiftKey && n2.push("Shift");
  var r2 = 1 === e2.key.length ? e2.key.toUpperCase() : e2.key;
  return r2 in Vo || n2.push(r2), n2.join(t3);
}
function Jo(e2) {
  var t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Lo;
  return e2.ctrlKey || e2.metaKey && t3();
}
var Vo = { Ctrl: true, Command: true, Control: true, Alt: true, Option: true, Shift: true };
var { window: Ho } = tn;
function _o(e2) {
  rn(e2, "svelte-1r8q3m8", ".jse-absolute-popup.svelte-1r8q3m8.svelte-1r8q3m8{position:relative;left:0;top:0;width:0;height:0;z-index:1001}.jse-absolute-popup.svelte-1r8q3m8 .jse-hidden-input.svelte-1r8q3m8{position:fixed;left:0;top:0;width:0;height:0;padding:0;margin:0;border:none;outline:none;overflow:hidden}.jse-absolute-popup.svelte-1r8q3m8 .jse-absolute-popup-content.svelte-1r8q3m8{position:absolute}");
}
function Wo(e2) {
  var t3, n2, r2, o2, a2, i2, s2 = [e2[0].props], l = e2[0].component;
  function c(e3, t4) {
    for (var n3 = {}, r3 = 0; r3 < s2.length; r3 += 1) n3 = Ft(n3, s2[r3]);
    return void 0 !== t4 && 1 & t4 && (n3 = Ft(n3, or(s2, [ar(e3[0].props)]))), { props: n3 };
  }
  return l && (o2 = Sn(l, c(e2))), { c() {
    t3 = ln("div"), n2 = ln("input"), r2 = dn(), o2 && sr(o2.$$.fragment), hn(n2, "type", "text"), n2.readOnly = true, hn(n2, "tabindex", "-1"), hn(n2, "class", "jse-hidden-input svelte-1r8q3m8"), hn(t3, "class", "jse-absolute-popup-content svelte-1r8q3m8"), hn(t3, "style", a2 = Ko(e2[1], e2[0].options));
  }, m(a3, s3) {
    on(a3, t3, s3), nn(t3, n2), e2[7](n2), nn(t3, r2), o2 && lr(o2, t3, null), i2 = true;
  }, p(e3, n3) {
    if (1 & n3 && l !== (l = e3[0].component)) {
      if (o2) {
        Kn();
        var r3 = o2;
        Gn(r3.$$.fragment, 1, 0, () => {
          cr(r3, 1);
        }), Zn();
      }
      l ? (sr((o2 = Sn(l, c(e3, n3))).$$.fragment), Xn(o2.$$.fragment, 1), lr(o2, t3, null)) : o2 = null;
    } else if (l) {
      var u = 1 & n3 ? or(s2, [ar(e3[0].props)]) : {};
      o2.$set(u);
    }
    (!i2 || 3 & n3 && a2 !== (a2 = Ko(e3[1], e3[0].options))) && hn(t3, "style", a2);
  }, i(e3) {
    i2 || (o2 && Xn(o2.$$.fragment, e3), i2 = true);
  }, o(e3) {
    o2 && Gn(o2.$$.fragment, e3), i2 = false;
  }, d(n3) {
    n3 && an(t3), e2[7](null), o2 && cr(o2);
  } };
}
function Qo(e2) {
  var t3, n2, r2, o2, a2 = e2[1] && Wo(e2);
  return { c() {
    t3 = ln("div"), a2 && a2.c(), hn(t3, "role", "none"), hn(t3, "class", "jse-absolute-popup svelte-1r8q3m8");
  }, m(i2, s2) {
    on(i2, t3, s2), a2 && a2.m(t3, null), e2[8](t3), n2 = true, r2 || (o2 = [pn(Ho, "mousedown", e2[3], true), pn(Ho, "keydown", e2[4], true), pn(Ho, "wheel", e2[5], true), pn(t3, "mousedown", Yo), pn(t3, "keydown", e2[4])], r2 = true);
  }, p(e3, n3) {
    var [r3] = n3;
    e3[1] ? a2 ? (a2.p(e3, r3), 2 & r3 && Xn(a2, 1)) : ((a2 = Wo(e3)).c(), Xn(a2, 1), a2.m(t3, null)) : a2 && (Kn(), Gn(a2, 1, 1, () => {
      a2 = null;
    }), Zn());
  }, i(e3) {
    n2 || (Xn(a2), n2 = true);
  }, o(e3) {
    Gn(a2), n2 = false;
  }, d(n3) {
    n3 && an(t3), a2 && a2.d(), e2[8](null), r2 = false, Dt(o2);
  } };
}
function Yo(e2) {
  e2.stopPropagation();
}
function Ko(e2, t3) {
  var n2 = e2.getBoundingClientRect(), { left: r2, top: o2, positionAbove: a2, positionLeft: i2 } = function() {
    if (t3.anchor) {
      var { anchor: e3, width: n3 = 0, height: r3 = 0, offsetTop: o3 = 0, offsetLeft: a3 = 0, position: i3 } = t3, { left: s2, top: l, bottom: c, right: u } = e3.getBoundingClientRect(), d = "top" === i3 || l + r3 > window.innerHeight && l > r3, v = "left" === i3 || s2 + n3 > window.innerWidth && s2 > n3;
      return { left: v ? u - a3 : s2 + a3, top: d ? l - o3 : c + o3, positionAbove: d, positionLeft: v };
    }
    if ("number" == typeof t3.left && "number" == typeof t3.top) {
      var { left: p, top: f, width: m3 = 0, height: h2 = 0 } = t3;
      return { left: p, top: f, positionAbove: f + h2 > window.innerHeight && f > h2, positionLeft: p + m3 > window.innerWidth && p > m3 };
    }
    throw new Error('Invalid config: pass either "left" and "top", or pass "anchor"');
  }();
  return (a2 ? "bottom: ".concat(n2.top - o2, "px;") : "top: ".concat(o2 - n2.top, "px;")) + (i2 ? "right: ".concat(n2.left - r2, "px;") : "left: ".concat(r2 - n2.left, "px;"));
}
function Zo(e2, t3, n2) {
  var r2, o2, { popup: a2 } = t3, { closeAbsolutePopup: i2 } = t3;
  function s2(e3) {
    a2.options && a2.options.closeOnOuterClick && !Eo(e3.target, (e4) => e4 === r2) && i2(a2.id);
  }
  return qn(function() {
    o2 && o2.focus();
  }), e2.$$set = (e3) => {
    "popup" in e3 && n2(0, a2 = e3.popup), "closeAbsolutePopup" in e3 && n2(6, i2 = e3.closeAbsolutePopup);
  }, [a2, r2, o2, function(e3) {
    s2(e3);
  }, function(e3) {
    "Escape" === Do(e3) && (e3.preventDefault(), e3.stopPropagation(), i2(a2.id));
  }, function(e3) {
    s2(e3);
  }, i2, function(e3) {
    Tn[e3 ? "unshift" : "push"](() => {
      n2(2, o2 = e3);
    });
  }, function(e3) {
    Tn[e3 ? "unshift" : "push"](() => {
      n2(1, r2 = e3);
    });
  }];
}
var Xo = class extends dr {
  constructor(e2) {
    super(), ur(this, e2, Zo, Qo, Vt, { popup: 0, closeAbsolutePopup: 6 }, _o);
  }
};
function Go(e2, t3, n2) {
  var r2 = e2.slice();
  return r2[6] = t3[n2], r2;
}
function ea(e2) {
  var t3, n2;
  return t3 = new Xo({ props: { popup: e2[6], closeAbsolutePopup: e2[1] } }), { c() {
    sr(t3.$$.fragment);
  }, m(e3, r2) {
    lr(t3, e3, r2), n2 = true;
  }, p(e3, n3) {
    var r2 = {};
    1 & n3 && (r2.popup = e3[6]), t3.$set(r2);
  }, i(e3) {
    n2 || (Xn(t3.$$.fragment, e3), n2 = true);
  }, o(e3) {
    Gn(t3.$$.fragment, e3), n2 = false;
  }, d(e3) {
    cr(t3, e3);
  } };
}
function ta(e2) {
  for (var t3, n2, r2 = er(e2[0]), o2 = [], a2 = 0; a2 < r2.length; a2 += 1) o2[a2] = ea(Go(e2, r2, a2));
  var i2 = (e3) => Gn(o2[e3], 1, 1, () => {
    o2[e3] = null;
  }), s2 = e2[3].default, l = _t(s2, e2, e2[2], null);
  return { c() {
    for (var e3 = 0; e3 < o2.length; e3 += 1) o2[e3].c();
    t3 = dn(), l && l.c();
  }, m(e3, r3) {
    for (var a3 = 0; a3 < o2.length; a3 += 1) o2[a3] && o2[a3].m(e3, r3);
    on(e3, t3, r3), l && l.m(e3, r3), n2 = true;
  }, p(e3, a3) {
    var [c] = a3;
    if (3 & c) {
      var u;
      for (r2 = er(e3[0]), u = 0; u < r2.length; u += 1) {
        var d = Go(e3, r2, u);
        o2[u] ? (o2[u].p(d, c), Xn(o2[u], 1)) : (o2[u] = ea(d), o2[u].c(), Xn(o2[u], 1), o2[u].m(t3.parentNode, t3));
      }
      for (Kn(), u = r2.length; u < o2.length; u += 1) i2(u);
      Zn();
    }
    l && l.p && (!n2 || 4 & c) && Yt(l, s2, e3, e3[2], n2 ? Qt(s2, e3[2], c, null) : Kt(e3[2]), null);
  }, i(e3) {
    if (!n2) {
      for (var t4 = 0; t4 < r2.length; t4 += 1) Xn(o2[t4]);
      Xn(l, e3), n2 = true;
    }
  }, o(e3) {
    o2 = o2.filter(Boolean);
    for (var t4 = 0; t4 < o2.length; t4 += 1) Gn(o2[t4]);
    Gn(l, e3), n2 = false;
  }, d(e3) {
    e3 && an(t3), sn(o2, e3), l && l.d(e3);
  } };
}
function na(e2, t3, n2) {
  var r2, o2, { $$slots: a2 = {}, $$scope: i2 } = t3, s2 = vr("jsoneditor:AbsolutePopup"), l = [];
  function c(e3) {
    var t4 = l.findIndex((t5) => t5.id === e3);
    if (-1 !== t4) {
      var r3 = l[t4];
      r3.options.onClose && r3.options.onClose(), n2(0, l = l.filter((t5) => t5.id !== e3));
    }
  }
  return r2 = "absolute-popup", o2 = { openAbsolutePopup: function(e3, t4, r3) {
    s2("open...", t4, r3);
    var o3 = { id: hr(), component: e3, props: t4 || {}, options: r3 || {} };
    return n2(0, l = [...l, o3]), o3.id;
  }, closeAbsolutePopup: c }, zn().$$.context.set(r2, o2), e2.$$set = (e3) => {
    "$$scope" in e3 && n2(2, i2 = e3.$$scope);
  }, e2.$$.update = () => {
    1 & e2.$$.dirty && s2("popups", l);
  }, [l, c, i2, a2];
}
var ra = class extends dr {
  constructor(e2) {
    super(), ur(this, e2, na, ta, Ht, {});
  }
};
function oa(e2, t3) {
  for (var n2 = new Set(t3), r2 = e2.replace(/ \(copy( \d+)?\)$/, ""), o2 = e2, a2 = 1; n2.has(o2); ) {
    var i2 = "copy" + (a2 > 1 ? " " + a2 : "");
    o2 = "".concat(r2, " (").concat(i2, ")"), a2++;
  }
  return o2;
}
function aa(e2, t3) {
  var n2 = t3 - 3;
  return e2.length > t3 ? e2.substring(0, n2) + "..." : e2;
}
function ia(e2) {
  if ("" === e2) return "";
  var t3 = e2.toLowerCase();
  if ("null" === t3) return null;
  if ("true" === t3) return true;
  if ("false" === t3) return false;
  if ("undefined" !== t3) {
    var n2 = Number(e2), r2 = parseFloat(e2);
    return isNaN(n2) || isNaN(r2) ? e2 : n2;
  }
}
var sa = { id: "jsonquery", name: "JSONQuery", description: '\n<p>\n  Enter a <a href="https://jsonquerylang.org" target="_blank" \n  rel="noopener noreferrer">JSON Query</a> function to filter, sort, or transform the data.\n  You can use functions like <code>get</code>, <code>filter</code>,\n  <code>sort</code>, <code>pick</code>, <code>groupBy</code>, <code>uniq</code>, etcetera. \n  Example query: <code>filter(.age >= 18)</code>\n</p>\n', createQuery: function(e2, t3) {
  var { filter: n2, sort: r2, projection: o2 } = t3, a2 = [];
  n2 && n2.path && n2.relation && n2.value && a2.push(["filter", [(i2 = n2.relation, M("1 ".concat(i2, " 1"))[0]), la(n2.path), ia(n2.value)]]);
  var i2;
  r2 && r2.path && r2.direction && a2.push(["sort", la(r2.path), "desc" === r2.direction ? "desc" : "asc"]);
  o2 && o2.paths && (o2.paths.length > 1 ? a2.push(["pick", ...o2.paths.map(la)]) : a2.push(["map", la(o2.paths[0])]));
  return D(["pipe", ...a2]);
}, executeQuery: function(e2, t3) {
  return "" !== t3.trim() ? K(e2, t3) : e2;
} };
function la(e2) {
  return ["get", ...e2];
}
function ca(e2) {
  var t3;
  return { c() {
    t3 = cn("g");
  }, m(n2, r2) {
    on(n2, t3, r2), t3.innerHTML = e2[0];
  }, p(e3, n2) {
    var [r2] = n2;
    1 & r2 && (t3.innerHTML = e3[0]);
  }, i: Bt, o: Bt, d(e3) {
    e3 && an(t3);
  } };
}
function ua(e2, t3, n2) {
  var r2 = 870711;
  var o2 = "", { data: a2 } = t3;
  function i2(e3) {
    if (!e3 || !e3.raw) return "";
    var t4 = e3.raw, n3 = {};
    return t4 = t4.replace(/\s(?:xml:)?id=["']?([^"')\s]+)/g, (e4, t5) => {
      var o3 = "fa-".concat((r2 += 1).toString(16));
      return n3[t5] = o3, ' id="'.concat(o3, '"');
    }), t4 = t4.replace(/#(?:([^'")\s]+)|xpointer\(id\((['"]?)([^')]+)\2\)\))/g, (e4, t5, r3, o3) => {
      var a3 = t5 || o3;
      return a3 && n3[a3] ? "#".concat(n3[a3]) : e4;
    }), t4;
  }
  return e2.$$set = (e3) => {
    "data" in e3 && n2(1, a2 = e3.data);
  }, e2.$$.update = () => {
    2 & e2.$$.dirty && n2(0, o2 = i2(a2));
  }, [o2, a2];
}
var da = class extends dr {
  constructor(e2) {
    super(), ur(this, e2, ua, ca, Vt, { data: 1 });
  }
};
function va(e2) {
  rn(e2, "svelte-1mc5hvj", ".fa-icon.svelte-1mc5hvj{display:inline-block;fill:currentColor}.fa-flip-horizontal.svelte-1mc5hvj{transform:scale(-1, 1)}.fa-flip-vertical.svelte-1mc5hvj{transform:scale(1, -1)}.fa-spin.svelte-1mc5hvj{animation:svelte-1mc5hvj-fa-spin 1s 0s infinite linear}.fa-inverse.svelte-1mc5hvj{color:#fff}.fa-pulse.svelte-1mc5hvj{animation:svelte-1mc5hvj-fa-spin 1s infinite steps(8)}@keyframes svelte-1mc5hvj-fa-spin{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}");
}
function pa(e2) {
  for (var t3, n2, r2, o2, a2 = e2[12].default, i2 = _t(a2, e2, e2[11], null), s2 = [{ version: "1.1" }, { class: n2 = "fa-icon " + e2[0] }, { width: e2[1] }, { height: e2[2] }, { "aria-label": e2[9] }, { role: r2 = e2[9] ? "img" : "presentation" }, { viewBox: e2[3] }, { style: e2[8] }, e2[10]], l = {}, c = 0; c < s2.length; c += 1) l = Ft(l, s2[c]);
  return { c() {
    t3 = cn("svg"), i2 && i2.c(), bn(t3, l), kn(t3, "fa-spin", e2[4]), kn(t3, "fa-pulse", e2[6]), kn(t3, "fa-inverse", e2[5]), kn(t3, "fa-flip-horizontal", "horizontal" === e2[7]), kn(t3, "fa-flip-vertical", "vertical" === e2[7]), kn(t3, "svelte-1mc5hvj", true);
  }, m(e3, n3) {
    on(e3, t3, n3), i2 && i2.m(t3, null), o2 = true;
  }, p(e3, c2) {
    var [u] = c2;
    i2 && i2.p && (!o2 || 2048 & u) && Yt(i2, a2, e3, e3[11], o2 ? Qt(a2, e3[11], u, null) : Kt(e3[11]), null), bn(t3, l = or(s2, [{ version: "1.1" }, (!o2 || 1 & u && n2 !== (n2 = "fa-icon " + e3[0])) && { class: n2 }, (!o2 || 2 & u) && { width: e3[1] }, (!o2 || 4 & u) && { height: e3[2] }, (!o2 || 512 & u) && { "aria-label": e3[9] }, (!o2 || 512 & u && r2 !== (r2 = e3[9] ? "img" : "presentation")) && { role: r2 }, (!o2 || 8 & u) && { viewBox: e3[3] }, (!o2 || 256 & u) && { style: e3[8] }, 1024 & u && e3[10]])), kn(t3, "fa-spin", e3[4]), kn(t3, "fa-pulse", e3[6]), kn(t3, "fa-inverse", e3[5]), kn(t3, "fa-flip-horizontal", "horizontal" === e3[7]), kn(t3, "fa-flip-vertical", "vertical" === e3[7]), kn(t3, "svelte-1mc5hvj", true);
  }, i(e3) {
    o2 || (Xn(i2, e3), o2 = true);
  }, o(e3) {
    Gn(i2, e3), o2 = false;
  }, d(e3) {
    e3 && an(t3), i2 && i2.d(e3);
  } };
}
function fa(e2, t3, n2) {
  var r2 = ["class", "width", "height", "box", "spin", "inverse", "pulse", "flip", "style", "label"], o2 = Xt(t3, r2), { $$slots: a2 = {}, $$scope: i2 } = t3, { class: s2 = "" } = t3, { width: l } = t3, { height: c } = t3, { box: u = "0 0 0 0" } = t3, { spin: d = false } = t3, { inverse: v = false } = t3, { pulse: p = false } = t3, { flip: f = "none" } = t3, { style: m3 = "" } = t3, { label: h2 = "" } = t3;
  return e2.$$set = (e3) => {
    t3 = Ft(Ft({}, t3), Zt(e3)), n2(10, o2 = Xt(t3, r2)), "class" in e3 && n2(0, s2 = e3.class), "width" in e3 && n2(1, l = e3.width), "height" in e3 && n2(2, c = e3.height), "box" in e3 && n2(3, u = e3.box), "spin" in e3 && n2(4, d = e3.spin), "inverse" in e3 && n2(5, v = e3.inverse), "pulse" in e3 && n2(6, p = e3.pulse), "flip" in e3 && n2(7, f = e3.flip), "style" in e3 && n2(8, m3 = e3.style), "label" in e3 && n2(9, h2 = e3.label), "$$scope" in e3 && n2(11, i2 = e3.$$scope);
  }, [s2, l, c, u, d, v, p, f, m3, h2, o2, i2, a2];
}
var ma = class extends dr {
  constructor(e2) {
    super(), ur(this, e2, fa, pa, Vt, { class: 0, width: 1, height: 2, box: 3, spin: 4, inverse: 5, pulse: 6, flip: 7, style: 8, label: 9 }, va);
  }
};
function ha(e2, t3, n2) {
  var r2 = e2.slice();
  return r2[24] = t3[n2], r2;
}
function ga(e2, t3, n2) {
  var r2 = e2.slice();
  return r2[27] = t3[n2], r2;
}
function ja(e2) {
  for (var t3, n2 = [e2[27]], r2 = {}, o2 = 0; o2 < n2.length; o2 += 1) r2 = Ft(r2, n2[o2]);
  return { c() {
    bn(t3 = cn("path"), r2);
  }, m(e3, n3) {
    on(e3, t3, n3);
  }, p(e3, o3) {
    bn(t3, r2 = or(n2, [64 & o3 && e3[27]]));
  }, d(e3) {
    e3 && an(t3);
  } };
}
function xa(e2) {
  for (var t3, n2 = [e2[24]], r2 = {}, o2 = 0; o2 < n2.length; o2 += 1) r2 = Ft(r2, n2[o2]);
  return { c() {
    bn(t3 = cn("polygon"), r2);
  }, m(e3, n3) {
    on(e3, t3, n3);
  }, p(e3, o3) {
    bn(t3, r2 = or(n2, [64 & o3 && e3[24]]));
  }, d(e3) {
    e3 && an(t3);
  } };
}
function ba(e2) {
  var t3, n2, r2;
  function o2(t4) {
    e2[16](t4);
  }
  var a2 = {};
  return void 0 !== e2[6] && (a2.data = e2[6]), t3 = new da({ props: a2 }), Tn.push(() => ir(t3, "data", o2)), { c() {
    sr(t3.$$.fragment);
  }, m(e3, n3) {
    lr(t3, e3, n3), r2 = true;
  }, p(e3, r3) {
    var o3 = {};
    !n2 && 64 & r3 && (n2 = true, o3.data = e3[6], Jn(() => n2 = false)), t3.$set(o3);
  }, i(e3) {
    r2 || (Xn(t3.$$.fragment, e3), r2 = true);
  }, o(e3) {
    Gn(t3.$$.fragment, e3), r2 = false;
  }, d(e3) {
    cr(t3, e3);
  } };
}
function ya(e2) {
  var t3, n2 = e2[15].default, r2 = _t(n2, e2, e2[17], null), o2 = r2 || function(e3) {
    for (var t4, n3, r3, o3, a2, i2, s2, l = er((null === (t4 = e3[6]) || void 0 === t4 ? void 0 : t4.paths) || []), c = [], u = 0; u < l.length; u += 1) c[u] = ja(ga(e3, l, u));
    for (var d = er((null === (n3 = e3[6]) || void 0 === n3 ? void 0 : n3.polygons) || []), v = [], p = 0; p < d.length; p += 1) v[p] = xa(ha(e3, d, p));
    var f = (null === (r3 = e3[6]) || void 0 === r3 ? void 0 : r3.raw) && ba(e3);
    return { c() {
      for (var e4 = 0; e4 < c.length; e4 += 1) c[e4].c();
      o3 = dn();
      for (var t5 = 0; t5 < v.length; t5 += 1) v[t5].c();
      a2 = dn(), f && f.c(), i2 = vn();
    }, m(e4, t5) {
      for (var n4 = 0; n4 < c.length; n4 += 1) c[n4] && c[n4].m(e4, t5);
      on(e4, o3, t5);
      for (var r4 = 0; r4 < v.length; r4 += 1) v[r4] && v[r4].m(e4, t5);
      on(e4, a2, t5), f && f.m(e4, t5), on(e4, i2, t5), s2 = true;
    }, p(e4, t5) {
      var n4;
      if (64 & t5) {
        var r4, s3;
        for (l = er((null === (r4 = e4[6]) || void 0 === r4 ? void 0 : r4.paths) || []), s3 = 0; s3 < l.length; s3 += 1) {
          var u2 = ga(e4, l, s3);
          c[s3] ? c[s3].p(u2, t5) : (c[s3] = ja(u2), c[s3].c(), c[s3].m(o3.parentNode, o3));
        }
        for (; s3 < c.length; s3 += 1) c[s3].d(1);
        c.length = l.length;
      }
      if (64 & t5) {
        var p2, m3;
        for (d = er((null === (p2 = e4[6]) || void 0 === p2 ? void 0 : p2.polygons) || []), m3 = 0; m3 < d.length; m3 += 1) {
          var h2 = ha(e4, d, m3);
          v[m3] ? v[m3].p(h2, t5) : (v[m3] = xa(h2), v[m3].c(), v[m3].m(a2.parentNode, a2));
        }
        for (; m3 < v.length; m3 += 1) v[m3].d(1);
        v.length = d.length;
      }
      null !== (n4 = e4[6]) && void 0 !== n4 && n4.raw ? f ? (f.p(e4, t5), 64 & t5 && Xn(f, 1)) : ((f = ba(e4)).c(), Xn(f, 1), f.m(i2.parentNode, i2)) : f && (Kn(), Gn(f, 1, 1, () => {
        f = null;
      }), Zn());
    }, i(e4) {
      s2 || (Xn(f), s2 = true);
    }, o(e4) {
      Gn(f), s2 = false;
    }, d(e4) {
      e4 && (an(o3), an(a2), an(i2)), sn(c, e4), sn(v, e4), f && f.d(e4);
    } };
  }(e2);
  return { c() {
    o2 && o2.c();
  }, m(e3, n3) {
    o2 && o2.m(e3, n3), t3 = true;
  }, p(e3, a2) {
    r2 ? r2.p && (!t3 || 131072 & a2) && Yt(r2, n2, e3, e3[17], t3 ? Qt(n2, e3[17], a2, null) : Kt(e3[17]), null) : o2 && o2.p && (!t3 || 64 & a2) && o2.p(e3, t3 ? a2 : -1);
  }, i(e3) {
    t3 || (Xn(o2, e3), t3 = true);
  }, o(e3) {
    Gn(o2, e3), t3 = false;
  }, d(e3) {
    o2 && o2.d(e3);
  } };
}
function $a(e2) {
  for (var t3, n2, r2 = [{ label: e2[5] }, { width: e2[7] }, { height: e2[8] }, { box: e2[10] }, { style: e2[9] }, { spin: e2[1] }, { flip: e2[4] }, { inverse: e2[2] }, { pulse: e2[3] }, { class: e2[0] }, e2[11]], o2 = { $$slots: { default: [ya] }, $$scope: { ctx: e2 } }, a2 = 0; a2 < r2.length; a2 += 1) o2 = Ft(o2, r2[a2]);
  return t3 = new ma({ props: o2 }), { c() {
    sr(t3.$$.fragment);
  }, m(e3, r3) {
    lr(t3, e3, r3), n2 = true;
  }, p(e3, n3) {
    var [o3] = n3, a3 = 4031 & o3 ? or(r2, [32 & o3 && { label: e3[5] }, 128 & o3 && { width: e3[7] }, 256 & o3 && { height: e3[8] }, 1024 & o3 && { box: e3[10] }, 512 & o3 && { style: e3[9] }, 2 & o3 && { spin: e3[1] }, 16 & o3 && { flip: e3[4] }, 4 & o3 && { inverse: e3[2] }, 8 & o3 && { pulse: e3[3] }, 1 & o3 && { class: e3[0] }, 2048 & o3 && ar(e3[11])]) : {};
    131136 & o3 && (a3.$$scope = { dirty: o3, ctx: e3 }), t3.$set(a3);
  }, i(e3) {
    n2 || (Xn(t3.$$.fragment, e3), n2 = true);
  }, o(e3) {
    Gn(t3.$$.fragment, e3), n2 = false;
  }, d(e3) {
    cr(t3, e3);
  } };
}
function wa(e2, t3, n2) {
  var r2, o2, a2, i2 = ["class", "data", "scale", "spin", "inverse", "pulse", "flip", "label", "style"], s2 = Xt(t3, i2), { $$slots: l = {}, $$scope: c } = t3, { class: u = "" } = t3, { data: d } = t3, { scale: v = 1 } = t3, { spin: p = false } = t3, { inverse: f = false } = t3, { pulse: m3 = false } = t3, { flip: h2 } = t3, { label: g = "" } = t3, { style: j = "" } = t3, x = 10, b2 = 10;
  function y() {
    var e3 = 1;
    return void 0 !== v && (e3 = Number(v)), isNaN(e3) || e3 <= 0 ? (console.warn('Invalid prop: prop "scale" should be a number over 0.'), 1) : 1 * e3;
  }
  function $2() {
    return r2 ? Math.max(r2.width, r2.height) / 16 : 1;
  }
  return e2.$$set = (e3) => {
    t3 = Ft(Ft({}, t3), Zt(e3)), n2(11, s2 = Xt(t3, i2)), "class" in e3 && n2(0, u = e3.class), "data" in e3 && n2(12, d = e3.data), "scale" in e3 && n2(13, v = e3.scale), "spin" in e3 && n2(1, p = e3.spin), "inverse" in e3 && n2(2, f = e3.inverse), "pulse" in e3 && n2(3, m3 = e3.pulse), "flip" in e3 && n2(4, h2 = e3.flip), "label" in e3 && n2(5, g = e3.label), "style" in e3 && n2(14, j = e3.style), "$$scope" in e3 && n2(17, c = e3.$$scope);
  }, e2.$$.update = () => {
    28672 & e2.$$.dirty && (n2(6, r2 = function(e3) {
      var t4;
      if (e3) {
        if (!("definition" in e3)) {
          if ("iconName" in e3 && "icon" in e3) {
            e3.iconName;
            var [n3, r3, , , o3] = e3.icon;
            t4 = { width: n3, height: r3, paths: (Array.isArray(o3) ? o3 : [o3]).map((e4) => ({ d: e4 })) };
          } else t4 = e3[Object.keys(e3)[0]];
          return t4;
        }
        console.error("`import faIconName from '@fortawesome/package-name/faIconName` not supported - Please use `import { faIconName } from '@fortawesome/package-name/faIconName'` instead");
      }
    }(d)), n2(7, x = r2 ? r2.width / $2() * y() : 0), n2(8, b2 = r2 ? r2.height / $2() * y() : 0), n2(9, o2 = function() {
      var e3 = "";
      null !== j && (e3 += j);
      var t4 = y();
      return 1 === t4 ? 0 === e3.length ? "" : e3 : ("" === e3 || e3.endsWith(";") || (e3 += "; "), "".concat(e3, "font-size: ").concat(t4, "em"));
    }()), n2(10, a2 = r2 ? "0 0 ".concat(r2.width, " ").concat(r2.height) : "0 0 ".concat(x, " ").concat(b2)));
  }, [u, p, f, m3, h2, g, r2, x, b2, o2, a2, s2, d, v, j, l, function(e3) {
    n2(6, r2 = e3), n2(12, d), n2(14, j), n2(13, v);
  }, c];
}
var Ca = class extends dr {
  constructor(e2) {
    super(), ur(this, e2, wa, $a, Vt, { class: 0, data: 12, scale: 13, spin: 1, inverse: 2, pulse: 3, flip: 4, label: 5, style: 14 });
  }
};
function ka(e2) {
  rn(e2, "svelte-1ryp01u", ".jse-boolean-toggle.svelte-1ryp01u{padding:0;margin:1px 0 0;vertical-align:top;display:inline-flex;color:var(--jse-value-color-boolean, #ff8c00)}.jse-boolean-toggle.svelte-1ryp01u:not(.jse-readonly){cursor:pointer}");
}
function Sa(e2) {
  var t3, n2, r2, o2, a2, i2, s2;
  return n2 = new Ca({ props: { data: true === e2[0] ? faCheckSquare : faSquare } }), { c() {
    t3 = ln("div"), sr(n2.$$.fragment), hn(t3, "role", "checkbox"), hn(t3, "tabindex", "-1"), hn(t3, "aria-checked", r2 = true === e2[0]), hn(t3, "class", "jse-boolean-toggle svelte-1ryp01u"), hn(t3, "title", o2 = e2[1] ? "Boolean value ".concat(e2[0]) : "Click to toggle this boolean value"), kn(t3, "jse-readonly", e2[1]);
  }, m(r3, o3) {
    on(r3, t3, o3), lr(n2, t3, null), a2 = true, i2 || (s2 = pn(t3, "mousedown", e2[2]), i2 = true);
  }, p(e3, i3) {
    var [s3] = i3, l = {};
    1 & s3 && (l.data = true === e3[0] ? faCheckSquare : faSquare), n2.$set(l), (!a2 || 1 & s3 && r2 !== (r2 = true === e3[0])) && hn(t3, "aria-checked", r2), (!a2 || 3 & s3 && o2 !== (o2 = e3[1] ? "Boolean value ".concat(e3[0]) : "Click to toggle this boolean value")) && hn(t3, "title", o2), (!a2 || 2 & s3) && kn(t3, "jse-readonly", e3[1]);
  }, i(e3) {
    a2 || (Xn(n2.$$.fragment, e3), a2 = true);
  }, o(e3) {
    Gn(n2.$$.fragment, e3), a2 = false;
  }, d(e3) {
    e3 && an(t3), cr(n2), i2 = false, s2();
  } };
}
function Oa(e2, t3, n2) {
  var { path: r2 } = t3, { value: o2 } = t3, { readOnly: a2 } = t3, { onPatch: i2 } = t3, { focus: s2 } = t3;
  return e2.$$set = (e3) => {
    "path" in e3 && n2(3, r2 = e3.path), "value" in e3 && n2(0, o2 = e3.value), "readOnly" in e3 && n2(1, a2 = e3.readOnly), "onPatch" in e3 && n2(4, i2 = e3.onPatch), "focus" in e3 && n2(5, s2 = e3.focus);
  }, [o2, a2, function(e3) {
    e3.stopPropagation(), a2 || (i2([{ op: "replace", path: compileJSONPointer(r2), value: !o2 }]), s2());
  }, r2, i2, s2];
}
var za = class extends dr {
  constructor(e2) {
    super(), ur(this, e2, Oa, Sa, Ht, { path: 3, value: 0, readOnly: 1, onPatch: 4, focus: 5 }, ka);
  }
};
function qa(e2) {
  rn(e2, "svelte-s1wu8v", ".jse-color-picker-popup.svelte-s1wu8v .picker_wrapper.popup,.jse-color-picker-popup.svelte-s1wu8v .picker_wrapper.popup .picker_arrow::before,.jse-color-picker-popup.svelte-s1wu8v .picker_wrapper.popup .picker_arrow::after{background:var(--jse-color-picker-background, var(--jse-panel-background, #ebebeb));line-height:normal}.jse-color-picker-popup.svelte-s1wu8v .picker_slider,.jse-color-picker-popup.svelte-s1wu8v .picker_sl,.jse-color-picker-popup.svelte-s1wu8v .picker_editor input,.jse-color-picker-popup.svelte-s1wu8v .picker_sample,.jse-color-picker-popup.svelte-s1wu8v .picker_done button{box-shadow:var(--jse-color-picker-border-box-shadow, #cbcbcb 0 0 0 1px)}.jse-color-picker-popup.svelte-s1wu8v .picker_editor input{background:var(--jse-background-color, #fff);color:var(--jse-text-color, #4d4d4d)}.jse-color-picker-popup.svelte-s1wu8v .picker_done button{background:var(--jse-button-background, #e0e0e0);color:var(--jse-button-color, var(--jse-text-color, #4d4d4d))}.jse-color-picker-popup.svelte-s1wu8v .picker_done button:hover{background:var(--jse-button-background-highlight, #e7e7e7)}");
}
function Ma(e2) {
  var t3;
  return { c() {
    hn(t3 = ln("div"), "class", "jse-color-picker-popup svelte-s1wu8v");
  }, m(n2, r2) {
    on(n2, t3, r2), e2[4](t3);
  }, p: Bt, i: Bt, o: Bt, d(n2) {
    n2 && an(t3), e2[4](null);
  } };
}
function Ra(e2, t3, n2) {
  var r2, { color: a2 } = t3, { onChange: i2 } = t3, { showOnTop: s2 } = t3, l = () => {
  };
  return qn(o(function* () {
    var e3, t4 = new (null === (e3 = yield import("./vanilla-picker-JXDTFP2B.js")) || void 0 === e3 ? void 0 : e3.default)({ parent: r2, color: a2, popup: s2 ? "top" : "bottom", onDone(e4) {
      var t5 = 1 === e4.rgba[3] ? e4.hex.substring(0, 7) : e4.hex;
      i2(t5);
    } });
    t4.show(), l = () => {
      t4.destroy();
    };
  })), Mn(() => {
    l();
  }), e2.$$set = (e3) => {
    "color" in e3 && n2(1, a2 = e3.color), "onChange" in e3 && n2(2, i2 = e3.onChange), "showOnTop" in e3 && n2(3, s2 = e3.showOnTop);
  }, [r2, a2, i2, s2, function(e3) {
    Tn[e3 ? "unshift" : "push"](() => {
      n2(0, r2 = e3);
    });
  }];
}
var Ea = class extends dr {
  constructor(e2) {
    super(), ur(this, e2, Ra, Ma, Vt, { color: 1, onChange: 2, showOnTop: 3 }, qa);
  }
};
function Pa(e2) {
  rn(e2, "svelte-xeg9n6", ".jse-color-picker-button.svelte-xeg9n6{font-size:var(--jse-font-size-mono, 14px);width:var(--jse-color-picker-button-size, 1em);height:var(--jse-color-picker-button-size, 1em);box-sizing:border-box;padding:0;margin:2px 0 0 calc(0.5 * var(--jse-padding, 10px));display:inline-flex;vertical-align:top;border:1px solid var(--jse-text-color, #4d4d4d);border-radius:2px;background:inherit;outline:none}.jse-color-picker-button.svelte-xeg9n6:not(.jse-readonly){cursor:pointer}");
}
function Ia(e2) {
  var t3, n2, r2, o2;
  return { c() {
    hn(t3 = ln("button"), "type", "button"), hn(t3, "class", "jse-color-picker-button svelte-xeg9n6"), wn(t3, "background", e2[2]), hn(t3, "title", n2 = e2[1] ? "Color ".concat(e2[0]) : "Click to open a color picker"), kn(t3, "jse-readonly", e2[1]);
  }, m(n3, a2) {
    on(n3, t3, a2), r2 || (o2 = pn(t3, "click", e2[3]), r2 = true);
  }, p(e3, r3) {
    var [o3] = r3;
    4 & o3 && wn(t3, "background", e3[2]), 3 & o3 && n2 !== (n2 = e3[1] ? "Color ".concat(e3[0]) : "Click to open a color picker") && hn(t3, "title", n2), 2 & o3 && kn(t3, "jse-readonly", e3[1]);
  }, i: Bt, o: Bt, d(e3) {
    e3 && an(t3), r2 = false, o2();
  } };
}
function Ta(e2, t3, n2) {
  var r2, { openAbsolutePopup: o2 } = En("absolute-popup"), { path: a2 } = t3, { value: i2 } = t3, { readOnly: s2 } = t3, { onPatch: l } = t3, { focus: u } = t3;
  function d(e3) {
    l([{ op: "replace", path: compileJSONPointer(a2), value: e3 }]), v();
  }
  function v() {
    u();
  }
  return e2.$$set = (e3) => {
    "path" in e3 && n2(4, a2 = e3.path), "value" in e3 && n2(0, i2 = e3.value), "readOnly" in e3 && n2(1, s2 = e3.readOnly), "onPatch" in e3 && n2(5, l = e3.onPatch), "focus" in e3 && n2(6, u = e3.focus);
  }, e2.$$.update = () => {
    1 & e2.$$.dirty && n2(2, r2 = Cr(i2));
  }, [i2, s2, r2, function(e3) {
    var t4, n3;
    if (!s2) {
      var r3 = e3.target, a3 = r3.getBoundingClientRect().top, l2 = null !== (t4 = null === (n3 = Io(r3)) || void 0 === n3 ? void 0 : n3.innerHeight) && void 0 !== t4 ? t4 : 0;
      o2(Ea, { color: i2, onChange: d, showOnTop: l2 - a3 < 300 && a3 > 300 }, { anchor: r3, closeOnOuterClick: true, onClose: v, offsetTop: 18, offsetLeft: -8, height: 300 });
    }
  }, a2, l, u];
}
var Aa = class extends dr {
  constructor(e2) {
    super(), ur(this, e2, Ta, Ia, Ht, { path: 4, value: 0, readOnly: 1, onPatch: 5, focus: 6 }, Pa);
  }
};
var Na = 50;
var Ba = 200;
var Fa = 400;
var Ua = 1200;
var La = 1e3;
var Da = 100;
var Ja = 100;
var Va = 2e4;
var Ha = [{ start: 0, end: Da }];
var _a2 = 104857600;
var Wa = 1048576;
var Qa = 10485760;
var Ya = 10240;
var Ka = "Insert or paste contents, enter [ insert a new array, enter { to insert a new object, or start typing to insert a new value";
var Za = "Open context menu (Click here, right click on the selection, or use the context menu button or Ctrl+Q)";
var Xa = "hover-insert-inside";
var Ga = "hover-insert-after";
var ei = "hover-collection";
var ti = "valid";
var ni = "repairable";
var ri = 336;
var oi = 260;
var ai = 100;
var ii = { [mo.asc]: "ascending", [mo.desc]: "descending" };
function si(e2) {
  for (var t3 = sortBy_default(e2, (e3) => e3.start), n2 = [t3[0]], r2 = 0; r2 < t3.length; r2++) {
    var o2 = n2.length - 1, a2 = n2[o2], i2 = t3[r2];
    i2.start <= a2.end ? n2[o2] = { start: Math.min(a2.start, i2.start), end: Math.max(a2.end, i2.end) } : n2.push(i2);
  }
  return n2;
}
function li(e2) {
  return ci(e2) + Da;
}
function ci(e2) {
  return Math.floor(e2 / Da) * Da;
}
function ui(e2) {
  return !!e2 && ("space" === e2.type || true === e2.space);
}
function di(e2) {
  return !!e2 && ("separator" === e2.type || true === e2.separator);
}
function vi(e2) {
  return !!e2 && ("label" === e2.type && "string" == typeof e2.text);
}
function pi(e2) {
  return !!e2 && "function" == typeof e2.onClick;
}
function fi(e2) {
  return !!e2 && ("dropdown-button" === e2.type && pi(e2.main) && Array.isArray(e2.items));
}
function mi(e2) {
  return !!e2 && ("row" === e2.type && Array.isArray(e2.items));
}
function hi(e2) {
  return !!e2 && ("column" === e2.type && Array.isArray(e2.items));
}
function gi(e2) {
  return br(e2) && br(e2.parseError);
}
function ji(e2) {
  return br(e2) && Array.isArray(e2.validationErrors);
}
function xi(e2) {
  return br(e2) && Array.isArray(e2.path) && "string" == typeof e2.message && "severity" in e2;
}
function bi(e2) {
  return br(e2) && xi(e2) && "boolean" == typeof e2.isChildError;
}
function $i(e2) {
  return br(e2) && "function" == typeof e2.action && br(e2.props);
}
function wi(e2) {
  return void 0 !== e2 && "object" === e2.type;
}
function Ci(e2) {
  return void 0 !== e2 && "array" === e2.type;
}
function ki(e2) {
  return void 0 !== e2 && "value" === e2.type;
}
function Si(e2) {
  return wi(e2) || Ci(e2);
}
function Oi(e2) {
  return void 0 !== e2 && Array.isArray(e2.searchResults);
}
function zi(e2) {
  var { json: t3, expand: n2 } = e2, r2 = function(e3) {
    var { json: t4, factory: n3 } = e3;
    return Array.isArray(t4) ? n3.createArrayDocumentState() : br(t4) ? n3.createObjectDocumentState() : void 0 !== t4 ? n3.createValueDocumentState() : void 0;
  }({ json: t3, factory: Ri });
  return n2 && r2 && (r2 = Ni(t3, r2, [], n2)), r2;
}
function qi() {
  var { expanded: e2 } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : { expanded: false };
  return { type: "array", expanded: e2, visibleSections: Ha, items: [] };
}
function Mi() {
  var { expanded: e2 } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : { expanded: false };
  return { type: "object", expanded: e2, properties: {} };
}
var Ri = { createObjectDocumentState: Mi, createArrayDocumentState: qi, createValueDocumentState: function() {
  return { type: "value" };
} };
function Ei(e2, t3, n2, r2) {
  var { createObjectDocumentState: o2, createArrayDocumentState: a2, createValueDocumentState: i2 } = r2;
  return function e3(t4, n3, r3) {
    if (Array.isArray(t4)) {
      var s2 = Ci(n3) ? n3 : a2();
      if (0 === r3.length) return s2;
      var l = gr(r3[0]), c = e3(t4[l], s2.items[l], r3.slice(1));
      return setIn(s2, ["items", r3[0]], c);
    }
    if (br(t4)) {
      var u = wi(n3) ? n3 : o2();
      if (0 === r3.length) return u;
      var d = r3[0], p = e3(t4[d], u.properties[d], r3.slice(1));
      return setIn(u, ["properties", d], p);
    }
    return ki(n3) ? n3 : i2();
  }(e2, t3, n2);
}
function Pi(e2, t3) {
  return Ii(e2, t3, arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : [], (e3, t4) => {
    if (void 0 !== e3 && void 0 !== t4) return Array.isArray(e3) ? Ci(t4) ? t4 : qi({ expanded: !!Si(t4) && t4.expanded }) : br(e3) ? wi(t4) ? t4 : Mi({ expanded: !!Si(t4) && t4.expanded }) : ki(t4) ? t4 : void 0;
  }, () => true);
}
function Ii(e2, t3, n2, r2, o2) {
  var a2 = r2(e2, t3, n2);
  if (Array.isArray(e2) && Ci(a2) && o2(a2)) {
    var s2 = [];
    return Ti(e2, a2.visibleSections, (t4) => {
      var i2 = n2.concat(String(t4)), l2 = Ii(e2[t4], a2.items[t4], i2, r2, o2);
      void 0 !== l2 && (s2[t4] = l2);
    }), !Tr(s2, a2.items) ? i(i({}, a2), {}, { items: s2 }) : a2;
  }
  if (br(e2) && wi(a2) && o2(a2)) {
    var l = {};
    return Object.keys(e2).forEach((t4) => {
      var i2 = n2.concat(t4), s3 = Ii(e2[t4], a2.properties[t4], i2, r2, o2);
      void 0 !== s3 && (l[t4] = s3);
    }), !Tr(Object.values(l), Object.values(a2.properties)) ? i(i({}, a2), {}, { properties: l }) : a2;
  }
  return a2;
}
function Ti(e2, t3, n2) {
  t3.forEach((t4) => {
    var { start: r2, end: o2 } = t4;
    Nr(r2, Math.min(e2.length, o2), n2);
  });
}
function Ai(e2, t3) {
  for (var n2 = e2, r2 = [], o2 = 0; o2 < t3.length; ) {
    if (Array.isArray(n2)) {
      var a2 = t3[o2];
      r2.push("items", a2), n2 = n2[gr(a2)];
    } else {
      if (!br(n2)) throw new Error("Cannot convert path: Object or Array expected at index ".concat(o2));
      var i2 = t3[o2];
      r2.push("properties", i2), n2 = n2[i2];
    }
    o2++;
  }
  return r2;
}
function Ni(e2, t3, n2, r2) {
  for (var o2 = t3, a2 = function(t4) {
    var r3 = n2.slice(0, t4);
    o2 = Hi(e2, o2, r3, (e3, r4) => {
      var o3 = Si(r4) && !r4.expanded ? i(i({}, r4), {}, { expanded: true }) : r4;
      return Ci(o3) ? function(e4, t5) {
        if (function(e5, t6) {
          return e5.some((e6) => t6 >= e6.start && t6 < e6.end);
        }(e4.visibleSections, t5)) return e4;
        var n3 = ci(t5), r5 = { start: n3, end: li(n3) };
        return i(i({}, e4), {}, { visibleSections: si(e4.visibleSections.concat(r5)) });
      }(o3, gr(n2[t4])) : o3;
    });
  }, s2 = 0; s2 < n2.length; s2++) a2(s2);
  return Hi(e2, o2, n2, (e3, t4) => function(e4, t5, n3, r3) {
    return Ii(e4, t5, n3, (e5, t6, n4) => Array.isArray(e5) && r3(n4) ? Ci(t6) ? t6.expanded ? t6 : i(i({}, t6), {}, { expanded: true }) : qi({ expanded: true }) : br(e5) && r3(n4) ? wi(t6) ? t6.expanded ? t6 : i(i({}, t6), {}, { expanded: true }) : Mi({ expanded: true }) : t6, (e5) => Si(e5) && e5.expanded);
  }(e3, t4, [], r2));
}
function Bi(e2, t3, n2, r2) {
  return Hi(e2, t3, n2, (e3, t4) => r2 ? function(e4, t5, n3) {
    return Ii(e4, t5, n3, (e5, t6) => Fi(t6), () => true);
  }(e3, t4, n2) : Fi(t4));
}
function Fi(e2) {
  return Ci(e2) && e2.expanded ? i(i({}, e2), {}, { expanded: false, visibleSections: Ha }) : wi(e2) && e2.expanded ? i(i({}, e2), {}, { expanded: false }) : e2;
}
function Ui(e2, t3, n2) {
  var r2 = { json: e2, documentState: t3 }, o2 = n2.reduce((e3, t4) => ({ json: immutableJSONPatch(e3.json, [t4]), documentState: Li(e3.json, e3.documentState, t4) }), r2);
  return { json: o2.json, documentState: Pi(o2.json, o2.documentState) };
}
function Li(e2, t3, n2) {
  if (isJSONPatchAdd(n2)) return _i(e2, t3, n2, void 0);
  if (isJSONPatchRemove(n2)) return Wi(e2, t3, n2);
  if (isJSONPatchReplace(n2)) {
    var r2 = parsePath(e2, n2.path), o2 = Yi(e2, t3, r2);
    return o2 ? Vi(e2, t3, r2, { type: "value", enforceString: o2 }) : t3;
  }
  return isJSONPatchCopy(n2) || isJSONPatchMove(n2) ? function(e3, t4, n3) {
    if (isJSONPatchMove(n3) && n3.from === n3.path) return t4;
    var r3 = t4, o3 = parsePath(e3, n3.from), a2 = Di(e3, r3, o3);
    isJSONPatchMove(n3) && (r3 = Wi(e3, r3, { op: "remove", path: n3.from }));
    return r3 = _i(e3, r3, { op: "add", path: n3.path, value: null }, a2), r3;
  }(e2, t3, n2) : t3;
}
function Di(e2, t3, n2) {
  try {
    return getIn(t3, Ai(e2, n2));
  } catch (e3) {
    return;
  }
}
function Ji(e2, t3, n2, r2, o2) {
  var a2 = Ei(e2, t3, n2, o2);
  return updateIn(a2, Ai(e2, n2), (t4) => {
    var o3 = getIn(e2, n2);
    return r2(o3, t4);
  });
}
function Vi(e2, t3, n2, r2) {
  return function(e3, t4, n3, r3, o2) {
    var a2 = Ei(e3, t4, n3, o2);
    return setIn(a2, Ai(e3, n3), r3);
  }(e2, t3, n2, r2, Ri);
}
function Hi(e2, t3, n2, r2) {
  return Ji(e2, t3, n2, r2, Ri);
}
function _i(e2, t3, n2, r2) {
  var o2 = parsePath(e2, n2.path), a2 = t3;
  return Vi(e2, a2 = Hi(e2, a2, initial_default(o2), (e3, t4) => {
    if (!Ci(t4)) return t4;
    var n3 = gr(last_default(o2)), { items: a3, visibleSections: s2 } = t4;
    return i(i({}, t4), {}, { items: n3 < a3.length ? Dr(a3, n3, void 0 !== r2 ? [r2] : Array(1)) : a3, visibleSections: Qi(s2, n3, 1) });
  }), o2, r2);
}
function Wi(e2, t3, n2) {
  var r2 = parsePath(e2, n2.path), o2 = initial_default(r2), a2 = getIn(e2, o2);
  return Array.isArray(a2) ? Hi(e2, t3, o2, (e3, t4) => {
    if (!Ci(t4)) return t4;
    var n3 = gr(last_default(r2)), { items: o3, visibleSections: a3 } = t4;
    return i(i({}, t4), {}, { items: o3.slice(0, n3).concat(o3.slice(n3 + 1)), visibleSections: Qi(a3, n3, -1) });
  }) : function(e3, t4, n3) {
    var r3 = Ai(e3, n3);
    return existsIn(t4, r3) ? deleteIn(t4, Ai(e3, n3)) : t4;
  }(e2, t3, r2);
}
function Qi(e2, t3, n2) {
  return function(e3) {
    var t4 = e3.slice(0), n3 = 1;
    for (; n3 < t4.length; ) t4[n3 - 1].end === t4[n3].start && (t4[n3 - 1] = { start: t4[n3 - 1].start, end: t4[n3].end }, t4.splice(n3)), n3++;
    return t4;
  }(e2.map((e3) => ({ start: e3.start > t3 ? e3.start + n2 : e3.start, end: e3.end > t3 ? e3.end + n2 : e3.end })));
}
function Yi(e2, t3, n2) {
  var r2, o2 = getIn(e2, n2), a2 = Di(e2, t3, n2), i2 = ki(a2) ? a2.enforceString : void 0;
  return "boolean" == typeof i2 ? i2 : "string" == typeof (r2 = o2) && "string" != typeof Mr(r2, JSON);
}
function Ki(e2, t3) {
  var n2 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], r2 = e2.indexOf(t3);
  return -1 !== r2 ? n2 ? e2.slice(r2) : e2.slice(r2 + 1) : [];
}
function Zi(e2, t3) {
  var n2 = [];
  return function e3(t4, r2, o2) {
    n2.push(o2), isJSONArray(t4) && Ci(r2) && r2.expanded && Ti(t4, r2.visibleSections, (n3) => {
      e3(t4[n3], r2.items[n3], o2.concat(String(n3)));
    }), isJSONObject(t4) && wi(r2) && r2.expanded && Object.keys(t4).forEach((n3) => {
      e3(t4[n3], r2.properties[n3], o2.concat(n3));
    });
  }(e2, t3, []), n2;
}
function Xi(e2, t3) {
  var n2 = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2], r2 = [];
  return function o2(a2, i2) {
    r2.push({ path: i2, type: vo.value });
    var s2 = Di(e2, t3, i2);
    if (a2 && Si(s2) && s2.expanded) {
      if (n2 && r2.push({ path: i2, type: vo.inside }), isJSONArray(a2)) {
        var l = Ci(s2) ? s2.visibleSections : Ha;
        Ti(a2, l, (e3) => {
          var t4 = i2.concat(String(e3));
          o2(a2[e3], t4), n2 && r2.push({ path: t4, type: vo.after });
        });
      }
      if (isJSONObject(a2)) Object.keys(a2).forEach((e3) => {
        var t4 = i2.concat(e3);
        r2.push({ path: t4, type: vo.key }), o2(a2[e3], t4), n2 && r2.push({ path: t4, type: vo.after });
      });
    }
  }(e2, []), r2;
}
function Gi(e2, t3, n2) {
  var r2 = Zi(e2, t3), o2 = r2.map(compileJSONPointer).indexOf(compileJSONPointer(n2));
  if (-1 !== o2 && o2 < r2.length - 1) return r2[o2 + 1];
}
function es(e2, t3, n2) {
  var r2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : Ya;
  return Ni(e2, t3, n2, no({ json: getIn(e2, n2) }, r2) ? ts : rs);
}
function ts(e2) {
  return 0 === e2.length || 1 === e2.length && "0" === e2[0];
}
function ns(e2) {
  return 0 === e2.length;
}
function rs() {
  return true;
}
function os() {
  return false;
}
function as(e2) {
  return e2 && e2.type === uo.after || false;
}
function is(e2) {
  return e2 && e2.type === uo.inside || false;
}
function ss(e2) {
  return e2 && e2.type === uo.key || false;
}
function ls(e2) {
  return e2 && e2.type === uo.value || false;
}
function cs(e2) {
  return e2 && e2.type === uo.multi || false;
}
function us(e2) {
  return cs(e2) && isEqual_default(e2.focusPath, e2.anchorPath);
}
function ds(e2) {
  return cs(e2) || as(e2) || is(e2) || ss(e2) || ls(e2);
}
function vs(e2) {
  return e2 && e2.type === uo.text || false;
}
function ps(e2, t3) {
  var n2 = [];
  return function(e3, t4, n3) {
    if (!t4) return;
    var r2 = Js(t4), o2 = Ds(t4);
    if (isEqual_default(r2, o2)) return n3(r2);
    if (void 0 === e3) return;
    var a2 = ys(r2, o2);
    if (r2.length === a2.length || o2.length === a2.length) return n3(a2);
    var i2 = Es(r2, o2), s2 = ms(e3, i2), l = hs(e3, i2), c = Ls(e3, i2, s2), d = Ls(e3, i2, l);
    if (-1 === c || -1 === d) return;
    var v = getIn(e3, a2);
    if (isJSONObject(v)) {
      for (var p = Object.keys(v), f = c; f <= d; f++) {
        var m3 = n3(a2.concat(p[f]));
        if (void 0 !== m3) return m3;
      }
      return;
    }
    if (isJSONArray(v)) {
      for (var h2 = c; h2 <= d; h2++) {
        var g = n3(a2.concat(String(h2)));
        if (void 0 !== g) return g;
      }
      return;
    }
    throw new Error("Failed to create selection");
  }(e2, t3, (e3) => {
    n2.push(e3);
  }), n2;
}
function fs(e2) {
  return is(e2) ? e2.path : initial_default(Ds(e2));
}
function ms(e2, t3) {
  if (!cs(t3)) return t3.path;
  var n2 = Ls(e2, t3, t3.anchorPath);
  return Ls(e2, t3, t3.focusPath) < n2 ? t3.focusPath : t3.anchorPath;
}
function hs(e2, t3) {
  if (!cs(t3)) return t3.path;
  var n2 = Ls(e2, t3, t3.anchorPath);
  return Ls(e2, t3, t3.focusPath) > n2 ? t3.focusPath : t3.anchorPath;
}
function gs(e2, t3, n2) {
  var r2 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
  if (n2) {
    var o2 = r2 ? Ds(n2) : ms(e2, n2), a2 = function(e3, t4, n3) {
      var r3 = Zi(e3, t4), o3 = r3.map(compileJSONPointer), a3 = compileJSONPointer(n3), i3 = o3.indexOf(a3);
      if (-1 !== i3 && i3 > 0) return r3[i3 - 1];
    }(e2, t3, o2);
    if (r2) return is(n2) || as(n2) ? void 0 !== a2 ? Es(o2, o2) : void 0 : void 0 !== a2 ? Es(Js(n2), a2) : void 0;
    if (as(n2)) return zs(o2);
    if (is(n2)) return zs(o2);
    if (ss(n2)) {
      if (void 0 === a2 || 0 === a2.length) return;
      var i2 = initial_default(a2), s2 = getIn(e2, i2);
      return Array.isArray(s2) || isEmpty_default(a2) ? zs(a2) : Ss(a2);
    }
    return ls(n2), void 0 !== a2 ? zs(a2) : void 0;
  }
}
function js(e2, t3, n2, r2) {
  if (!n2) return { caret: void 0, previous: void 0, next: void 0 };
  var o2 = Xi(e2, t3, r2), a2 = o2.findIndex((e3) => isEqual_default(e3.path, Ds(n2)) && String(e3.type) === String(n2.type));
  return { caret: -1 !== a2 ? o2[a2] : void 0, previous: -1 !== a2 && a2 > 0 ? o2[a2 - 1] : void 0, next: -1 !== a2 && a2 < o2.length - 1 ? o2[a2 + 1] : void 0 };
}
function xs(e2, t3) {
  for (var n2 = Zi(e2, t3), r2 = 0; r2 < n2.length - 1 && n2[r2 + 1].length > n2[r2].length; ) r2++;
  var o2 = n2[r2];
  return void 0 === o2 || 0 === o2.length || Array.isArray(getIn(e2, initial_default(o2))) ? zs(o2) : Ss(o2);
}
function bs(e2, t3) {
  if (1 === t3.length) {
    var n2 = head_default(t3);
    if ("replace" === n2.op) return zs(parsePath(e2, n2.path));
  }
  if (!isEmpty_default(t3) && t3.every((e3) => "move" === e3.op)) {
    var r2 = head_default(t3), o2 = t3.slice(1);
    if ((isJSONPatchCopy(r2) || isJSONPatchMove(r2)) && r2.from !== r2.path && o2.every((e3) => (isJSONPatchCopy(e3) || isJSONPatchMove(e3)) && e3.from === e3.path)) return Ss(parsePath(e2, r2.path));
  }
  var a2 = t3.filter((e3) => "test" !== e3.op && "remove" !== e3.op && ("move" !== e3.op || e3.from !== e3.path) && "string" == typeof e3.path).map((t4) => parsePath(e2, t4.path));
  if (!isEmpty_default(a2)) return { type: uo.multi, anchorPath: head_default(a2), focusPath: last_default(a2) };
}
function ys(e2, t3) {
  for (var n2 = 0; n2 < e2.length && n2 < t3.length && e2[n2] === t3[n2]; ) n2++;
  return e2.slice(0, n2);
}
function $s(e2) {
  return ss(e2) || ls(e2) || us(e2);
}
function ws(e2, t3) {
  return $s(t3) && yr(getIn(e2, Ds(t3))) ? Ds(t3) : initial_default(Ds(t3));
}
function Cs(e2, t3) {
  if (e2.length < t3.length) return false;
  for (var n2 = 0; n2 < t3.length; n2++) if (e2[n2] !== t3[n2]) return false;
  return true;
}
function ks(e2) {
  if (Is(e2)) {
    var { type: t3, path: n2 } = e2;
    return { type: t3, path: n2 };
  }
  return e2;
}
function Ss(e2) {
  return { type: uo.key, path: e2 };
}
function Os(e2, t3) {
  return { type: uo.key, path: e2, edit: true, initialValue: t3 };
}
function zs(e2) {
  return { type: uo.value, path: e2 };
}
function qs(e2, t3) {
  return { type: uo.value, path: e2, edit: true, initialValue: t3 };
}
function Ms(e2) {
  return { type: uo.inside, path: e2 };
}
function Rs(e2) {
  return { type: uo.after, path: e2 };
}
function Es(e2, t3) {
  var n2 = ys(e2, t3), r2 = e2.length > n2.length && t3.length > n2.length;
  return { type: uo.multi, anchorPath: r2 ? n2.concat(e2[n2.length]) : n2, focusPath: r2 ? n2.concat(t3[n2.length]) : n2 };
}
function Ps(e2, t3, n2, r2) {
  if (ss(t3)) return String(last_default(t3.path));
  if (ls(t3)) {
    var o2 = getIn(e2, t3.path);
    return "string" == typeof o2 ? o2 : r2.stringify(o2, null, n2);
  }
  if (cs(t3)) {
    if (isEmpty_default(t3.focusPath)) return r2.stringify(e2, null, n2);
    var a2 = fs(t3), i2 = getIn(e2, a2);
    if (Array.isArray(i2)) {
      if (us(t3)) {
        var s2 = getIn(e2, t3.focusPath);
        return r2.stringify(s2, null, n2);
      }
      return ps(e2, t3).map((t4) => {
        var o3 = getIn(e2, t4);
        return "".concat(r2.stringify(o3, null, n2), ",");
      }).join("\n");
    }
    return ps(e2, t3).map((t4) => {
      var o3 = last_default(t4), a3 = getIn(e2, t4);
      return "".concat(r2.stringify(o3), ": ").concat(r2.stringify(a3, null, n2), ",");
    }).join("\n");
  }
}
function Is(e2) {
  return (ss(e2) || ls(e2)) && true === e2.edit;
}
function Ts(e2) {
  return ss(e2) || ls(e2) || cs(e2);
}
function As(e2) {
  return ss(e2) || ls(e2) || us(e2);
}
function Ns(e2) {
  switch (e2.type) {
    case vo.key:
      return Ss(e2.path);
    case vo.value:
      return zs(e2.path);
    case vo.after:
      return Rs(e2.path);
    case vo.inside:
      return Ms(e2.path);
  }
}
function Bs(e2, t3) {
  switch (e2) {
    case uo.key:
      return Ss(t3);
    case uo.value:
      return zs(t3);
    case uo.after:
      return Rs(t3);
    case uo.inside:
      return Ms(t3);
    case uo.multi:
    case uo.text:
      return Es(t3, t3);
  }
}
function Fs(e2, t3, n2) {
  if (t3) return Us(e2, t3, n2) || Cs(cs(t3) ? initial_default(t3.focusPath) : t3.path, n2) ? t3 : void 0;
}
function Us(e2, t3, n2) {
  if (void 0 === e2 || !t3) return false;
  if (ss(t3) || is(t3) || as(t3)) return isEqual_default(t3.path, n2);
  if (ls(t3)) return Cs(n2, t3.path);
  if (cs(t3)) {
    var r2 = ms(e2, t3), o2 = hs(e2, t3), a2 = initial_default(t3.focusPath);
    if (!Cs(n2, a2) || n2.length <= a2.length) return false;
    var i2 = Ls(e2, t3, r2), s2 = Ls(e2, t3, o2), l = Ls(e2, t3, n2);
    return -1 !== l && l >= i2 && l <= s2;
  }
  return false;
}
function Ls(e2, t3, n2) {
  var r2 = initial_default(t3.focusPath);
  if (!Cs(n2, r2) || n2.length <= r2.length) return -1;
  var o2 = n2[r2.length], a2 = getIn(e2, r2);
  if (isJSONObject(a2)) return Object.keys(a2).indexOf(o2);
  if (isJSONArray(a2)) {
    var i2 = gr(o2);
    if (i2 < a2.length) return i2;
  }
  return -1;
}
function Ds(e2) {
  return cs(e2) ? e2.focusPath : e2.path;
}
function Js(e2) {
  return cs(e2) ? e2.anchorPath : e2.path;
}
function Vs() {
  for (var e2 = [], t3 = arguments.length, n2 = new Array(t3), r2 = 0; r2 < t3; r2++) n2[r2] = arguments[r2];
  for (var o2 of n2) if ("string" == typeof o2 && e2.push(o2), o2 && "object" == typeof o2) for (var a2 in o2) Object.hasOwnProperty.call(o2, a2) && o2[a2] && e2.push(a2);
  return e2.join(" ");
}
function Hs(e2, t3, n2) {
  return Vs("jse-value", "jse-" + Or(e2, n2), { "jse-url": qr(e2), "jse-empty": "string" == typeof e2 && 0 === e2.length, "jse-table-cell": t3 === co.table });
}
function _s(e2) {
  rn(e2, "svelte-l3ivvc", ".jse-value.jse-string.svelte-l3ivvc{color:var(--jse-value-color-string, #008000)}.jse-value.jse-object.svelte-l3ivvc,.jse-value.jse-array.svelte-l3ivvc{min-width:16px;color:var(--jse-delimiter-color, rgba(0, 0, 0, 0.38))}.jse-value.jse-number.svelte-l3ivvc{color:var(--jse-value-color-number, #ee422e)}.jse-value.jse-boolean.svelte-l3ivvc{color:var(--jse-value-color-boolean, #ff8c00)}.jse-value.jse-null.svelte-l3ivvc{color:var(--jse-value-color-null, #004ed0)}.jse-value.jse-invalid.svelte-l3ivvc{color:var(--jse-text-color, #4d4d4d)}.jse-value.jse-url.svelte-l3ivvc{color:var(--jse-value-color-url, #008000);text-decoration:underline}div.jse-editable-div.svelte-l3ivvc{min-width:2em;padding:0 5px;box-sizing:border-box;outline:none;border-radius:1px;vertical-align:top;cursor:text !important;word-break:normal;white-space:pre-wrap;overflow-wrap:anywhere}div.jse-editable-div.jse-short-text.svelte-l3ivvc{overflow-wrap:normal}div.jse-editable-div.jse-table-cell.svelte-l3ivvc{overflow-wrap:normal;white-space:nowrap}div.jse-editable-div[contenteditable=true].svelte-l3ivvc{outline:var(--jse-edit-outline, 2px solid #656565);background:var(--jse-background-color, #fff);position:relative;display:inline-block;border-radius:0;z-index:3}div.jse-editable-div.jse-empty.svelte-l3ivvc:not(:focus){outline:1px dotted var(--jse-tag-background, rgba(0, 0, 0, 0.2));-moz-outline-radius:2px}div.jse-editable-div.jse-empty.svelte-l3ivvc::after{pointer-events:none;color:var(--jse-tag-background, rgba(0, 0, 0, 0.2))}");
}
function Ws(e2) {
  var t3, n2, r2, o2;
  return { c() {
    hn(t3 = ln("div"), "role", "textbox"), hn(t3, "aria-label", e2[1]), hn(t3, "tabindex", "0"), hn(t3, "class", n2 = Gt(Vs("jse-editable-div", e2[3], { "jse-short-text": e2[0] })) + " svelte-l3ivvc"), hn(t3, "contenteditable", "true"), hn(t3, "spellcheck", "false");
  }, m(n3, a2) {
    on(n3, t3, a2), e2[15](t3), r2 || (o2 = [pn(t3, "input", e2[4]), pn(t3, "keydown", e2[5]), pn(t3, "paste", e2[6]), pn(t3, "blur", e2[7])], r2 = true);
  }, p(e3, r3) {
    var [o3] = r3;
    2 & o3 && hn(t3, "aria-label", e3[1]), 9 & o3 && n2 !== (n2 = Gt(Vs("jse-editable-div", e3[3], { "jse-short-text": e3[0] })) + " svelte-l3ivvc") && hn(t3, "class", n2);
  }, i: Bt, o: Bt, d(n3) {
    n3 && an(t3), e2[15](null), r2 = false, Dt(o2);
  } };
}
function Qs(e2, t3, n2) {
  var r2, o2, a2 = vr("jsoneditor:EditableDiv"), { value: i2 } = t3, { initialValue: s2 } = t3, { shortText: l = false } = t3, { label: c } = t3, { onChange: u } = t3, { onCancel: d } = t3, { onFind: v } = t3, { onPaste: p = noop_default } = t3, { onValueClass: f = () => "" } = t3, m3 = false;
  function h2() {
    return r2 ? function(e3) {
      return e3.replace(/\n$/, "");
    }(r2.innerText) : "";
  }
  function g(e3) {
    r2 && n2(2, r2.innerText = qo(e3), r2);
  }
  return qn(() => {
    a2("onMount", { value: i2, initialValue: s2 }), g(void 0 !== s2 ? s2 : i2), r2 && function(e3) {
      if (null != e3.firstChild) {
        var t4 = document.createRange(), n3 = window.getSelection();
        t4.setStart(e3, 1), t4.collapse(true), null == n3 || n3.removeAllRanges(), null == n3 || n3.addRange(t4);
      } else e3.focus();
    }(r2);
  }), Mn(() => {
    var e3 = h2();
    a2("onDestroy", { closed: m3, value: i2, newValue: e3 }), m3 || e3 === i2 || u(e3, ho.no);
  }), e2.$$set = (e3) => {
    "value" in e3 && n2(8, i2 = e3.value), "initialValue" in e3 && n2(9, s2 = e3.initialValue), "shortText" in e3 && n2(0, l = e3.shortText), "label" in e3 && n2(1, c = e3.label), "onChange" in e3 && n2(10, u = e3.onChange), "onCancel" in e3 && n2(11, d = e3.onCancel), "onFind" in e3 && n2(12, v = e3.onFind), "onPaste" in e3 && n2(13, p = e3.onPaste), "onValueClass" in e3 && n2(14, f = e3.onValueClass);
  }, e2.$$.update = () => {
    16640 & e2.$$.dirty && n2(3, o2 = f(i2));
  }, [l, c, r2, o2, function() {
    var e3 = h2();
    "" === e3 && g(""), n2(3, o2 = f(e3));
  }, function(e3) {
    e3.stopPropagation();
    var t4 = Do(e3);
    if ("Escape" === t4 && (m3 = true, d()), "Enter" === t4 || "Tab" === t4) {
      m3 = true;
      var n3 = h2();
      u(n3, ho.nextInside);
    }
    "Ctrl+F" === t4 && (e3.preventDefault(), v(false)), "Ctrl+H" === t4 && (e3.preventDefault(), v(true));
  }, function(e3) {
    if (e3.stopPropagation(), p && e3.clipboardData) {
      var t4 = e3.clipboardData.getData("text/plain");
      p(t4);
    }
  }, function() {
    var e3 = document.hasFocus(), t4 = h2();
    a2("handleBlur", { hasFocus: e3, closed: m3, value: i2, newValue: t4 }), document.hasFocus() && !m3 && (m3 = true, t4 !== i2 && u(t4, ho.self));
  }, i2, s2, u, d, v, p, f, function(e3) {
    Tn[e3 ? "unshift" : "push"](() => {
      n2(2, r2 = e3);
    });
  }];
}
var Ys = class extends dr {
  constructor(e2) {
    super(), ur(this, e2, Qs, Ws, Ht, { value: 8, initialValue: 9, shortText: 0, label: 1, onChange: 10, onCancel: 11, onFind: 12, onPaste: 13, onValueClass: 14 }, _s);
  }
};
function Ks(e2) {
  var t3, n2;
  return t3 = new Ys({ props: { value: e2[2].escapeValue(e2[0]), initialValue: Is(e2[1]) ? e2[1].initialValue : void 0, label: "Edit value", onChange: e2[4], onCancel: e2[5], onPaste: e2[6], onFind: e2[3], onValueClass: e2[7] } }), { c() {
    sr(t3.$$.fragment);
  }, m(e3, r2) {
    lr(t3, e3, r2), n2 = true;
  }, p(e3, n3) {
    var [r2] = n3, o2 = {};
    5 & r2 && (o2.value = e3[2].escapeValue(e3[0])), 2 & r2 && (o2.initialValue = Is(e3[1]) ? e3[1].initialValue : void 0), 8 & r2 && (o2.onFind = e3[3]), t3.$set(o2);
  }, i(e3) {
    n2 || (Xn(t3.$$.fragment, e3), n2 = true);
  }, o(e3) {
    Gn(t3.$$.fragment, e3), n2 = false;
  }, d(e3) {
    cr(t3, e3);
  } };
}
function Zs(e2, t3, n2) {
  var { path: r2 } = t3, { value: o2 } = t3, { selection: a2 } = t3, { mode: i2 } = t3, { parser: s2 } = t3, { normalization: l } = t3, { enforceString: u } = t3, { onPatch: d } = t3, { onPasteJson: v } = t3, { onSelect: p } = t3, { onFind: f } = t3, { focus: m3 } = t3, { findNextInside: h2 } = t3;
  function g(e3) {
    return u ? e3 : Mr(e3, s2);
  }
  function j() {
    p(zs(r2)), m3();
  }
  return e2.$$set = (e3) => {
    "path" in e3 && n2(8, r2 = e3.path), "value" in e3 && n2(0, o2 = e3.value), "selection" in e3 && n2(1, a2 = e3.selection), "mode" in e3 && n2(9, i2 = e3.mode), "parser" in e3 && n2(10, s2 = e3.parser), "normalization" in e3 && n2(2, l = e3.normalization), "enforceString" in e3 && n2(11, u = e3.enforceString), "onPatch" in e3 && n2(12, d = e3.onPatch), "onPasteJson" in e3 && n2(13, v = e3.onPasteJson), "onSelect" in e3 && n2(14, p = e3.onSelect), "onFind" in e3 && n2(3, f = e3.onFind), "focus" in e3 && n2(15, m3 = e3.focus), "findNextInside" in e3 && n2(16, h2 = e3.findNextInside);
  }, [o2, a2, l, f, function(e3, t4) {
    d([{ op: "replace", path: compileJSONPointer(r2), value: g(l.unescapeValue(e3)) }], (e4, n3, o3) => {
      if (!o3 || isEqual_default(r2, Ds(o3))) return { state: n3, selection: t4 === ho.nextInside ? h2(r2) : zs(r2) };
    }), m3();
  }, j, function(e3) {
    try {
      var t4 = s2.parse(e3);
      yr(t4) && v({ path: r2, contents: t4, onPasteAsJson: () => {
        j();
        var e4 = [{ op: "replace", path: compileJSONPointer(r2), value: t4 }];
        d(e4, (e5, t5) => ({ state: es(e5, t5, r2) }));
      } });
    } catch (e4) {
    }
  }, function(e3) {
    return Hs(g(l.unescapeValue(e3)), i2, s2);
  }, r2, i2, s2, u, d, v, p, m3, h2];
}
var Xs = class extends dr {
  constructor(e2) {
    super(), ur(this, e2, Zs, Ks, Ht, { path: 8, value: 0, selection: 1, mode: 9, parser: 10, normalization: 2, enforceString: 11, onPatch: 12, onPasteJson: 13, onSelect: 14, onFind: 3, focus: 15, findNextInside: 16 });
  }
};
function Gs(e2, t3, n2) {
  var r2 = initial_default(t3), o2 = getIn(e2, r2);
  if (isJSONArray(o2)) {
    var a2 = gr(last_default(t3));
    return n2.map((e3, t4) => ({ op: "add", path: compileJSONPointer(r2.concat(String(a2 + t4))), value: e3.value }));
  }
  if (isJSONObject(o2)) {
    var i2 = last_default(t3), s2 = Object.keys(o2), l = void 0 !== i2 ? Ki(s2, i2, true) : [];
    return [...n2.map((e3) => {
      var t4 = oa(e3.key, s2);
      return { op: "add", path: compileJSONPointer(r2.concat(t4)), value: e3.value };
    }), ...l.map((e3) => al(r2, e3))];
  }
  throw new Error("Cannot create insert operations: parent must be an Object or Array");
}
function el(e2, t3, n2) {
  var r2 = getIn(e2, t3);
  if (Array.isArray(r2)) {
    var o2 = r2.length;
    return n2.map((e3, n3) => ({ op: "add", path: compileJSONPointer(t3.concat(String(o2 + n3))), value: e3.value }));
  }
  return n2.map((e3) => {
    var n3 = oa(e3.key, Object.keys(r2));
    return { op: "add", path: compileJSONPointer(t3.concat(n3)), value: e3.value };
  });
}
function tl(e2, t3, n2, r2) {
  var o2 = oa(r2, t3.filter((e3) => e3 !== n2)), a2 = Ki(t3, n2, false);
  return [{ op: "move", from: compileJSONPointer(e2.concat(n2)), path: compileJSONPointer(e2.concat(o2)) }, ...a2.map((t4) => al(e2, t4))];
}
function nl(e2, t3) {
  var n2 = last_default(t3);
  if (isEmpty_default(n2)) throw new Error("Cannot duplicate root object");
  var r2 = initial_default(n2), o2 = last_default(n2), a2 = getIn(e2, r2);
  if (isJSONArray(a2)) {
    var i2 = last_default(t3), s2 = i2 ? gr(last_default(i2)) + 1 : 0;
    return [...t3.map((e3, t4) => ({ op: "copy", from: compileJSONPointer(e3), path: compileJSONPointer(r2.concat(String(t4 + s2))) }))];
  }
  if (isJSONObject(a2)) {
    var l = Object.keys(a2), d = void 0 !== o2 ? Ki(l, o2, false) : [];
    return [...t3.map((e3) => {
      var t4 = oa(last_default(e3), l);
      return { op: "copy", from: compileJSONPointer(e3), path: compileJSONPointer(r2.concat(t4)) };
    }), ...d.map((e3) => al(r2, e3))];
  }
  throw new Error("Cannot create duplicate operations: parent must be an Object or Array");
}
function rl(e2, t3, n2, r2) {
  if (ss(t3)) {
    var o2 = Vr(n2, r2), a2 = initial_default(t3.path), i2 = getIn(e2, a2);
    return tl(a2, Object.keys(i2), last_default(t3.path), "string" == typeof o2 ? o2 : n2);
  }
  if (ls(t3) || cs(t3) && isEmpty_default(t3.focusPath)) try {
    return [{ op: "replace", path: compileJSONPointer(Ds(t3)), value: Hr(n2, (e3) => Jr(e3, r2)) }];
  } catch (e3) {
    return [{ op: "replace", path: compileJSONPointer(Ds(t3)), value: n2 }];
  }
  if (cs(t3)) {
    var s2 = il(n2, r2);
    return function(e3, t4, n3) {
      var r3 = head_default(t4), o3 = initial_default(r3), a3 = getIn(e3, o3);
      if (isJSONArray(a3)) {
        var i3 = head_default(t4), s3 = i3 ? gr(last_default(i3)) : 0;
        return [...ol(t4), ...n3.map((e4, t5) => ({ op: "add", path: compileJSONPointer(o3.concat(String(t5 + s3))), value: e4.value }))];
      }
      if (isJSONObject(a3)) {
        var l2 = last_default(t4), d2 = initial_default(l2), v2 = last_default(l2), p2 = Object.keys(a3), f2 = void 0 !== v2 ? Ki(p2, v2, false) : [], m4 = new Set(t4.map((e4) => last_default(e4))), h3 = p2.filter((e4) => !m4.has(e4));
        return [...ol(t4), ...n3.map((e4) => {
          var t5 = oa(e4.key, h3);
          return { op: "add", path: compileJSONPointer(d2.concat(t5)), value: e4.value };
        }), ...f2.map((e4) => al(d2, e4))];
      }
      throw new Error("Cannot create replace operations: parent must be an Object or Array");
    }(e2, ps(e2, t3), s2);
  }
  if (as(t3)) {
    var l = il(n2, r2), d = t3.path, v = initial_default(d), p = getIn(e2, v);
    if (isJSONArray(p)) {
      var f = gr(last_default(d));
      return Gs(e2, v.concat(String(f + 1)), l);
    }
    if (isJSONObject(p)) {
      var m3 = String(last_default(d)), h2 = Object.keys(p);
      if (isEmpty_default(h2) || last_default(h2) === m3) return el(e2, v, l);
      var g = h2.indexOf(m3), j = h2[g + 1];
      return Gs(e2, v.concat(j), l);
    }
    throw new Error("Cannot create insert operations: parent must be an Object or Array");
  }
  if (is(t3)) {
    var x = il(n2, r2), b2 = t3.path, y = getIn(e2, b2);
    if (isJSONArray(y)) return Gs(e2, b2.concat("0"), x);
    if (isJSONObject(y)) {
      var C3 = Object.keys(y);
      if (isEmpty_default(C3)) return el(e2, b2, x);
      var k2 = head_default(C3);
      return Gs(e2, b2.concat(k2), x);
    }
    throw new Error("Cannot create insert operations: parent must be an Object or Array");
  }
  throw new Error("Cannot insert: unsupported type of selection " + JSON.stringify(t3));
}
function ol(e2) {
  return e2.map((e3) => ({ op: "remove", path: compileJSONPointer(e3) })).reverse();
}
function al(e2, t3) {
  return { op: "move", from: compileJSONPointer(e2.concat(t3)), path: compileJSONPointer(e2.concat(t3)) };
}
function il(e2, t3) {
  var n2 = /^\s*{/.test(e2), r2 = /^\s*\[/.test(e2), o2 = Vr(e2, t3), a2 = void 0 !== o2 ? o2 : Hr(e2, (e3) => Jr(e3, t3));
  return n2 && br(a2) || r2 && Array.isArray(a2) ? [{ key: "New item", value: a2 }] : Array.isArray(a2) ? a2.map((e3, t4) => ({ key: "New item " + t4, value: e3 })) : br(a2) ? Object.keys(a2).map((e3) => ({ key: e3, value: a2[e3] })) : [{ key: "New item", value: a2 }];
}
function sl(e2, t3) {
  if (ss(t3)) {
    var n2 = initial_default(t3.path), r2 = getIn(e2, n2), o2 = tl(n2, Object.keys(r2), last_default(t3.path), "");
    return { operations: o2, newSelection: bs(e2, o2) };
  }
  if (ls(t3)) return { operations: [{ op: "replace", path: compileJSONPointer(t3.path), value: "" }], newSelection: t3 };
  if (cs(t3)) {
    var a2 = ps(e2, t3), i2 = ol(a2), s2 = last_default(a2);
    if (isEmpty_default(s2)) {
      return { operations: [{ op: "replace", path: "", value: "" }], newSelection: zs([]) };
    }
    var l = initial_default(s2), d = getIn(e2, l);
    if (isJSONArray(d)) {
      var v = head_default(a2), p = gr(last_default(v));
      return { operations: i2, newSelection: 0 === p ? Ms(l) : Rs(l.concat(String(p - 1))) };
    }
    if (isJSONObject(d)) {
      var f = Object.keys(d), m3 = head_default(a2), h2 = last_default(m3), g = f.indexOf(h2), j = f[g - 1];
      return { operations: i2, newSelection: 0 === g ? Ms(l) : Rs(l.concat(j)) };
    }
    throw new Error("Cannot create remove operations: parent must be an Object or Array");
  }
  throw new Error("Cannot remove: unsupported type of selection " + JSON.stringify(t3));
}
function ll(e2, t3) {
  return revertJSONPatch(e2, t3, { before: (e3, t4, n2) => {
    if (isJSONPatchRemove(t4)) {
      var r2 = parseJSONPointer(t4.path);
      return { revertOperations: [...n2, ...cl(e3, r2)] };
    }
    if (isJSONPatchMove(t4)) {
      var o2 = parseJSONPointer(t4.from);
      return { revertOperations: [...n2, ...cl(e3, o2)] };
    }
    return { document: e3 };
  } });
}
function cl(e2, t3) {
  var n2 = initial_default(t3), r2 = last_default(t3), o2 = getIn(e2, n2);
  return isJSONObject(o2) ? Ki(Object.keys(o2), r2, false).map((e3) => al(n2, e3)) : [];
}
function ul(e2) {
  var t3 = e2.activeIndex < e2.items.length - 1 ? e2.activeIndex + 1 : e2.items.length > 0 ? 0 : -1, n2 = e2.items[t3], r2 = e2.items.map((e3, n3) => i(i({}, e3), {}, { active: n3 === t3 }));
  return i(i({}, e2), {}, { items: r2, activeItem: n2, activeIndex: t3 });
}
function dl(e2, t3) {
  var n2, r2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, o2 = e2.toLowerCase(), a2 = null !== (n2 = null == r2 ? void 0 : r2.maxResults) && void 0 !== n2 ? n2 : 1 / 0, i2 = null == r2 ? void 0 : r2.columns, s2 = [], l = [];
  function c(e3) {
    s2.length >= a2 || s2.push(e3);
  }
  function d(e3, t4) {
    if (isJSONArray(t4)) {
      var n3 = l.length;
      l.push("0");
      for (var r3 = 0; r3 < t4.length; r3++) if (l[n3] = String(r3), d(e3, t4[r3]), s2.length >= a2) return;
      l.pop();
    } else if (isJSONObject(t4)) {
      var o3 = Object.keys(t4), i3 = l.length;
      for (var u of (l.push(""), o3)) if (l[i3] = u, vl(u, e3, l, fo.key, c), d(e3, t4[u]), s2.length >= a2) return;
      l.pop();
    } else vl(String(t4), e3, l, fo.value, c);
  }
  if ("" === e2) return [];
  if (i2) {
    if (!Array.isArray(t3)) throw new Error("json must be an Array when option columns is defined");
    for (var v = 0; v < t3.length; v++) {
      l[0] = String(v);
      for (var p = t3[v], f = 0; f < i2.length; f++) {
        var m3 = i2[f];
        if (1 === m3.length) l[1] = m3[0];
        else for (var h2 = 0; h2 < m3.length; h2++) l[h2 + 1] = m3[h2];
        for (; l.length > m3.length + 1; ) l.pop();
        d(o2, getIn(p, m3));
      }
      if (s2.length >= a2) break;
    }
    return s2;
  }
  return d(o2, t3), s2;
}
function vl(e2, t3, n2, r2, o2) {
  var a2 = e2.toLowerCase(), i2 = 0, s2 = -1, l = -1;
  do {
    -1 !== (l = a2.indexOf(t3, s2)) && (s2 = l + t3.length, o2({ path: n2.slice(0), field: r2, fieldIndex: i2, start: l, end: s2 }), i2++);
  } while (-1 !== l);
}
function pl(e2, t3, n2, r2) {
  return e2.substring(0, n2) + t3 + e2.substring(r2);
}
function fl(e2, t3, n2) {
  var r2 = e2;
  return forEachRight_default(n2, (e3) => {
    r2 = pl(r2, t3, e3.start, e3.end);
  }), r2;
}
function ml(e2, t3, n2, r2, o2) {
  var { field: a2, path: i2, start: s2, end: l } = r2;
  if (a2 === fo.key) {
    var d = initial_default(i2), v = getIn(e2, d), p = last_default(i2), f = tl(d, Object.keys(v), p, pl(p, n2, s2, l));
    return { newSelection: bs(e2, f), operations: f };
  }
  if (a2 === fo.value) {
    var m3 = getIn(e2, i2);
    if (void 0 === m3) throw new Error("Cannot replace: path not found ".concat(compileJSONPointer(i2)));
    var h2 = "string" == typeof m3 ? m3 : String(m3), g = Yi(e2, t3, i2), j = pl(h2, n2, s2, l), x = [{ op: "replace", path: compileJSONPointer(i2), value: g ? j : Mr(j, o2) }];
    return { newSelection: bs(e2, x), operations: x };
  }
  throw new Error("Cannot replace: unknown type of search result field ".concat(a2));
}
function hl(e2) {
  return e2.path.concat(e2.field, String(e2.fieldIndex));
}
function gl(e2) {
  var t3 = Oi(e2) ? e2.searchResults.filter((e3) => e3.field === fo.key) : void 0;
  return t3 && t3.length > 0 ? t3 : void 0;
}
function jl(e2) {
  var t3 = Oi(e2) ? e2.searchResults.filter((e3) => e3.field === fo.value) : void 0;
  return t3 && t3.length > 0 ? t3 : void 0;
}
var xl = { createObjectDocumentState: () => ({ type: "object", properties: {} }), createArrayDocumentState: () => ({ type: "array", items: [] }), createValueDocumentState: () => ({ type: "value" }) };
function bl(e2, t3) {
  return t3.reduce((t4, n2) => function(e3, t5, n3, r2) {
    return Ji(e3, t5, n3, r2, xl);
  }(e2, t4, n2.path, (e3, t5) => i(i({}, t5), {}, { searchResults: t5.searchResults ? t5.searchResults.concat(n2) : [n2] })), void 0);
}
function yl(e2) {
  var t3, n2 = null !== (t3 = null == e2 ? void 0 : e2.searchResults) && void 0 !== t3 ? t3 : [], r2 = wi(e2) ? Object.values(e2.properties).flatMap(yl) : Ci(e2) ? e2.items.flatMap(yl) : [];
  return n2.concat(r2);
}
function $l(e2) {
  rn(e2, "svelte-5fb7bl", ".jse-highlight.svelte-5fb7bl{background-color:var(--jse-search-match-color, #ffe665);outline:var(--jse-search-match-outline, none)}.jse-highlight.jse-active.svelte-5fb7bl{background-color:var(--jse-search-match-active-color, var(--jse-search-match-color, #ffe665));outline:var(--jse-search-match-outline, 2px solid #e0be00)}");
}
function wl(e2, t3, n2) {
  var r2 = e2.slice();
  return r2[3] = t3[n2], r2;
}
function Cl(e2) {
  var t3, n2, r2 = qo(e2[3].text) + "";
  return { c() {
    t3 = ln("span"), n2 = un(r2), hn(t3, "class", "jse-highlight svelte-5fb7bl"), kn(t3, "jse-active", e2[3].active);
  }, m(e3, r3) {
    on(e3, t3, r3), nn(t3, n2);
  }, p(e3, o2) {
    1 & o2 && r2 !== (r2 = qo(e3[3].text) + "") && yn(n2, r2), 1 & o2 && kn(t3, "jse-active", e3[3].active);
  }, d(e3) {
    e3 && an(t3);
  } };
}
function kl(e2) {
  var t3, n2 = e2[3].text + "";
  return { c() {
    t3 = un(n2);
  }, m(e3, n3) {
    on(e3, t3, n3);
  }, p(e3, r2) {
    1 & r2 && n2 !== (n2 = e3[3].text + "") && yn(t3, n2);
  }, d(e3) {
    e3 && an(t3);
  } };
}
function Sl(e2) {
  var t3;
  function n2(e3, t4) {
    return "normal" === e3[3].type ? kl : Cl;
  }
  var r2 = n2(e2), o2 = r2(e2);
  return { c() {
    o2.c(), t3 = vn();
  }, m(e3, n3) {
    o2.m(e3, n3), on(e3, t3, n3);
  }, p(e3, a2) {
    r2 === (r2 = n2(e3)) && o2 ? o2.p(e3, a2) : (o2.d(1), (o2 = r2(e3)) && (o2.c(), o2.m(t3.parentNode, t3)));
  }, d(e3) {
    e3 && an(t3), o2.d(e3);
  } };
}
function Ol(e2) {
  for (var t3, n2 = er(e2[0]), r2 = [], o2 = 0; o2 < n2.length; o2 += 1) r2[o2] = Sl(wl(e2, n2, o2));
  return { c() {
    for (var e3 = 0; e3 < r2.length; e3 += 1) r2[e3].c();
    t3 = vn();
  }, m(e3, n3) {
    for (var o3 = 0; o3 < r2.length; o3 += 1) r2[o3] && r2[o3].m(e3, n3);
    on(e3, t3, n3);
  }, p(e3, o3) {
    var [a2] = o3;
    if (1 & a2) {
      var i2;
      for (n2 = er(e3[0]), i2 = 0; i2 < n2.length; i2 += 1) {
        var s2 = wl(e3, n2, i2);
        r2[i2] ? r2[i2].p(s2, a2) : (r2[i2] = Sl(s2), r2[i2].c(), r2[i2].m(t3.parentNode, t3));
      }
      for (; i2 < r2.length; i2 += 1) r2[i2].d(1);
      r2.length = n2.length;
    }
  }, i: Bt, o: Bt, d(e3) {
    e3 && an(t3), sn(r2, e3);
  } };
}
function zl(e2, t3, n2) {
  var r2, { text: o2 } = t3, { searchResultItems: a2 } = t3;
  return e2.$$set = (e3) => {
    "text" in e3 && n2(1, o2 = e3.text), "searchResultItems" in e3 && n2(2, a2 = e3.searchResultItems);
  }, e2.$$.update = () => {
    6 & e2.$$.dirty && n2(0, r2 = function(e3, t4) {
      var n3 = [], r3 = 0;
      for (var o3 of t4) {
        var a3 = e3.slice(r3, o3.start);
        "" !== a3 && n3.push({ type: "normal", text: a3, active: false });
        var i2 = e3.slice(o3.start, o3.end);
        n3.push({ type: "highlight", text: i2, active: o3.active }), r3 = o3.end;
      }
      var s2 = last_default(t4);
      return s2 && s2.end < e3.length && n3.push({ type: "normal", text: e3.slice(s2.end), active: false }), n3;
    }(String(o2), a2));
  }, [r2, o2, a2];
}
var ql = class extends dr {
  constructor(e2) {
    super(), ur(this, e2, zl, Ol, Vt, { text: 1, searchResultItems: 2 }, $l);
  }
};
function Ml(e2) {
  rn(e2, "svelte-9ohlz8", '.jse-value.jse-string.svelte-9ohlz8{color:var(--jse-value-color-string, #008000)}.jse-value.jse-object.svelte-9ohlz8,.jse-value.jse-array.svelte-9ohlz8{min-width:16px;color:var(--jse-delimiter-color, rgba(0, 0, 0, 0.38))}.jse-value.jse-number.svelte-9ohlz8{color:var(--jse-value-color-number, #ee422e)}.jse-value.jse-boolean.svelte-9ohlz8{color:var(--jse-value-color-boolean, #ff8c00)}.jse-value.jse-null.svelte-9ohlz8{color:var(--jse-value-color-null, #004ed0)}.jse-value.jse-invalid.svelte-9ohlz8{color:var(--jse-text-color, #4d4d4d)}.jse-value.jse-url.svelte-9ohlz8{color:var(--jse-value-color-url, #008000);text-decoration:underline}.jse-value.svelte-9ohlz8{display:inline-block;min-width:2em;padding:0 5px;box-sizing:border-box;outline:none;border-radius:1px;vertical-align:top;word-break:normal;overflow-wrap:anywhere;white-space:pre-wrap}.jse-value.jse-table-cell.svelte-9ohlz8{overflow-wrap:normal;white-space:nowrap}.jse-value.jse-empty.svelte-9ohlz8{min-width:4em;outline:1px dotted var(--jse-tag-background, rgba(0, 0, 0, 0.2));-moz-outline-radius:2px}.jse-value.jse-empty.svelte-9ohlz8::after{pointer-events:none;color:var(--jse-tag-background, rgba(0, 0, 0, 0.2));content:"value"}');
}
function Rl(e2) {
  var t3, n2 = qo(e2[2].escapeValue(e2[0])) + "";
  return { c() {
    t3 = un(n2);
  }, m(e3, n3) {
    on(e3, t3, n3);
  }, p(e3, r2) {
    5 & r2 && n2 !== (n2 = qo(e3[2].escapeValue(e3[0])) + "") && yn(t3, n2);
  }, i: Bt, o: Bt, d(e3) {
    e3 && an(t3);
  } };
}
function El(e2) {
  var t3, n2;
  return t3 = new ql({ props: { text: e2[2].escapeValue(e2[0]), searchResultItems: e2[4] } }), { c() {
    sr(t3.$$.fragment);
  }, m(e3, r2) {
    lr(t3, e3, r2), n2 = true;
  }, p(e3, n3) {
    var r2 = {};
    5 & n3 && (r2.text = e3[2].escapeValue(e3[0])), 16 & n3 && (r2.searchResultItems = e3[4]), t3.$set(r2);
  }, i(e3) {
    n2 || (Xn(t3.$$.fragment, e3), n2 = true);
  }, o(e3) {
    Gn(t3.$$.fragment, e3), n2 = false;
  }, d(e3) {
    cr(t3, e3);
  } };
}
function Pl(e2) {
  var t3, n2, r2, o2, a2, i2, s2, l, c = [El, Rl], u = [];
  function d(e3, t4) {
    return e3[4] ? 0 : 1;
  }
  return n2 = d(e2), r2 = u[n2] = c[n2](e2), { c() {
    t3 = ln("div"), r2.c(), hn(t3, "role", "button"), hn(t3, "tabindex", "-1"), hn(t3, "data-type", "selectable-value"), hn(t3, "class", o2 = Gt(Hs(e2[0], e2[1], e2[3])) + " svelte-9ohlz8"), hn(t3, "title", a2 = e2[5] ? "Ctrl+Click or Ctrl+Enter to open url in new window" : void 0);
  }, m(r3, o3) {
    on(r3, t3, o3), u[n2].m(t3, null), i2 = true, s2 || (l = [pn(t3, "click", e2[6]), pn(t3, "dblclick", e2[7])], s2 = true);
  }, p(e3, s3) {
    var [l2] = s3, v = n2;
    (n2 = d(e3)) === v ? u[n2].p(e3, l2) : (Kn(), Gn(u[v], 1, 1, () => {
      u[v] = null;
    }), Zn(), (r2 = u[n2]) ? r2.p(e3, l2) : (r2 = u[n2] = c[n2](e3)).c(), Xn(r2, 1), r2.m(t3, null)), (!i2 || 11 & l2 && o2 !== (o2 = Gt(Hs(e3[0], e3[1], e3[3])) + " svelte-9ohlz8")) && hn(t3, "class", o2), (!i2 || 32 & l2 && a2 !== (a2 = e3[5] ? "Ctrl+Click or Ctrl+Enter to open url in new window" : void 0)) && hn(t3, "title", a2);
  }, i(e3) {
    i2 || (Xn(r2), i2 = true);
  }, o(e3) {
    Gn(r2), i2 = false;
  }, d(e3) {
    e3 && an(t3), u[n2].d(), s2 = false, Dt(l);
  } };
}
function Il(e2, t3, n2) {
  var r2, { path: o2 } = t3, { value: a2 } = t3, { mode: i2 } = t3, { readOnly: s2 } = t3, { normalization: l } = t3, { parser: c } = t3, { onSelect: u } = t3, { searchResultItems: d } = t3;
  return e2.$$set = (e3) => {
    "path" in e3 && n2(8, o2 = e3.path), "value" in e3 && n2(0, a2 = e3.value), "mode" in e3 && n2(1, i2 = e3.mode), "readOnly" in e3 && n2(9, s2 = e3.readOnly), "normalization" in e3 && n2(2, l = e3.normalization), "parser" in e3 && n2(3, c = e3.parser), "onSelect" in e3 && n2(10, u = e3.onSelect), "searchResultItems" in e3 && n2(4, d = e3.searchResultItems);
  }, e2.$$.update = () => {
    1 & e2.$$.dirty && n2(5, r2 = qr(a2));
  }, [a2, i2, l, c, d, r2, function(e3) {
    "string" == typeof a2 && r2 && Jo(e3) && (e3.preventDefault(), e3.stopPropagation(), window.open(a2, "_blank"));
  }, function(e3) {
    s2 || (e3.preventDefault(), u(qs(o2)));
  }, o2, s2, u];
}
var Tl = class extends dr {
  constructor(e2) {
    super(), ur(this, e2, Il, Pl, Ht, { path: 8, value: 0, mode: 1, readOnly: 9, normalization: 2, parser: 3, onSelect: 10, searchResultItems: 4 }, Ml);
  }
};
function Al(e2) {
  rn(e2, "svelte-14y3y8t", '.jse-tooltip.svelte-14y3y8t{font-family:var(--jse-font-family, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif);font-size:var(--jse-font-size, 16px);line-height:normal;padding:calc(0.5 * var(--jse-padding, 10px)) var(--jse-padding, 10px);border-radius:3px;background:var(--jse-context-menu-background, #656565);color:var(--jse-context-menu-color, var(--jse-text-color-inverse, #fff));white-space:nowrap;box-shadow:var(--jse-controls-box-shadow, 0 2px 6px 0 rgba(0, 0, 0, 0.24))}');
}
function Nl(e2) {
  var t3, n2;
  return { c() {
    t3 = ln("div"), n2 = un(e2[0]), hn(t3, "class", "jse-tooltip svelte-14y3y8t");
  }, m(e3, r2) {
    on(e3, t3, r2), nn(t3, n2);
  }, p(e3, t4) {
    var [r2] = t4;
    1 & r2 && yn(n2, e3[0]);
  }, i: Bt, o: Bt, d(e3) {
    e3 && an(t3);
  } };
}
function Bl(e2, t3, n2) {
  var { text: r2 } = t3;
  return e2.$$set = (e3) => {
    "text" in e3 && n2(0, r2 = e3.text);
  }, [r2];
}
var Fl = class extends dr {
  constructor(e2) {
    super(), ur(this, e2, Bl, Nl, Vt, { text: 0 }, Al);
  }
};
function Ul(e2, t3) {
  var n2, { text: r2, openAbsolutePopup: o2, closeAbsolutePopup: a2 } = t3;
  function i2() {
    n2 = o2(Fl, { text: r2 }, { position: "top", width: 10 * r2.length, offsetTop: 3, anchor: e2, closeOnOuterClick: true });
  }
  function s2() {
    a2(n2);
  }
  return e2.addEventListener("mouseenter", i2), e2.addEventListener("mouseleave", s2), { destroy() {
    e2.removeEventListener("mouseenter", i2), e2.removeEventListener("mouseleave", s2);
  } };
}
function Ll(e2) {
  rn(e2, "svelte-1jla5ec", ".jse-timestamp.svelte-1jla5ec{padding:0;margin:0;vertical-align:middle;display:inline-flex;color:var(--jse-value-color-number, #ee422e)}");
}
function Dl(e2) {
  var t3, n2, r2, o2, a2, s2;
  return n2 = new Ca({ props: { data: faClock } }), { c() {
    t3 = ln("div"), sr(n2.$$.fragment), hn(t3, "class", "jse-timestamp svelte-1jla5ec");
  }, m(l, c) {
    on(l, t3, c), lr(n2, t3, null), o2 = true, a2 || (s2 = en(r2 = Ul.call(null, t3, i({ text: e2[0] }, e2[1]))), a2 = true);
  }, p(e3, t4) {
    var [n3] = t4;
    r2 && Jt(r2.update) && 1 & n3 && r2.update.call(null, i({ text: e3[0] }, e3[1]));
  }, i(e3) {
    o2 || (Xn(n2.$$.fragment, e3), o2 = true);
  }, o(e3) {
    Gn(n2.$$.fragment, e3), o2 = false;
  }, d(e3) {
    e3 && an(t3), cr(n2), a2 = false, s2();
  } };
}
function Jl(e2, t3, n2) {
  var r2, o2 = En("absolute-popup"), { value: a2 } = t3;
  return e2.$$set = (e3) => {
    "value" in e3 && n2(2, a2 = e3.value);
  }, e2.$$.update = () => {
    4 & e2.$$.dirty && n2(0, r2 = "Time: ".concat(new Date(a2).toString()));
  }, [r2, o2, a2];
}
var Vl = class extends dr {
  constructor(e2) {
    super(), ur(this, e2, Jl, Dl, Ht, { value: 2 }, Ll);
  }
};
function Hl(e2) {
  var { path: t3, value: n2, mode: r2, readOnly: o2, selection: a2, enforceString: i2, searchResultItems: s2, isEditing: l, parser: c, normalization: u, onPatch: d, onPasteJson: v, onSelect: p, onFind: f, findNextInside: m3, focus: h2 } = e2, g = [];
  return !l && $r(n2) && g.push({ component: za, props: { path: t3, value: n2, readOnly: o2, onPatch: d, focus: h2 } }), !l && Sr(n2) && g.push({ component: Aa, props: { path: t3, value: n2, readOnly: o2, onPatch: d, focus: h2 } }), l && g.push({ component: Xs, props: { path: t3, value: n2, selection: a2, mode: r2, enforceString: i2, parser: c, normalization: u, onPatch: d, onPasteJson: v, onSelect: p, onFind: f, findNextInside: m3, focus: h2 } }), l || g.push({ component: Tl, props: { path: t3, value: n2, mode: r2, readOnly: o2, parser: c, normalization: u, searchResultItems: s2, onSelect: p } }), !l && wr(n2) && g.push({ component: Vl, props: { value: n2 } }), g;
}
function _l(e2) {
  return e2.map((e3, t3) => Xl.test(e3) ? "[" + e3 + "]" : /[.[\]]/.test(e3) || "" === e3 ? '["' + (e3.replace(/"/g, '\\"') + '"]') : (t3 > 0 ? "." : "") + e3).join("");
}
function Wl(e2) {
  for (var t3 = [], n2 = 0; n2 < e2.length; ) "." === e2[n2] && n2++, "[" === e2[n2] ? (n2++, '"' === e2[n2] ? (n2++, t3.push(r2((e3) => '"' === e3, true)), o2('"')) : t3.push(r2((e3) => "]" === e3)), o2("]")) : t3.push(r2((e3) => "." === e3 || "[" === e3));
  function r2(t4) {
    for (var r3 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], o3 = ""; n2 < e2.length && !t4(e2[n2]); ) r3 && "\\" === e2[n2] && '"' === e2[n2 + 1] ? (o3 += '"', n2 += 2) : (o3 += e2[n2], n2++);
    return o3;
  }
  function o2(t4) {
    if (e2[n2] !== t4) throw new SyntaxError("Invalid JSON path: ".concat(t4, " expected at position ").concat(n2));
    n2++;
  }
  return t3;
}
function Ql(e2) {
  return { value: e2, label: isEmpty_default(e2) ? "(item root)" : _l(e2) };
}
var Xl = /^\d+$/;
var Gl = {};
var ec = { showWizard: true, showOriginal: true };
var tc = Math.min;
var nc = Math.max;
var rc = Math.round;
var oc = Math.floor;
var ac = (e2) => ({ x: e2, y: e2 });
var ic = { left: "right", right: "left", bottom: "top", top: "bottom" };
var sc = { start: "end", end: "start" };
function lc(e2, t3, n2) {
  return nc(e2, tc(t3, n2));
}
function cc(e2, t3) {
  return "function" == typeof e2 ? e2(t3) : e2;
}
function uc(e2) {
  return e2.split("-")[0];
}
function dc(e2) {
  return e2.split("-")[1];
}
function vc(e2) {
  return "x" === e2 ? "y" : "x";
}
function pc(e2) {
  return "y" === e2 ? "height" : "width";
}
function fc(e2) {
  return ["top", "bottom"].includes(uc(e2)) ? "y" : "x";
}
function mc(e2) {
  return vc(fc(e2));
}
function hc(e2) {
  return e2.replace(/start|end/g, (e3) => sc[e3]);
}
function gc(e2) {
  return e2.replace(/left|right|bottom|top/g, (e3) => ic[e3]);
}
function jc(e2) {
  return "number" != typeof e2 ? function(e3) {
    return i({ top: 0, right: 0, bottom: 0, left: 0 }, e3);
  }(e2) : { top: e2, right: e2, bottom: e2, left: e2 };
}
function xc(e2) {
  var { x: t3, y: n2, width: r2, height: o2 } = e2;
  return { width: r2, height: o2, top: n2, left: t3, right: t3 + r2, bottom: n2 + o2, x: t3, y: n2 };
}
function bc(e2, t3, n2) {
  var r2, { reference: o2, floating: a2 } = e2, i2 = fc(t3), s2 = mc(t3), l = pc(s2), c = uc(t3), u = "y" === i2, d = o2.x + o2.width / 2 - a2.width / 2, v = o2.y + o2.height / 2 - a2.height / 2, p = o2[l] / 2 - a2[l] / 2;
  switch (c) {
    case "top":
      r2 = { x: d, y: o2.y - a2.height };
      break;
    case "bottom":
      r2 = { x: d, y: o2.y + o2.height };
      break;
    case "right":
      r2 = { x: o2.x + o2.width, y: v };
      break;
    case "left":
      r2 = { x: o2.x - a2.width, y: v };
      break;
    default:
      r2 = { x: o2.x, y: o2.y };
  }
  switch (dc(t3)) {
    case "start":
      r2[s2] -= p * (n2 && u ? -1 : 1);
      break;
    case "end":
      r2[s2] += p * (n2 && u ? -1 : 1);
  }
  return r2;
}
var yc = function() {
  var e2 = o(function* (e3, t3, n2) {
    for (var { placement: r2 = "bottom", strategy: o2 = "absolute", middleware: a2 = [], platform: s2 } = n2, l = a2.filter(Boolean), c = yield null == s2.isRTL ? void 0 : s2.isRTL(t3), u = yield s2.getElementRects({ reference: e3, floating: t3, strategy: o2 }), { x: d, y: v } = bc(u, r2, c), p = r2, f = {}, m3 = 0, h2 = 0; h2 < l.length; h2++) {
      var { name: g, fn: j } = l[h2], { x, y: b2, data: y, reset: $2 } = yield j({ x: d, y: v, initialPlacement: r2, placement: p, strategy: o2, middlewareData: f, rects: u, platform: s2, elements: { reference: e3, floating: t3 } });
      d = null != x ? x : d, v = null != b2 ? b2 : v, f = i(i({}, f), {}, { [g]: i(i({}, f[g]), y) }), $2 && m3 <= 50 && (m3++, "object" == typeof $2 && ($2.placement && (p = $2.placement), $2.rects && (u = true === $2.rects ? yield s2.getElementRects({ reference: e3, floating: t3, strategy: o2 }) : $2.rects), { x: d, y: v } = bc(u, p, c)), h2 = -1);
    }
    return { x: d, y: v, placement: p, strategy: o2, middlewareData: f };
  });
  return function(t3, n2, r2) {
    return e2.apply(this, arguments);
  };
}();
function $c(e2, t3) {
  return wc.apply(this, arguments);
}
function wc() {
  return wc = o(function* (e2, t3) {
    var n2;
    void 0 === t3 && (t3 = {});
    var { x: r2, y: o2, platform: a2, rects: i2, elements: s2, strategy: l } = e2, { boundary: c = "clippingAncestors", rootBoundary: u = "viewport", elementContext: d = "floating", altBoundary: v = false, padding: p = 0 } = cc(t3, e2), f = jc(p), m3 = s2[v ? "floating" === d ? "reference" : "floating" : d], h2 = xc(yield a2.getClippingRect({ element: null == (n2 = yield null == a2.isElement ? void 0 : a2.isElement(m3)) || n2 ? m3 : m3.contextElement || (yield null == a2.getDocumentElement ? void 0 : a2.getDocumentElement(s2.floating)), boundary: c, rootBoundary: u, strategy: l })), g = "floating" === d ? { x: r2, y: o2, width: i2.floating.width, height: i2.floating.height } : i2.reference, j = yield null == a2.getOffsetParent ? void 0 : a2.getOffsetParent(s2.floating), x = (yield null == a2.isElement ? void 0 : a2.isElement(j)) && (yield null == a2.getScale ? void 0 : a2.getScale(j)) || { x: 1, y: 1 }, b2 = xc(a2.convertOffsetParentRelativeRectToViewportRelativeRect ? yield a2.convertOffsetParentRelativeRectToViewportRelativeRect({ elements: s2, rect: g, offsetParent: j, strategy: l }) : g);
    return { top: (h2.top - b2.top + f.top) / x.y, bottom: (b2.bottom - h2.bottom + f.bottom) / x.y, left: (h2.left - b2.left + f.left) / x.x, right: (b2.right - h2.right + f.right) / x.x };
  }), wc.apply(this, arguments);
}
function Cc() {
  return Cc = o(function* (e2, t3) {
    var { placement: n2, platform: r2, elements: o2 } = e2, a2 = yield null == r2.isRTL ? void 0 : r2.isRTL(o2.floating), s2 = uc(n2), l = dc(n2), c = "y" === fc(n2), u = ["left", "top"].includes(s2) ? -1 : 1, d = a2 && c ? -1 : 1, v = cc(t3, e2), { mainAxis: p, crossAxis: f, alignmentAxis: m3 } = "number" == typeof v ? { mainAxis: v, crossAxis: 0, alignmentAxis: null } : i({ mainAxis: 0, crossAxis: 0, alignmentAxis: null }, v);
    return l && "number" == typeof m3 && (f = "end" === l ? -1 * m3 : m3), c ? { x: f * d, y: p * u } : { x: p * u, y: f * d };
  }), Cc.apply(this, arguments);
}
function kc(e2) {
  return zc(e2) ? (e2.nodeName || "").toLowerCase() : "#document";
}
function Sc(e2) {
  var t3;
  return (null == e2 || null == (t3 = e2.ownerDocument) ? void 0 : t3.defaultView) || window;
}
function Oc(e2) {
  var t3;
  return null == (t3 = (zc(e2) ? e2.ownerDocument : e2.document) || window.document) ? void 0 : t3.documentElement;
}
function zc(e2) {
  return e2 instanceof Node || e2 instanceof Sc(e2).Node;
}
function qc(e2) {
  return e2 instanceof Element || e2 instanceof Sc(e2).Element;
}
function Mc(e2) {
  return e2 instanceof HTMLElement || e2 instanceof Sc(e2).HTMLElement;
}
function Rc(e2) {
  return "undefined" != typeof ShadowRoot && (e2 instanceof ShadowRoot || e2 instanceof Sc(e2).ShadowRoot);
}
function Ec(e2) {
  var { overflow: t3, overflowX: n2, overflowY: r2, display: o2 } = Bc(e2);
  return /auto|scroll|overlay|hidden|clip/.test(t3 + r2 + n2) && !["inline", "contents"].includes(o2);
}
function Pc(e2) {
  return ["table", "td", "th"].includes(kc(e2));
}
function Ic(e2) {
  return [":popover-open", ":modal"].some((t3) => {
    try {
      return e2.matches(t3);
    } catch (e3) {
      return false;
    }
  });
}
function Tc(e2) {
  var t3 = Ac(), n2 = qc(e2) ? Bc(e2) : e2;
  return "none" !== n2.transform || "none" !== n2.perspective || !!n2.containerType && "normal" !== n2.containerType || !t3 && !!n2.backdropFilter && "none" !== n2.backdropFilter || !t3 && !!n2.filter && "none" !== n2.filter || ["transform", "perspective", "filter"].some((e3) => (n2.willChange || "").includes(e3)) || ["paint", "layout", "strict", "content"].some((e3) => (n2.contain || "").includes(e3));
}
function Ac() {
  return !("undefined" == typeof CSS || !CSS.supports) && CSS.supports("-webkit-backdrop-filter", "none");
}
function Nc(e2) {
  return ["html", "body", "#document"].includes(kc(e2));
}
function Bc(e2) {
  return Sc(e2).getComputedStyle(e2);
}
function Fc(e2) {
  return qc(e2) ? { scrollLeft: e2.scrollLeft, scrollTop: e2.scrollTop } : { scrollLeft: e2.scrollX, scrollTop: e2.scrollY };
}
function Uc(e2) {
  if ("html" === kc(e2)) return e2;
  var t3 = e2.assignedSlot || e2.parentNode || Rc(e2) && e2.host || Oc(e2);
  return Rc(t3) ? t3.host : t3;
}
function Lc(e2) {
  var t3 = Uc(e2);
  return Nc(t3) ? e2.ownerDocument ? e2.ownerDocument.body : e2.body : Mc(t3) && Ec(t3) ? t3 : Lc(t3);
}
function Dc(e2, t3, n2) {
  var r2;
  void 0 === t3 && (t3 = []), void 0 === n2 && (n2 = true);
  var o2 = Lc(e2), a2 = o2 === (null == (r2 = e2.ownerDocument) ? void 0 : r2.body), i2 = Sc(o2);
  return a2 ? t3.concat(i2, i2.visualViewport || [], Ec(o2) ? o2 : [], i2.frameElement && n2 ? Dc(i2.frameElement) : []) : t3.concat(o2, Dc(o2, [], n2));
}
function Jc(e2) {
  var t3 = Bc(e2), n2 = parseFloat(t3.width) || 0, r2 = parseFloat(t3.height) || 0, o2 = Mc(e2), a2 = o2 ? e2.offsetWidth : n2, i2 = o2 ? e2.offsetHeight : r2, s2 = rc(n2) !== a2 || rc(r2) !== i2;
  return s2 && (n2 = a2, r2 = i2), { width: n2, height: r2, $: s2 };
}
function Vc(e2) {
  return qc(e2) ? e2 : e2.contextElement;
}
function Hc(e2) {
  var t3 = Vc(e2);
  if (!Mc(t3)) return ac(1);
  var n2 = t3.getBoundingClientRect(), { width: r2, height: o2, $: a2 } = Jc(t3), i2 = (a2 ? rc(n2.width) : n2.width) / r2, s2 = (a2 ? rc(n2.height) : n2.height) / o2;
  return i2 && Number.isFinite(i2) || (i2 = 1), s2 && Number.isFinite(s2) || (s2 = 1), { x: i2, y: s2 };
}
var _c = ac(0);
function Wc(e2) {
  var t3 = Sc(e2);
  return Ac() && t3.visualViewport ? { x: t3.visualViewport.offsetLeft, y: t3.visualViewport.offsetTop } : _c;
}
function Qc(e2, t3, n2, r2) {
  void 0 === t3 && (t3 = false), void 0 === n2 && (n2 = false);
  var o2 = e2.getBoundingClientRect(), a2 = Vc(e2), i2 = ac(1);
  t3 && (r2 ? qc(r2) && (i2 = Hc(r2)) : i2 = Hc(e2));
  var s2 = function(e3, t4, n3) {
    return void 0 === t4 && (t4 = false), !(!n3 || t4 && n3 !== Sc(e3)) && t4;
  }(a2, n2, r2) ? Wc(a2) : ac(0), l = (o2.left + s2.x) / i2.x, c = (o2.top + s2.y) / i2.y, u = o2.width / i2.x, d = o2.height / i2.y;
  if (a2) for (var v = Sc(a2), p = r2 && qc(r2) ? Sc(r2) : r2, f = v, m3 = f.frameElement; m3 && r2 && p !== f; ) {
    var h2 = Hc(m3), g = m3.getBoundingClientRect(), j = Bc(m3), x = g.left + (m3.clientLeft + parseFloat(j.paddingLeft)) * h2.x, b2 = g.top + (m3.clientTop + parseFloat(j.paddingTop)) * h2.y;
    l *= h2.x, c *= h2.y, u *= h2.x, d *= h2.y, l += x, c += b2, m3 = (f = Sc(m3)).frameElement;
  }
  return xc({ width: u, height: d, x: l, y: c });
}
function Yc(e2) {
  return Qc(Oc(e2)).left + Fc(e2).scrollLeft;
}
function Kc(e2, t3, n2) {
  var r2;
  if ("viewport" === t3) r2 = function(e3, t4) {
    var n3 = Sc(e3), r3 = Oc(e3), o3 = n3.visualViewport, a2 = r3.clientWidth, i2 = r3.clientHeight, s2 = 0, l = 0;
    if (o3) {
      a2 = o3.width, i2 = o3.height;
      var c = Ac();
      (!c || c && "fixed" === t4) && (s2 = o3.offsetLeft, l = o3.offsetTop);
    }
    return { width: a2, height: i2, x: s2, y: l };
  }(e2, n2);
  else if ("document" === t3) r2 = function(e3) {
    var t4 = Oc(e3), n3 = Fc(e3), r3 = e3.ownerDocument.body, o3 = nc(t4.scrollWidth, t4.clientWidth, r3.scrollWidth, r3.clientWidth), a2 = nc(t4.scrollHeight, t4.clientHeight, r3.scrollHeight, r3.clientHeight), i2 = -n3.scrollLeft + Yc(e3), s2 = -n3.scrollTop;
    return "rtl" === Bc(r3).direction && (i2 += nc(t4.clientWidth, r3.clientWidth) - o3), { width: o3, height: a2, x: i2, y: s2 };
  }(Oc(e2));
  else if (qc(t3)) r2 = function(e3, t4) {
    var n3 = Qc(e3, true, "fixed" === t4), r3 = n3.top + e3.clientTop, o3 = n3.left + e3.clientLeft, a2 = Mc(e3) ? Hc(e3) : ac(1);
    return { width: e3.clientWidth * a2.x, height: e3.clientHeight * a2.y, x: o3 * a2.x, y: r3 * a2.y };
  }(t3, n2);
  else {
    var o2 = Wc(e2);
    r2 = i(i({}, t3), {}, { x: t3.x - o2.x, y: t3.y - o2.y });
  }
  return xc(r2);
}
function Zc(e2, t3) {
  var n2 = Uc(e2);
  return !(n2 === t3 || !qc(n2) || Nc(n2)) && ("fixed" === Bc(n2).position || Zc(n2, t3));
}
function Xc(e2, t3, n2) {
  var r2 = Mc(t3), o2 = Oc(t3), a2 = "fixed" === n2, i2 = Qc(e2, true, a2, t3), s2 = { scrollLeft: 0, scrollTop: 0 }, l = ac(0);
  if (r2 || !r2 && !a2) if (("body" !== kc(t3) || Ec(o2)) && (s2 = Fc(t3)), r2) {
    var c = Qc(t3, true, a2, t3);
    l.x = c.x + t3.clientLeft, l.y = c.y + t3.clientTop;
  } else o2 && (l.x = Yc(o2));
  return { x: i2.left + s2.scrollLeft - l.x, y: i2.top + s2.scrollTop - l.y, width: i2.width, height: i2.height };
}
function Gc(e2) {
  return "static" === Bc(e2).position;
}
function eu(e2, t3) {
  return Mc(e2) && "fixed" !== Bc(e2).position ? t3 ? t3(e2) : e2.offsetParent : null;
}
function tu(e2, t3) {
  var n2 = Sc(e2);
  if (Ic(e2)) return n2;
  if (!Mc(e2)) {
    for (var r2 = Uc(e2); r2 && !Nc(r2); ) {
      if (qc(r2) && !Gc(r2)) return r2;
      r2 = Uc(r2);
    }
    return n2;
  }
  for (var o2 = eu(e2, t3); o2 && Pc(o2) && Gc(o2); ) o2 = eu(o2, t3);
  return o2 && Nc(o2) && Gc(o2) && !Tc(o2) ? n2 : o2 || function(e3) {
    for (var t4 = Uc(e3); Mc(t4) && !Nc(t4); ) {
      if (Tc(t4)) return t4;
      if (Ic(t4)) return null;
      t4 = Uc(t4);
    }
    return null;
  }(e2) || n2;
}
var nu = { convertOffsetParentRelativeRectToViewportRelativeRect: function(e2) {
  var { elements: t3, rect: n2, offsetParent: r2, strategy: o2 } = e2, a2 = "fixed" === o2, i2 = Oc(r2), s2 = !!t3 && Ic(t3.floating);
  if (r2 === i2 || s2 && a2) return n2;
  var l = { scrollLeft: 0, scrollTop: 0 }, c = ac(1), u = ac(0), d = Mc(r2);
  if ((d || !d && !a2) && (("body" !== kc(r2) || Ec(i2)) && (l = Fc(r2)), Mc(r2))) {
    var v = Qc(r2);
    c = Hc(r2), u.x = v.x + r2.clientLeft, u.y = v.y + r2.clientTop;
  }
  return { width: n2.width * c.x, height: n2.height * c.y, x: n2.x * c.x - l.scrollLeft * c.x + u.x, y: n2.y * c.y - l.scrollTop * c.y + u.y };
}, getDocumentElement: Oc, getClippingRect: function(e2) {
  var { element: t3, boundary: n2, rootBoundary: r2, strategy: o2 } = e2, a2 = "clippingAncestors" === n2 ? Ic(t3) ? [] : function(e3, t4) {
    var n3 = t4.get(e3);
    if (n3) return n3;
    for (var r3 = Dc(e3, [], false).filter((e4) => qc(e4) && "body" !== kc(e4)), o3 = null, a3 = "fixed" === Bc(e3).position, i3 = a3 ? Uc(e3) : e3; qc(i3) && !Nc(i3); ) {
      var s3 = Bc(i3), l2 = Tc(i3);
      l2 || "fixed" !== s3.position || (o3 = null), (a3 ? !l2 && !o3 : !l2 && "static" === s3.position && o3 && ["absolute", "fixed"].includes(o3.position) || Ec(i3) && !l2 && Zc(e3, i3)) ? r3 = r3.filter((e4) => e4 !== i3) : o3 = s3, i3 = Uc(i3);
    }
    return t4.set(e3, r3), r3;
  }(t3, this._c) : [].concat(n2), i2 = [...a2, r2], s2 = i2[0], l = i2.reduce((e3, n3) => {
    var r3 = Kc(t3, n3, o2);
    return e3.top = nc(r3.top, e3.top), e3.right = tc(r3.right, e3.right), e3.bottom = tc(r3.bottom, e3.bottom), e3.left = nc(r3.left, e3.left), e3;
  }, Kc(t3, s2, o2));
  return { width: l.right - l.left, height: l.bottom - l.top, x: l.left, y: l.top };
}, getOffsetParent: tu, getElementRects: function() {
  var e2 = o(function* (e3) {
    var t3 = this.getOffsetParent || tu, n2 = this.getDimensions, r2 = yield n2(e3.floating);
    return { reference: Xc(e3.reference, yield t3(e3.floating), e3.strategy), floating: { x: 0, y: 0, width: r2.width, height: r2.height } };
  });
  return function(t3) {
    return e2.apply(this, arguments);
  };
}(), getClientRects: function(e2) {
  return Array.from(e2.getClientRects());
}, getDimensions: function(e2) {
  var { width: t3, height: n2 } = Jc(e2);
  return { width: t3, height: n2 };
}, getScale: Hc, isElement: qc, isRTL: function(e2) {
  return "rtl" === Bc(e2).direction;
} };
function ru(e2, t3, n2, r2) {
  void 0 === r2 && (r2 = {});
  var { ancestorScroll: o2 = true, ancestorResize: a2 = true, elementResize: s2 = "function" == typeof ResizeObserver, layoutShift: l = "function" == typeof IntersectionObserver, animationFrame: c = false } = r2, u = Vc(e2), d = o2 || a2 ? [...u ? Dc(u) : [], ...Dc(t3)] : [];
  d.forEach((e3) => {
    o2 && e3.addEventListener("scroll", n2, { passive: true }), a2 && e3.addEventListener("resize", n2);
  });
  var v, p = u && l ? function(e3, t4) {
    var n3, r3 = null, o3 = Oc(e3);
    function a3() {
      var e4;
      clearTimeout(n3), null == (e4 = r3) || e4.disconnect(), r3 = null;
    }
    return function s3(l2, c2) {
      void 0 === l2 && (l2 = false), void 0 === c2 && (c2 = 1), a3();
      var { left: u2, top: d2, width: v2, height: p2 } = e3.getBoundingClientRect();
      if (l2 || t4(), v2 && p2) {
        var f2 = { rootMargin: -oc(d2) + "px " + -oc(o3.clientWidth - (u2 + v2)) + "px " + -oc(o3.clientHeight - (d2 + p2)) + "px " + -oc(u2) + "px", threshold: nc(0, tc(1, c2)) || 1 }, m4 = true;
        try {
          r3 = new IntersectionObserver(h3, i(i({}, f2), {}, { root: o3.ownerDocument }));
        } catch (e4) {
          r3 = new IntersectionObserver(h3, f2);
        }
        r3.observe(e3);
      }
      function h3(e4) {
        var t5 = e4[0].intersectionRatio;
        if (t5 !== c2) {
          if (!m4) return s3();
          t5 ? s3(false, t5) : n3 = setTimeout(() => {
            s3(false, 1e-7);
          }, 1e3);
        }
        m4 = false;
      }
    }(true), a3;
  }(u, n2) : null, f = -1, m3 = null;
  s2 && (m3 = new ResizeObserver((e3) => {
    var [r3] = e3;
    r3 && r3.target === u && m3 && (m3.unobserve(t3), cancelAnimationFrame(f), f = requestAnimationFrame(() => {
      var e4;
      null == (e4 = m3) || e4.observe(t3);
    })), n2();
  }), u && !c && m3.observe(u), m3.observe(t3));
  var h2 = c ? Qc(e2) : null;
  return c && function t4() {
    var r3 = Qc(e2);
    !h2 || r3.x === h2.x && r3.y === h2.y && r3.width === h2.width && r3.height === h2.height || n2();
    h2 = r3, v = requestAnimationFrame(t4);
  }(), n2(), () => {
    var e3;
    d.forEach((e4) => {
      o2 && e4.removeEventListener("scroll", n2), a2 && e4.removeEventListener("resize", n2);
    }), null == p || p(), null == (e3 = m3) || e3.disconnect(), m3 = null, c && cancelAnimationFrame(v);
  };
}
var ou = function(e2) {
  return void 0 === e2 && (e2 = 0), { name: "offset", options: e2, fn: (t3) => o(function* () {
    var n2, r2, { x: o2, y: a2, placement: s2, middlewareData: l } = t3, c = yield function(e3, t4) {
      return Cc.apply(this, arguments);
    }(t3, e2);
    return s2 === (null == (n2 = l.offset) ? void 0 : n2.placement) && null != (r2 = l.arrow) && r2.alignmentOffset ? {} : { x: o2 + c.x, y: a2 + c.y, data: i(i({}, c), {}, { placement: s2 }) };
  })() };
};
var au = function(e2) {
  return void 0 === e2 && (e2 = {}), { name: "shift", options: e2, fn: (r2) => o(function* () {
    var { x: o2, y: a2, placement: s2 } = r2, l = cc(e2, r2), { mainAxis: c = true, crossAxis: u = false, limiter: d = { fn: (e3) => {
      var { x: t3, y: n2 } = e3;
      return { x: t3, y: n2 };
    } } } = l, v = n(l, t2), p = { x: o2, y: a2 }, f = yield $c(r2, v), m3 = fc(uc(s2)), h2 = vc(m3), g = p[h2], j = p[m3];
    if (c) {
      var x = "y" === h2 ? "bottom" : "right";
      g = lc(g + f["y" === h2 ? "top" : "left"], g, g - f[x]);
    }
    if (u) {
      var b2 = "y" === m3 ? "bottom" : "right";
      j = lc(j + f["y" === m3 ? "top" : "left"], j, j - f[b2]);
    }
    var y = d.fn(i(i({}, r2), {}, { [h2]: g, [m3]: j }));
    return i(i({}, y), {}, { data: { x: y.x - o2, y: y.y - a2 } });
  })() };
};
var iu = function(t3) {
  return void 0 === t3 && (t3 = {}), { name: "flip", options: t3, fn: (r2) => o(function* () {
    var o2, a2, { placement: i2, middlewareData: s2, rects: l, initialPlacement: c, platform: u, elements: d } = r2, v = cc(t3, r2), { mainAxis: p = true, crossAxis: f = true, fallbackPlacements: m3, fallbackStrategy: h2 = "bestFit", fallbackAxisSideDirection: g = "none", flipAlignment: j = true } = v, x = n(v, e);
    if (null != (o2 = s2.arrow) && o2.alignmentOffset) return {};
    var b2 = uc(i2), y = fc(c), $2 = uc(c) === c, w = yield null == u.isRTL ? void 0 : u.isRTL(d.floating), C3 = m3 || ($2 || !j ? [gc(c)] : function(e2) {
      var t4 = gc(e2);
      return [hc(e2), t4, hc(t4)];
    }(c)), k2 = "none" !== g;
    !m3 && k2 && C3.push(...function(e2, t4, n2, r3) {
      var o3 = dc(e2), a3 = function(e3, t5, n3) {
        var r4 = ["left", "right"], o4 = ["right", "left"];
        switch (e3) {
          case "top":
          case "bottom":
            return n3 ? t5 ? o4 : r4 : t5 ? r4 : o4;
          case "left":
          case "right":
            return t5 ? ["top", "bottom"] : ["bottom", "top"];
          default:
            return [];
        }
      }(uc(e2), "start" === n2, r3);
      return o3 && (a3 = a3.map((e3) => e3 + "-" + o3), t4 && (a3 = a3.concat(a3.map(hc)))), a3;
    }(c, j, g, w));
    var S4 = [c, ...C3], O = yield $c(r2, x), z3 = [], q2 = (null == (a2 = s2.flip) ? void 0 : a2.overflows) || [];
    if (p && z3.push(O[b2]), f) {
      var M3 = function(e2, t4, n2) {
        void 0 === n2 && (n2 = false);
        var r3 = dc(e2), o3 = mc(e2), a3 = pc(o3), i3 = "x" === o3 ? r3 === (n2 ? "end" : "start") ? "right" : "left" : "start" === r3 ? "bottom" : "top";
        return t4.reference[a3] > t4.floating[a3] && (i3 = gc(i3)), [i3, gc(i3)];
      }(i2, l, w);
      z3.push(O[M3[0]], O[M3[1]]);
    }
    if (q2 = [...q2, { placement: i2, overflows: z3 }], !z3.every((e2) => e2 <= 0)) {
      var R3, E3, P3 = ((null == (R3 = s2.flip) ? void 0 : R3.index) || 0) + 1, I3 = S4[P3];
      if (I3) return { data: { index: P3, overflows: q2 }, reset: { placement: I3 } };
      var T3 = null == (E3 = q2.filter((e2) => e2.overflows[0] <= 0).sort((e2, t4) => e2.overflows[1] - t4.overflows[1])[0]) ? void 0 : E3.placement;
      if (!T3) switch (h2) {
        case "bestFit":
          var A, N3 = null == (A = q2.filter((e2) => {
            if (k2) {
              var t4 = fc(e2.placement);
              return t4 === y || "y" === t4;
            }
            return true;
          }).map((e2) => [e2.placement, e2.overflows.filter((e3) => e3 > 0).reduce((e3, t4) => e3 + t4, 0)]).sort((e2, t4) => e2[1] - t4[1])[0]) ? void 0 : A[0];
          N3 && (T3 = N3);
          break;
        case "initialPlacement":
          T3 = c;
      }
      if (i2 !== T3) return { reset: { placement: T3 } };
    }
    return {};
  })() };
};
var su = (e2, t3, n2) => {
  var r2 = /* @__PURE__ */ new Map(), o2 = i({ platform: nu }, n2), a2 = i(i({}, o2.platform), {}, { _c: r2 });
  return yc(e2, t3, i(i({}, o2), {}, { platform: a2 }));
};
function lu(e2) {
  var { loadOptions: t3, filterText: n2, items: r2, multiple: o2, value: a2, itemId: i2, groupBy: s2, filterSelectedItems: l, itemFilter: c, convertStringItemsToObjects: u, filterGroupedItems: d, label: v } = e2;
  if (r2 && t3) return r2;
  if (!r2) return [];
  r2 && r2.length > 0 && "object" != typeof r2[0] && (r2 = u(r2));
  var p = r2.filter((e3) => {
    var t4 = c(e3[v], n2, e3);
    return t4 && o2 && null != a2 && a2.length && (t4 = !a2.some((t5) => !!l && t5[i2] === e3[i2])), t4;
  });
  return s2 && (p = d(p)), p;
}
function cu(e2) {
  return uu.apply(this, arguments);
}
function uu() {
  return uu = o(function* (e2) {
    var { dispatch: t3, loadOptions: n2, convertStringItemsToObjects: r2, filterText: o2 } = e2, a2 = yield n2(o2).catch((e3) => {
      console.warn("svelte-select loadOptions error :>> ", e3), t3("error", { type: "loadOptions", details: e3 });
    });
    if (a2 && !a2.cancelled) return a2 ? (a2 && a2.length > 0 && "object" != typeof a2[0] && (a2 = r2(a2)), t3("loaded", { items: a2 })) : a2 = [], { filteredItems: a2, loading: false, focused: true, listOpen: true };
  }), uu.apply(this, arguments);
}
function du(e2) {
  rn(e2, "svelte-qbd276", "svg.svelte-qbd276{width:var(--chevron-icon-width, 20px);height:var(--chevron-icon-width, 20px);color:var(--chevron-icon-colour, currentColor)}");
}
function vu(e2) {
  var t3, n2;
  return { c() {
    t3 = cn("svg"), hn(n2 = cn("path"), "fill", "currentColor"), hn(n2, "d", "M4.516 7.548c0.436-0.446 1.043-0.481 1.576 0l3.908 3.747\n          3.908-3.747c0.533-0.481 1.141-0.446 1.574 0 0.436 0.445 0.408 1.197 0\n          1.615-0.406 0.418-4.695 4.502-4.695 4.502-0.217 0.223-0.502\n          0.335-0.787 0.335s-0.57-0.112-0.789-0.335c0\n          0-4.287-4.084-4.695-4.502s-0.436-1.17 0-1.615z"), hn(t3, "width", "100%"), hn(t3, "height", "100%"), hn(t3, "viewBox", "0 0 20 20"), hn(t3, "focusable", "false"), hn(t3, "aria-hidden", "true"), hn(t3, "class", "svelte-qbd276");
  }, m(e3, r2) {
    on(e3, t3, r2), nn(t3, n2);
  }, p: Bt, i: Bt, o: Bt, d(e3) {
    e3 && an(t3);
  } };
}
var pu = class extends dr {
  constructor(e2) {
    super(), ur(this, e2, null, vu, Vt, {}, du);
  }
};
function fu(e2) {
  rn(e2, "svelte-whdbu1", "svg.svelte-whdbu1{width:var(--clear-icon-width, 20px);height:var(--clear-icon-width, 20px);color:var(--clear-icon-color, currentColor)}");
}
function mu(e2) {
  var t3, n2;
  return { c() {
    t3 = cn("svg"), hn(n2 = cn("path"), "fill", "currentColor"), hn(n2, "d", "M34.923,37.251L24,26.328L13.077,37.251L9.436,33.61l10.923-10.923L9.436,11.765l3.641-3.641L24,19.047L34.923,8.124\n    l3.641,3.641L27.641,22.688L38.564,33.61L34.923,37.251z"), hn(t3, "width", "100%"), hn(t3, "height", "100%"), hn(t3, "viewBox", "-2 -2 50 50"), hn(t3, "focusable", "false"), hn(t3, "aria-hidden", "true"), hn(t3, "role", "presentation"), hn(t3, "class", "svelte-whdbu1");
  }, m(e3, r2) {
    on(e3, t3, r2), nn(t3, n2);
  }, p: Bt, i: Bt, o: Bt, d(e3) {
    e3 && an(t3);
  } };
}
var hu = class extends dr {
  constructor(e2) {
    super(), ur(this, e2, null, mu, Vt, {}, fu);
  }
};
function gu(e2) {
  rn(e2, "svelte-1p3nqvd", ".loading.svelte-1p3nqvd{width:var(--spinner-width, 20px);height:var(--spinner-height, 20px);color:var(--spinner-color, var(--icons-color));animation:svelte-1p3nqvd-rotate 0.75s linear infinite;transform-origin:center center;transform:none}.circle_path.svelte-1p3nqvd{stroke-dasharray:90;stroke-linecap:round}@keyframes svelte-1p3nqvd-rotate{100%{transform:rotate(360deg)}}");
}
function ju(e2) {
  var t3, n2;
  return { c() {
    t3 = cn("svg"), hn(n2 = cn("circle"), "class", "circle_path svelte-1p3nqvd"), hn(n2, "cx", "50"), hn(n2, "cy", "50"), hn(n2, "r", "20"), hn(n2, "fill", "none"), hn(n2, "stroke", "currentColor"), hn(n2, "stroke-width", "5"), hn(n2, "stroke-miterlimit", "10"), hn(t3, "class", "loading svelte-1p3nqvd"), hn(t3, "viewBox", "25 25 50 50");
  }, m(e3, r2) {
    on(e3, t3, r2), nn(t3, n2);
  }, p: Bt, i: Bt, o: Bt, d(e3) {
    e3 && an(t3);
  } };
}
var xu = class extends dr {
  constructor(e2) {
    super(), ur(this, e2, null, ju, Vt, {}, gu);
  }
};
function bu(e2) {
  rn(e2, "svelte-82qwg8", ".svelte-select.svelte-82qwg8.svelte-82qwg8.svelte-82qwg8{--borderRadius:var(--border-radius);--clearSelectColor:var(--clear-select-color);--clearSelectWidth:var(--clear-select-width);--disabledBackground:var(--disabled-background);--disabledBorderColor:var(--disabled-border-color);--disabledColor:var(--disabled-color);--disabledPlaceholderColor:var(--disabled-placeholder-color);--disabledPlaceholderOpacity:var(--disabled-placeholder-opacity);--errorBackground:var(--error-background);--errorBorder:var(--error-border);--groupItemPaddingLeft:var(--group-item-padding-left);--groupTitleColor:var(--group-title-color);--groupTitleFontSize:var(--group-title-font-size);--groupTitleFontWeight:var(--group-title-font-weight);--groupTitlePadding:var(--group-title-padding);--groupTitleTextTransform:var(--group-title-text-transform);--groupTitleBorderColor:var(--group-title-border-color);--groupTitleBorderWidth:var(--group-title-border-width);--groupTitleBorderStyle:var(--group-title-border-style);--indicatorColor:var(--chevron-color);--indicatorHeight:var(--chevron-height);--indicatorWidth:var(--chevron-width);--inputColor:var(--input-color);--inputLeft:var(--input-left);--inputLetterSpacing:var(--input-letter-spacing);--inputMargin:var(--input-margin);--inputPadding:var(--input-padding);--itemActiveBackground:var(--item-active-background);--itemColor:var(--item-color);--itemFirstBorderRadius:var(--item-first-border-radius);--itemHoverBG:var(--item-hover-bg);--itemHoverColor:var(--item-hover-color);--itemIsActiveBG:var(--item-is-active-bg);--itemIsActiveColor:var(--item-is-active-color);--itemIsNotSelectableColor:var(--item-is-not-selectable-color);--itemPadding:var(--item-padding);--listBackground:var(--list-background);--listBorder:var(--list-border);--listBorderRadius:var(--list-border-radius);--listEmptyColor:var(--list-empty-color);--listEmptyPadding:var(--list-empty-padding);--listEmptyTextAlign:var(--list-empty-text-align);--listMaxHeight:var(--list-max-height);--listPosition:var(--list-position);--listShadow:var(--list-shadow);--listZIndex:var(--list-z-index);--multiItemBG:var(--multi-item-bg);--multiItemBorderRadius:var(--multi-item-border-radius);--multiItemDisabledHoverBg:var(--multi-item-disabled-hover-bg);--multiItemDisabledHoverColor:var(--multi-item-disabled-hover-color);--multiItemHeight:var(--multi-item-height);--multiItemMargin:var(--multi-item-margin);--multiItemPadding:var(--multi-item-padding);--multiSelectInputMargin:var(--multi-select-input-margin);--multiSelectInputPadding:var(--multi-select-input-padding);--multiSelectPadding:var(--multi-select-padding);--placeholderColor:var(--placeholder-color);--placeholderOpacity:var(--placeholder-opacity);--selectedItemPadding:var(--selected-item-padding);--spinnerColor:var(--spinner-color);--spinnerHeight:var(--spinner-height);--spinnerWidth:var(--spinner-width);--internal-padding:0 0 0 16px;border:var(--border, 1px solid #d8dbdf);border-radius:var(--border-radius, 6px);min-height:var(--height, 42px);position:relative;display:flex;align-items:stretch;padding:var(--padding, var(--internal-padding));background:var(--background, #fff);margin:var(--margin, 0);width:var(--width, 100%);font-size:var(--font-size, 16px);max-height:var(--max-height)}.svelte-82qwg8.svelte-82qwg8.svelte-82qwg8{box-sizing:var(--box-sizing, border-box)}.svelte-select.svelte-82qwg8.svelte-82qwg8.svelte-82qwg8:hover{border:var(--border-hover, 1px solid #b2b8bf)}.value-container.svelte-82qwg8.svelte-82qwg8.svelte-82qwg8{display:flex;flex:1 1 0%;flex-wrap:wrap;align-items:center;gap:5px 10px;padding:var(--value-container-padding, 5px 0);position:relative;overflow:var(--value-container-overflow, hidden);align-self:stretch}.prepend.svelte-82qwg8.svelte-82qwg8.svelte-82qwg8,.indicators.svelte-82qwg8.svelte-82qwg8.svelte-82qwg8{display:flex;flex-shrink:0;align-items:center}.indicators.svelte-82qwg8.svelte-82qwg8.svelte-82qwg8{position:var(--indicators-position);top:var(--indicators-top);right:var(--indicators-right);bottom:var(--indicators-bottom)}input.svelte-82qwg8.svelte-82qwg8.svelte-82qwg8{position:absolute;cursor:default;border:none;color:var(--input-color, var(--item-color));padding:var(--input-padding, 0);letter-spacing:var(--input-letter-spacing, inherit);margin:var(--input-margin, 0);min-width:10px;top:0;right:0;bottom:0;left:0;background:transparent;font-size:var(--font-size, 16px)}.svelte-82qwg8:not(.multi)>.value-container.svelte-82qwg8>input.svelte-82qwg8{width:100%;height:100%}input.svelte-82qwg8.svelte-82qwg8.svelte-82qwg8::placeholder{color:var(--placeholder-color, #78848f);opacity:var(--placeholder-opacity, 1)}input.svelte-82qwg8.svelte-82qwg8.svelte-82qwg8:focus{outline:none}.svelte-select.focused.svelte-82qwg8.svelte-82qwg8.svelte-82qwg8{border:var(--border-focused, 1px solid #006fe8);border-radius:var(--border-radius-focused, var(--border-radius, 6px))}.disabled.svelte-82qwg8.svelte-82qwg8.svelte-82qwg8{background:var(--disabled-background, #ebedef);border-color:var(--disabled-border-color, #ebedef);color:var(--disabled-color, #c1c6cc)}.disabled.svelte-82qwg8 input.svelte-82qwg8.svelte-82qwg8::placeholder{color:var(--disabled-placeholder-color, #c1c6cc);opacity:var(--disabled-placeholder-opacity, 1)}.selected-item.svelte-82qwg8.svelte-82qwg8.svelte-82qwg8{position:relative;overflow:var(--selected-item-overflow, hidden);padding:var(--selected-item-padding, 0 20px 0 0);text-overflow:ellipsis;white-space:nowrap;color:var(--selected-item-color, inherit);font-size:var(--font-size, 16px)}.multi.svelte-82qwg8 .selected-item.svelte-82qwg8.svelte-82qwg8{position:absolute;line-height:var(--height, 42px);height:var(--height, 42px)}.selected-item.svelte-82qwg8.svelte-82qwg8.svelte-82qwg8:focus{outline:none}.hide-selected-item.svelte-82qwg8.svelte-82qwg8.svelte-82qwg8{opacity:0}.icon.svelte-82qwg8.svelte-82qwg8.svelte-82qwg8{display:flex;align-items:center;justify-content:center}.clear-select.svelte-82qwg8.svelte-82qwg8.svelte-82qwg8{all:unset;display:flex;align-items:center;justify-content:center;width:var(--clear-select-width, 40px);height:var(--clear-select-height, 100%);color:var(--clear-select-color, var(--icons-color));margin:var(--clear-select-margin, 0);pointer-events:all;flex-shrink:0}.clear-select.svelte-82qwg8.svelte-82qwg8.svelte-82qwg8:focus{outline:var(--clear-select-focus-outline, 1px solid #006fe8)}.loading.svelte-82qwg8.svelte-82qwg8.svelte-82qwg8{width:var(--loading-width, 40px);height:var(--loading-height);color:var(--loading-color, var(--icons-color));margin:var(--loading--margin, 0);flex-shrink:0}.chevron.svelte-82qwg8.svelte-82qwg8.svelte-82qwg8{width:var(--chevron-width, 40px);height:var(--chevron-height, 40px);background:var(--chevron-background, transparent);pointer-events:var(--chevron-pointer-events, none);color:var(--chevron-color, var(--icons-color));border:var(--chevron-border, 0 0 0 1px solid #d8dbdf);flex-shrink:0}.multi.svelte-82qwg8.svelte-82qwg8.svelte-82qwg8{padding:var(--multi-select-padding, var(--internal-padding))}.multi.svelte-82qwg8 input.svelte-82qwg8.svelte-82qwg8{padding:var(--multi-select-input-padding, 0);position:relative;margin:var(--multi-select-input-margin, 5px 0);flex:1 1 40px}.svelte-select.error.svelte-82qwg8.svelte-82qwg8.svelte-82qwg8{border:var(--error-border, 1px solid #ff2d55);background:var(--error-background, #fff)}.a11y-text.svelte-82qwg8.svelte-82qwg8.svelte-82qwg8{z-index:9999;border:0px;clip:rect(1px, 1px, 1px, 1px);height:1px;width:1px;position:absolute;overflow:hidden;padding:0px;white-space:nowrap}.multi-item.svelte-82qwg8.svelte-82qwg8.svelte-82qwg8{background:var(--multi-item-bg, #ebedef);margin:var(--multi-item-margin, 0);outline:var(--multi-item-outline, 1px solid #ddd);border-radius:var(--multi-item-border-radius, 4px);height:var(--multi-item-height, 25px);line-height:var(--multi-item-height, 25px);display:flex;cursor:default;padding:var(--multi-item-padding, 0 5px);overflow:hidden;gap:var(--multi-item-gap, 4px);outline-offset:-1px;max-width:var(--multi-max-width, none);color:var(--multi-item-color, var(--item-color))}.multi-item.disabled.svelte-82qwg8.svelte-82qwg8.svelte-82qwg8:hover{background:var(--multi-item-disabled-hover-bg, #ebedef);color:var(--multi-item-disabled-hover-color, #c1c6cc)}.multi-item-text.svelte-82qwg8.svelte-82qwg8.svelte-82qwg8{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.multi-item-clear.svelte-82qwg8.svelte-82qwg8.svelte-82qwg8{display:flex;align-items:center;justify-content:center;--clear-icon-color:var(--multi-item-clear-icon-color, #000)}.multi-item.active.svelte-82qwg8.svelte-82qwg8.svelte-82qwg8{outline:var(--multi-item-active-outline, 1px solid #006fe8)}.svelte-select-list.svelte-82qwg8.svelte-82qwg8.svelte-82qwg8{box-shadow:var(--list-shadow, 0 2px 3px 0 rgba(44, 62, 80, 0.24));border-radius:var(--list-border-radius, 4px);max-height:var(--list-max-height, 252px);overflow-y:auto;background:var(--list-background, #fff);position:var(--list-position, absolute);z-index:var(--list-z-index, 2);border:var(--list-border)}.prefloat.svelte-82qwg8.svelte-82qwg8.svelte-82qwg8{opacity:0;pointer-events:none}.list-group-title.svelte-82qwg8.svelte-82qwg8.svelte-82qwg8{color:var(--group-title-color, #8f8f8f);cursor:default;font-size:var(--group-title-font-size, 16px);font-weight:var(--group-title-font-weight, 600);height:var(--height, 42px);line-height:var(--height, 42px);padding:var(--group-title-padding, 0 20px);text-overflow:ellipsis;overflow-x:hidden;white-space:nowrap;text-transform:var(--group-title-text-transform, uppercase);border-width:var(--group-title-border-width, medium);border-style:var(--group-title-border-style, none);border-color:var(--group-title-border-color, color)}.empty.svelte-82qwg8.svelte-82qwg8.svelte-82qwg8{text-align:var(--list-empty-text-align, center);padding:var(--list-empty-padding, 20px 0);color:var(--list-empty-color, #78848f)}.item.svelte-82qwg8.svelte-82qwg8.svelte-82qwg8{cursor:default;height:var(--item-height, var(--height, 42px));line-height:var(--item-line-height, var(--height, 42px));padding:var(--item-padding, 0 20px);color:var(--item-color, inherit);text-overflow:ellipsis;overflow:hidden;white-space:nowrap;transition:var(--item-transition, all 0.2s);align-items:center;width:100%}.item.group-item.svelte-82qwg8.svelte-82qwg8.svelte-82qwg8{padding-left:var(--group-item-padding-left, 40px)}.item.svelte-82qwg8.svelte-82qwg8.svelte-82qwg8:active{background:var(--item-active-background, #b9daff)}.item.active.svelte-82qwg8.svelte-82qwg8.svelte-82qwg8{background:var(--item-is-active-bg, #007aff);color:var(--item-is-active-color, #fff)}.item.first.svelte-82qwg8.svelte-82qwg8.svelte-82qwg8{border-radius:var(--item-first-border-radius, 4px 4px 0 0)}.item.hover.svelte-82qwg8.svelte-82qwg8.svelte-82qwg8:not(.active){background:var(--item-hover-bg, #e7f2ff);color:var(--item-hover-color, inherit)}.item.not-selectable.svelte-82qwg8.svelte-82qwg8.svelte-82qwg8,.item.hover.item.not-selectable.svelte-82qwg8.svelte-82qwg8.svelte-82qwg8,.item.active.item.not-selectable.svelte-82qwg8.svelte-82qwg8.svelte-82qwg8,.item.not-selectable.svelte-82qwg8.svelte-82qwg8.svelte-82qwg8:active{color:var(--item-is-not-selectable-color, #999);background:transparent}.required.svelte-82qwg8.svelte-82qwg8.svelte-82qwg8{opacity:0;z-index:-1;position:absolute;top:0;left:0;bottom:0;right:0}");
}
var yu = (e2) => ({ value: 8 & e2[0] });
var $u = (e2) => ({ value: e2[3] });
var wu = (e2) => ({ value: 8 & e2[0] });
var Cu = (e2) => ({ value: e2[3] });
var ku = (e2) => ({ listOpen: 64 & e2[0] });
var Su = (e2) => ({ listOpen: e2[6] });
var Ou = (e2) => ({});
var zu = (e2) => ({});
var qu = (e2) => ({});
var Mu = (e2) => ({});
var Ru = (e2) => ({ selection: 8 & e2[0] });
var Eu = (e2) => ({ selection: e2[3] });
function Pu(e2, t3, n2) {
  var r2 = e2.slice();
  return r2[126] = t3[n2], r2[128] = n2, r2;
}
var Iu = (e2) => ({});
var Tu = (e2) => ({});
var Au = (e2) => ({ selection: 8 & e2[0] });
var Nu = (e2) => ({ selection: e2[126], index: e2[128] });
var Bu = (e2) => ({});
var Fu = (e2) => ({});
var Uu = (e2) => ({});
var Lu = (e2) => ({});
var Du = (e2) => ({});
var Ju = (e2) => ({});
function Vu(e2, t3, n2) {
  var r2 = e2.slice();
  return r2[126] = t3[n2], r2[128] = n2, r2;
}
var Hu = (e2) => ({ item: 16777216 & e2[0] });
var _u = (e2) => ({ item: e2[126], index: e2[128] });
var Wu = (e2) => ({ filteredItems: 16777216 & e2[0] });
var Qu = (e2) => ({ filteredItems: e2[24] });
var Yu = (e2) => ({});
var Ku = (e2) => ({});
function Zu(e2) {
  var t3, n2, r2, o2, a2, i2, s2, l, c = e2[50]["list-prepend"] && Xu(e2), u = [td, ed, Gu], d = [];
  function v(e3, t4) {
    return e3[50].list ? 0 : e3[24].length > 0 ? 1 : e3[19] ? -1 : 2;
  }
  ~(r2 = v(e2)) && (o2 = d[r2] = u[r2](e2));
  var p = e2[50]["list-append"] && rd(e2);
  return { c() {
    t3 = ln("div"), c && c.c(), n2 = dn(), o2 && o2.c(), a2 = dn(), p && p.c(), hn(t3, "class", "svelte-select-list svelte-82qwg8"), hn(t3, "role", "none"), kn(t3, "prefloat", e2[28]);
  }, m(o3, u2) {
    on(o3, t3, u2), c && c.m(t3, null), nn(t3, n2), ~r2 && d[r2].m(t3, null), nn(t3, a2), p && p.m(t3, null), e2[91](t3), i2 = true, s2 || (l = [en(e2[49].call(null, t3)), pn(t3, "scroll", e2[41]), pn(t3, "pointerup", mn(fn(e2[85]))), pn(t3, "mousedown", mn(fn(e2[86])))], s2 = true);
  }, p(e3, s3) {
    e3[50]["list-prepend"] ? c ? (c.p(e3, s3), 524288 & s3[1] && Xn(c, 1)) : ((c = Xu(e3)).c(), Xn(c, 1), c.m(t3, n2)) : c && (Kn(), Gn(c, 1, 1, () => {
      c = null;
    }), Zn());
    var l2 = r2;
    (r2 = v(e3)) === l2 ? ~r2 && d[r2].p(e3, s3) : (o2 && (Kn(), Gn(d[l2], 1, 1, () => {
      d[l2] = null;
    }), Zn()), ~r2 ? ((o2 = d[r2]) ? o2.p(e3, s3) : (o2 = d[r2] = u[r2](e3)).c(), Xn(o2, 1), o2.m(t3, a2)) : o2 = null), e3[50]["list-append"] ? p ? (p.p(e3, s3), 524288 & s3[1] && Xn(p, 1)) : ((p = rd(e3)).c(), Xn(p, 1), p.m(t3, null)) : p && (Kn(), Gn(p, 1, 1, () => {
      p = null;
    }), Zn()), (!i2 || 268435456 & s3[0]) && kn(t3, "prefloat", e3[28]);
  }, i(e3) {
    i2 || (Xn(c), Xn(o2), Xn(p), i2 = true);
  }, o(e3) {
    Gn(c), Gn(o2), Gn(p), i2 = false;
  }, d(n3) {
    n3 && an(t3), c && c.d(), ~r2 && d[r2].d(), p && p.d(), e2[91](null), s2 = false, Dt(l);
  } };
}
function Xu(e2) {
  var t3, n2 = e2[83]["list-prepend"], r2 = _t(n2, e2, e2[82], Ku);
  return { c() {
    r2 && r2.c();
  }, m(e3, n3) {
    r2 && r2.m(e3, n3), t3 = true;
  }, p(e3, o2) {
    r2 && r2.p && (!t3 || 1048576 & o2[2]) && Yt(r2, n2, e3, e3[82], t3 ? Qt(n2, e3[82], o2, Yu) : Kt(e3[82]), Ku);
  }, i(e3) {
    t3 || (Xn(r2, e3), t3 = true);
  }, o(e3) {
    Gn(r2, e3), t3 = false;
  }, d(e3) {
    r2 && r2.d(e3);
  } };
}
function Gu(e2) {
  var t3, n2, r2 = e2[83].empty, o2 = _t(r2, e2, e2[82], Ju), a2 = o2 || { c() {
    (n2 = ln("div")).textContent = "No options", hn(n2, "class", "empty svelte-82qwg8");
  }, m(e3, t4) {
    on(e3, n2, t4);
  }, p: Bt, d(e3) {
    e3 && an(n2);
  } };
  return { c() {
    a2 && a2.c();
  }, m(e3, n3) {
    a2 && a2.m(e3, n3), t3 = true;
  }, p(e3, n3) {
    o2 && o2.p && (!t3 || 1048576 & n3[2]) && Yt(o2, r2, e3, e3[82], t3 ? Qt(r2, e3[82], n3, Du) : Kt(e3[82]), Ju);
  }, i(e3) {
    t3 || (Xn(a2, e3), t3 = true);
  }, o(e3) {
    Gn(a2, e3), t3 = false;
  }, d(e3) {
    a2 && a2.d(e3);
  } };
}
function ed(e2) {
  for (var t3, n2, r2 = er(e2[24]), o2 = [], a2 = 0; a2 < r2.length; a2 += 1) o2[a2] = nd(Vu(e2, r2, a2));
  var i2 = (e3) => Gn(o2[e3], 1, 1, () => {
    o2[e3] = null;
  });
  return { c() {
    for (var e3 = 0; e3 < o2.length; e3 += 1) o2[e3].c();
    t3 = vn();
  }, m(e3, r3) {
    for (var a3 = 0; a3 < o2.length; a3 += 1) o2[a3] && o2[a3].m(e3, r3);
    on(e3, t3, r3), n2 = true;
  }, p(e3, n3) {
    if (1627402376 & n3[0] | 28672 & n3[1] | 1048576 & n3[2]) {
      var a3;
      for (r2 = er(e3[24]), a3 = 0; a3 < r2.length; a3 += 1) {
        var s2 = Vu(e3, r2, a3);
        o2[a3] ? (o2[a3].p(s2, n3), Xn(o2[a3], 1)) : (o2[a3] = nd(s2), o2[a3].c(), Xn(o2[a3], 1), o2[a3].m(t3.parentNode, t3));
      }
      for (Kn(), a3 = r2.length; a3 < o2.length; a3 += 1) i2(a3);
      Zn();
    }
  }, i(e3) {
    if (!n2) {
      for (var t4 = 0; t4 < r2.length; t4 += 1) Xn(o2[t4]);
      n2 = true;
    }
  }, o(e3) {
    o2 = o2.filter(Boolean);
    for (var t4 = 0; t4 < o2.length; t4 += 1) Gn(o2[t4]);
    n2 = false;
  }, d(e3) {
    e3 && an(t3), sn(o2, e3);
  } };
}
function td(e2) {
  var t3, n2 = e2[83].list, r2 = _t(n2, e2, e2[82], Qu);
  return { c() {
    r2 && r2.c();
  }, m(e3, n3) {
    r2 && r2.m(e3, n3), t3 = true;
  }, p(e3, o2) {
    r2 && r2.p && (!t3 || 16777216 & o2[0] | 1048576 & o2[2]) && Yt(r2, n2, e3, e3[82], t3 ? Qt(n2, e3[82], o2, Wu) : Kt(e3[82]), Qu);
  }, i(e3) {
    t3 || (Xn(r2, e3), t3 = true);
  }, o(e3) {
    Gn(r2, e3), t3 = false;
  }, d(e3) {
    r2 && r2.d(e3);
  } };
}
function nd(e2) {
  var t3, n2, r2, o2, a2, i2, s2, l, c = e2[83].item, u = _t(c, e2, e2[82], _u), d = u || function(e3) {
    var t4, n3, r3 = (null === (t4 = e3[126]) || void 0 === t4 ? void 0 : t4[e3[12]]) + "";
    return { c() {
      n3 = un(r3);
    }, m(e4, t5) {
      on(e4, n3, t5);
    }, p(e4, t5) {
      var o3;
      16781312 & t5[0] && r3 !== (r3 = (null === (o3 = e4[126]) || void 0 === o3 ? void 0 : o3[e4[12]]) + "") && yn(n3, r3);
    }, d(e4) {
      e4 && an(n3);
    } };
  }(e2);
  function v() {
    return e2[88](e2[128]);
  }
  function p() {
    return e2[89](e2[128]);
  }
  function f() {
    return e2[90](e2[126], e2[128]);
  }
  return { c() {
    var r3;
    t3 = ln("div"), n2 = ln("div"), d && d.c(), a2 = dn(), hn(n2, "class", "item svelte-82qwg8"), kn(n2, "list-group-title", e2[126].groupHeader), kn(n2, "active", e2[45](e2[126], e2[3], e2[13])), kn(n2, "first", 0 === e2[128]), kn(n2, "hover", e2[7] === e2[128]), kn(n2, "group-item", e2[126].groupItem), kn(n2, "not-selectable", false === (null === (r3 = e2[126]) || void 0 === r3 ? void 0 : r3.selectable)), hn(t3, "class", "list-item svelte-82qwg8"), hn(t3, "tabindex", "-1"), hn(t3, "role", "none");
  }, m(c2, u2) {
    on(c2, t3, u2), nn(t3, n2), d && d.m(n2, null), nn(t3, a2), i2 = true, s2 || (l = [en(r2 = e2[46].call(null, n2, { scroll: e2[45](e2[126], e2[3], e2[13]), listDom: e2[30] })), en(o2 = e2[47].call(null, n2, { scroll: e2[29] === e2[128], listDom: e2[30] })), pn(t3, "mouseover", v), pn(t3, "focus", p), pn(t3, "click", mn(f)), pn(t3, "keydown", mn(fn(e2[87])))], s2 = true);
  }, p(t4, a3) {
    var s3;
    (e2 = t4, u ? u.p && (!i2 || 16777216 & a3[0] | 1048576 & a3[2]) && Yt(u, c, e2, e2[82], i2 ? Qt(c, e2[82], a3, Hu) : Kt(e2[82]), _u) : d && d.p && (!i2 || 16781312 & a3[0]) && d.p(e2, i2 ? a3 : [-1, -1, -1, -1, -1]), r2 && Jt(r2.update) && 1090527240 & a3[0] && r2.update.call(null, { scroll: e2[45](e2[126], e2[3], e2[13]), listDom: e2[30] }), o2 && Jt(o2.update) && 1610612736 & a3[0] && o2.update.call(null, { scroll: e2[29] === e2[128], listDom: e2[30] }), (!i2 || 16777216 & a3[0]) && kn(n2, "list-group-title", e2[126].groupHeader), (!i2 || 16785416 & a3[0] | 16384 & a3[1]) && kn(n2, "active", e2[45](e2[126], e2[3], e2[13])), (!i2 || 128 & a3[0]) && kn(n2, "hover", e2[7] === e2[128]), (!i2 || 16777216 & a3[0]) && kn(n2, "group-item", e2[126].groupItem), !i2 || 16777216 & a3[0]) && kn(n2, "not-selectable", false === (null === (s3 = e2[126]) || void 0 === s3 ? void 0 : s3.selectable));
  }, i(e3) {
    i2 || (Xn(d, e3), i2 = true);
  }, o(e3) {
    Gn(d, e3), i2 = false;
  }, d(e3) {
    e3 && an(t3), d && d.d(e3), s2 = false, Dt(l);
  } };
}
function rd(e2) {
  var t3, n2 = e2[83]["list-append"], r2 = _t(n2, e2, e2[82], Lu);
  return { c() {
    r2 && r2.c();
  }, m(e3, n3) {
    r2 && r2.m(e3, n3), t3 = true;
  }, p(e3, o2) {
    r2 && r2.p && (!t3 || 1048576 & o2[2]) && Yt(r2, n2, e3, e3[82], t3 ? Qt(n2, e3[82], o2, Uu) : Kt(e3[82]), Lu);
  }, i(e3) {
    t3 || (Xn(r2, e3), t3 = true);
  }, o(e3) {
    Gn(r2, e3), t3 = false;
  }, d(e3) {
    r2 && r2.d(e3);
  } };
}
function od(e2) {
  var t3, n2, r2, o2, a2;
  return { c() {
    t3 = ln("span"), n2 = un(e2[32]), r2 = dn(), o2 = ln("span"), a2 = un(e2[31]), hn(t3, "id", "aria-selection"), hn(t3, "class", "svelte-82qwg8"), hn(o2, "id", "aria-context"), hn(o2, "class", "svelte-82qwg8");
  }, m(e3, i2) {
    on(e3, t3, i2), nn(t3, n2), on(e3, r2, i2), on(e3, o2, i2), nn(o2, a2);
  }, p(e3, t4) {
    2 & t4[1] && yn(n2, e3[32]), 1 & t4[1] && yn(a2, e3[31]);
  }, d(e3) {
    e3 && (an(t3), an(r2), an(o2));
  } };
}
function ad(e2) {
  var t3, n2, r2, o2, a2 = [sd, id], i2 = [];
  function s2(e3, t4) {
    return e3[9] ? 0 : 1;
  }
  return t3 = s2(e2), n2 = i2[t3] = a2[t3](e2), { c() {
    n2.c(), r2 = vn();
  }, m(e3, n3) {
    i2[t3].m(e3, n3), on(e3, r2, n3), o2 = true;
  }, p(e3, o3) {
    var l = t3;
    (t3 = s2(e3)) === l ? i2[t3].p(e3, o3) : (Kn(), Gn(i2[l], 1, 1, () => {
      i2[l] = null;
    }), Zn(), (n2 = i2[t3]) ? n2.p(e3, o3) : (n2 = i2[t3] = a2[t3](e3)).c(), Xn(n2, 1), n2.m(r2.parentNode, r2));
  }, i(e3) {
    o2 || (Xn(n2), o2 = true);
  }, o(e3) {
    Gn(n2), o2 = false;
  }, d(e3) {
    e3 && an(r2), i2[t3].d(e3);
  } };
}
function id(e2) {
  var t3, n2, r2 = e2[83].selection, o2 = _t(r2, e2, e2[82], Eu), a2 = o2 || function(e3) {
    var t4, n3 = e3[3][e3[12]] + "";
    return { c() {
      t4 = un(n3);
    }, m(e4, n4) {
      on(e4, t4, n4);
    }, p(e4, r3) {
      4104 & r3[0] && n3 !== (n3 = e4[3][e4[12]] + "") && yn(t4, n3);
    }, d(e4) {
      e4 && an(t4);
    } };
  }(e2);
  return { c() {
    t3 = ln("div"), a2 && a2.c(), hn(t3, "class", "selected-item svelte-82qwg8"), kn(t3, "hide-selected-item", e2[35]);
  }, m(e3, r3) {
    on(e3, t3, r3), a2 && a2.m(t3, null), n2 = true;
  }, p(e3, i2) {
    o2 ? o2.p && (!n2 || 8 & i2[0] | 1048576 & i2[2]) && Yt(o2, r2, e3, e3[82], n2 ? Qt(r2, e3[82], i2, Ru) : Kt(e3[82]), Eu) : a2 && a2.p && (!n2 || 4104 & i2[0]) && a2.p(e3, n2 ? i2 : [-1, -1, -1, -1, -1]), (!n2 || 16 & i2[1]) && kn(t3, "hide-selected-item", e3[35]);
  }, i(e3) {
    n2 || (Xn(a2, e3), n2 = true);
  }, o(e3) {
    Gn(a2, e3), n2 = false;
  }, d(e3) {
    e3 && an(t3), a2 && a2.d(e3);
  } };
}
function sd(e2) {
  for (var t3, n2, r2 = er(e2[3]), o2 = [], a2 = 0; a2 < r2.length; a2 += 1) o2[a2] = cd(Pu(e2, r2, a2));
  var i2 = (e3) => Gn(o2[e3], 1, 1, () => {
    o2[e3] = null;
  });
  return { c() {
    for (var e3 = 0; e3 < o2.length; e3 += 1) o2[e3].c();
    t3 = vn();
  }, m(e3, r3) {
    for (var a3 = 0; a3 < o2.length; a3 += 1) o2[a3] && o2[a3].m(e3, r3);
    on(e3, t3, r3), n2 = true;
  }, p(e3, n3) {
    if (67116040 & n3[0] | 32 & n3[1] | 1048576 & n3[2]) {
      var a3;
      for (r2 = er(e3[3]), a3 = 0; a3 < r2.length; a3 += 1) {
        var s2 = Pu(e3, r2, a3);
        o2[a3] ? (o2[a3].p(s2, n3), Xn(o2[a3], 1)) : (o2[a3] = cd(s2), o2[a3].c(), Xn(o2[a3], 1), o2[a3].m(t3.parentNode, t3));
      }
      for (Kn(), a3 = r2.length; a3 < o2.length; a3 += 1) i2(a3);
      Zn();
    }
  }, i(e3) {
    if (!n2) {
      for (var t4 = 0; t4 < r2.length; t4 += 1) Xn(o2[t4]);
      n2 = true;
    }
  }, o(e3) {
    o2 = o2.filter(Boolean);
    for (var t4 = 0; t4 < o2.length; t4 += 1) Gn(o2[t4]);
    n2 = false;
  }, d(e3) {
    e3 && an(t3), sn(o2, e3);
  } };
}
function ld(e2) {
  var t3, n2, r2, o2, a2 = e2[83]["multi-clear-icon"], i2 = _t(a2, e2, e2[82], Tu), s2 = i2 || function() {
    var e3, t4;
    return e3 = new hu({}), { c() {
      sr(e3.$$.fragment);
    }, m(n3, r3) {
      lr(e3, n3, r3), t4 = true;
    }, i(n3) {
      t4 || (Xn(e3.$$.fragment, n3), t4 = true);
    }, o(n3) {
      Gn(e3.$$.fragment, n3), t4 = false;
    }, d(t5) {
      cr(e3, t5);
    } };
  }();
  function l() {
    return e2[92](e2[128]);
  }
  return { c() {
    t3 = ln("div"), s2 && s2.c(), hn(t3, "class", "multi-item-clear svelte-82qwg8");
  }, m(e3, a3) {
    on(e3, t3, a3), s2 && s2.m(t3, null), n2 = true, r2 || (o2 = pn(t3, "pointerup", mn(fn(l))), r2 = true);
  }, p(t4, r3) {
    e2 = t4, i2 && i2.p && (!n2 || 1048576 & r3[2]) && Yt(i2, a2, e2, e2[82], n2 ? Qt(a2, e2[82], r3, Iu) : Kt(e2[82]), Tu);
  }, i(e3) {
    n2 || (Xn(s2, e3), n2 = true);
  }, o(e3) {
    Gn(s2, e3), n2 = false;
  }, d(e3) {
    e3 && an(t3), s2 && s2.d(e3), r2 = false, o2();
  } };
}
function cd(e2) {
  var t3, n2, r2, o2, a2, i2, s2, l = e2[83].selection, c = _t(l, e2, e2[82], Nu), u = c || function(e3) {
    var t4, n3 = e3[126][e3[12]] + "";
    return { c() {
      t4 = un(n3);
    }, m(e4, n4) {
      on(e4, t4, n4);
    }, p(e4, r3) {
      4104 & r3[0] && n3 !== (n3 = e4[126][e4[12]] + "") && yn(t4, n3);
    }, d(e4) {
      e4 && an(t4);
    } };
  }(e2), d = !e2[11] && !e2[10] && hu && ld(e2);
  function v() {
    return e2[93](e2[128]);
  }
  return { c() {
    t3 = ln("div"), n2 = ln("span"), u && u.c(), r2 = dn(), d && d.c(), o2 = dn(), hn(n2, "class", "multi-item-text svelte-82qwg8"), hn(t3, "class", "multi-item svelte-82qwg8"), hn(t3, "role", "none"), kn(t3, "active", e2[26] === e2[128]), kn(t3, "disabled", e2[11]);
  }, m(l2, c2) {
    on(l2, t3, c2), nn(t3, n2), u && u.m(n2, null), nn(t3, r2), d && d.m(t3, null), nn(t3, o2), a2 = true, i2 || (s2 = [pn(t3, "click", fn(v)), pn(t3, "keydown", mn(fn(e2[84])))], i2 = true);
  }, p(n3, r3) {
    e2 = n3, c ? c.p && (!a2 || 8 & r3[0] | 1048576 & r3[2]) && Yt(c, l, e2, e2[82], a2 ? Qt(l, e2[82], r3, Au) : Kt(e2[82]), Nu) : u && u.p && (!a2 || 4104 & r3[0]) && u.p(e2, a2 ? r3 : [-1, -1, -1, -1, -1]), e2[11] || e2[10] || !hu ? d && (Kn(), Gn(d, 1, 1, () => {
      d = null;
    }), Zn()) : d ? (d.p(e2, r3), 3072 & r3[0] && Xn(d, 1)) : ((d = ld(e2)).c(), Xn(d, 1), d.m(t3, o2)), (!a2 || 67108864 & r3[0]) && kn(t3, "active", e2[26] === e2[128]), (!a2 || 2048 & r3[0]) && kn(t3, "disabled", e2[11]);
  }, i(e3) {
    a2 || (Xn(u, e3), Xn(d), a2 = true);
  }, o(e3) {
    Gn(u, e3), Gn(d), a2 = false;
  }, d(e3) {
    e3 && an(t3), u && u.d(e3), d && d.d(), i2 = false, Dt(s2);
  } };
}
function ud(e2) {
  var t3, n2, r2 = e2[83]["loading-icon"], o2 = _t(r2, e2, e2[82], Mu), a2 = o2 || function() {
    var e3, t4;
    return e3 = new xu({}), { c() {
      sr(e3.$$.fragment);
    }, m(n3, r3) {
      lr(e3, n3, r3), t4 = true;
    }, i(n3) {
      t4 || (Xn(e3.$$.fragment, n3), t4 = true);
    }, o(n3) {
      Gn(e3.$$.fragment, n3), t4 = false;
    }, d(t5) {
      cr(e3, t5);
    } };
  }();
  return { c() {
    t3 = ln("div"), a2 && a2.c(), hn(t3, "class", "icon loading svelte-82qwg8"), hn(t3, "aria-hidden", "true");
  }, m(e3, r3) {
    on(e3, t3, r3), a2 && a2.m(t3, null), n2 = true;
  }, p(e3, t4) {
    o2 && o2.p && (!n2 || 1048576 & t4[2]) && Yt(o2, r2, e3, e3[82], n2 ? Qt(r2, e3[82], t4, qu) : Kt(e3[82]), Mu);
  }, i(e3) {
    n2 || (Xn(a2, e3), n2 = true);
  }, o(e3) {
    Gn(a2, e3), n2 = false;
  }, d(e3) {
    e3 && an(t3), a2 && a2.d(e3);
  } };
}
function dd(e2) {
  var t3, n2, r2, o2, a2 = e2[83]["clear-icon"], i2 = _t(a2, e2, e2[82], zu), s2 = i2 || function() {
    var e3, t4;
    return e3 = new hu({}), { c() {
      sr(e3.$$.fragment);
    }, m(n3, r3) {
      lr(e3, n3, r3), t4 = true;
    }, i(n3) {
      t4 || (Xn(e3.$$.fragment, n3), t4 = true);
    }, o(n3) {
      Gn(e3.$$.fragment, n3), t4 = false;
    }, d(t5) {
      cr(e3, t5);
    } };
  }();
  return { c() {
    t3 = ln("button"), s2 && s2.c(), hn(t3, "type", "button"), hn(t3, "class", "icon clear-select svelte-82qwg8");
  }, m(a3, i3) {
    on(a3, t3, i3), s2 && s2.m(t3, null), n2 = true, r2 || (o2 = pn(t3, "click", e2[22]), r2 = true);
  }, p(e3, t4) {
    i2 && i2.p && (!n2 || 1048576 & t4[2]) && Yt(i2, a2, e3, e3[82], n2 ? Qt(a2, e3[82], t4, Ou) : Kt(e3[82]), zu);
  }, i(e3) {
    n2 || (Xn(s2, e3), n2 = true);
  }, o(e3) {
    Gn(s2, e3), n2 = false;
  }, d(e3) {
    e3 && an(t3), s2 && s2.d(e3), r2 = false, o2();
  } };
}
function vd(e2) {
  var t3, n2, r2 = e2[83]["chevron-icon"], o2 = _t(r2, e2, e2[82], Su), a2 = o2 || function() {
    var e3, t4;
    return e3 = new pu({}), { c() {
      sr(e3.$$.fragment);
    }, m(n3, r3) {
      lr(e3, n3, r3), t4 = true;
    }, i(n3) {
      t4 || (Xn(e3.$$.fragment, n3), t4 = true);
    }, o(n3) {
      Gn(e3.$$.fragment, n3), t4 = false;
    }, d(t5) {
      cr(e3, t5);
    } };
  }();
  return { c() {
    t3 = ln("div"), a2 && a2.c(), hn(t3, "class", "icon chevron svelte-82qwg8"), hn(t3, "aria-hidden", "true");
  }, m(e3, r3) {
    on(e3, t3, r3), a2 && a2.m(t3, null), n2 = true;
  }, p(e3, t4) {
    o2 && o2.p && (!n2 || 64 & t4[0] | 1048576 & t4[2]) && Yt(o2, r2, e3, e3[82], n2 ? Qt(r2, e3[82], t4, ku) : Kt(e3[82]), Su);
  }, i(e3) {
    n2 || (Xn(a2, e3), n2 = true);
  }, o(e3) {
    Gn(a2, e3), n2 = false;
  }, d(e3) {
    e3 && an(t3), a2 && a2.d(e3);
  } };
}
function pd(e2) {
  var t3, n2, r2 = e2[83].required, o2 = _t(r2, e2, e2[82], $u), a2 = o2 || { c() {
    hn(n2 = ln("select"), "class", "required svelte-82qwg8"), n2.required = true, hn(n2, "tabindex", "-1"), hn(n2, "aria-hidden", "true");
  }, m(e3, t4) {
    on(e3, n2, t4);
  }, p: Bt, d(e3) {
    e3 && an(n2);
  } };
  return { c() {
    a2 && a2.c();
  }, m(e3, n3) {
    a2 && a2.m(e3, n3), t3 = true;
  }, p(e3, n3) {
    o2 && o2.p && (!t3 || 8 & n3[0] | 1048576 & n3[2]) && Yt(o2, r2, e3, e3[82], t3 ? Qt(r2, e3[82], n3, yu) : Kt(e3[82]), $u);
  }, i(e3) {
    t3 || (Xn(a2, e3), t3 = true);
  }, o(e3) {
    Gn(a2, e3), t3 = false;
  }, d(e3) {
    a2 && a2.d(e3);
  } };
}
function fd(e2) {
  for (var t3, n2, r2, o2, a2, i2, s2, l, c, u, d, v, p, f, m3, h2, g, j, x, b2, y = e2[6] && Zu(e2), $2 = e2[2] && od(e2), w = e2[83].prepend, C3 = _t(w, e2, e2[82], Fu), k2 = e2[25] && ad(e2), S4 = [{ readOnly: u = !e2[17] }, e2[27], { placeholder: e2[33] }, { style: e2[18] }, { disabled: e2[11] }], O = {}, z3 = 0; z3 < S4.length; z3 += 1) O = Ft(O, S4[z3]);
  var q2 = e2[5] && ud(e2), M3 = e2[34] && dd(e2), R3 = e2[20] && vd(e2), E3 = e2[83]["input-hidden"], P3 = _t(E3, e2, e2[82], Cu), I3 = P3 || /* @__PURE__ */ function(e3) {
    var t4, n3;
    return { c() {
      hn(t4 = ln("input"), "name", e3[8]), hn(t4, "type", "hidden"), t4.value = n3 = e3[3] ? JSON.stringify(e3[3]) : null, hn(t4, "class", "svelte-82qwg8");
    }, m(e4, n4) {
      on(e4, t4, n4);
    }, p(e4, r3) {
      256 & r3[0] && hn(t4, "name", e4[8]), 8 & r3[0] && n3 !== (n3 = e4[3] ? JSON.stringify(e4[3]) : null) && (t4.value = n3);
    }, d(e4) {
      e4 && an(t4);
    } };
  }(e2), T3 = e2[16] && (!e2[3] || 0 === e2[3].length) && pd(e2);
  return { c() {
    t3 = ln("div"), y && y.c(), n2 = dn(), r2 = ln("span"), $2 && $2.c(), o2 = dn(), a2 = ln("div"), C3 && C3.c(), i2 = dn(), s2 = ln("div"), k2 && k2.c(), l = dn(), c = ln("input"), d = dn(), v = ln("div"), q2 && q2.c(), p = dn(), M3 && M3.c(), f = dn(), R3 && R3.c(), m3 = dn(), I3 && I3.c(), h2 = dn(), T3 && T3.c(), hn(r2, "aria-live", "polite"), hn(r2, "aria-atomic", "false"), hn(r2, "aria-relevant", "additions text"), hn(r2, "class", "a11y-text svelte-82qwg8"), hn(a2, "class", "prepend svelte-82qwg8"), xn(c, O), kn(c, "svelte-82qwg8", true), hn(s2, "class", "value-container svelte-82qwg8"), hn(v, "class", "indicators svelte-82qwg8"), hn(t3, "class", g = "svelte-select " + e2[21] + " svelte-82qwg8"), hn(t3, "style", e2[14]), hn(t3, "role", "none"), kn(t3, "multi", e2[9]), kn(t3, "disabled", e2[11]), kn(t3, "focused", e2[2]), kn(t3, "list-open", e2[6]), kn(t3, "show-chevron", e2[20]), kn(t3, "error", e2[15]);
  }, m(u2, g2) {
    on(u2, t3, g2), y && y.m(t3, null), nn(t3, n2), nn(t3, r2), $2 && $2.m(r2, null), nn(t3, o2), nn(t3, a2), C3 && C3.m(a2, null), nn(t3, i2), nn(t3, s2), k2 && k2.m(s2, null), nn(s2, l), nn(s2, c), c.autofocus && c.focus(), e2[94](c), $n(c, e2[4]), nn(t3, d), nn(t3, v), q2 && q2.m(v, null), nn(v, p), M3 && M3.m(v, null), nn(v, f), R3 && R3.m(v, null), nn(t3, m3), I3 && I3.m(t3, null), nn(t3, h2), T3 && T3.m(t3, null), e2[96](t3), j = true, x || (b2 = [pn(window, "click", e2[42]), pn(window, "keydown", e2[37]), pn(c, "keydown", e2[37]), pn(c, "blur", e2[39]), pn(c, "focus", e2[38]), pn(c, "input", e2[95]), pn(t3, "pointerup", fn(e2[40])), en(e2[48].call(null, t3))], x = true);
  }, p(e3, o3) {
    e3[6] ? y ? (y.p(e3, o3), 64 & o3[0] && Xn(y, 1)) : ((y = Zu(e3)).c(), Xn(y, 1), y.m(t3, n2)) : y && (Kn(), Gn(y, 1, 1, () => {
      y = null;
    }), Zn()), e3[2] ? $2 ? $2.p(e3, o3) : (($2 = od(e3)).c(), $2.m(r2, null)) : $2 && ($2.d(1), $2 = null), C3 && C3.p && (!j || 1048576 & o3[2]) && Yt(C3, w, e3, e3[82], j ? Qt(w, e3[82], o3, Bu) : Kt(e3[82]), Fu), e3[25] ? k2 ? (k2.p(e3, o3), 33554432 & o3[0] && Xn(k2, 1)) : ((k2 = ad(e3)).c(), Xn(k2, 1), k2.m(s2, l)) : k2 && (Kn(), Gn(k2, 1, 1, () => {
      k2 = null;
    }), Zn()), xn(c, O = or(S4, [(!j || 131072 & o3[0] && u !== (u = !e3[17])) && { readOnly: u }, 134217728 & o3[0] && e3[27], (!j || 4 & o3[1]) && { placeholder: e3[33] }, (!j || 262144 & o3[0]) && { style: e3[18] }, (!j || 2048 & o3[0]) && { disabled: e3[11] }])), 16 & o3[0] && c.value !== e3[4] && $n(c, e3[4]), kn(c, "svelte-82qwg8", true), e3[5] ? q2 ? (q2.p(e3, o3), 32 & o3[0] && Xn(q2, 1)) : ((q2 = ud(e3)).c(), Xn(q2, 1), q2.m(v, p)) : q2 && (Kn(), Gn(q2, 1, 1, () => {
      q2 = null;
    }), Zn()), e3[34] ? M3 ? (M3.p(e3, o3), 8 & o3[1] && Xn(M3, 1)) : ((M3 = dd(e3)).c(), Xn(M3, 1), M3.m(v, f)) : M3 && (Kn(), Gn(M3, 1, 1, () => {
      M3 = null;
    }), Zn()), e3[20] ? R3 ? (R3.p(e3, o3), 1048576 & o3[0] && Xn(R3, 1)) : ((R3 = vd(e3)).c(), Xn(R3, 1), R3.m(v, null)) : R3 && (Kn(), Gn(R3, 1, 1, () => {
      R3 = null;
    }), Zn()), P3 ? P3.p && (!j || 8 & o3[0] | 1048576 & o3[2]) && Yt(P3, E3, e3, e3[82], j ? Qt(E3, e3[82], o3, wu) : Kt(e3[82]), Cu) : I3 && I3.p && (!j || 264 & o3[0]) && I3.p(e3, j ? o3 : [-1, -1, -1, -1, -1]), !e3[16] || e3[3] && 0 !== e3[3].length ? T3 && (Kn(), Gn(T3, 1, 1, () => {
      T3 = null;
    }), Zn()) : T3 ? (T3.p(e3, o3), 65544 & o3[0] && Xn(T3, 1)) : ((T3 = pd(e3)).c(), Xn(T3, 1), T3.m(t3, null)), (!j || 2097152 & o3[0] && g !== (g = "svelte-select " + e3[21] + " svelte-82qwg8")) && hn(t3, "class", g), (!j || 16384 & o3[0]) && hn(t3, "style", e3[14]), (!j || 2097664 & o3[0]) && kn(t3, "multi", e3[9]), (!j || 2099200 & o3[0]) && kn(t3, "disabled", e3[11]), (!j || 2097156 & o3[0]) && kn(t3, "focused", e3[2]), (!j || 2097216 & o3[0]) && kn(t3, "list-open", e3[6]), (!j || 3145728 & o3[0]) && kn(t3, "show-chevron", e3[20]), (!j || 2129920 & o3[0]) && kn(t3, "error", e3[15]);
  }, i(e3) {
    j || (Xn(y), Xn(C3, e3), Xn(k2), Xn(q2), Xn(M3), Xn(R3), Xn(I3, e3), Xn(T3), j = true);
  }, o(e3) {
    Gn(y), Gn(C3, e3), Gn(k2), Gn(q2), Gn(M3), Gn(R3), Gn(I3, e3), Gn(T3), j = false;
  }, d(n3) {
    n3 && an(t3), y && y.d(), $2 && $2.d(), C3 && C3.d(n3), k2 && k2.d(), e2[94](null), q2 && q2.d(), M3 && M3.d(), R3 && R3.d(), I3 && I3.d(n3), T3 && T3.d(), e2[96](null), x = false, Dt(b2);
  } };
}
function md(e2) {
  return e2.map((e3, t3) => ({ index: t3, value: e3, label: "".concat(e3) }));
}
function hd(e2, t3, n2) {
  var r2, a2, s2, l, c, u, d, v, p, f, m3, h2, g, j, x, b2, { $$slots: y = {}, $$scope: $2 } = t3, w = function(e3) {
    var t4 = {};
    for (var n3 in e3) t4[n3] = true;
    return t4;
  }(y), C3 = Rn(), { justValue: k2 = null } = t3, { filter: S4 = lu } = t3, { getItems: O = cu } = t3, { id: z3 = null } = t3, { name: q2 = null } = t3, { container: M3 } = t3, { input: R3 } = t3, { multiple: E3 = false } = t3, { multiFullItemClearable: P3 = false } = t3, { disabled: I3 = false } = t3, { focused: T3 = false } = t3, { value: A = null } = t3, { filterText: N3 = "" } = t3, { placeholder: B3 = "Please select" } = t3, { placeholderAlwaysShow: F3 = false } = t3, { items: U3 = null } = t3, { label: L3 = "label" } = t3, { itemFilter: D3 = (e3, t4, n3) => "".concat(e3).toLowerCase().includes(t4.toLowerCase()) } = t3, { groupBy: J3 } = t3, { groupFilter: V = (e3) => e3 } = t3, { groupHeaderSelectable: H2 = false } = t3, { itemId: _2 = "value" } = t3, { loadOptions: W3 } = t3, { containerStyles: Q2 = "" } = t3, { hasError: Y2 = false } = t3, { filterSelectedItems: K3 = true } = t3, { required: Z3 = false } = t3, { closeListOnChange: X2 = true } = t3, { clearFilterTextOnBlur: G2 = true } = t3, { createGroupHeaderItem: ee2 = (e3, t4) => ({ value: e3, [L3]: e3 }) } = t3, { searchable: te2 = true } = t3, { inputStyles: ne2 = "" } = t3, { clearable: re2 = true } = t3, { loading: oe2 = false } = t3, { listOpen: ae2 = false } = t3, { debounce: ie4 = function(e3) {
    var t4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
    clearTimeout(f), f = setTimeout(e3, t4);
  } } = t3, { debounceWait: se2 = 300 } = t3, { hideEmptyState: le2 = false } = t3, { inputAttributes: ce2 = {} } = t3, { listAutoWidth: ue2 = true } = t3, { showChevron: de2 = false } = t3, { listOffset: ve2 = 5 } = t3, { hoverItemIndex: pe2 = 0 } = t3, { floatingConfig: fe2 = {} } = t3, { class: me2 = "" } = t3;
  function he2(e3) {
    var t4 = [], n3 = {};
    e3.forEach((e4) => {
      var r4 = J3(e4);
      t4.includes(r4) || (t4.push(r4), n3[r4] = [], r4 && n3[r4].push(Object.assign(ee2(r4, e4), { id: r4, groupHeader: true, selectable: H2 }))), n3[r4].push(Object.assign({ groupItem: !!r4 }, e4));
    });
    var r3 = [];
    return V(t4).forEach((e4) => {
      n3[e4] && r3.push(...n3[e4]);
    }), r3;
  }
  function ge2() {
    var e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, t4 = arguments.length > 1 ? arguments[1] : void 0;
    n2(7, pe2 = e3 < 0 ? 0 : e3), !t4 && J3 && d[pe2] && !d[pe2].selectable && Ae2(1);
  }
  function je2() {
    var e3 = true;
    if (A) {
      var t4 = [], r3 = [];
      A.forEach((n3) => {
        t4.includes(n3[_2]) ? e3 = false : (t4.push(n3[_2]), r3.push(n3));
      }), e3 || n2(3, A = r3);
    }
    return e3;
  }
  function xe2(e3) {
    var t4 = e3 ? e3[_2] : A[_2];
    return U3.find((e4) => e4[_2] === t4);
  }
  function be2(e3) {
    return ye2.apply(this, arguments);
  }
  function ye2() {
    return (ye2 = o(function* (e3) {
      var t4 = A[e3];
      1 === A.length ? n2(3, A = void 0) : n2(3, A = A.filter((e4) => e4 !== t4)), C3("clear", t4);
    })).apply(this, arguments);
  }
  function $e2(e3) {
    var t4, r3;
    T3 && R3 === (null === (t4 = document) || void 0 === t4 ? void 0 : t4.activeElement) || (e3 && C3("focus", e3), null === (r3 = R3) || void 0 === r3 || r3.focus(), n2(2, T3 = true));
  }
  function we2(e3) {
    return Ce2.apply(this, arguments);
  }
  function Ce2() {
    return (Ce2 = o(function* (e3) {
      var t4;
      Ee2 || (ae2 || T3) && (C3("blur", e3), ke2(), n2(2, T3 = false), n2(26, m3 = void 0), null === (t4 = R3) || void 0 === t4 || t4.blur());
    })).apply(this, arguments);
  }
  function ke2() {
    G2 && n2(4, N3 = ""), n2(6, ae2 = false);
  }
  b2 = o(function* () {
    n2(78, h2 = A), n2(79, g = N3), n2(80, j = E3);
  }), zn().$$.before_update.push(b2), qn(() => {
    ae2 && n2(2, T3 = true), T3 && R3 && R3.focus();
  });
  var { ariaValues: Se2 = (e3) => "Option ".concat(e3, ", selected.") } = t3, { ariaListOpen: Oe2 = (e3, t4) => "You are currently focused on option ".concat(e3, ". There are ").concat(t4, " results available.") } = t3, { ariaFocused: ze2 = () => "Select is focused, type to refine list, press down to open the menu." } = t3;
  var qe2, Me2 = null;
  function Re2() {
    clearTimeout(qe2), qe2 = setTimeout(() => {
      Ee2 = false;
    }, 100);
  }
  Mn(() => {
    var e3;
    null === (e3 = Me2) || void 0 === e3 || e3.remove();
  });
  var Ee2 = false;
  function Pe2(e3) {
    e3 && false !== e3.selectable && function(e4) {
      if (e4) {
        n2(4, N3 = "");
        var t4 = Object.assign({}, e4);
        if (t4.groupHeader && !t4.selectable) return;
        n2(3, A = E3 ? A ? A.concat([t4]) : [t4] : n2(3, A = t4)), setTimeout(() => {
          X2 && ke2(), n2(26, m3 = void 0), C3("change", A), C3("select", e4);
        });
      }
    }(e3);
  }
  function Ie2(e3) {
    Ee2 || n2(7, pe2 = e3);
  }
  function Te2(e3) {
    var { item: t4, i: r3 } = e3;
    if (false !== (null == t4 ? void 0 : t4.selectable)) return A && !E3 && A[_2] === t4[_2] ? ke2() : void (function(e4) {
      return e4.groupHeader && e4.selectable || e4.selectable || !e4.hasOwnProperty("selectable");
    }(t4) && (n2(7, pe2 = r3), Pe2(t4)));
  }
  function Ae2(e3) {
    if (0 === d.filter((e4) => !Object.hasOwn(e4, "selectable") || true === e4.selectable).length) return n2(7, pe2 = 0);
    e3 > 0 && pe2 === d.length - 1 ? n2(7, pe2 = 0) : n2(7, e3 < 0 && 0 === pe2 ? pe2 = d.length - 1 : pe2 += e3);
    var t4 = d[pe2];
    t4 && false === t4.selectable && (1 !== e3 && -1 !== e3 || Ae2(e3));
  }
  var Ne2 = Fe2, Be2 = Fe2;
  function Fe2(e3) {
    return { update(t4) {
      t4.scroll && (Re2(), e3.scrollIntoView({ behavior: "auto", block: "nearest" }));
    } };
  }
  var Ue2, Le2, De3, Je2, Ve2, He2, _e2, We2, Qe2 = { strategy: "absolute", placement: "bottom-start", middleware: [ou(ve2), iu(), au()], autoUpdate: false }, [Ye2, Ke2, Ze2] = (Je2 = { autoUpdate: true }, Ve2 = Ue2 = Qe2, He2 = (e3) => i(i(i({}, Je2), Ue2 || {}), e3 || {}), We2 = (e3) => {
    Mn(e3.subscribe((e4) => {
      void 0 === Le2 ? (Le2 = e4, _e2()) : (Object.assign(Le2, e4), _e2());
    }));
  }, [(e3) => {
    if ("subscribe" in e3) return We2(e3), {};
    Le2 = e3, _e2();
  }, (e3, t4) => {
    var n3;
    De3 = e3, Ve2 = He2(t4), setTimeout(() => _e2(t4), 0), _e2(t4);
    var r3 = () => {
      n3 && (n3(), n3 = void 0);
    }, o2 = function() {
      var { autoUpdate: e4 } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ve2 || {};
      r3(), false !== e4 && Ln().then(() => ru(Le2, De3, () => _e2(Ve2), true === e4 ? {} : e4));
    };
    return n3 = o2(), { update(e4) {
      _e2(e4), n3 = o2(e4);
    }, destroy() {
      r3();
    } };
  }, _e2 = (e3) => {
    Le2 && De3 && (Ve2 = He2(e3), su(Le2, De3, Ve2).then((e4) => {
      var t4;
      Object.assign(De3.style, { position: e4.strategy, left: "".concat(e4.x, "px"), top: "".concat(e4.y, "px") }), (null === (t4 = Ve2) || void 0 === t4 ? void 0 : t4.onComputed) && Ve2.onComputed(e4);
    }));
  }]), Xe2 = true;
  return e2.$$set = (e3) => {
    "justValue" in e3 && n2(52, k2 = e3.justValue), "filter" in e3 && n2(53, S4 = e3.filter), "getItems" in e3 && n2(54, O = e3.getItems), "id" in e3 && n2(55, z3 = e3.id), "name" in e3 && n2(8, q2 = e3.name), "container" in e3 && n2(0, M3 = e3.container), "input" in e3 && n2(1, R3 = e3.input), "multiple" in e3 && n2(9, E3 = e3.multiple), "multiFullItemClearable" in e3 && n2(10, P3 = e3.multiFullItemClearable), "disabled" in e3 && n2(11, I3 = e3.disabled), "focused" in e3 && n2(2, T3 = e3.focused), "value" in e3 && n2(3, A = e3.value), "filterText" in e3 && n2(4, N3 = e3.filterText), "placeholder" in e3 && n2(56, B3 = e3.placeholder), "placeholderAlwaysShow" in e3 && n2(57, F3 = e3.placeholderAlwaysShow), "items" in e3 && n2(51, U3 = e3.items), "label" in e3 && n2(12, L3 = e3.label), "itemFilter" in e3 && n2(58, D3 = e3.itemFilter), "groupBy" in e3 && n2(59, J3 = e3.groupBy), "groupFilter" in e3 && n2(60, V = e3.groupFilter), "groupHeaderSelectable" in e3 && n2(61, H2 = e3.groupHeaderSelectable), "itemId" in e3 && n2(13, _2 = e3.itemId), "loadOptions" in e3 && n2(62, W3 = e3.loadOptions), "containerStyles" in e3 && n2(14, Q2 = e3.containerStyles), "hasError" in e3 && n2(15, Y2 = e3.hasError), "filterSelectedItems" in e3 && n2(63, K3 = e3.filterSelectedItems), "required" in e3 && n2(16, Z3 = e3.required), "closeListOnChange" in e3 && n2(64, X2 = e3.closeListOnChange), "clearFilterTextOnBlur" in e3 && n2(65, G2 = e3.clearFilterTextOnBlur), "createGroupHeaderItem" in e3 && n2(66, ee2 = e3.createGroupHeaderItem), "searchable" in e3 && n2(17, te2 = e3.searchable), "inputStyles" in e3 && n2(18, ne2 = e3.inputStyles), "clearable" in e3 && n2(68, re2 = e3.clearable), "loading" in e3 && n2(5, oe2 = e3.loading), "listOpen" in e3 && n2(6, ae2 = e3.listOpen), "debounce" in e3 && n2(69, ie4 = e3.debounce), "debounceWait" in e3 && n2(70, se2 = e3.debounceWait), "hideEmptyState" in e3 && n2(19, le2 = e3.hideEmptyState), "inputAttributes" in e3 && n2(71, ce2 = e3.inputAttributes), "listAutoWidth" in e3 && n2(72, ue2 = e3.listAutoWidth), "showChevron" in e3 && n2(20, de2 = e3.showChevron), "listOffset" in e3 && n2(73, ve2 = e3.listOffset), "hoverItemIndex" in e3 && n2(7, pe2 = e3.hoverItemIndex), "floatingConfig" in e3 && n2(74, fe2 = e3.floatingConfig), "class" in e3 && n2(21, me2 = e3.class), "ariaValues" in e3 && n2(75, Se2 = e3.ariaValues), "ariaListOpen" in e3 && n2(76, Oe2 = e3.ariaListOpen), "ariaFocused" in e3 && n2(77, ze2 = e3.ariaFocused), "$$scope" in e3 && n2(82, $2 = e3.$$scope);
  }, e2.$$.update = () => {
    var t4, i2, f2;
    (8 & e2.$$.dirty[0] | 1048576 & e2.$$.dirty[1] && A && function() {
      if ("string" == typeof A) {
        var e3 = (U3 || []).find((e4) => e4[_2] === A);
        n2(3, A = e3 || { [_2]: A, label: A });
      } else E3 && Array.isArray(A) && A.length > 0 && n2(3, A = A.map((e4) => "string" == typeof e4 ? { value: e4, label: e4 } : e4));
    }(), 131072 & e2.$$.dirty[0] | 512 & e2.$$.dirty[2] && (!ce2 && te2 || (n2(27, x = Object.assign({ autocapitalize: "none", autocomplete: "off", autocorrect: "off", spellcheck: false, tabindex: 0, type: "text", "aria-autocomplete": "list" }, ce2)), z3 && n2(27, x.id = z3, x), te2 || n2(27, x.readonly = true, x))), 512 & e2.$$.dirty[0] && E3 && A && (Array.isArray(A) ? n2(3, A = [...A]) : n2(3, A = [A])), 512 & e2.$$.dirty[0] | 262144 & e2.$$.dirty[2] && j && !E3 && A && n2(3, A = null), 520 & e2.$$.dirty[0] && E3 && A && A.length > 1 && je2(), 8 & e2.$$.dirty[0] && A && (E3 ? JSON.stringify(A) !== JSON.stringify(h2) && je2() && C3("input", A) : h2 && JSON.stringify(A[_2]) === JSON.stringify(h2[_2]) || C3("input", A)), 520 & e2.$$.dirty[0] | 65536 & e2.$$.dirty[2] && !A && E3 && h2 && C3("input", A), 6 & e2.$$.dirty[0] && !T3 && R3 && ke2(), 16 & e2.$$.dirty[0] | 131072 & e2.$$.dirty[2] && N3 !== g && (W3 || 0 !== N3.length) && (W3 ? ie4(o(function* () {
      n2(5, oe2 = true);
      var e3 = yield O({ dispatch: C3, loadOptions: W3, convertStringItemsToObjects: md, filterText: N3 });
      e3 ? (n2(5, oe2 = e3.loading), n2(6, ae2 = ae2 ? e3.listOpen : N3.length > 0), n2(2, T3 = ae2 && e3.focused), n2(51, U3 = J3 ? he2(e3.filteredItems) : e3.filteredItems)) : (n2(5, oe2 = false), n2(2, T3 = true), n2(6, ae2 = true));
    }), se2) : (n2(6, ae2 = true), E3 && n2(26, m3 = void 0))), 12824 & e2.$$.dirty[0] | 407896064 & e2.$$.dirty[1] | 3 & e2.$$.dirty[2] && n2(24, d = S4({ loadOptions: W3, filterText: N3, items: U3, multiple: E3, value: A, itemId: _2, groupBy: J3, label: L3, filterSelectedItems: K3, itemFilter: D3, convertStringItemsToObjects: md, filterGroupedItems: he2 })), 16777800 & e2.$$.dirty[0] && !E3 && ae2 && A && d && ge2(d.findIndex((e3) => e3[_2] === A[_2]), true), 576 & e2.$$.dirty[0] && ae2 && E3 && n2(7, pe2 = 0), 16 & e2.$$.dirty[0] && N3 && n2(7, pe2 = 0), 128 & e2.$$.dirty[0] && C3("hoverItem", pe2), 520 & e2.$$.dirty[0] && n2(25, r2 = E3 ? A && A.length > 0 : A), 33554448 & e2.$$.dirty[0] && n2(35, a2 = r2 && N3.length > 0), 33556512 & e2.$$.dirty[0] | 64 & e2.$$.dirty[2] && n2(34, s2 = r2 && re2 && !I3 && !oe2), 520 & e2.$$.dirty[0] | 100663296 & e2.$$.dirty[1]) && n2(33, l = F3 && E3 || E3 && 0 === (null === (t4 = A) || void 0 === t4 ? void 0 : t4.length) ? B3 : A ? "" : B3);
    (520 & e2.$$.dirty[0] && n2(32, c = A ? (i2 = void 0, i2 = E3 && A.length > 0 ? A.map((e3) => e3[L3]).join(", ") : A[L3], Se2(i2)) : ""), 16777412 & e2.$$.dirty[0] && n2(31, u = function() {
      if (!d || 0 === d.length) return "";
      var e3 = d[pe2];
      if (ae2 && e3) {
        var t5 = d ? d.length : 0;
        return Oe2(e3[L3], t5);
      }
      return ze2();
    }()), 1048576 & e2.$$.dirty[1] && function(e3) {
      e3 && 0 !== e3.length && !e3.some((e4) => "object" != typeof e4) && A && (E3 ? !A.some((e4) => !e4 || !e4[_2]) : A[_2]) && (Array.isArray(A) ? n2(3, A = A.map((e4) => xe2(e4) || e4)) : n2(3, A = xe2() || A));
    }(U3), 8712 & e2.$$.dirty[0] && n2(52, k2 = E3 ? A ? A.map((e3) => e3[_2]) : null : A ? A[_2] : A), 520 & e2.$$.dirty[0] | 65536 & e2.$$.dirty[2] && (E3 || !h2 || A || C3("input", A)), 16777800 & e2.$$.dirty[0] && ae2 && d && !E3 && !A && ge2(), 16777216 & e2.$$.dirty[0] && function(e3) {
      ae2 && C3("filter", e3);
    }(d), 1 & e2.$$.dirty[0] | 4096 & e2.$$.dirty[2]) && (M3 && void 0 === (null === (f2 = fe2) || void 0 === f2 ? void 0 : f2.autoUpdate) && n2(81, Qe2.autoUpdate = true, Qe2));
    1 & e2.$$.dirty[0] | 528384 & e2.$$.dirty[2] && M3 && fe2 && Ze2(Object.assign(Qe2, fe2)), 8388608 & e2.$$.dirty[0] && n2(30, v = !!Me2), 8388672 & e2.$$.dirty[0] && function(e3, t5) {
      if (!e3 || !t5) return n2(28, Xe2 = true);
      setTimeout(() => {
        n2(28, Xe2 = false);
      }, 0);
    }(Me2, ae2), 8388673 & e2.$$.dirty[0] && ae2 && M3 && Me2 && function() {
      var { width: e3 } = M3.getBoundingClientRect();
      n2(23, Me2.style.width = ue2 ? e3 + "px" : "auto", Me2);
    }(), 128 & e2.$$.dirty[0] && n2(29, p = pe2), 70 & e2.$$.dirty[0] && R3 && ae2 && !T3 && $e2();
  }, [M3, R3, T3, A, N3, oe2, ae2, pe2, q2, E3, P3, I3, L3, _2, Q2, Y2, Z3, te2, ne2, le2, de2, me2, function() {
    C3("clear", A), n2(3, A = void 0), ke2(), $e2();
  }, Me2, d, r2, m3, x, Xe2, p, v, u, c, l, s2, a2, be2, function(e3) {
    if (T3) switch (e3.stopPropagation(), e3.key) {
      case "Escape":
        e3.preventDefault(), ke2();
        break;
      case "Enter":
        if (e3.preventDefault(), ae2) {
          if (0 === d.length) break;
          var t4 = d[pe2];
          if (A && !E3 && A[_2] === t4[_2]) {
            ke2();
            break;
          }
          Pe2(d[pe2]);
        }
        break;
      case "ArrowDown":
        e3.preventDefault(), ae2 ? Ae2(1) : (n2(6, ae2 = true), n2(26, m3 = void 0));
        break;
      case "ArrowUp":
        e3.preventDefault(), ae2 ? Ae2(-1) : (n2(6, ae2 = true), n2(26, m3 = void 0));
        break;
      case "Tab":
        if (ae2 && T3) {
          if (0 === d.length || A && A[_2] === d[pe2][_2]) return ke2();
          e3.preventDefault(), Pe2(d[pe2]), ke2();
        }
        break;
      case "Backspace":
        if (!E3 || N3.length > 0) return;
        if (E3 && A && A.length > 0) {
          if (be2(void 0 !== m3 ? m3 : A.length - 1), 0 === m3 || void 0 === m3) break;
          n2(26, m3 = A.length > m3 ? m3 - 1 : void 0);
        }
        break;
      case "ArrowLeft":
        if (!A || !E3 || N3.length > 0) return;
        void 0 === m3 ? n2(26, m3 = A.length - 1) : A.length > m3 && 0 !== m3 && n2(26, m3 -= 1);
        break;
      case "ArrowRight":
        if (!A || !E3 || N3.length > 0 || void 0 === m3) return;
        m3 === A.length - 1 ? n2(26, m3 = void 0) : m3 < A.length - 1 && n2(26, m3 += 1);
    }
  }, $e2, we2, function() {
    if (!I3) return N3.length > 0 ? n2(6, ae2 = true) : void n2(6, ae2 = !ae2);
  }, Re2, function(e3) {
    var t4;
    ae2 || T3 || !M3 || M3.contains(e3.target) || null !== (t4 = Me2) && void 0 !== t4 && t4.contains(e3.target) || we2();
  }, Ie2, Te2, function(e3, t4, n3) {
    if (!E3) return t4 && t4[n3] === e3[n3];
  }, Ne2, Be2, Ye2, Ke2, w, U3, k2, S4, O, z3, B3, F3, D3, J3, V, H2, W3, K3, X2, G2, ee2, () => d, re2, ie4, se2, ce2, ue2, ve2, fe2, Se2, Oe2, ze2, h2, g, j, Qe2, $2, y, function(t4) {
    Pn.call(this, e2, t4);
  }, function(t4) {
    Pn.call(this, e2, t4);
  }, function(t4) {
    Pn.call(this, e2, t4);
  }, function(t4) {
    Pn.call(this, e2, t4);
  }, (e3) => Ie2(e3), (e3) => Ie2(e3), (e3, t4) => Te2({ item: e3, i: t4 }), function(e3) {
    Tn[e3 ? "unshift" : "push"](() => {
      n2(23, Me2 = e3);
    });
  }, (e3) => be2(e3), (e3) => P3 ? be2(e3) : {}, function(e3) {
    Tn[e3 ? "unshift" : "push"](() => {
      n2(1, R3 = e3);
    });
  }, function() {
    N3 = this.value, n2(4, N3);
  }, function(e3) {
    Tn[e3 ? "unshift" : "push"](() => {
      n2(0, M3 = e3);
    });
  }];
}
var gd = class extends dr {
  constructor(e2) {
    super(), ur(this, e2, hd, fd, Vt, { justValue: 52, filter: 53, getItems: 54, id: 55, name: 8, container: 0, input: 1, multiple: 9, multiFullItemClearable: 10, disabled: 11, focused: 2, value: 3, filterText: 4, placeholder: 56, placeholderAlwaysShow: 57, items: 51, label: 12, itemFilter: 58, groupBy: 59, groupFilter: 60, groupHeaderSelectable: 61, itemId: 13, loadOptions: 62, containerStyles: 14, hasError: 15, filterSelectedItems: 63, required: 16, closeListOnChange: 64, clearFilterTextOnBlur: 65, createGroupHeaderItem: 66, getFilteredItems: 67, searchable: 17, inputStyles: 18, clearable: 68, loading: 5, listOpen: 6, debounce: 69, debounceWait: 70, hideEmptyState: 19, inputAttributes: 71, listAutoWidth: 72, showChevron: 20, listOffset: 73, hoverItemIndex: 7, floatingConfig: 74, class: 21, handleClear: 22, ariaValues: 75, ariaListOpen: 76, ariaFocused: 77 }, bu, [-1, -1, -1, -1, -1]);
  }
  get getFilteredItems() {
    return this.$$.ctx[67];
  }
  get handleClear() {
    return this.$$.ctx[22];
  }
};
function jd(e2) {
  rn(e2, "svelte-qbze6z", "table.jse-transform-wizard.svelte-qbze6z.svelte-qbze6z{border-collapse:collapse;border-spacing:0;width:100%}table.jse-transform-wizard.svelte-qbze6z input.svelte-qbze6z{font-family:inherit;font-size:inherit}table.jse-transform-wizard.svelte-qbze6z tr th.svelte-qbze6z{font-weight:normal;text-align:left;width:60px}table.jse-transform-wizard.svelte-qbze6z tr td .jse-horizontal.svelte-qbze6z{width:100%;display:flex;flex-direction:row;margin-bottom:calc(0.5 * var(--jse-padding, 10px))}table.jse-transform-wizard.svelte-qbze6z tr td .jse-horizontal.svelte-qbze6z .svelte-select .multi-item{align-items:center}table.jse-transform-wizard.svelte-qbze6z tr td .jse-horizontal.svelte-qbze6z .svelte-select .value-container{gap:0 !important}table.jse-transform-wizard.svelte-qbze6z tr td .jse-horizontal.svelte-qbze6z .svelte-select.jse-filter-path{flex:4;margin-right:calc(0.5 * var(--jse-padding, 10px))}table.jse-transform-wizard.svelte-qbze6z tr td .jse-horizontal.svelte-qbze6z .svelte-select.jse-filter-relation{flex:1.5;margin-right:calc(0.5 * var(--jse-padding, 10px))}table.jse-transform-wizard.svelte-qbze6z tr td .jse-horizontal.svelte-qbze6z .svelte-select.jse-sort-path{flex:3;margin-right:calc(0.5 * var(--jse-padding, 10px))}table.jse-transform-wizard.svelte-qbze6z tr td .jse-horizontal.svelte-qbze6z .svelte-select.jse-sort-direction{flex:1}table.jse-transform-wizard.svelte-qbze6z tr td .jse-horizontal.svelte-qbze6z .svelte-select.jse-projection-paths{flex:1}table.jse-transform-wizard.svelte-qbze6z tr td .jse-horizontal.svelte-qbze6z .svelte-select input{box-sizing:border-box}table.jse-transform-wizard.svelte-qbze6z tr td .jse-horizontal .jse-filter-value.svelte-qbze6z{flex:4;padding:4px 8px;border:var(--jse-input-border, 1px solid #d8dbdf);border-radius:var(--jse-input-radius, 3px);outline:none;background:var(--jse-input-background, var(--jse-background-color, #fff));color:inherit}table.jse-transform-wizard.svelte-qbze6z tr td .jse-horizontal .jse-filter-value.svelte-qbze6z:focus{border:var(--jse-input-border-focus, 1px solid var(--jse-input-border-focus, var(--jse-theme-color, #3883fa)))}");
}
function xd(e2) {
  var t3, n2, r2, o2, a2, i2, s2, l, c, u, d, v, p, f, m3, h2, g, j, x, b2, y, $2, w, C3, k2, S4, O, z3, q2, M3, R3, E3, P3, I3, T3;
  function A(t4) {
    e2[16](t4);
  }
  var N3 = { class: "jse-filter-path", showChevron: true, items: e2[7] };
  function B3(t4) {
    e2[17](t4);
  }
  void 0 !== e2[0] && (N3.value = e2[0]), s2 = new gd({ props: N3 }), Tn.push(() => ir(s2, "value", A));
  var F3 = { class: "jse-filter-relation", showChevron: true, clearable: false, items: e2[8] };
  function U3(t4) {
    e2[19](t4);
  }
  void 0 !== e2[1] && (F3.value = e2[1]), u = new gd({ props: F3 }), Tn.push(() => ir(u, "value", B3));
  var L3 = { class: "jse-sort-path", showChevron: true, items: e2[7] };
  function D3(t4) {
    e2[20](t4);
  }
  void 0 !== e2[3] && (L3.value = e2[3]), b2 = new gd({ props: L3 }), Tn.push(() => ir(b2, "value", U3));
  var J3 = { class: "jse-sort-direction", showChevron: true, clearable: false, items: e2[9] };
  function V(t4) {
    e2[21](t4);
  }
  void 0 !== e2[4] && (J3.value = e2[4]), w = new gd({ props: J3 }), Tn.push(() => ir(w, "value", D3));
  var H2 = { class: "jse-projection-paths", multiple: true, showChevron: true, items: e2[6] };
  return void 0 !== e2[5] && (H2.value = e2[5]), R3 = new gd({ props: H2 }), Tn.push(() => ir(R3, "value", V)), { c() {
    t3 = ln("table"), n2 = ln("tr"), (r2 = ln("th")).textContent = "Filter", o2 = dn(), a2 = ln("td"), i2 = ln("div"), sr(s2.$$.fragment), c = dn(), sr(u.$$.fragment), v = dn(), p = ln("input"), f = dn(), m3 = ln("tr"), (h2 = ln("th")).textContent = "Sort", g = dn(), j = ln("td"), x = ln("div"), sr(b2.$$.fragment), $2 = dn(), sr(w.$$.fragment), k2 = dn(), S4 = ln("tr"), (O = ln("th")).textContent = "Pick", z3 = dn(), q2 = ln("td"), M3 = ln("div"), sr(R3.$$.fragment), hn(r2, "class", "svelte-qbze6z"), hn(p, "class", "jse-filter-value svelte-qbze6z"), hn(i2, "class", "jse-horizontal svelte-qbze6z"), hn(h2, "class", "svelte-qbze6z"), hn(x, "class", "jse-horizontal svelte-qbze6z"), hn(O, "class", "svelte-qbze6z"), hn(M3, "class", "jse-horizontal svelte-qbze6z"), hn(t3, "class", "jse-transform-wizard svelte-qbze6z");
  }, m(l2, d2) {
    on(l2, t3, d2), nn(t3, n2), nn(n2, r2), nn(n2, o2), nn(n2, a2), nn(a2, i2), lr(s2, i2, null), nn(i2, c), lr(u, i2, null), nn(i2, v), nn(i2, p), $n(p, e2[2]), nn(t3, f), nn(t3, m3), nn(m3, h2), nn(m3, g), nn(m3, j), nn(j, x), lr(b2, x, null), nn(x, $2), lr(w, x, null), nn(t3, k2), nn(t3, S4), nn(S4, O), nn(S4, z3), nn(S4, q2), nn(q2, M3), lr(R3, M3, null), P3 = true, I3 || (T3 = pn(p, "input", e2[18]), I3 = true);
  }, p(e3, t4) {
    var [n3] = t4, r3 = {};
    128 & n3 && (r3.items = e3[7]), !l && 1 & n3 && (l = true, r3.value = e3[0], Jn(() => l = false)), s2.$set(r3);
    var o3 = {};
    !d && 2 & n3 && (d = true, o3.value = e3[1], Jn(() => d = false)), u.$set(o3), 4 & n3 && p.value !== e3[2] && $n(p, e3[2]);
    var a3 = {};
    128 & n3 && (a3.items = e3[7]), !y && 8 & n3 && (y = true, a3.value = e3[3], Jn(() => y = false)), b2.$set(a3);
    var i3 = {};
    !C3 && 16 & n3 && (C3 = true, i3.value = e3[4], Jn(() => C3 = false)), w.$set(i3);
    var c2 = {};
    64 & n3 && (c2.items = e3[6]), !E3 && 32 & n3 && (E3 = true, c2.value = e3[5], Jn(() => E3 = false)), R3.$set(c2);
  }, i(e3) {
    P3 || (Xn(s2.$$.fragment, e3), Xn(u.$$.fragment, e3), Xn(b2.$$.fragment, e3), Xn(w.$$.fragment, e3), Xn(R3.$$.fragment, e3), P3 = true);
  }, o(e3) {
    Gn(s2.$$.fragment, e3), Gn(u.$$.fragment, e3), Gn(b2.$$.fragment, e3), Gn(w.$$.fragment, e3), Gn(R3.$$.fragment, e3), P3 = false;
  }, d(e3) {
    e3 && an(t3), cr(s2), cr(u), cr(b2), cr(w), cr(R3), I3 = false, T3();
  } };
}
function bd(e2, t3, n2) {
  var r2, o2, a2, i2, s2, l, c, u, d, p, f, m3 = vr("jsoneditor:TransformWizard"), { json: h2 } = t3, { queryOptions: g = {} } = t3, { onChange: j } = t3, x = ["==", "!=", "<", "<=", ">", ">="].map((e3) => ({ value: e3, label: e3 })), b2 = [{ value: "asc", label: "ascending" }, { value: "desc", label: "descending" }], y = null !== (r2 = g) && void 0 !== r2 && null !== (r2 = r2.filter) && void 0 !== r2 && r2.path ? Ql(g.filter.path) : void 0, $2 = null !== (o2 = x.find((e3) => {
    var t4;
    return e3.value === (null === (t4 = g.filter) || void 0 === t4 ? void 0 : t4.relation);
  })) && void 0 !== o2 ? o2 : x[0], w = (null === (a2 = g) || void 0 === a2 || null === (a2 = a2.filter) || void 0 === a2 ? void 0 : a2.value) || "", C3 = null !== (i2 = g) && void 0 !== i2 && null !== (i2 = i2.sort) && void 0 !== i2 && i2.path ? Ql(g.sort.path) : void 0, k2 = null !== (s2 = b2.find((e3) => {
    var t4;
    return e3.value === (null === (t4 = g.sort) || void 0 === t4 ? void 0 : t4.direction);
  })) && void 0 !== s2 ? s2 : b2[0];
  return e2.$$set = (e3) => {
    "json" in e3 && n2(11, h2 = e3.json), "queryOptions" in e3 && n2(10, g = e3.queryOptions), "onChange" in e3 && n2(12, j = e3.onChange);
  }, e2.$$.update = () => {
    var t4, r3, o3, a3, i3, s3, x2, b3, S4, O, z3, q2, M3;
    (2048 & e2.$$.dirty && n2(15, l = Array.isArray(h2)), 34816 & e2.$$.dirty && n2(14, c = l ? Ar(h2) : []), 34816 & e2.$$.dirty && n2(13, u = l ? Ar(h2, true) : []), 16384 & e2.$$.dirty && n2(7, d = c.map(Ql)), 8192 & e2.$$.dirty && n2(6, p = u ? u.map(Ql) : []), 1088 & e2.$$.dirty) && n2(5, f = null !== (t4 = g) && void 0 !== t4 && null !== (t4 = t4.projection) && void 0 !== t4 && t4.paths && p ? g.projection.paths.map((e3) => p.find((t5) => isEqual_default(t5.value, e3))).filter((e3) => !!e3) : void 0);
    1 & e2.$$.dirty && (o3 = null === (r3 = y) || void 0 === r3 ? void 0 : r3.value, isEqual_default(null === (a3 = g) || void 0 === a3 || null === (a3 = a3.filter) || void 0 === a3 ? void 0 : a3.path, o3) || (m3("changeFilterPath", o3), n2(10, g = setIn(g, ["filter", "path"], o3, true)), j(g)));
    2 & e2.$$.dirty && (s3 = null === (i3 = $2) || void 0 === i3 ? void 0 : i3.value, isEqual_default(null === (x2 = g) || void 0 === x2 || null === (x2 = x2.filter) || void 0 === x2 ? void 0 : x2.relation, s3) || (m3("changeFilterRelation", s3), n2(10, g = setIn(g, ["filter", "relation"], s3, true)), j(g)));
    (4 & e2.$$.dirty && (b3 = w, isEqual_default(null === (S4 = g) || void 0 === S4 || null === (S4 = S4.filter) || void 0 === S4 ? void 0 : S4.value, b3) || (m3("changeFilterValue", b3), n2(10, g = setIn(g, ["filter", "value"], b3, true)), j(g))), 8 & e2.$$.dirty) && function(e3) {
      var t5;
      isEqual_default(null === (t5 = g) || void 0 === t5 || null === (t5 = t5.sort) || void 0 === t5 ? void 0 : t5.path, e3) || (m3("changeSortPath", e3), n2(10, g = setIn(g, ["sort", "path"], e3, true)), j(g));
    }(null === (O = C3) || void 0 === O ? void 0 : O.value);
    16 & e2.$$.dirty && (q2 = null === (z3 = k2) || void 0 === z3 ? void 0 : z3.value, isEqual_default(null === (M3 = g) || void 0 === M3 || null === (M3 = M3.sort) || void 0 === M3 ? void 0 : M3.direction, q2) || (m3("changeSortDirection", q2), n2(10, g = setIn(g, ["sort", "direction"], q2, true)), j(g)));
    32 & e2.$$.dirty && function(e3) {
      var t5;
      isEqual_default(null === (t5 = g) || void 0 === t5 || null === (t5 = t5.projection) || void 0 === t5 ? void 0 : t5.paths, e3) || (m3("changeProjectionPaths", e3), n2(10, g = setIn(g, ["projection", "paths"], e3, true)), j(g));
    }(f ? f.map((e3) => e3.value) : void 0);
  }, [y, $2, w, C3, k2, f, p, d, x, b2, g, h2, j, u, c, l, function(e3) {
    n2(0, y = e3);
  }, function(e3) {
    n2(1, $2 = e3);
  }, function() {
    w = this.value, n2(2, w);
  }, function(e3) {
    n2(3, C3 = e3);
  }, function(e3) {
    n2(4, k2 = e3);
  }, function(e3) {
    n2(5, f = e3), n2(10, g), n2(6, p), n2(13, u), n2(15, l), n2(11, h2);
  }];
}
var yd = class extends dr {
  constructor(e2) {
    super(), ur(this, e2, bd, xd, Ht, { json: 11, queryOptions: 10, onChange: 12 }, jd);
  }
};
function $d(e2) {
  rn(e2, "svelte-atm4um", '.jse-select-query-language.svelte-atm4um.svelte-atm4um{position:relative;width:32px}.jse-select-query-language.svelte-atm4um .jse-select-query-language-container.svelte-atm4um{position:absolute;top:0;right:0;display:flex;flex-direction:column;box-shadow:var(--jse-controls-box-shadow, 0 2px 6px 0 rgba(0, 0, 0, 0.24))}.jse-select-query-language.svelte-atm4um .jse-select-query-language-container .jse-query-language.svelte-atm4um{border:none;background:transparent;color:inherit;cursor:pointer;font-family:var(--jse-font-family, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif);font-size:var(--jse-font-size, 16px);padding:5px;margin:0;text-align:left;padding:var(--jse-padding, 10px) calc(2 * var(--jse-padding, 10px));white-space:nowrap;color:var(--jse-context-menu-color, var(--jse-text-color-inverse, #fff));background:var(--jse-context-menu-background, #656565)}.jse-select-query-language.svelte-atm4um .jse-select-query-language-container .jse-query-language.svelte-atm4um:hover{background:var(--jse-context-menu-background-highlight, #7a7a7a)}');
}
function wd(e2, t3, n2) {
  var r2 = e2.slice();
  return r2[5] = t3[n2], r2;
}
function Cd(e2) {
  var t3, n2;
  return t3 = new Ca({ props: { data: faSquare } }), { c() {
    sr(t3.$$.fragment);
  }, m(e3, r2) {
    lr(t3, e3, r2), n2 = true;
  }, i(e3) {
    n2 || (Xn(t3.$$.fragment, e3), n2 = true);
  }, o(e3) {
    Gn(t3.$$.fragment, e3), n2 = false;
  }, d(e3) {
    cr(t3, e3);
  } };
}
function kd(e2) {
  var t3, n2;
  return t3 = new Ca({ props: { data: faCheckSquare } }), { c() {
    sr(t3.$$.fragment);
  }, m(e3, r2) {
    lr(t3, e3, r2), n2 = true;
  }, i(e3) {
    n2 || (Xn(t3.$$.fragment, e3), n2 = true);
  }, o(e3) {
    Gn(t3.$$.fragment, e3), n2 = false;
  }, d(e3) {
    cr(t3, e3);
  } };
}
function Sd(e2) {
  var t3, n2, r2, o2, a2, i2, s2, l, c, u, d = e2[5].name + "", v = [kd, Cd], p = [];
  function f(e3, t4) {
    return e3[5].id === e3[0] ? 0 : 1;
  }
  function m3() {
    return e2[4](e2[5]);
  }
  return n2 = f(e2), r2 = p[n2] = v[n2](e2), { c() {
    t3 = ln("button"), r2.c(), o2 = dn(), a2 = un(d), i2 = dn(), hn(t3, "type", "button"), hn(t3, "class", "jse-query-language svelte-atm4um"), hn(t3, "title", s2 = "Select ".concat(e2[5].name, " as query language")), kn(t3, "selected", e2[5].id === e2[0]);
  }, m(e3, r3) {
    on(e3, t3, r3), p[n2].m(t3, null), nn(t3, o2), nn(t3, a2), nn(t3, i2), l = true, c || (u = pn(t3, "click", m3), c = true);
  }, p(i3, c2) {
    var u2 = n2;
    (n2 = f(e2 = i3)) !== u2 && (Kn(), Gn(p[u2], 1, 1, () => {
      p[u2] = null;
    }), Zn(), (r2 = p[n2]) || (r2 = p[n2] = v[n2](e2)).c(), Xn(r2, 1), r2.m(t3, o2)), (!l || 2 & c2) && d !== (d = e2[5].name + "") && yn(a2, d), (!l || 2 & c2 && s2 !== (s2 = "Select ".concat(e2[5].name, " as query language"))) && hn(t3, "title", s2), (!l || 3 & c2) && kn(t3, "selected", e2[5].id === e2[0]);
  }, i(e3) {
    l || (Xn(r2), l = true);
  }, o(e3) {
    Gn(r2), l = false;
  }, d(e3) {
    e3 && an(t3), p[n2].d(), c = false, u();
  } };
}
function Od(e2) {
  for (var t3, n2, r2, o2 = er(e2[1]), a2 = [], i2 = 0; i2 < o2.length; i2 += 1) a2[i2] = Sd(wd(e2, o2, i2));
  var s2 = (e3) => Gn(a2[e3], 1, 1, () => {
    a2[e3] = null;
  });
  return { c() {
    t3 = ln("div"), n2 = ln("div");
    for (var e3 = 0; e3 < a2.length; e3 += 1) a2[e3].c();
    hn(n2, "class", "jse-select-query-language-container svelte-atm4um"), hn(t3, "class", "jse-select-query-language svelte-atm4um");
  }, m(e3, o3) {
    on(e3, t3, o3), nn(t3, n2);
    for (var i3 = 0; i3 < a2.length; i3 += 1) a2[i3] && a2[i3].m(n2, null);
    r2 = true;
  }, p(e3, t4) {
    var [r3] = t4;
    if (7 & r3) {
      var i3;
      for (o2 = er(e3[1]), i3 = 0; i3 < o2.length; i3 += 1) {
        var l = wd(e3, o2, i3);
        a2[i3] ? (a2[i3].p(l, r3), Xn(a2[i3], 1)) : (a2[i3] = Sd(l), a2[i3].c(), Xn(a2[i3], 1), a2[i3].m(n2, null));
      }
      for (Kn(), i3 = o2.length; i3 < a2.length; i3 += 1) s2(i3);
      Zn();
    }
  }, i(e3) {
    if (!r2) {
      for (var t4 = 0; t4 < o2.length; t4 += 1) Xn(a2[t4]);
      r2 = true;
    }
  }, o(e3) {
    a2 = a2.filter(Boolean);
    for (var t4 = 0; t4 < a2.length; t4 += 1) Gn(a2[t4]);
    r2 = false;
  }, d(e3) {
    e3 && an(t3), sn(a2, e3);
  } };
}
function zd(e2, t3, n2) {
  var { queryLanguages: r2 } = t3, { queryLanguageId: o2 } = t3, { onChangeQueryLanguage: a2 } = t3;
  function i2(e3) {
    n2(0, o2 = e3), a2(e3);
  }
  return e2.$$set = (e3) => {
    "queryLanguages" in e3 && n2(1, r2 = e3.queryLanguages), "queryLanguageId" in e3 && n2(0, o2 = e3.queryLanguageId), "onChangeQueryLanguage" in e3 && n2(3, a2 = e3.onChangeQueryLanguage);
  }, [o2, r2, i2, a2, (e3) => i2(e3.id)];
}
var qd = class extends dr {
  constructor(e2) {
    super(), ur(this, e2, zd, Od, Vt, { queryLanguages: 1, queryLanguageId: 0, onChangeQueryLanguage: 3 }, $d);
  }
};
function Md(e2) {
  rn(e2, "svelte-1y24war", ".jse-header.svelte-1y24war.svelte-1y24war{display:flex;background:var(--jse-theme-color, #3883fa);color:var(--jse-menu-color, var(--jse-text-color-inverse, #fff))}.jse-header.svelte-1y24war .jse-title.svelte-1y24war{flex:1;padding:5px;vertical-align:middle}.jse-header.svelte-1y24war button.svelte-1y24war{border:none;background:transparent;min-width:32px;color:inherit;cursor:pointer}.jse-header.svelte-1y24war button.svelte-1y24war:hover{background:rgba(255, 255, 255, 0.1)}");
}
var Rd = (e2) => ({});
var Ed = (e2) => ({});
function Pd(e2) {
  var t3, n2, r2, o2, a2;
  return n2 = new Ca({ props: { data: e2[0] ? faDownLeftAndUpRightToCenter : faUpRightAndDownLeftFromCenter } }), { c() {
    t3 = ln("button"), sr(n2.$$.fragment), hn(t3, "type", "button"), hn(t3, "class", "jse-fullscreen svelte-1y24war"), hn(t3, "title", "Toggle full screen");
  }, m(i2, s2) {
    on(i2, t3, s2), lr(n2, t3, null), r2 = true, o2 || (a2 = pn(t3, "click", e2[6]), o2 = true);
  }, p(e3, t4) {
    var r3 = {};
    1 & t4 && (r3.data = e3[0] ? faDownLeftAndUpRightToCenter : faUpRightAndDownLeftFromCenter), n2.$set(r3);
  }, i(e3) {
    r2 || (Xn(n2.$$.fragment, e3), r2 = true);
  }, o(e3) {
    Gn(n2.$$.fragment, e3), r2 = false;
  }, d(e3) {
    e3 && an(t3), cr(n2), o2 = false, a2();
  } };
}
function Id(e2) {
  var t3, n2, r2, o2, a2, i2, s2, l, c, u, d, v = e2[5].actions, p = _t(v, e2, e2[4], Ed), f = e2[2] && Pd(e2);
  return l = new Ca({ props: { data: faTimes } }), { c() {
    t3 = ln("div"), n2 = ln("div"), r2 = un(e2[1]), o2 = dn(), p && p.c(), a2 = dn(), f && f.c(), i2 = dn(), s2 = ln("button"), sr(l.$$.fragment), hn(n2, "class", "jse-title svelte-1y24war"), hn(s2, "type", "button"), hn(s2, "class", "jse-close svelte-1y24war"), hn(t3, "class", "jse-header svelte-1y24war");
  }, m(v2, m3) {
    on(v2, t3, m3), nn(t3, n2), nn(n2, r2), nn(t3, o2), p && p.m(t3, null), nn(t3, a2), f && f.m(t3, null), nn(t3, i2), nn(t3, s2), lr(l, s2, null), c = true, u || (d = pn(s2, "click", e2[7]), u = true);
  }, p(e3, n3) {
    var [o3] = n3;
    (!c || 2 & o3) && yn(r2, e3[1]), p && p.p && (!c || 16 & o3) && Yt(p, v, e3, e3[4], c ? Qt(v, e3[4], o3, Rd) : Kt(e3[4]), Ed), e3[2] ? f ? (f.p(e3, o3), 4 & o3 && Xn(f, 1)) : ((f = Pd(e3)).c(), Xn(f, 1), f.m(t3, i2)) : f && (Kn(), Gn(f, 1, 1, () => {
      f = null;
    }), Zn());
  }, i(e3) {
    c || (Xn(p, e3), Xn(f), Xn(l.$$.fragment, e3), c = true);
  }, o(e3) {
    Gn(p, e3), Gn(f), Gn(l.$$.fragment, e3), c = false;
  }, d(e3) {
    e3 && an(t3), p && p.d(e3), f && f.d(), cr(l), u = false, d();
  } };
}
function Td(e2, t3, n2) {
  var { $$slots: r2 = {}, $$scope: o2 } = t3, { title: a2 = "Modal" } = t3, { fullScreenButton: i2 = false } = t3, { fullscreen: s2 = false } = t3, { onClose: l } = t3;
  return e2.$$set = (e3) => {
    "title" in e3 && n2(1, a2 = e3.title), "fullScreenButton" in e3 && n2(2, i2 = e3.fullScreenButton), "fullscreen" in e3 && n2(0, s2 = e3.fullscreen), "onClose" in e3 && n2(3, l = e3.onClose), "$$scope" in e3 && n2(4, o2 = e3.$$scope);
  }, [s2, a2, i2, l, o2, r2, () => n2(0, s2 = !s2), () => {
    var e3;
    return null === (e3 = l) || void 0 === e3 ? void 0 : e3();
  }];
}
var Ad = class extends dr {
  constructor(e2) {
    super(), ur(this, e2, Td, Id, Ht, { title: 1, fullScreenButton: 2, fullscreen: 0, onClose: 3 }, Md);
  }
};
function Nd(e2) {
  rn(e2, "svelte-1kpylsp", ".jse-config.svelte-1kpylsp{border:none;background:transparent;min-width:32px;color:inherit;cursor:pointer}.jse-config.svelte-1kpylsp:hover{background:rgba(255, 255, 255, 0.1)}.jse-config.hide.svelte-1kpylsp{display:none}");
}
function Bd(e2) {
  var t3, n2, r2, o2, a2;
  return n2 = new Ca({ props: { data: faCog } }), { c() {
    t3 = ln("button"), sr(n2.$$.fragment), hn(t3, "slot", "actions"), hn(t3, "type", "button"), hn(t3, "class", "jse-config svelte-1kpylsp"), hn(t3, "title", "Select a query language"), kn(t3, "hide", e2[1].length <= 1);
  }, m(i2, s2) {
    on(i2, t3, s2), lr(n2, t3, null), e2[7](t3), r2 = true, o2 || (a2 = pn(t3, "click", e2[4]), o2 = true);
  }, p(e3, n3) {
    (!r2 || 2 & n3) && kn(t3, "hide", e3[1].length <= 1);
  }, i(e3) {
    r2 || (Xn(n2.$$.fragment, e3), r2 = true);
  }, o(e3) {
    Gn(n2.$$.fragment, e3), r2 = false;
  }, d(r3) {
    r3 && an(t3), cr(n2), e2[7](null), o2 = false, a2();
  } };
}
function Fd(e2) {
  var t3, n2, r2;
  function o2(t4) {
    e2[8](t4);
  }
  var a2 = { title: "Transform", fullScreenButton: true, onClose: e2[2], $$slots: { actions: [Bd] }, $$scope: { ctx: e2 } };
  return void 0 !== e2[0] && (a2.fullscreen = e2[0]), t3 = new Ad({ props: a2 }), Tn.push(() => ir(t3, "fullscreen", o2)), { c() {
    sr(t3.$$.fragment);
  }, m(e3, n3) {
    lr(t3, e3, n3), r2 = true;
  }, p(e3, r3) {
    var [o3] = r3, a3 = {};
    4 & o3 && (a3.onClose = e3[2]), 4106 & o3 && (a3.$$scope = { dirty: o3, ctx: e3 }), !n2 && 1 & o3 && (n2 = true, a3.fullscreen = e3[0], Jn(() => n2 = false)), t3.$set(a3);
  }, i(e3) {
    r2 || (Xn(t3.$$.fragment, e3), r2 = true);
  }, o(e3) {
    Gn(t3.$$.fragment, e3), r2 = false;
  }, d(e3) {
    cr(t3, e3);
  } };
}
function Ud(e2, t3, n2) {
  var r2, o2, { queryLanguages: a2 } = t3, { queryLanguageId: i2 } = t3, { fullscreen: s2 } = t3, { onChangeQueryLanguage: l } = t3, { onClose: c } = t3, { openAbsolutePopup: u, closeAbsolutePopup: d } = En("absolute-popup");
  return e2.$$set = (e3) => {
    "queryLanguages" in e3 && n2(1, a2 = e3.queryLanguages), "queryLanguageId" in e3 && n2(5, i2 = e3.queryLanguageId), "fullscreen" in e3 && n2(0, s2 = e3.fullscreen), "onChangeQueryLanguage" in e3 && n2(6, l = e3.onChangeQueryLanguage), "onClose" in e3 && n2(2, c = e3.onClose);
  }, [s2, a2, c, r2, function() {
    var e3 = { queryLanguages: a2, queryLanguageId: i2, onChangeQueryLanguage: (e4) => {
      d(o2), l(e4);
    } };
    o2 = u(qd, e3, { offsetTop: -2, offsetLeft: 0, anchor: r2, closeOnOuterClick: true });
  }, i2, l, function(e3) {
    Tn[e3 ? "unshift" : "push"](() => {
      n2(3, r2 = e3);
    });
  }, function(e3) {
    n2(0, s2 = e3);
  }];
}
var Ld = class extends dr {
  constructor(e2) {
    super(), ur(this, e2, Ud, Fd, Ht, { queryLanguages: 1, queryLanguageId: 5, fullscreen: 0, onChangeQueryLanguage: 6, onClose: 2 }, Nd);
  }
};
var Dd = vr("jsoneditor:AutoScrollHandler");
var Jd = (e2, t3, n2, r2) => (e2 /= r2 / 2) < 1 ? n2 / 2 * e2 * e2 + t3 : -n2 / 2 * (--e2 * (e2 - 2) - 1) + t3;
var Vd = () => {
  var e2, t3, n2, r2, o2, a2, i2, s2, l, c, u, d, v;
  function p(t4) {
    return t4.getBoundingClientRect().top - (e2.getBoundingClientRect ? e2.getBoundingClientRect().top : 0) + n2;
  }
  function f(t4) {
    e2.scrollTo ? e2.scrollTo(e2.scrollLeft, t4) : e2.scrollTop = t4;
  }
  function m3(e3) {
    c || (c = e3), f(a2(u = e3 - c, n2, s2, l)), v = true, u < l ? requestAnimationFrame(m3) : function() {
      if (f(n2 + s2), t3 && i2) {
        t3.setAttribute("tabindex", "-1"), t3.focus();
      }
      "function" == typeof d && d();
      c = 0, v = false;
    }();
  }
  return function(u2) {
    var f2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    switch (l = 1e3, o2 = f2.offset || 0, d = f2.callback, a2 = f2.easing || Jd, i2 = f2.a11y || false, typeof f2.container) {
      case "object":
        e2 = f2.container;
        break;
      case "string":
        e2 = document.querySelector(f2.container);
        break;
      default:
        e2 = window.document.documentElement;
    }
    switch (n2 = e2.scrollTop, typeof u2) {
      case "number":
        t3 = void 0, i2 = false, r2 = n2 + u2;
        break;
      case "object":
        r2 = p(t3 = u2);
        break;
      case "string":
        t3 = document.querySelector(u2), r2 = p(t3);
    }
    switch (s2 = r2 - n2 + o2, typeof f2.duration) {
      case "number":
        l = f2.duration;
        break;
      case "function":
        l = f2.duration(s2);
    }
    v ? c = 0 : requestAnimationFrame(m3);
  };
};
var Hd = 1e3;
var _d = vr("jsoneditor:History");
function Wd() {
  var e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, t3 = e2.maxItems || Hd, n2 = [], r2 = 0;
  function o2() {
    return r2 < n2.length;
  }
  function a2() {
    return r2 > 0;
  }
  function i2() {
    return { canUndo: o2(), canRedo: a2(), length: n2.length };
  }
  function s2() {
    e2.onChange && e2.onChange(i2());
  }
  return { add: function(e3) {
    _d("add", e3), n2 = [e3].concat(n2.slice(r2)).slice(0, t3), r2 = 0, s2();
  }, clear: function() {
    _d("clear"), n2 = [], r2 = 0, s2();
  }, getState: i2, undo: function() {
    if (o2()) {
      var e3 = n2[r2];
      return r2 += 1, _d("undo", e3), s2(), e3;
    }
  }, redo: function() {
    if (a2()) return _d("redo", n2[r2 -= 1]), s2(), n2[r2];
  } };
}
function Qd(e2, t3) {
  var n2 = Date.now(), r2 = e2();
  return t3(Date.now() - n2), r2;
}
var Yd = vr("validation");
var Kd = { createObjectDocumentState: () => ({ type: "object", properties: {} }), createArrayDocumentState: () => ({ type: "array", items: [] }), createValueDocumentState: () => ({ type: "value" }) };
function Zd(e2, t3, n2, r2) {
  return Ji(e2, t3, n2, r2, Kd);
}
function Xd(e2, t3, n2, r2) {
  if (Yd("validateJSON"), !t3) return [];
  if (n2 !== r2) {
    var o2 = n2.stringify(e2);
    return t3(void 0 !== o2 ? r2.parse(o2) : void 0);
  }
  return t3(e2);
}
function Gd(e2, t3, n2, r2) {
  if (Yd("validateText"), e2.length > _a2) return { validationErrors: [{ path: [], message: "Validation turned off: the document is too large", severity: po.info }] };
  if (0 !== e2.length) try {
    var o2 = Qd(() => n2.parse(e2), (e3) => Yd("validate: parsed json in ".concat(e3, " ms")));
    if (!t3) return;
    var a2 = n2 === r2 ? o2 : Qd(() => r2.parse(e2), (e3) => Yd("validate: parsed json with the validationParser in ".concat(e3, " ms"))), i2 = Qd(() => t3(a2), (e3) => Yd("validate: validated json in ".concat(e3, " ms")));
    return isEmpty_default(i2) ? void 0 : { validationErrors: i2 };
  } catch (t4) {
    var s2 = Qd(() => function(e3, t5) {
      if (e3.length > Wa) return false;
      try {
        return t5.parse(jsonrepair(e3)), true;
      } catch (e4) {
        return false;
      }
    }(e2, n2), (e3) => Yd("validate: checked whether repairable in ".concat(e3, " ms")));
    return { parseError: Qr(e2, t4.message || t4.toString()), isRepairable: s2 };
  }
}
var ev = vr("jsoneditor:FocusTracker");
function tv(e2) {
  var t3, { onMount: n2, onDestroy: r2, getWindow: o2, hasFocus: a2, onFocus: i2, onBlur: s2 } = e2, l = false;
  function c() {
    var e3 = a2();
    e3 && (clearTimeout(t3), l || (ev("focus"), i2(), l = e3));
  }
  function u() {
    l && (clearTimeout(t3), t3 = setTimeout(() => {
      a2() || (ev("blur"), l = false, s2());
    }));
  }
  n2(() => {
    ev("mount FocusTracker");
    var e3 = o2();
    e3 && (e3.addEventListener("focusin", c, true), e3.addEventListener("focusout", u, true));
  }), r2(() => {
    ev("destroy FocusTracker");
    var e3 = o2();
    e3 && (e3.removeEventListener("focusin", c, true), e3.removeEventListener("focusout", u, true));
  });
}
function nv(e2) {
  rn(e2, "svelte-czprfx", '.jse-message.svelte-czprfx.svelte-czprfx{font-family:var(--jse-font-family-mono, consolas, menlo, monaco, "Ubuntu Mono", "source-code-pro", monospace);font-size:var(--jse-font-size-mono, 14px);padding:var(--jse-padding, 10px);display:flex;gap:var(--jse-padding, 10px);flex-wrap:wrap;align-items:stretch}.jse-message.jse-success.svelte-czprfx.svelte-czprfx{background:var(--message-success-background, #9ac45d);color:var(--jse-message-success-color, #fff)}.jse-message.svelte-czprfx .jse-text.svelte-czprfx{display:flex;flex:1;min-width:60%;align-items:center}.jse-message.svelte-czprfx .jse-text.jse-clickable.svelte-czprfx{cursor:pointer}.jse-message.svelte-czprfx .jse-text.jse-clickable.svelte-czprfx:hover{background-color:rgba(255, 255, 255, 0.1)}.jse-message.jse-error.svelte-czprfx.svelte-czprfx{background:var(--jse-message-error-background, var(--jse-error-color, #ee5341));color:var(--jse-message-error-color, #fff)}.jse-message.jse-warning.svelte-czprfx.svelte-czprfx{background:var(--jse-message-warning-background, #ffde5c);color:var(--jse-message-warning-color, #4d4d4d)}.jse-message.jse-info.svelte-czprfx.svelte-czprfx{background:var(--jse-message-info-background, #4f91ff);color:var(--jse-message-info-color, #fff)}.jse-message.svelte-czprfx .jse-actions.svelte-czprfx{display:flex;gap:var(--jse-padding, 10px)}.jse-message.svelte-czprfx .jse-actions button.jse-action.svelte-czprfx{border:none;background:transparent;color:inherit;cursor:pointer;font-family:var(--jse-font-family, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif);font-size:var(--jse-font-size, 16px);padding:5px;margin:0;background:var(--jse-message-action-background, rgba(255, 255, 255, 0.2));color:inherit;padding:calc(0.5 * var(--jse-padding, 10px)) var(--jse-padding, 10px)}.jse-message.svelte-czprfx .jse-actions button.jse-action.svelte-czprfx:hover{background:var(--jse-message-action-background-highlight, rgba(255, 255, 255, 0.3))}');
}
function rv(e2, t3, n2) {
  var r2 = e2.slice();
  return r2[9] = t3[n2], r2;
}
function ov(e2) {
  var t3, n2;
  return t3 = new Ca({ props: { data: e2[1] } }), { c() {
    sr(t3.$$.fragment);
  }, m(e3, r2) {
    lr(t3, e3, r2), n2 = true;
  }, p(e3, n3) {
    var r2 = {};
    2 & n3 && (r2.data = e3[1]), t3.$set(r2);
  }, i(e3) {
    n2 || (Xn(t3.$$.fragment, e3), n2 = true);
  }, o(e3) {
    Gn(t3.$$.fragment, e3), n2 = false;
  }, d(e3) {
    cr(t3, e3);
  } };
}
function av(e2) {
  var t3, n2;
  return t3 = new Ca({ props: { data: e2[9].icon } }), { c() {
    sr(t3.$$.fragment);
  }, m(e3, r2) {
    lr(t3, e3, r2), n2 = true;
  }, p(e3, n3) {
    var r2 = {};
    8 & n3 && (r2.data = e3[9].icon), t3.$set(r2);
  }, i(e3) {
    n2 || (Xn(t3.$$.fragment, e3), n2 = true);
  }, o(e3) {
    Gn(t3.$$.fragment, e3), n2 = false;
  }, d(e3) {
    cr(t3, e3);
  } };
}
function iv(e2) {
  var t3, n2, r2, o2, a2, i2, s2, l, c, u = e2[9].text + "", d = e2[9].icon && av(e2);
  function v() {
    return e2[7](e2[9]);
  }
  function p() {
    return e2[8](e2[9]);
  }
  return { c() {
    t3 = ln("button"), d && d.c(), n2 = dn(), r2 = un(u), o2 = dn(), hn(t3, "type", "button"), hn(t3, "class", "jse-button jse-action jse-primary svelte-czprfx"), hn(t3, "title", a2 = e2[9].title), t3.disabled = i2 = e2[9].disabled;
  }, m(e3, a3) {
    on(e3, t3, a3), d && d.m(t3, null), nn(t3, n2), nn(t3, r2), nn(t3, o2), s2 = true, l || (c = [pn(t3, "click", v), pn(t3, "mousedown", p)], l = true);
  }, p(o3, l2) {
    (e2 = o3)[9].icon ? d ? (d.p(e2, l2), 8 & l2 && Xn(d, 1)) : ((d = av(e2)).c(), Xn(d, 1), d.m(t3, n2)) : d && (Kn(), Gn(d, 1, 1, () => {
      d = null;
    }), Zn()), (!s2 || 8 & l2) && u !== (u = e2[9].text + "") && yn(r2, u), (!s2 || 8 & l2 && a2 !== (a2 = e2[9].title)) && hn(t3, "title", a2), (!s2 || 8 & l2 && i2 !== (i2 = e2[9].disabled)) && (t3.disabled = i2);
  }, i(e3) {
    s2 || (Xn(d), s2 = true);
  }, o(e3) {
    Gn(d), s2 = false;
  }, d(e3) {
    e3 && an(t3), d && d.d(), l = false, Dt(c);
  } };
}
function sv(e2) {
  for (var t3, n2, r2, o2, a2, i2, s2, l, c, u, d, v = e2[1] && ov(e2), p = er(e2[3]), f = [], m3 = 0; m3 < p.length; m3 += 1) f[m3] = iv(rv(e2, p, m3));
  var h2 = (e3) => Gn(f[e3], 1, 1, () => {
    f[e3] = null;
  });
  return { c() {
    t3 = ln("div"), n2 = ln("div"), r2 = ln("div"), v && v.c(), o2 = dn(), a2 = un(e2[2]), i2 = dn(), s2 = ln("div");
    for (var c2 = 0; c2 < f.length; c2 += 1) f[c2].c();
    hn(r2, "class", "jse-text-centered"), hn(n2, "role", "button"), hn(n2, "tabindex", "-1"), hn(n2, "class", "jse-text svelte-czprfx"), kn(n2, "jse-clickable", !!e2[4]), hn(s2, "class", "jse-actions svelte-czprfx"), hn(t3, "class", l = "jse-message jse-" + e2[0] + " svelte-czprfx");
  }, m(l2, p2) {
    on(l2, t3, p2), nn(t3, n2), nn(n2, r2), v && v.m(r2, null), nn(r2, o2), nn(r2, a2), nn(t3, i2), nn(t3, s2);
    for (var m4 = 0; m4 < f.length; m4 += 1) f[m4] && f[m4].m(s2, null);
    c = true, u || (d = pn(n2, "click", e2[5]), u = true);
  }, p(e3, i3) {
    var [u2] = i3;
    if (e3[1] ? v ? (v.p(e3, u2), 2 & u2 && Xn(v, 1)) : ((v = ov(e3)).c(), Xn(v, 1), v.m(r2, o2)) : v && (Kn(), Gn(v, 1, 1, () => {
      v = null;
    }), Zn()), (!c || 4 & u2) && yn(a2, e3[2]), (!c || 16 & u2) && kn(n2, "jse-clickable", !!e3[4]), 8 & u2) {
      var d2;
      for (p = er(e3[3]), d2 = 0; d2 < p.length; d2 += 1) {
        var m4 = rv(e3, p, d2);
        f[d2] ? (f[d2].p(m4, u2), Xn(f[d2], 1)) : (f[d2] = iv(m4), f[d2].c(), Xn(f[d2], 1), f[d2].m(s2, null));
      }
      for (Kn(), d2 = p.length; d2 < f.length; d2 += 1) h2(d2);
      Zn();
    }
    (!c || 1 & u2 && l !== (l = "jse-message jse-" + e3[0] + " svelte-czprfx")) && hn(t3, "class", l);
  }, i(e3) {
    if (!c) {
      Xn(v);
      for (var t4 = 0; t4 < p.length; t4 += 1) Xn(f[t4]);
      c = true;
    }
  }, o(e3) {
    Gn(v), f = f.filter(Boolean);
    for (var t4 = 0; t4 < f.length; t4 += 1) Gn(f[t4]);
    c = false;
  }, d(e3) {
    e3 && an(t3), v && v.d(), sn(f, e3), u = false, d();
  } };
}
function lv(e2, t3, n2) {
  var { type: r2 = "success" } = t3, { icon: o2 } = t3, { message: a2 } = t3, { actions: i2 = [] } = t3, { onClick: s2 } = t3, { onClose: l } = t3;
  l && Mn(l);
  return e2.$$set = (e3) => {
    "type" in e3 && n2(0, r2 = e3.type), "icon" in e3 && n2(1, o2 = e3.icon), "message" in e3 && n2(2, a2 = e3.message), "actions" in e3 && n2(3, i2 = e3.actions), "onClick" in e3 && n2(4, s2 = e3.onClick), "onClose" in e3 && n2(6, l = e3.onClose);
  }, [r2, o2, a2, i2, s2, function() {
    s2 && s2();
  }, l, (e3) => {
    e3.onClick && e3.onClick();
  }, (e3) => {
    e3.onMouseDown && e3.onMouseDown();
  }];
}
var cv = class extends dr {
  constructor(e2) {
    super(), ur(this, e2, lv, sv, Ht, { type: 0, icon: 1, message: 2, actions: 3, onClick: 4, onClose: 6 }, nv);
  }
};
function uv(e2) {
  rn(e2, "svelte-1uindol", '.jse-validation-errors-overview.svelte-1uindol.svelte-1uindol{font-family:var(--jse-font-family-mono, consolas, menlo, monaco, "Ubuntu Mono", "source-code-pro", monospace);font-size:var(--jse-font-size-mono, 14px);overflow:auto;max-height:25%}.jse-validation-errors-overview.svelte-1uindol table.svelte-1uindol{border-collapse:collapse;width:100%}.jse-validation-errors-overview.svelte-1uindol table tr.svelte-1uindol{cursor:pointer}.jse-validation-errors-overview.svelte-1uindol table tr.jse-validation-error.svelte-1uindol{background:var(--jse-message-error-background, var(--jse-error-color, #ee5341));color:var(--jse-message-error-color, #fff)}.jse-validation-errors-overview.svelte-1uindol table tr.jse-validation-warning.svelte-1uindol{background:var(--jse-message-warning-background, #ffde5c);color:var(--jse-message-warning-color, #4d4d4d)}.jse-validation-errors-overview.svelte-1uindol table tr.jse-validation-warning.svelte-1uindol:hover{filter:brightness(105%)}.jse-validation-errors-overview.svelte-1uindol table tr.jse-validation-info.svelte-1uindol{background:var(--jse-message-info-background, #4f91ff);color:var(--jse-message-info-color, #fff)}.jse-validation-errors-overview.svelte-1uindol table tr.svelte-1uindol:hover{filter:brightness(110%)}.jse-validation-errors-overview.svelte-1uindol table tr td.svelte-1uindol{padding:4px var(--jse-padding, 10px);vertical-align:middle}.jse-validation-errors-overview.svelte-1uindol table tr td.jse-validation-error-icon.svelte-1uindol{width:36px;box-sizing:border-box}.jse-validation-errors-overview.svelte-1uindol table tr td.jse-validation-error-action.svelte-1uindol{width:36px;box-sizing:border-box;padding:0}.jse-validation-errors-overview.svelte-1uindol table tr td.jse-validation-error-action button.jse-validation-errors-collapse.svelte-1uindol{border:none;background:transparent;color:inherit;cursor:pointer;font-family:var(--jse-font-family, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif);font-size:var(--jse-font-size, 16px);padding:5px;margin:0;width:36px;height:26px;cursor:pointer}.jse-validation-errors-overview.svelte-1uindol table tr td.jse-validation-error-action button.jse-validation-errors-collapse.svelte-1uindol:hover{background-color:rgba(255, 255, 255, 0.2)}.jse-validation-errors-overview.svelte-1uindol table tr td div.jse-validation-errors-expand.svelte-1uindol{display:inline-block;position:relative;top:3px}');
}
function dv(e2, t3, n2) {
  var r2 = e2.slice();
  return r2[8] = t3[n2], r2[10] = n2, r2;
}
function vv(e2) {
  var t3, n2, r2, o2, a2 = [fv, pv], i2 = [];
  function s2(e3, t4) {
    return e3[2] || 1 === e3[3] ? 0 : 1;
  }
  return n2 = s2(e2), r2 = i2[n2] = a2[n2](e2), { c() {
    t3 = ln("div"), r2.c(), hn(t3, "class", "jse-validation-errors-overview svelte-1uindol");
  }, m(e3, r3) {
    on(e3, t3, r3), i2[n2].m(t3, null), o2 = true;
  }, p(e3, o3) {
    var l = n2;
    (n2 = s2(e3)) === l ? i2[n2].p(e3, o3) : (Kn(), Gn(i2[l], 1, 1, () => {
      i2[l] = null;
    }), Zn(), (r2 = i2[n2]) ? r2.p(e3, o3) : (r2 = i2[n2] = a2[n2](e3)).c(), Xn(r2, 1), r2.m(t3, null));
  }, i(e3) {
    o2 || (Xn(r2), o2 = true);
  }, o(e3) {
    Gn(r2), o2 = false;
  }, d(e3) {
    e3 && an(t3), i2[n2].d();
  } };
}
function pv(e2) {
  var t3, n2, r2, o2, a2, i2, s2, l, c, u, d, v, p, f, m3;
  return a2 = new Ca({ props: { data: faExclamationTriangle } }), d = new Ca({ props: { data: faAngleRight } }), { c() {
    t3 = ln("table"), n2 = ln("tbody"), r2 = ln("tr"), o2 = ln("td"), sr(a2.$$.fragment), i2 = dn(), s2 = ln("td"), l = un(e2[3]), c = un(" validation errors\n              "), u = ln("div"), sr(d.$$.fragment), hn(o2, "class", "jse-validation-error-icon svelte-1uindol"), hn(u, "class", "jse-validation-errors-expand svelte-1uindol"), hn(s2, "class", "jse-validation-error-count svelte-1uindol"), hn(r2, "class", v = "jse-validation-" + e2[6](e2[0]) + " svelte-1uindol"), hn(t3, "class", "jse-validation-errors-overview-collapsed svelte-1uindol");
  }, m(v2, h2) {
    on(v2, t3, h2), nn(t3, n2), nn(n2, r2), nn(r2, o2), lr(a2, o2, null), nn(r2, i2), nn(r2, s2), nn(s2, l), nn(s2, c), nn(s2, u), lr(d, u, null), p = true, f || (m3 = pn(r2, "click", e2[5]), f = true);
  }, p(e3, t4) {
    (!p || 8 & t4) && yn(l, e3[3]), (!p || 1 & t4 && v !== (v = "jse-validation-" + e3[6](e3[0]) + " svelte-1uindol")) && hn(r2, "class", v);
  }, i(e3) {
    p || (Xn(a2.$$.fragment, e3), Xn(d.$$.fragment, e3), p = true);
  }, o(e3) {
    Gn(a2.$$.fragment, e3), Gn(d.$$.fragment, e3), p = false;
  }, d(e3) {
    e3 && an(t3), cr(a2), cr(d), f = false, m3();
  } };
}
function fv(e2) {
  for (var t3, n2, r2, o2, a2 = er(Br(e2[0], Ja)), i2 = [], s2 = 0; s2 < a2.length; s2 += 1) i2[s2] = hv(dv(e2, a2, s2));
  var l = (e3) => Gn(i2[e3], 1, 1, () => {
    i2[e3] = null;
  }), c = e2[3] > Ja && gv(e2);
  return { c() {
    t3 = ln("table"), n2 = ln("tbody");
    for (var e3 = 0; e3 < i2.length; e3 += 1) i2[e3].c();
    r2 = dn(), c && c.c(), hn(t3, "class", "jse-validation-errors-overview-expanded svelte-1uindol");
  }, m(e3, a3) {
    on(e3, t3, a3), nn(t3, n2);
    for (var s3 = 0; s3 < i2.length; s3 += 1) i2[s3] && i2[s3].m(n2, null);
    nn(n2, r2), c && c.m(n2, null), o2 = true;
  }, p(e3, t4) {
    if (19 & t4) {
      var o3;
      for (a2 = er(Br(e3[0], Ja)), o3 = 0; o3 < a2.length; o3 += 1) {
        var s3 = dv(e3, a2, o3);
        i2[o3] ? (i2[o3].p(s3, t4), Xn(i2[o3], 1)) : (i2[o3] = hv(s3), i2[o3].c(), Xn(i2[o3], 1), i2[o3].m(n2, r2));
      }
      for (Kn(), o3 = a2.length; o3 < i2.length; o3 += 1) l(o3);
      Zn();
    }
    e3[3] > Ja ? c ? c.p(e3, t4) : ((c = gv(e3)).c(), c.m(n2, null)) : c && (c.d(1), c = null);
  }, i(e3) {
    if (!o2) {
      for (var t4 = 0; t4 < a2.length; t4 += 1) Xn(i2[t4]);
      o2 = true;
    }
  }, o(e3) {
    i2 = i2.filter(Boolean);
    for (var t4 = 0; t4 < i2.length; t4 += 1) Gn(i2[t4]);
    o2 = false;
  }, d(e3) {
    e3 && an(t3), sn(i2, e3), c && c.d();
  } };
}
function mv(e2) {
  var t3, n2, r2, o2, a2;
  return n2 = new Ca({ props: { data: faAngleDown } }), { c() {
    t3 = ln("button"), sr(n2.$$.fragment), hn(t3, "type", "button"), hn(t3, "class", "jse-validation-errors-collapse svelte-1uindol"), hn(t3, "title", "Collapse validation errors");
  }, m(i2, s2) {
    on(i2, t3, s2), lr(n2, t3, null), r2 = true, o2 || (a2 = pn(t3, "click", mn(e2[4])), o2 = true);
  }, p: Bt, i(e3) {
    r2 || (Xn(n2.$$.fragment, e3), r2 = true);
  }, o(e3) {
    Gn(n2.$$.fragment, e3), r2 = false;
  }, d(e3) {
    e3 && an(t3), cr(n2), o2 = false, a2();
  } };
}
function hv(e2) {
  var t3, n2, r2, o2, a2, i2, s2, l, c, u, d, v, p, f, m3, h2 = _l(e2[8].path) + "", g = e2[8].message + "";
  r2 = new Ca({ props: { data: faExclamationTriangle } });
  var j = 0 === e2[10] && e2[0].length > 1 && mv(e2);
  function x() {
    return e2[7](e2[8]);
  }
  return { c() {
    t3 = ln("tr"), n2 = ln("td"), sr(r2.$$.fragment), o2 = dn(), a2 = ln("td"), i2 = un(h2), s2 = dn(), l = ln("td"), c = un(g), u = dn(), d = ln("td"), j && j.c(), hn(n2, "class", "jse-validation-error-icon svelte-1uindol"), hn(a2, "class", "jse-validation-error-path svelte-1uindol"), hn(l, "class", "jse-validation-error-message svelte-1uindol"), hn(d, "class", "jse-validation-error-action svelte-1uindol"), hn(t3, "class", v = "jse-validation-" + e2[8].severity + " svelte-1uindol"), hn(t3, "tabindex", "0");
  }, m(e3, v2) {
    on(e3, t3, v2), nn(t3, n2), lr(r2, n2, null), nn(t3, o2), nn(t3, a2), nn(a2, i2), nn(t3, s2), nn(t3, l), nn(l, c), nn(t3, u), nn(t3, d), j && j.m(d, null), p = true, f || (m3 = pn(t3, "click", x), f = true);
  }, p(n3, r3) {
    e2 = n3, (!p || 1 & r3) && h2 !== (h2 = _l(e2[8].path) + "") && yn(i2, h2), (!p || 1 & r3) && g !== (g = e2[8].message + "") && yn(c, g), 0 === e2[10] && e2[0].length > 1 ? j ? (j.p(e2, r3), 1 & r3 && Xn(j, 1)) : ((j = mv(e2)).c(), Xn(j, 1), j.m(d, null)) : j && (Kn(), Gn(j, 1, 1, () => {
      j = null;
    }), Zn()), (!p || 1 & r3 && v !== (v = "jse-validation-" + e2[8].severity + " svelte-1uindol")) && hn(t3, "class", v);
  }, i(e3) {
    p || (Xn(r2.$$.fragment, e3), Xn(j), p = true);
  }, o(e3) {
    Gn(r2.$$.fragment, e3), Gn(j), p = false;
  }, d(e3) {
    e3 && an(t3), cr(r2), j && j.d(), f = false, m3();
  } };
}
function gv(e2) {
  var t3, n2, r2, o2, a2, i2, s2, l, c, u, d, v = e2[3] - Ja + "";
  return { c() {
    t3 = ln("tr"), n2 = ln("td"), r2 = dn(), o2 = ln("td"), a2 = dn(), i2 = ln("td"), s2 = un("(and "), l = un(v), c = un(" more errors)"), u = dn(), d = ln("td"), hn(n2, "class", "svelte-1uindol"), hn(o2, "class", "svelte-1uindol"), hn(i2, "class", "svelte-1uindol"), hn(d, "class", "svelte-1uindol"), hn(t3, "class", "jse-validation-error svelte-1uindol");
  }, m(e3, v2) {
    on(e3, t3, v2), nn(t3, n2), nn(t3, r2), nn(t3, o2), nn(t3, a2), nn(t3, i2), nn(i2, s2), nn(i2, l), nn(i2, c), nn(t3, u), nn(t3, d);
  }, p(e3, t4) {
    8 & t4 && v !== (v = e3[3] - Ja + "") && yn(l, v);
  }, d(e3) {
    e3 && an(t3);
  } };
}
function jv(e2) {
  var t3, n2, r2 = !isEmpty_default(e2[0]), o2 = r2 && vv(e2);
  return { c() {
    o2 && o2.c(), t3 = vn();
  }, m(e3, r3) {
    o2 && o2.m(e3, r3), on(e3, t3, r3), n2 = true;
  }, p(e3, n3) {
    var [a2] = n3;
    1 & a2 && (r2 = !isEmpty_default(e3[0])), r2 ? o2 ? (o2.p(e3, a2), 1 & a2 && Xn(o2, 1)) : ((o2 = vv(e3)).c(), Xn(o2, 1), o2.m(t3.parentNode, t3)) : o2 && (Kn(), Gn(o2, 1, 1, () => {
      o2 = null;
    }), Zn());
  }, i(e3) {
    n2 || (Xn(o2), n2 = true);
  }, o(e3) {
    Gn(o2), n2 = false;
  }, d(e3) {
    e3 && an(t3), o2 && o2.d(e3);
  } };
}
function xv(e2, t3, n2) {
  var r2, { validationErrors: o2 } = t3, { selectError: a2 } = t3, i2 = true;
  return e2.$$set = (e3) => {
    "validationErrors" in e3 && n2(0, o2 = e3.validationErrors), "selectError" in e3 && n2(1, a2 = e3.selectError);
  }, e2.$$.update = () => {
    1 & e2.$$.dirty && n2(3, r2 = o2.length);
  }, [o2, a2, i2, r2, function() {
    n2(2, i2 = false);
  }, function() {
    n2(2, i2 = true);
  }, function(e3) {
    return [po.error, po.warning, po.info].find((t4) => e3.some((e4) => e4.severity === t4));
  }, (e3) => {
    setTimeout(() => a2(e3));
  }];
}
var bv = class extends dr {
  constructor(e2) {
    super(), ur(this, e2, xv, jv, Ht, { validationErrors: 0, selectError: 1 }, uv);
  }
};
function yv(e2, t3) {
  if (e2) return e2.addEventListener("keydown", n2), { destroy() {
    e2.removeEventListener("keydown", n2);
  } };
  function n2(e3) {
    "Escape" === e3.key && (e3.preventDefault(), e3.stopPropagation(), t3());
  }
}
function $v(e2) {
  rn(e2, "svelte-1s9c2ql", 'dialog.jse-modal.svelte-1s9c2ql.svelte-1s9c2ql{border-radius:3px;font-size:var(--jse-padding, 10px);border:none;padding:0;display:flex;min-width:0;margin:auto;overflow:visible;transition:width 0.1s ease-in-out, height 0.1s ease-in-out}dialog.jse-modal.jse-sort-modal.svelte-1s9c2ql.svelte-1s9c2ql{width:400px}dialog.jse-modal.jse-repair-modal.svelte-1s9c2ql.svelte-1s9c2ql{width:600px;height:500px}dialog.jse-modal.jse-jsoneditor-modal.svelte-1s9c2ql.svelte-1s9c2ql{width:800px;height:600px}dialog.jse-modal.jse-transform-modal.svelte-1s9c2ql.svelte-1s9c2ql{width:1200px;height:800px}dialog.jse-modal.jse-fullscreen.svelte-1s9c2ql.svelte-1s9c2ql{width:100%;height:100%}dialog.jse-modal.svelte-1s9c2ql.svelte-1s9c2ql::backdrop{background:var(--jse-overlay-background, rgba(0, 0, 0, 0.3))}dialog.jse-modal[open].svelte-1s9c2ql.svelte-1s9c2ql{animation:svelte-1s9c2ql-zoom 0.3s cubic-bezier(0.34, 1.56, 0.64, 1)}dialog.jse-modal[open].svelte-1s9c2ql.svelte-1s9c2ql::backdrop{animation:svelte-1s9c2ql-fade 0.2s ease-out}dialog.jse-modal.svelte-1s9c2ql .jse-modal-inner.svelte-1s9c2ql{flex:1;display:flex;flex-direction:column;min-width:0;min-height:0;padding:0;font-family:var(--jse-font-family, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif);font-size:var(--jse-font-size, 16px);line-height:normal;background:var(--jse-modal-background, #f5f5f5);color:var(--jse-text-color, #4d4d4d)}@keyframes svelte-1s9c2ql-zoom{from{transform:scale(0.95)}to{transform:scale(1)}}@keyframes svelte-1s9c2ql-fade{from{opacity:0}to{opacity:1}}dialog.jse-modal.svelte-1s9c2ql .svelte-select{--border:var(--jse-svelte-select-border, 1px solid #d8dbdf);--item-is-active-bg:var(--jse-item-is-active-bg, #3883fa);--border-radius:var(--jse-svelte-select-border-radius, 3px);--background:var(--jse-svelte-select-background, #fff);--padding:var(--jse-svelte-select-padding, 0 10px);--multi-select-padding:var(--jse-svelte-select-multi-select-padding, 0 10px);--font-size:var(--jse-svelte-select-font-size, var(--jse-font-size, 16px));--height:36px;--multi-item-height:28px;--multi-item-margin:2px;--multi-item-padding:2px 8px;--multi-item-border-radius:6px;--indicator-top:8px}');
}
function wv(e2) {
  var t3, n2, r2, o2, a2, i2, s2 = e2[6].default, l = _t(s2, e2, e2[5], null);
  return { c() {
    t3 = ln("dialog"), n2 = ln("div"), l && l.c(), hn(n2, "class", "jse-modal-inner svelte-1s9c2ql"), hn(t3, "class", r2 = Gt(Vs("jse-modal", e2[0])) + " svelte-1s9c2ql"), kn(t3, "jse-fullscreen", e2[1]);
  }, m(r3, s3) {
    var c;
    on(r3, t3, s3), nn(t3, n2), l && l.m(n2, null), e2[8](t3), o2 = true, a2 || (i2 = [pn(t3, "close", e2[3]), pn(t3, "click", (c = e2[3], function(e3) {
      e3.target === this && c.call(this, e3);
    })), pn(t3, "cancel", fn(e2[7])), en(yv.call(null, t3, e2[3]))], a2 = true);
  }, p(e3, n3) {
    var [a3] = n3;
    l && l.p && (!o2 || 32 & a3) && Yt(l, s2, e3, e3[5], o2 ? Qt(s2, e3[5], a3, null) : Kt(e3[5]), null), (!o2 || 1 & a3 && r2 !== (r2 = Gt(Vs("jse-modal", e3[0])) + " svelte-1s9c2ql")) && hn(t3, "class", r2), (!o2 || 3 & a3) && kn(t3, "jse-fullscreen", e3[1]);
  }, i(e3) {
    o2 || (Xn(l, e3), o2 = true);
  }, o(e3) {
    Gn(l, e3), o2 = false;
  }, d(n3) {
    n3 && an(t3), l && l.d(n3), e2[8](null), a2 = false, Dt(i2);
  } };
}
function Cv(e2, t3, n2) {
  var r2, { $$slots: o2 = {}, $$scope: a2 } = t3, { className: i2 } = t3, { fullscreen: s2 = false } = t3, { onClose: l } = t3;
  return qn(() => r2.showModal()), Mn(() => r2.close()), e2.$$set = (e3) => {
    "className" in e3 && n2(0, i2 = e3.className), "fullscreen" in e3 && n2(1, s2 = e3.fullscreen), "onClose" in e3 && n2(4, l = e3.onClose), "$$scope" in e3 && n2(5, a2 = e3.$$scope);
  }, [i2, s2, r2, function() {
    l();
  }, l, a2, o2, function(t4) {
    Pn.call(this, e2, t4);
  }, function(e3) {
    Tn[e3 ? "unshift" : "push"](() => {
      n2(2, r2 = e3);
    });
  }];
}
var kv = class extends dr {
  constructor(e2) {
    super(), ur(this, e2, Cv, wv, Vt, { className: 0, fullscreen: 1, onClose: 4 }, $v);
  }
};
function Sv(e2) {
  rn(e2, "svelte-189qksl", '.jse-modal-contents.svelte-189qksl.svelte-189qksl{flex:1;display:flex;flex-direction:column;padding:20px;overflow:auto;min-width:0;min-height:0}.jse-modal-contents.svelte-189qksl .jse-actions.svelte-189qksl{display:flex;flex-direction:row;justify-content:flex-end;padding-top:var(--jse-padding, 10px)}.jse-modal-contents.svelte-189qksl .jse-actions button.jse-primary.svelte-189qksl{border:none;background:transparent;color:inherit;cursor:pointer;font-family:var(--jse-font-family, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif);font-size:var(--jse-font-size, 16px);padding:5px;margin:0;background:var(--jse-button-primary-background, var(--jse-theme-color, #3883fa));color:var(--jse-button-primary-color, #fff);padding:var(--jse-padding, 10px) calc(2 * var(--jse-padding, 10px));border-radius:3px}.jse-modal-contents.svelte-189qksl .jse-actions button.jse-primary.svelte-189qksl:hover{background:var(--jse-button-primary-background-highlight, var(--jse-theme-color-highlight, #5f9dff))}.jse-modal-contents.svelte-189qksl .jse-actions button.jse-primary.svelte-189qksl:disabled{background:var(--jse-button-primary-background-disabled, #9d9d9d)}.jse-shortcuts.svelte-189qksl.svelte-189qksl{display:flex;flex-wrap:wrap;justify-content:space-around;margin:calc(2 * var(--jse-padding, 10px)) 0}.jse-shortcuts.svelte-189qksl .jse-shortcut .jse-key.svelte-189qksl{font-size:200%;color:var(--jse-theme-color, #3883fa)}');
}
function Ov(e2) {
  var t3, n2, r2, o2, a2, i2, s2, l, c, u, d, v, p, f, m3, h2, g, j, x, b2, y, $2, w;
  return t3 = new Ad({ props: { title: "Copying and pasting", onClose: e2[0] } }), { c() {
    sr(t3.$$.fragment), n2 = dn(), r2 = ln("div"), (o2 = ln("div")).textContent = "These actions are unavailable via the menu. Please use:", a2 = dn(), i2 = ln("div"), s2 = ln("div"), (l = ln("div")).textContent = "".concat(e2[1], "+C"), c = un("\n        for copy"), u = dn(), d = ln("div"), (v = ln("div")).textContent = "".concat(e2[1], "+X"), p = un("\n        for cut"), f = dn(), m3 = ln("div"), (h2 = ln("div")).textContent = "".concat(e2[1], "+V"), g = un("\n        for paste"), j = dn(), x = ln("div"), (b2 = ln("button")).textContent = "Close", hn(l, "class", "jse-key svelte-189qksl"), hn(s2, "class", "jse-shortcut"), hn(v, "class", "jse-key svelte-189qksl"), hn(d, "class", "jse-shortcut"), hn(h2, "class", "jse-key svelte-189qksl"), hn(m3, "class", "jse-shortcut"), hn(i2, "class", "jse-shortcuts svelte-189qksl"), hn(b2, "type", "button"), hn(b2, "class", "jse-primary svelte-189qksl"), hn(x, "class", "jse-actions svelte-189qksl"), hn(r2, "class", "jse-modal-contents svelte-189qksl");
  }, m(C3, k2) {
    lr(t3, C3, k2), on(C3, n2, k2), on(C3, r2, k2), nn(r2, o2), nn(r2, a2), nn(r2, i2), nn(i2, s2), nn(s2, l), nn(s2, c), nn(i2, u), nn(i2, d), nn(d, v), nn(d, p), nn(i2, f), nn(i2, m3), nn(m3, h2), nn(m3, g), nn(r2, j), nn(r2, x), nn(x, b2), y = true, $2 || (w = pn(b2, "click", function() {
      Jt(e2[0]) && e2[0].apply(this, arguments);
    }), $2 = true);
  }, p(n3, r3) {
    e2 = n3;
    var o3 = {};
    1 & r3 && (o3.onClose = e2[0]), t3.$set(o3);
  }, i(e3) {
    y || (Xn(t3.$$.fragment, e3), y = true);
  }, o(e3) {
    Gn(t3.$$.fragment, e3), y = false;
  }, d(e3) {
    e3 && (an(n2), an(r2)), cr(t3, e3), $2 = false, w();
  } };
}
function zv(e2) {
  var t3, n2;
  return t3 = new kv({ props: { onClose: e2[0], className: "jse-copy-paste", $$slots: { default: [Ov] }, $$scope: { ctx: e2 } } }), { c() {
    sr(t3.$$.fragment);
  }, m(e3, r2) {
    lr(t3, e3, r2), n2 = true;
  }, p(e3, n3) {
    var [r2] = n3, o2 = {};
    1 & r2 && (o2.onClose = e3[0]), 5 & r2 && (o2.$$scope = { dirty: r2, ctx: e3 }), t3.$set(o2);
  }, i(e3) {
    n2 || (Xn(t3.$$.fragment, e3), n2 = true);
  }, o(e3) {
    Gn(t3.$$.fragment, e3), n2 = false;
  }, d(e3) {
    cr(t3, e3);
  } };
}
function qv(e2, t3, n2) {
  var { onClose: r2 } = t3, o2 = Lo() ? "⌘" : "Ctrl";
  return e2.$$set = (e3) => {
    "onClose" in e3 && n2(0, r2 = e3.onClose);
  }, [r2, o2];
}
var Mv = class extends dr {
  constructor(e2) {
    super(), ur(this, e2, qv, zv, Ht, { onClose: 0 }, Sv);
  }
};
function Rv(e2) {
  rn(e2, "svelte-pf7s2l", '.jse-menu.svelte-pf7s2l.svelte-pf7s2l{background:var(--jse-theme-color, #3883fa);font-family:var(--jse-font-family, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif);font-size:var(--jse-font-size-main-menu, 14px);color:var(--jse-menu-color, var(--jse-text-color-inverse, #fff));display:flex;flex-wrap:wrap;align-items:stretch;position:relative}.jse-menu.svelte-pf7s2l .jse-button.svelte-pf7s2l{font-family:inherit;font-size:inherit;line-height:1.5em;border:none;background:transparent;color:inherit;cursor:pointer;width:var(--jse-menu-button-size, 32px);height:var(--jse-menu-button-size, 32px);padding:calc(0.5 * var(--jse-padding, 10px));margin:0;border-radius:0;display:inline-flex;align-items:center;text-align:center;justify-content:center}.jse-menu.svelte-pf7s2l .jse-button.svelte-pf7s2l:hover,.jse-menu.svelte-pf7s2l .jse-button.svelte-pf7s2l:focus{background:var(--jse-theme-color-highlight, #5f9dff)}.jse-menu.svelte-pf7s2l .jse-button.svelte-pf7s2l:disabled{color:var(--jse-menu-color, var(--jse-text-color-inverse, #fff));opacity:0.5;background:transparent}.jse-menu.svelte-pf7s2l .jse-button.jse-group-button.svelte-pf7s2l{width:auto;height:calc(var(--jse-menu-button-size, 32px) - var(--jse-padding, 10px));margin:calc(0.5 * var(--jse-padding, 10px)) 0;padding:0 calc(0.5 * var(--jse-padding, 10px)) 1px;border:1px solid var(--jse-menu-color, var(--jse-text-color-inverse, #fff))}.jse-menu.svelte-pf7s2l .jse-button.jse-group-button.svelte-pf7s2l:not(.jse-last){border-right:none}.jse-menu.svelte-pf7s2l .jse-button.jse-group-button.jse-first.svelte-pf7s2l{margin-left:calc(0.5 * var(--jse-padding, 10px))}.jse-menu.svelte-pf7s2l .jse-button.jse-group-button.jse-last.svelte-pf7s2l{margin-right:calc(0.5 * var(--jse-padding, 10px))}.jse-menu.svelte-pf7s2l .jse-button.jse-group-button.svelte-pf7s2l:hover,.jse-menu.svelte-pf7s2l .jse-button.jse-group-button.svelte-pf7s2l:focus{background:var(--jse-theme-color-highlight, #5f9dff)}.jse-menu.svelte-pf7s2l .jse-button.jse-group-button.jse-selected.svelte-pf7s2l{background:var(--jse-menu-color, var(--jse-text-color-inverse, #fff));color:var(--jse-theme-color, #3883fa)}.jse-menu.svelte-pf7s2l .jse-space.svelte-pf7s2l{flex:1}.jse-menu.svelte-pf7s2l .jse-separator.svelte-pf7s2l{background:var(--jse-menu-color, var(--jse-text-color-inverse, #fff));opacity:0.3;width:1px;margin:3px}');
}
var Ev = (e2) => ({});
var Pv = (e2) => ({});
function Iv(e2, t3, n2) {
  var r2 = e2.slice();
  return r2[3] = t3[n2], r2;
}
var Tv = (e2) => ({});
var Av = (e2) => ({});
function Nv(e2) {
  var t3, n2 = Hv(e2[3]) + "";
  return { c() {
    t3 = un(n2);
  }, m(e3, n3) {
    on(e3, t3, n3);
  }, p(e3, r2) {
    1 & r2 && n2 !== (n2 = Hv(e3[3]) + "") && yn(t3, n2);
  }, i: Bt, o: Bt, d(e3) {
    e3 && an(t3);
  } };
}
function Bv(e2) {
  var t3, n2, r2, o2, a2, i2, s2, l, c = e2[3].icon && Lv(e2), u = e2[3].text && Dv(e2);
  return { c() {
    t3 = ln("button"), c && c.c(), n2 = dn(), u && u.c(), hn(t3, "type", "button"), hn(t3, "class", r2 = "jse-button " + e2[3].className + " svelte-pf7s2l"), hn(t3, "title", o2 = e2[3].title), t3.disabled = a2 = e2[3].disabled || false;
  }, m(r3, o3) {
    on(r3, t3, o3), c && c.m(t3, null), nn(t3, n2), u && u.m(t3, null), i2 = true, s2 || (l = pn(t3, "click", function() {
      Jt(e2[3].onClick) && e2[3].onClick.apply(this, arguments);
    }), s2 = true);
  }, p(s3, l2) {
    (e2 = s3)[3].icon ? c ? (c.p(e2, l2), 1 & l2 && Xn(c, 1)) : ((c = Lv(e2)).c(), Xn(c, 1), c.m(t3, n2)) : c && (Kn(), Gn(c, 1, 1, () => {
      c = null;
    }), Zn()), e2[3].text ? u ? u.p(e2, l2) : ((u = Dv(e2)).c(), u.m(t3, null)) : u && (u.d(1), u = null), (!i2 || 1 & l2 && r2 !== (r2 = "jse-button " + e2[3].className + " svelte-pf7s2l")) && hn(t3, "class", r2), (!i2 || 1 & l2 && o2 !== (o2 = e2[3].title)) && hn(t3, "title", o2), (!i2 || 1 & l2 && a2 !== (a2 = e2[3].disabled || false)) && (t3.disabled = a2);
  }, i(e3) {
    i2 || (Xn(c), i2 = true);
  }, o(e3) {
    Gn(c), i2 = false;
  }, d(e3) {
    e3 && an(t3), c && c.d(), u && u.d(), s2 = false, l();
  } };
}
function Fv(e2) {
  var t3;
  return { c() {
    hn(t3 = ln("div"), "class", "jse-space svelte-pf7s2l");
  }, m(e3, n2) {
    on(e3, t3, n2);
  }, p: Bt, i: Bt, o: Bt, d(e3) {
    e3 && an(t3);
  } };
}
function Uv(e2) {
  var t3;
  return { c() {
    hn(t3 = ln("div"), "class", "jse-separator svelte-pf7s2l");
  }, m(e3, n2) {
    on(e3, t3, n2);
  }, p: Bt, i: Bt, o: Bt, d(e3) {
    e3 && an(t3);
  } };
}
function Lv(e2) {
  var t3, n2;
  return t3 = new Ca({ props: { data: e2[3].icon } }), { c() {
    sr(t3.$$.fragment);
  }, m(e3, r2) {
    lr(t3, e3, r2), n2 = true;
  }, p(e3, n3) {
    var r2 = {};
    1 & n3 && (r2.data = e3[3].icon), t3.$set(r2);
  }, i(e3) {
    n2 || (Xn(t3.$$.fragment, e3), n2 = true);
  }, o(e3) {
    Gn(t3.$$.fragment, e3), n2 = false;
  }, d(e3) {
    cr(t3, e3);
  } };
}
function Dv(e2) {
  var t3, n2 = e2[3].text + "";
  return { c() {
    t3 = un(n2);
  }, m(e3, n3) {
    on(e3, t3, n3);
  }, p(e3, r2) {
    1 & r2 && n2 !== (n2 = e3[3].text + "") && yn(t3, n2);
  }, d(e3) {
    e3 && an(t3);
  } };
}
function Jv(e2) {
  var t3, n2, r2, o2, a2, i2, s2, l = [Uv, Fv, Bv, Nv], c = [];
  function u(e3, o3) {
    return 1 & o3 && (t3 = null), 1 & o3 && (n2 = null), 1 & o3 && (r2 = null), null == t3 && (t3 = !!di(e3[3])), t3 ? 0 : (null == n2 && (n2 = !!ui(e3[3])), n2 ? 1 : (null == r2 && (r2 = !!pi(e3[3])), r2 ? 2 : 3));
  }
  return o2 = u(e2, -1), a2 = c[o2] = l[o2](e2), { c() {
    a2.c(), i2 = vn();
  }, m(e3, t4) {
    c[o2].m(e3, t4), on(e3, i2, t4), s2 = true;
  }, p(e3, t4) {
    var n3 = o2;
    (o2 = u(e3, t4)) === n3 ? c[o2].p(e3, t4) : (Kn(), Gn(c[n3], 1, 1, () => {
      c[n3] = null;
    }), Zn(), (a2 = c[o2]) ? a2.p(e3, t4) : (a2 = c[o2] = l[o2](e3)).c(), Xn(a2, 1), a2.m(i2.parentNode, i2));
  }, i(e3) {
    s2 || (Xn(a2), s2 = true);
  }, o(e3) {
    Gn(a2), s2 = false;
  }, d(e3) {
    e3 && an(i2), c[o2].d(e3);
  } };
}
function Vv(e2) {
  for (var t3, n2, r2, o2, a2 = e2[2].left, i2 = _t(a2, e2, e2[1], Av), s2 = er(e2[0]), l = [], c = 0; c < s2.length; c += 1) l[c] = Jv(Iv(e2, s2, c));
  var u = (e3) => Gn(l[e3], 1, 1, () => {
    l[e3] = null;
  }), d = e2[2].right, v = _t(d, e2, e2[1], Pv);
  return { c() {
    t3 = ln("div"), i2 && i2.c(), n2 = dn();
    for (var e3 = 0; e3 < l.length; e3 += 1) l[e3].c();
    r2 = dn(), v && v.c(), hn(t3, "class", "jse-menu svelte-pf7s2l");
  }, m(e3, a3) {
    on(e3, t3, a3), i2 && i2.m(t3, null), nn(t3, n2);
    for (var s3 = 0; s3 < l.length; s3 += 1) l[s3] && l[s3].m(t3, null);
    nn(t3, r2), v && v.m(t3, null), o2 = true;
  }, p(e3, n3) {
    var [c2] = n3;
    if (i2 && i2.p && (!o2 || 2 & c2) && Yt(i2, a2, e3, e3[1], o2 ? Qt(a2, e3[1], c2, Tv) : Kt(e3[1]), Av), 1 & c2) {
      var p;
      for (s2 = er(e3[0]), p = 0; p < s2.length; p += 1) {
        var f = Iv(e3, s2, p);
        l[p] ? (l[p].p(f, c2), Xn(l[p], 1)) : (l[p] = Jv(f), l[p].c(), Xn(l[p], 1), l[p].m(t3, r2));
      }
      for (Kn(), p = s2.length; p < l.length; p += 1) u(p);
      Zn();
    }
    v && v.p && (!o2 || 2 & c2) && Yt(v, d, e3, e3[1], o2 ? Qt(d, e3[1], c2, Ev) : Kt(e3[1]), Pv);
  }, i(e3) {
    if (!o2) {
      Xn(i2, e3);
      for (var t4 = 0; t4 < s2.length; t4 += 1) Xn(l[t4]);
      Xn(v, e3), o2 = true;
    }
  }, o(e3) {
    Gn(i2, e3), l = l.filter(Boolean);
    for (var t4 = 0; t4 < l.length; t4 += 1) Gn(l[t4]);
    Gn(v, e3), o2 = false;
  }, d(e3) {
    e3 && an(t3), i2 && i2.d(e3), sn(l, e3), v && v.d(e3);
  } };
}
function Hv(e2) {
  return console.error("Unknown type of menu item", e2), "???";
}
function _v(e2, t3, n2) {
  var { $$slots: r2 = {}, $$scope: o2 } = t3, { items: a2 = [] } = t3;
  return e2.$$set = (e3) => {
    "items" in e3 && n2(0, a2 = e3.items), "$$scope" in e3 && n2(1, o2 = e3.$$scope);
  }, [a2, o2, r2];
}
var Wv = class extends dr {
  constructor(e2) {
    super(), ur(this, e2, _v, Vv, Ht, { items: 0 }, Rv);
  }
};
function Qv(e2) {
  rn(e2, "svelte-1sf8pm2", '.jse-json-repair-component.svelte-1sf8pm2.svelte-1sf8pm2{flex:1;display:flex;flex-direction:column;background:var(--jse-background-color, #fff);color:var(--jse-text-color, #4d4d4d)}.jse-json-repair-component.svelte-1sf8pm2 .jse-menu .jse-info.svelte-1sf8pm2{padding:calc(0.5 * var(--jse-padding, 10px));font-family:var(--jse-font-family, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif);font-size:var(--jse-font-size, 16px);vertical-align:center}.jse-json-repair-component.svelte-1sf8pm2 .jse-json-text.svelte-1sf8pm2{flex:1;border:none;padding:2px;font-family:var(--jse-font-family-mono, consolas, menlo, monaco, "Ubuntu Mono", "source-code-pro", monospace);font-size:var(--jse-font-size-mono, 14px);background:var(--jse-input-background, var(--jse-background-color, #fff));color:var(--jse-text-color, #4d4d4d);resize:none;outline:none}');
}
function Yv(e2) {
  var t3;
  return { c() {
    (t3 = ln("div")).textContent = "Repair invalid JSON, then click apply", hn(t3, "slot", "left"), hn(t3, "class", "jse-info svelte-1sf8pm2");
  }, m(e3, n2) {
    on(e3, t3, n2);
  }, p: Bt, d(e3) {
    e3 && an(t3);
  } };
}
function Kv(e2) {
  var t3, n2;
  return t3 = new cv({ props: { type: "success", message: "JSON is valid now and can be parsed.", actions: e2[5] } }), { c() {
    sr(t3.$$.fragment);
  }, m(e3, r2) {
    lr(t3, e3, r2), n2 = true;
  }, p(e3, n3) {
    var r2 = {};
    32 & n3 && (r2.actions = e3[5]), t3.$set(r2);
  }, i(e3) {
    n2 || (Xn(t3.$$.fragment, e3), n2 = true);
  }, o(e3) {
    Gn(t3.$$.fragment, e3), n2 = false;
  }, d(e3) {
    cr(t3, e3);
  } };
}
function Zv(e2) {
  var t3, n2;
  return t3 = new cv({ props: { type: "error", icon: faExclamationTriangle, message: "Cannot parse JSON: ".concat(e2[2].message), actions: e2[6] } }), { c() {
    sr(t3.$$.fragment);
  }, m(e3, r2) {
    lr(t3, e3, r2), n2 = true;
  }, p(e3, n3) {
    var r2 = {};
    4 & n3 && (r2.message = "Cannot parse JSON: ".concat(e3[2].message)), 64 & n3 && (r2.actions = e3[6]), t3.$set(r2);
  }, i(e3) {
    n2 || (Xn(t3.$$.fragment, e3), n2 = true);
  }, o(e3) {
    Gn(t3.$$.fragment, e3), n2 = false;
  }, d(e3) {
    cr(t3, e3);
  } };
}
function Xv(e2) {
  var t3, n2, r2, o2, a2, i2, s2, l, c, u;
  n2 = new Wv({ props: { items: e2[4], $$slots: { left: [Yv] }, $$scope: { ctx: e2 } } });
  var d = [Zv, Kv], v = [];
  function p(e3, t4) {
    return e3[2] ? 0 : 1;
  }
  return o2 = p(e2), a2 = v[o2] = d[o2](e2), { c() {
    t3 = ln("div"), sr(n2.$$.fragment), r2 = dn(), a2.c(), i2 = dn(), (s2 = ln("textarea")).readOnly = e2[1], hn(s2, "class", "jse-json-text svelte-1sf8pm2"), hn(s2, "autocomplete", "off"), hn(s2, "autocapitalize", "off"), hn(s2, "spellcheck", "false"), s2.value = e2[0], hn(t3, "class", "jse-json-repair-component svelte-1sf8pm2");
  }, m(a3, d2) {
    on(a3, t3, d2), lr(n2, t3, null), nn(t3, r2), v[o2].m(t3, null), nn(t3, i2), nn(t3, s2), e2[16](s2), l = true, c || (u = pn(s2, "input", e2[7]), c = true);
  }, p(e3, r3) {
    var [c2] = r3, u2 = {};
    16 & c2 && (u2.items = e3[4]), 8388608 & c2 && (u2.$$scope = { dirty: c2, ctx: e3 }), n2.$set(u2);
    var f = o2;
    (o2 = p(e3)) === f ? v[o2].p(e3, c2) : (Kn(), Gn(v[f], 1, 1, () => {
      v[f] = null;
    }), Zn(), (a2 = v[o2]) ? a2.p(e3, c2) : (a2 = v[o2] = d[o2](e3)).c(), Xn(a2, 1), a2.m(t3, i2)), (!l || 2 & c2) && (s2.readOnly = e3[1]), (!l || 1 & c2) && (s2.value = e3[0]);
  }, i(e3) {
    l || (Xn(n2.$$.fragment, e3), Xn(a2), l = true);
  }, o(e3) {
    Gn(n2.$$.fragment, e3), Gn(a2), l = false;
  }, d(r3) {
    r3 && an(t3), cr(n2), v[o2].d(), e2[16](null), c = false, u();
  } };
}
function Gv(e2, t3, n2) {
  var r2, o2, a2, i2, s2, l, c, u, { text: d = "" } = t3, { readOnly: v = false } = t3, { onParse: p } = t3, { onRepair: f } = t3, { onChange: m3 } = t3, { onApply: h2 } = t3, { onCancel: g } = t3, j = vr("jsoneditor:JSONRepair");
  function x() {
    h2(d);
  }
  return e2.$$set = (e3) => {
    "text" in e3 && n2(0, d = e3.text), "readOnly" in e3 && n2(1, v = e3.readOnly), "onParse" in e3 && n2(8, p = e3.onParse), "onRepair" in e3 && n2(9, f = e3.onRepair), "onChange" in e3 && n2(10, m3 = e3.onChange), "onApply" in e3 && n2(11, h2 = e3.onApply), "onCancel" in e3 && n2(12, g = e3.onCancel);
  }, e2.$$.update = () => {
    1 & e2.$$.dirty && n2(2, r2 = function(e3) {
      try {
        return void p(e3);
      } catch (t4) {
        return Qr(e3, t4.message);
      }
    }(d)), 1 & e2.$$.dirty && n2(15, o2 = function(e3) {
      try {
        return f(e3), true;
      } catch (e4) {
        return false;
      }
    }(d)), 4 & e2.$$.dirty && j("error", r2), 4096 & e2.$$.dirty && n2(4, u = [{ type: "space" }, { type: "button", icon: faTimes, title: "Cancel repair", className: "jse-cancel", onClick: g }]), 57344 & e2.$$.dirty && n2(6, s2 = o2 ? [a2, i2] : [a2]), 2 & e2.$$.dirty && n2(5, l = [{ icon: faCheck, text: "Apply", title: "Apply fixed JSON", disabled: v, onClick: x }]);
  }, n2(13, a2 = { icon: faArrowDown, text: "Show me", title: "Scroll to the error location", onClick: function() {
    if (c && r2) {
      var e3 = void 0 !== r2.position ? r2.position : 0;
      c.setSelectionRange(e3, e3), c.focus();
    }
  } }), n2(14, i2 = { icon: faWrench, text: "Auto repair", title: "Automatically repair JSON", onClick: function() {
    try {
      n2(0, d = f(d)), m3 && m3(d);
    } catch (e3) {
    }
  } }), [d, v, r2, c, u, l, s2, function(e3) {
    j("handleChange");
    var t4 = e3.target.value;
    d !== t4 && (n2(0, d = t4), m3 && m3(d));
  }, p, f, m3, h2, g, a2, i2, o2, function(e3) {
    Tn[e3 ? "unshift" : "push"](() => {
      n2(3, c = e3);
    });
  }];
}
var ep = class extends dr {
  constructor(e2) {
    super(), ur(this, e2, Gv, Xv, Ht, { text: 0, readOnly: 1, onParse: 8, onRepair: 9, onChange: 10, onApply: 11, onCancel: 12 }, Qv);
  }
};
function tp(e2) {
  var t3, n2, r2;
  function o2(t4) {
    e2[7](t4);
  }
  var a2 = { onParse: e2[1], onRepair: e2[2], onApply: e2[4], onCancel: e2[5] };
  return void 0 !== e2[0] && (a2.text = e2[0]), t3 = new ep({ props: a2 }), Tn.push(() => ir(t3, "text", o2)), { c() {
    sr(t3.$$.fragment);
  }, m(e3, n3) {
    lr(t3, e3, n3), r2 = true;
  }, p(e3, r3) {
    var o3 = {};
    2 & r3 && (o3.onParse = e3[1]), 4 & r3 && (o3.onRepair = e3[2]), !n2 && 1 & r3 && (n2 = true, o3.text = e3[0], Jn(() => n2 = false)), t3.$set(o3);
  }, i(e3) {
    r2 || (Xn(t3.$$.fragment, e3), r2 = true);
  }, o(e3) {
    Gn(t3.$$.fragment, e3), r2 = false;
  }, d(e3) {
    cr(t3, e3);
  } };
}
function np(e2) {
  var t3, n2;
  return t3 = new kv({ props: { onClose: e2[3], className: "jse-repair-modal", $$slots: { default: [tp] }, $$scope: { ctx: e2 } } }), { c() {
    sr(t3.$$.fragment);
  }, m(e3, r2) {
    lr(t3, e3, r2), n2 = true;
  }, p(e3, n3) {
    var [r2] = n3, o2 = {};
    8 & r2 && (o2.onClose = e3[3]), 263 & r2 && (o2.$$scope = { dirty: r2, ctx: e3 }), t3.$set(o2);
  }, i(e3) {
    n2 || (Xn(t3.$$.fragment, e3), n2 = true);
  }, o(e3) {
    Gn(t3.$$.fragment, e3), n2 = false;
  }, d(e3) {
    cr(t3, e3);
  } };
}
function rp(e2, t3, n2) {
  var { text: r2 } = t3, { onParse: o2 } = t3, { onRepair: a2 } = t3, { onApply: i2 } = t3, { onClose: s2 } = t3;
  return e2.$$set = (e3) => {
    "text" in e3 && n2(0, r2 = e3.text), "onParse" in e3 && n2(1, o2 = e3.onParse), "onRepair" in e3 && n2(2, a2 = e3.onRepair), "onApply" in e3 && n2(6, i2 = e3.onApply), "onClose" in e3 && n2(3, s2 = e3.onClose);
  }, [r2, o2, a2, s2, function(e3) {
    i2(e3), s2();
  }, function() {
    s2();
  }, i2, function(e3) {
    n2(0, r2 = e3);
  }];
}
var op = class extends dr {
  constructor(e2) {
    super(), ur(this, e2, rp, np, Ht, { text: 0, onParse: 1, onRepair: 2, onApply: 6, onClose: 3 });
  }
};
function ap(e2) {
  rn(e2, "svelte-1h6hzoq", 'div.jse-collapsed-items.svelte-1h6hzoq.svelte-1h6hzoq{margin-left:calc(var(--level) * var(--jse-indent-size, calc(1em + 4px)));font-family:var(--jse-font-family, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif);font-size:var(--jse-font-size, 16px);color:var(--jse-collapsed-items-link-color, rgba(0, 0, 0, 0.38));padding:calc(0.5 * var(--jse-padding, 10px));border:8px solid transparent;border-width:8px 0;background-color:var(--jse-contents-background-color, transparent);background-image:linear-gradient(var(--jse-collapsed-items-background-color, #f5f5f5), var(--jse-collapsed-items-background-color, #f5f5f5)), linear-gradient(to bottom right, transparent 50.5%, var(--jse-collapsed-items-background-color, #f5f5f5) 50.5%), linear-gradient(to bottom left, transparent 50.5%, var(--jse-collapsed-items-background-color, #f5f5f5) 50.5%), linear-gradient(to top right, transparent 50.5%, var(--jse-collapsed-items-background-color, #f5f5f5) 50.5%), linear-gradient(to top left, transparent 50.5%, var(--jse-collapsed-items-background-color, #f5f5f5) 50.5%);background-repeat:repeat, repeat-x, repeat-x, repeat-x, repeat-x;background-position:0 0, 8px 0, 8px 0, 8px 100%, 8px 100%;background-size:auto auto, 16px 16px, 16px 16px, 16px 16px, 16px 16px;background-clip:padding-box, border-box, border-box, border-box, border-box;background-origin:padding-box, border-box, border-box, border-box, border-box;display:flex}div.jse-collapsed-items.jse-selected.svelte-1h6hzoq.svelte-1h6hzoq{background-color:var(--jse-selection-background-color, #d3d3d3);--jse-collapsed-items-background-color:var(--jse-collapsed-items-selected-background-color, #c2c2c2)}div.jse-collapsed-items.svelte-1h6hzoq div.jse-text.svelte-1h6hzoq,div.jse-collapsed-items.svelte-1h6hzoq button.jse-expand-items.svelte-1h6hzoq{margin:0 calc(0.5 * var(--jse-padding, 10px))}div.jse-collapsed-items.svelte-1h6hzoq div.jse-text.svelte-1h6hzoq{display:inline}div.jse-collapsed-items.svelte-1h6hzoq button.jse-expand-items.svelte-1h6hzoq{font-family:inherit;font-size:inherit;color:var(--jse-collapsed-items-link-color, rgba(0, 0, 0, 0.38));background:none;border:none;padding:0;text-decoration:underline;cursor:pointer}div.jse-collapsed-items.svelte-1h6hzoq button.jse-expand-items.svelte-1h6hzoq:hover,div.jse-collapsed-items.svelte-1h6hzoq button.jse-expand-items.svelte-1h6hzoq:focus{color:var(--jse-collapsed-items-link-color-highlight, #ee5341)}');
}
function ip(e2, t3, n2) {
  var r2 = e2.slice();
  return r2[13] = t3[n2], r2;
}
function sp(e2) {
  var t3, n2, r2, o2, a2, i2, s2, l, c = e2[13].start + "", u = e2[13].end + "";
  function d() {
    return e2[12](e2[13]);
  }
  return { c() {
    t3 = ln("button"), n2 = un("show "), r2 = un(c), o2 = un("-"), a2 = un(u), i2 = dn(), hn(t3, "type", "button"), hn(t3, "class", "jse-expand-items svelte-1h6hzoq");
  }, m(e3, c2) {
    on(e3, t3, c2), nn(t3, n2), nn(t3, r2), nn(t3, o2), nn(t3, a2), nn(t3, i2), s2 || (l = pn(t3, "click", d), s2 = true);
  }, p(t4, n3) {
    e2 = t4, 16 & n3 && c !== (c = e2[13].start + "") && yn(r2, c), 16 & n3 && u !== (u = e2[13].end + "") && yn(a2, u);
  }, d(e3) {
    e3 && an(t3), s2 = false, l();
  } };
}
function lp(e2) {
  for (var t3, n2, r2, o2, a2, i2, s2, l, c, u, d = er(e2[4]), v = [], p = 0; p < d.length; p += 1) v[p] = sp(ip(e2, d, p));
  return { c() {
    t3 = ln("div"), n2 = ln("div"), r2 = ln("div"), o2 = un("Items "), a2 = un(e2[3]), i2 = un("-"), s2 = un(e2[2]), l = dn();
    for (var c2 = 0; c2 < v.length; c2 += 1) v[c2].c();
    hn(r2, "class", "jse-text svelte-1h6hzoq"), hn(t3, "role", "none"), hn(t3, "class", "jse-collapsed-items svelte-1h6hzoq"), kn(t3, "jse-selected", e2[5]), wn(t3, "--level", e2[0].length + 2);
  }, m(e3, d2) {
    on(e3, t3, d2), nn(t3, n2), nn(n2, r2), nn(r2, o2), nn(r2, a2), nn(r2, i2), nn(r2, s2), nn(n2, l);
    for (var p2 = 0; p2 < v.length; p2 += 1) v[p2] && v[p2].m(n2, null);
    c || (u = pn(t3, "mousemove", cp), c = true);
  }, p(e3, r3) {
    var [o3] = r3;
    if (8 & o3 && yn(a2, e3[3]), 4 & o3 && yn(s2, e3[2]), 19 & o3) {
      var i3;
      for (d = er(e3[4]), i3 = 0; i3 < d.length; i3 += 1) {
        var l2 = ip(e3, d, i3);
        v[i3] ? v[i3].p(l2, o3) : (v[i3] = sp(l2), v[i3].c(), v[i3].m(n2, null));
      }
      for (; i3 < v.length; i3 += 1) v[i3].d(1);
      v.length = d.length;
    }
    32 & o3 && kn(t3, "jse-selected", e3[5]), 1 & o3 && wn(t3, "--level", e3[0].length + 2);
  }, i: Bt, o: Bt, d(e3) {
    e3 && an(t3), sn(v, e3), c = false, u();
  } };
}
function cp(e2) {
  e2.stopPropagation();
}
function up(e2, t3, n2) {
  var r2, o2, a2, i2, s2, { visibleSections: l } = t3, { sectionIndex: c } = t3, { total: u } = t3, { path: d } = t3, { selection: v } = t3, { onExpandSection: p } = t3, { context: f } = t3;
  return e2.$$set = (e3) => {
    "visibleSections" in e3 && n2(6, l = e3.visibleSections), "sectionIndex" in e3 && n2(7, c = e3.sectionIndex), "total" in e3 && n2(8, u = e3.total), "path" in e3 && n2(0, d = e3.path), "selection" in e3 && n2(9, v = e3.selection), "onExpandSection" in e3 && n2(1, p = e3.onExpandSection), "context" in e3 && n2(10, f = e3.context);
  }, e2.$$.update = () => {
    192 & e2.$$.dirty && n2(11, r2 = l[c]), 2048 & e2.$$.dirty && n2(3, o2 = r2.end), 448 & e2.$$.dirty && n2(2, a2 = l[c + 1] ? l[c + 1].start : u), 1545 & e2.$$.dirty && n2(5, i2 = Us(f.getJson(), v, d.concat(String(o2)))), 12 & e2.$$.dirty && n2(4, s2 = function(e3, t4) {
      var n3 = { start: e3, end: Math.min(li(e3), t4) }, r3 = Math.max(ci((e3 + t4) / 2), e3), o3 = { start: r3, end: Math.min(li(r3), t4) }, a3 = ci(t4), i3 = a3 === t4 ? a3 - Da : a3, s3 = { start: Math.max(i3, e3), end: t4 }, l2 = [n3], c2 = o3.start >= n3.end && o3.end <= s3.start;
      return c2 && l2.push(o3), s3.start >= (c2 ? o3.end : n3.end) && l2.push(s3), l2;
    }(o2, a2));
  }, [d, p, a2, o2, s2, i2, l, c, u, v, f, r2, (e3) => p(d, e3)];
}
var dp = class extends dr {
  constructor(e2) {
    super(), ur(this, e2, up, lp, Ht, { visibleSections: 6, sectionIndex: 7, total: 8, path: 0, selection: 9, onExpandSection: 1, context: 10 }, ap);
  }
};
function vp(e2) {
  rn(e2, "svelte-137iwnw", ".jse-context-menu-pointer.svelte-137iwnw{position:absolute;top:calc(-0.5 * var(--jse-context-menu-pointer-size, calc(1em + 4px)));right:calc(-0.5 * var(--jse-context-menu-pointer-size, calc(1em + 4px)));width:var(--jse-context-menu-pointer-size, calc(1em + 4px));height:var(--jse-context-menu-pointer-size, calc(1em + 4px));padding:0;margin:0;cursor:pointer;background:transparent;border-radius:2px;background:var(--jse-context-menu-pointer-hover-background, #b2b2b2);color:var(--jse-context-menu-pointer-color, var(--jse-context-menu-color, var(--jse-text-color-inverse, #fff)));border:none;box-shadow:var(--jse-controls-box-shadow, 0 2px 6px 0 rgba(0, 0, 0, 0.24))}.jse-context-menu-pointer.jse-root.svelte-137iwnw{top:0;right:calc(-2px - var(--jse-context-menu-pointer-size, calc(1em + 4px)))}.jse-context-menu-pointer.jse-insert.svelte-137iwnw{right:-1px}.jse-context-menu-pointer.svelte-137iwnw:hover{background:var(--jse-context-menu-pointer-background-highlight, var(--jse-context-menu-background-highlight, #7a7a7a))}.jse-context-menu-pointer.jse-selected.svelte-137iwnw{background:var(--jse-context-menu-pointer-background, var(--jse-context-menu-background, #656565))}.jse-context-menu-pointer.jse-selected.svelte-137iwnw:hover{background:var(--jse-context-menu-pointer-background-highlight, var(--jse-context-menu-background-highlight, #7a7a7a))}");
}
function pp(e2) {
  var t3, n2, r2, o2, a2;
  return n2 = new Ca({ props: { data: faCaretDown } }), { c() {
    t3 = ln("button"), sr(n2.$$.fragment), hn(t3, "type", "button"), hn(t3, "class", "jse-context-menu-pointer svelte-137iwnw"), hn(t3, "title", Za), kn(t3, "jse-root", e2[0]), kn(t3, "jse-insert", e2[1]), kn(t3, "jse-selected", e2[2]);
  }, m(i2, s2) {
    on(i2, t3, s2), lr(n2, t3, null), r2 = true, o2 || (a2 = pn(t3, "click", e2[3]), o2 = true);
  }, p(e3, n3) {
    var [o3] = n3;
    (!r2 || 1 & o3) && kn(t3, "jse-root", e3[0]), (!r2 || 2 & o3) && kn(t3, "jse-insert", e3[1]), (!r2 || 4 & o3) && kn(t3, "jse-selected", e3[2]);
  }, i(e3) {
    r2 || (Xn(n2.$$.fragment, e3), r2 = true);
  }, o(e3) {
    Gn(n2.$$.fragment, e3), r2 = false;
  }, d(e3) {
    e3 && an(t3), cr(n2), o2 = false, a2();
  } };
}
function fp(e2, t3, n2) {
  var { root: r2 = false } = t3, { insert: o2 = false } = t3, { selected: a2 } = t3, { onContextMenu: i2 } = t3;
  return e2.$$set = (e3) => {
    "root" in e3 && n2(0, r2 = e3.root), "insert" in e3 && n2(1, o2 = e3.insert), "selected" in e3 && n2(2, a2 = e3.selected), "onContextMenu" in e3 && n2(4, i2 = e3.onContextMenu);
  }, [r2, o2, a2, function(e3) {
    for (var t4 = e3.target; t4 && "BUTTON" !== t4.nodeName; ) t4 = t4.parentNode;
    t4 && i2({ anchor: t4, left: 0, top: 0, width: oi, height: ri, offsetTop: 2, offsetLeft: 0, showTip: true });
  }, i2];
}
var mp = class extends dr {
  constructor(e2) {
    super(), ur(this, e2, fp, pp, Ht, { root: 0, insert: 1, selected: 2, onContextMenu: 4 }, vp);
  }
};
function hp(e2) {
  rn(e2, "svelte-2iqnqn", '.jse-key.svelte-2iqnqn{display:inline-block;min-width:2em;padding:0 5px;box-sizing:border-box;outline:none;border-radius:1px;vertical-align:top;color:var(--jse-key-color, #1a1a1a);word-break:normal;overflow-wrap:normal;white-space:pre-wrap}.jse-key.jse-empty.svelte-2iqnqn{min-width:3em;outline:1px dotted var(--jse-tag-background, rgba(0, 0, 0, 0.2));-moz-outline-radius:2px}.jse-key.jse-empty.svelte-2iqnqn::after{pointer-events:none;color:var(--jse-tag-background, rgba(0, 0, 0, 0.2));content:"key"}');
}
function gp(e2) {
  var t3, n2, r2, o2, a2, i2, s2 = [bp, xp], l = [];
  function c(e3, t4) {
    return e3[2] ? 0 : 1;
  }
  return n2 = c(e2), r2 = l[n2] = s2[n2](e2), { c() {
    t3 = ln("div"), r2.c(), hn(t3, "role", "none"), hn(t3, "data-type", "selectable-key"), hn(t3, "class", "jse-key svelte-2iqnqn"), kn(t3, "jse-empty", "" === e2[0]);
  }, m(r3, s3) {
    on(r3, t3, s3), l[n2].m(t3, null), o2 = true, a2 || (i2 = pn(t3, "dblclick", e2[6]), a2 = true);
  }, p(e3, a3) {
    var i3 = n2;
    (n2 = c(e3)) === i3 ? l[n2].p(e3, a3) : (Kn(), Gn(l[i3], 1, 1, () => {
      l[i3] = null;
    }), Zn(), (r2 = l[n2]) ? r2.p(e3, a3) : (r2 = l[n2] = s2[n2](e3)).c(), Xn(r2, 1), r2.m(t3, null)), (!o2 || 1 & a3) && kn(t3, "jse-empty", "" === e3[0]);
  }, i(e3) {
    o2 || (Xn(r2), o2 = true);
  }, o(e3) {
    Gn(r2), o2 = false;
  }, d(e3) {
    e3 && an(t3), l[n2].d(), a2 = false, i2();
  } };
}
function jp(e2) {
  var t3, n2;
  return t3 = new Ys({ props: { value: e2[3].normalization.escapeValue(e2[0]), initialValue: Is(e2[1]) ? e2[1].initialValue : void 0, label: "Edit key", shortText: true, onChange: e2[7], onCancel: e2[8], onFind: e2[3].onFind } }), { c() {
    sr(t3.$$.fragment);
  }, m(e3, r2) {
    lr(t3, e3, r2), n2 = true;
  }, p(e3, n3) {
    var r2 = {};
    9 & n3 && (r2.value = e3[3].normalization.escapeValue(e3[0])), 2 & n3 && (r2.initialValue = Is(e3[1]) ? e3[1].initialValue : void 0), 8 & n3 && (r2.onFind = e3[3].onFind), t3.$set(r2);
  }, i(e3) {
    n2 || (Xn(t3.$$.fragment, e3), n2 = true);
  }, o(e3) {
    Gn(t3.$$.fragment, e3), n2 = false;
  }, d(e3) {
    cr(t3, e3);
  } };
}
function xp(e2) {
  var t3, n2 = qo(e2[3].normalization.escapeValue(e2[0])) + "";
  return { c() {
    t3 = un(n2);
  }, m(e3, n3) {
    on(e3, t3, n3);
  }, p(e3, r2) {
    9 & r2 && n2 !== (n2 = qo(e3[3].normalization.escapeValue(e3[0])) + "") && yn(t3, n2);
  }, i: Bt, o: Bt, d(e3) {
    e3 && an(t3);
  } };
}
function bp(e2) {
  var t3, n2;
  return t3 = new ql({ props: { text: e2[3].normalization.escapeValue(e2[0]), searchResultItems: e2[2] } }), { c() {
    sr(t3.$$.fragment);
  }, m(e3, r2) {
    lr(t3, e3, r2), n2 = true;
  }, p(e3, n3) {
    var r2 = {};
    9 & n3 && (r2.text = e3[3].normalization.escapeValue(e3[0])), 4 & n3 && (r2.searchResultItems = e3[2]), t3.$set(r2);
  }, i(e3) {
    n2 || (Xn(t3.$$.fragment, e3), n2 = true);
  }, o(e3) {
    Gn(t3.$$.fragment, e3), n2 = false;
  }, d(e3) {
    cr(t3, e3);
  } };
}
function yp(e2) {
  var t3, n2;
  return t3 = new mp({ props: { selected: true, onContextMenu: e2[3].onContextMenu } }), { c() {
    sr(t3.$$.fragment);
  }, m(e3, r2) {
    lr(t3, e3, r2), n2 = true;
  }, p(e3, n3) {
    var r2 = {};
    8 & n3 && (r2.onContextMenu = e3[3].onContextMenu), t3.$set(r2);
  }, i(e3) {
    n2 || (Xn(t3.$$.fragment, e3), n2 = true);
  }, o(e3) {
    Gn(t3.$$.fragment, e3), n2 = false;
  }, d(e3) {
    cr(t3, e3);
  } };
}
function $p(e2) {
  var t3, n2, r2, o2, a2, i2 = [jp, gp], s2 = [];
  function l(e3, t4) {
    return !e3[3].readOnly && e3[5] ? 0 : 1;
  }
  t3 = l(e2), n2 = s2[t3] = i2[t3](e2);
  var c = !e2[3].readOnly && e2[4] && !e2[5] && yp(e2);
  return { c() {
    n2.c(), r2 = dn(), c && c.c(), o2 = vn();
  }, m(e3, n3) {
    s2[t3].m(e3, n3), on(e3, r2, n3), c && c.m(e3, n3), on(e3, o2, n3), a2 = true;
  }, p(e3, a3) {
    var [u] = a3, d = t3;
    (t3 = l(e3)) === d ? s2[t3].p(e3, u) : (Kn(), Gn(s2[d], 1, 1, () => {
      s2[d] = null;
    }), Zn(), (n2 = s2[t3]) ? n2.p(e3, u) : (n2 = s2[t3] = i2[t3](e3)).c(), Xn(n2, 1), n2.m(r2.parentNode, r2)), e3[3].readOnly || !e3[4] || e3[5] ? c && (Kn(), Gn(c, 1, 1, () => {
      c = null;
    }), Zn()) : c ? (c.p(e3, u), 56 & u && Xn(c, 1)) : ((c = yp(e3)).c(), Xn(c, 1), c.m(o2.parentNode, o2));
  }, i(e3) {
    a2 || (Xn(n2), Xn(c), a2 = true);
  }, o(e3) {
    Gn(n2), Gn(c), a2 = false;
  }, d(e3) {
    e3 && (an(r2), an(o2)), s2[t3].d(e3), c && c.d(e3);
  } };
}
function wp(e2, t3, n2) {
  var r2, o2, a2, { pointer: i2 } = t3, { key: s2 } = t3, { selection: c } = t3, { searchResultItems: u } = t3, { onUpdateKey: d } = t3, { context: v } = t3;
  return e2.$$set = (e3) => {
    "pointer" in e3 && n2(9, i2 = e3.pointer), "key" in e3 && n2(0, s2 = e3.key), "selection" in e3 && n2(1, c = e3.selection), "searchResultItems" in e3 && n2(2, u = e3.searchResultItems), "onUpdateKey" in e3 && n2(10, d = e3.onUpdateKey), "context" in e3 && n2(3, v = e3.context);
  }, e2.$$.update = () => {
    512 & e2.$$.dirty && n2(11, a2 = parseJSONPointer(i2)), 2050 & e2.$$.dirty && n2(4, r2 = ss(c) && isEqual_default(c.path, a2)), 18 & e2.$$.dirty && n2(5, o2 = r2 && Is(c));
  }, [s2, c, u, v, r2, o2, function(e3) {
    o2 || v.readOnly || (e3.preventDefault(), v.onSelect(Os(a2)));
  }, function(e3, t4) {
    var n3 = d(s2, v.normalization.unescapeValue(e3)), r3 = initial_default(a2).concat(n3);
    v.onSelect(t4 === ho.nextInside ? zs(r3) : Ss(r3)), t4 !== ho.self && v.focus();
  }, function() {
    v.onSelect(Ss(a2)), v.focus();
  }, i2, d, a2];
}
var Cp = class extends dr {
  constructor(e2) {
    super(), ur(this, e2, wp, $p, Ht, { pointer: 9, key: 0, selection: 1, searchResultItems: 2, onUpdateKey: 10, context: 3 }, hp);
  }
};
function kp(e2, t3, n2) {
  var r2 = e2.slice();
  return r2[8] = t3[n2], r2;
}
function Sp(e2) {
  var t3, n2, r2 = e2[8].component, o2 = zp(e2);
  return { c() {
    o2.c(), t3 = vn();
  }, m(e3, r3) {
    o2.m(e3, r3), on(e3, t3, r3), n2 = true;
  }, p(e3, n3) {
    1 & n3 && Ht(r2, r2 = e3[8].component) ? (Kn(), Gn(o2, 1, 1, Bt), Zn(), (o2 = zp(e3)).c(), Xn(o2, 1), o2.m(t3.parentNode, t3)) : o2.p(e3, n3);
  }, i(e3) {
    n2 || (Xn(o2), n2 = true);
  }, o(e3) {
    Gn(o2), n2 = false;
  }, d(e3) {
    e3 && an(t3), o2.d(e3);
  } };
}
function Op(e2) {
  var t3, n2 = e2[8].action, r2 = qp(e2);
  return { c() {
    r2.c(), t3 = vn();
  }, m(e3, n3) {
    r2.m(e3, n3), on(e3, t3, n3);
  }, p(e3, o2) {
    1 & o2 && Ht(n2, n2 = e3[8].action) ? (r2.d(1), (r2 = qp(e3)).c(), r2.m(t3.parentNode, t3)) : r2.p(e3, o2);
  }, i: Bt, o: Bt, d(e3) {
    e3 && an(t3), r2.d(e3);
  } };
}
function zp(e2) {
  var t3, n2, r2, o2 = [e2[8].props], a2 = e2[8].component;
  function i2(e3, t4) {
    for (var n3 = {}, r3 = 0; r3 < o2.length; r3 += 1) n3 = Ft(n3, o2[r3]);
    return void 0 !== t4 && 1 & t4 && (n3 = Ft(n3, or(o2, [ar(e3[8].props)]))), { props: n3 };
  }
  return a2 && (t3 = Sn(a2, i2(e2))), { c() {
    t3 && sr(t3.$$.fragment), n2 = vn();
  }, m(e3, o3) {
    t3 && lr(t3, e3, o3), on(e3, n2, o3), r2 = true;
  }, p(e3, r3) {
    if (1 & r3 && a2 !== (a2 = e3[8].component)) {
      if (t3) {
        Kn();
        var s2 = t3;
        Gn(s2.$$.fragment, 1, 0, () => {
          cr(s2, 1);
        }), Zn();
      }
      a2 ? (sr((t3 = Sn(a2, i2(e3, r3))).$$.fragment), Xn(t3.$$.fragment, 1), lr(t3, n2.parentNode, n2)) : t3 = null;
    } else if (a2) {
      var l = 1 & r3 ? or(o2, [ar(e3[8].props)]) : {};
      t3.$set(l);
    }
  }, i(e3) {
    r2 || (t3 && Xn(t3.$$.fragment, e3), r2 = true);
  }, o(e3) {
    t3 && Gn(t3.$$.fragment, e3), r2 = false;
  }, d(e3) {
    e3 && an(n2), t3 && cr(t3, e3);
  } };
}
function qp(e2) {
  var t3, n2, r2, o2;
  return { c() {
    hn(t3 = ln("div"), "role", "button"), hn(t3, "tabindex", "-1"), hn(t3, "class", "jse-value"), hn(t3, "data-type", "selectable-value");
  }, m(a2, i2) {
    on(a2, t3, i2), r2 || (o2 = en(n2 = e2[11].call(null, t3, e2[8].props)), r2 = true);
  }, p(t4, r3) {
    e2 = t4, n2 && Jt(n2.update) && 1 & r3 && n2.update.call(null, e2[8].props);
  }, d(e3) {
    e3 && an(t3), r2 = false, o2();
  } };
}
function Mp(e2) {
  var t3, n2, r2, o2, a2, i2 = [Op, Sp], s2 = [];
  function l(e3, n3) {
    return 1 & n3 && (t3 = null), null == t3 && (t3 = !!$i(e3[8])), t3 ? 0 : 1;
  }
  function c(e3, t4) {
    return 0 === t4 ? function(e4) {
      var t5 = e4.slice(), n3 = t5[8].action;
      return t5[11] = n3, t5;
    }(e3) : e3;
  }
  return n2 = l(e2, -1), r2 = s2[n2] = i2[n2](c(e2, n2)), { c() {
    r2.c(), o2 = vn();
  }, m(e3, t4) {
    s2[n2].m(e3, t4), on(e3, o2, t4), a2 = true;
  }, p(e3, t4) {
    var a3 = n2;
    (n2 = l(e3, t4)) === a3 ? s2[n2].p(c(e3, n2), t4) : (Kn(), Gn(s2[a3], 1, 1, () => {
      s2[a3] = null;
    }), Zn(), (r2 = s2[n2]) ? r2.p(c(e3, n2), t4) : (r2 = s2[n2] = i2[n2](c(e3, n2))).c(), Xn(r2, 1), r2.m(o2.parentNode, o2));
  }, i(e3) {
    a2 || (Xn(r2), a2 = true);
  }, o(e3) {
    Gn(r2), a2 = false;
  }, d(e3) {
    e3 && an(o2), s2[n2].d(e3);
  } };
}
function Rp(e2) {
  for (var t3, n2, r2 = er(e2[0]), o2 = [], a2 = 0; a2 < r2.length; a2 += 1) o2[a2] = Mp(kp(e2, r2, a2));
  var i2 = (e3) => Gn(o2[e3], 1, 1, () => {
    o2[e3] = null;
  });
  return { c() {
    for (var e3 = 0; e3 < o2.length; e3 += 1) o2[e3].c();
    t3 = vn();
  }, m(e3, r3) {
    for (var a3 = 0; a3 < o2.length; a3 += 1) o2[a3] && o2[a3].m(e3, r3);
    on(e3, t3, r3), n2 = true;
  }, p(e3, n3) {
    var [a3] = n3;
    if (1 & a3) {
      var s2;
      for (r2 = er(e3[0]), s2 = 0; s2 < r2.length; s2 += 1) {
        var l = kp(e3, r2, s2);
        o2[s2] ? (o2[s2].p(l, a3), Xn(o2[s2], 1)) : (o2[s2] = Mp(l), o2[s2].c(), Xn(o2[s2], 1), o2[s2].m(t3.parentNode, t3));
      }
      for (Kn(), s2 = r2.length; s2 < o2.length; s2 += 1) i2(s2);
      Zn();
    }
  }, i(e3) {
    if (!n2) {
      for (var t4 = 0; t4 < r2.length; t4 += 1) Xn(o2[t4]);
      n2 = true;
    }
  }, o(e3) {
    o2 = o2.filter(Boolean);
    for (var t4 = 0; t4 < o2.length; t4 += 1) Gn(o2[t4]);
    n2 = false;
  }, d(e3) {
    e3 && an(t3), sn(o2, e3);
  } };
}
function Ep(e2, t3, n2) {
  var r2, o2, { path: a2 } = t3, { value: i2 } = t3, { context: s2 } = t3, { enforceString: l } = t3, { selection: c } = t3, { searchResultItems: u } = t3;
  return e2.$$set = (e3) => {
    "path" in e3 && n2(1, a2 = e3.path), "value" in e3 && n2(2, i2 = e3.value), "context" in e3 && n2(3, s2 = e3.context), "enforceString" in e3 && n2(4, l = e3.enforceString), "selection" in e3 && n2(5, c = e3.selection), "searchResultItems" in e3 && n2(6, u = e3.searchResultItems);
  }, e2.$$.update = () => {
    32 & e2.$$.dirty && n2(7, r2 = ls(c) && Is(c)), 254 & e2.$$.dirty && n2(0, o2 = s2.onRenderValue({ path: a2, value: i2, mode: s2.mode, readOnly: s2.readOnly, enforceString: l, isEditing: r2, parser: s2.parser, normalization: s2.normalization, selection: c, searchResultItems: u, onPatch: s2.onPatch, onPasteJson: s2.onPasteJson, onSelect: s2.onSelect, onFind: s2.onFind, findNextInside: s2.findNextInside, focus: s2.focus }));
  }, [o2, a2, i2, s2, l, c, u, r2];
}
var Pp = class extends dr {
  constructor(e2) {
    super(), ur(this, e2, Ep, Rp, Ht, { path: 1, value: 2, context: 3, enforceString: 4, selection: 5, searchResultItems: 6 });
  }
};
var Ip = { selecting: false, selectionAnchor: void 0, selectionAnchorType: void 0, selectionFocus: void 0, dragging: false };
function Tp(e2) {
  var { json: t3, selection: n2, deltaY: r2, items: o2 } = e2;
  if (!n2) return { operations: void 0, updatedSelection: void 0, offset: 0 };
  var a2 = r2 < 0 ? function(e3) {
    var { json: t4, items: n3, selection: r3, deltaY: o3 } = e3, a3 = ms(t4, r3), i3 = n3.findIndex((e4) => isEqual_default(e4.path, a3)), s3 = () => {
      var e4;
      return null === (e4 = n3[l2 - 1]) || void 0 === e4 ? void 0 : e4.height;
    }, l2 = i3, c = 0;
    for (; void 0 !== s3() && Math.abs(o3) > c + s3() / 2; ) c += s3(), l2 -= 1;
    var u = n3[l2].path, d2 = l2 - i3;
    return l2 !== i3 && void 0 !== n3[l2] ? { beforePath: u, offset: d2 } : void 0;
  }({ json: t3, selection: n2, deltaY: r2, items: o2 }) : function(e3) {
    var t4, { json: n3, items: r3, selection: o3, deltaY: a3 } = e3, i3 = hs(n3, o3), s3 = r3.findIndex((e4) => isEqual_default(e4.path, i3)), l2 = 0, c = s3, d2 = () => {
      var e4;
      return null === (e4 = r3[c + 1]) || void 0 === e4 ? void 0 : e4.height;
    };
    for (; void 0 !== d2() && Math.abs(a3) > l2 + d2() / 2; ) l2 += d2(), c += 1;
    var v = initial_default(i3), p = getIn(n3, v), f = Array.isArray(p), m3 = null === (t4 = r3[f ? c : c + 1]) || void 0 === t4 ? void 0 : t4.path, h2 = c - s3;
    return m3 ? { beforePath: m3, offset: h2 } : { append: true, offset: h2 };
  }({ json: t3, selection: n2, deltaY: r2, items: o2 });
  if (!a2 || 0 === a2.offset) return { operations: void 0, updatedSelection: void 0, offset: 0 };
  var i2 = function(e3, t4, n3) {
    if (!t4) return [];
    var r3 = "beforePath" in n3 ? n3.beforePath : void 0, o3 = "append" in n3 ? n3.append : void 0, a3 = initial_default(Ds(t4)), i3 = getIn(e3, a3);
    if (!(o3 || r3 && Cs(r3, a3) && r3.length > a3.length)) return [];
    var s3 = ms(e3, t4), l2 = hs(e3, t4), d2 = last_default(s3), v = last_default(l2), p = r3 ? r3[a3.length] : void 0;
    if (!isJSONObject(i3)) {
      if (isJSONArray(i3)) {
        var f = gr(d2), m3 = gr(v), h2 = void 0 !== p ? gr(p) : i3.length;
        return times_default(m3 - f + 1, h2 < f ? (e4) => ({ op: "move", from: compileJSONPointer(a3.concat(String(f + e4))), path: compileJSONPointer(a3.concat(String(h2 + e4))) }) : () => ({ op: "move", from: compileJSONPointer(a3.concat(String(f))), path: compileJSONPointer(a3.concat(String(h2))) }));
      }
      throw new Error("Cannot create move operations: parent must be an Object or Array");
    }
    var g = Object.keys(i3), j = g.indexOf(d2), x = g.indexOf(v), b2 = o3 ? g.length : void 0 !== p ? g.indexOf(p) : -1;
    return -1 !== j && -1 !== x && -1 !== b2 ? b2 > j ? [...g.slice(j, x + 1), ...g.slice(b2, g.length)].map((e4) => al(a3, e4)) : [...g.slice(b2, j), ...g.slice(x + 1, g.length)].map((e4) => al(a3, e4)) : [];
  }(t3, n2, a2), s2 = initial_default(ms(t3, n2)), l = getIn(t3, s2);
  if (Array.isArray(l)) {
    var d = function(e3) {
      var t4, n3, { items: r3, json: o3, selection: a3, offset: i3 } = e3, s3 = ms(o3, a3), l2 = hs(o3, a3), c = r3.findIndex((e4) => isEqual_default(e4.path, s3)), u = r3.findIndex((e4) => isEqual_default(e4.path, l2)), d2 = null === (t4 = r3[c + i3]) || void 0 === t4 ? void 0 : t4.path, v = null === (n3 = r3[u + i3]) || void 0 === n3 ? void 0 : n3.path;
      return Es(d2, v);
    }({ items: o2, json: t3, selection: n2, offset: a2.offset });
    return { operations: i2, updatedSelection: d, offset: a2.offset };
  }
  return { operations: i2, updatedSelection: void 0, offset: a2.offset };
}
function Ap(e2) {
  rn(e2, "svelte-1a8aobl", 'button.jse-validation-error.svelte-1a8aobl{border:none;background:transparent;color:inherit;cursor:pointer;font-family:var(--jse-font-family, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif);font-size:var(--jse-font-size, 16px);padding:5px;margin:0;padding:0;margin:0;vertical-align:top;display:inline-flex;color:var(--jse-error-color, #ee5341)}button.jse-validation-info.svelte-1a8aobl{border:none;background:transparent;color:inherit;cursor:pointer;font-family:var(--jse-font-family, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif);font-size:var(--jse-font-size, 16px);padding:5px;margin:0;padding:0;margin:0;vertical-align:top;display:inline-flex;color:var(--jse-info-color, #4f91ff)}button.jse-validation-warning.svelte-1a8aobl{border:none;background:transparent;color:inherit;cursor:pointer;font-family:var(--jse-font-family, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif);font-size:var(--jse-font-size, 16px);padding:5px;margin:0;padding:0;margin:0;vertical-align:top;display:inline-flex;color:var(--jse-warning-color, #fdc539)}');
}
function Np(e2) {
  var t3, n2, r2, o2, a2, s2, l;
  return n2 = new Ca({ props: { data: faExclamationTriangle } }), { c() {
    t3 = ln("button"), sr(n2.$$.fragment), hn(t3, "type", "button"), hn(t3, "class", r2 = "jse-validation-" + e2[0].severity + " svelte-1a8aobl");
  }, m(r3, c) {
    on(r3, t3, c), lr(n2, t3, null), a2 = true, s2 || (l = [pn(t3, "click", function() {
      Jt(e2[1]) && e2[1].apply(this, arguments);
    }), en(o2 = Ul.call(null, t3, i({ text: e2[2] }, e2[3])))], s2 = true);
  }, p(n3, s3) {
    var [l2] = s3;
    e2 = n3, (!a2 || 1 & l2 && r2 !== (r2 = "jse-validation-" + e2[0].severity + " svelte-1a8aobl")) && hn(t3, "class", r2), o2 && Jt(o2.update) && 4 & l2 && o2.update.call(null, i({ text: e2[2] }, e2[3]));
  }, i(e3) {
    a2 || (Xn(n2.$$.fragment, e3), a2 = true);
  }, o(e3) {
    Gn(n2.$$.fragment, e3), a2 = false;
  }, d(e3) {
    e3 && an(t3), cr(n2), s2 = false, Dt(l);
  } };
}
function Bp(e2, t3, n2) {
  var r2, o2 = En("absolute-popup"), { validationError: a2 } = t3, { onExpand: i2 } = t3;
  return e2.$$set = (e3) => {
    "validationError" in e3 && n2(0, a2 = e3.validationError), "onExpand" in e3 && n2(1, i2 = e3.onExpand);
  }, e2.$$.update = () => {
    1 & e2.$$.dirty && n2(2, r2 = bi(a2) && a2.isChildError ? "Contains invalid data" : a2.message);
  }, [a2, i2, r2, o2];
}
var Fp = class extends dr {
  constructor(e2) {
    super(), ur(this, e2, Bp, Np, Vt, { validationError: 0, onExpand: 1 }, Ap);
  }
};
function Up(e2) {
  rn(e2, "svelte-1n9xu6u", '.jse-expand.svelte-1n9xu6u.svelte-1n9xu6u.svelte-1n9xu6u{width:var(--jse-indent-size, calc(1em + 4px));padding:0;margin:0;border:none;cursor:pointer;background:transparent;color:var(--jse-delimiter-color, rgba(0, 0, 0, 0.38));font-size:var(--jse-font-size-mono, 14px);height:var(--jse-line-height, calc(1em + 4px))}.jse-expand.svelte-1n9xu6u.svelte-1n9xu6u.svelte-1n9xu6u:hover{opacity:0.8}.jse-meta.svelte-1n9xu6u.svelte-1n9xu6u.svelte-1n9xu6u,.jse-separator.svelte-1n9xu6u.svelte-1n9xu6u.svelte-1n9xu6u,.jse-index.svelte-1n9xu6u.svelte-1n9xu6u.svelte-1n9xu6u,.jse-bracket.svelte-1n9xu6u.svelte-1n9xu6u.svelte-1n9xu6u{vertical-align:top;color:var(--jse-delimiter-color, rgba(0, 0, 0, 0.38))}.jse-index.svelte-1n9xu6u.svelte-1n9xu6u.svelte-1n9xu6u{padding:0 calc(0.5 * var(--jse-padding, 10px))}.jse-bracket.svelte-1n9xu6u.svelte-1n9xu6u.svelte-1n9xu6u{padding:0 2px}.jse-bracket.jse-expanded.svelte-1n9xu6u.svelte-1n9xu6u.svelte-1n9xu6u{padding-right:var(--jse-padding, 10px)}.jse-tag.svelte-1n9xu6u.svelte-1n9xu6u.svelte-1n9xu6u{border:none;font-size:80%;font-family:var(--jse-font-family, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif);color:var(--jse-tag-color, var(--jse-text-color-inverse, #fff));background:var(--jse-tag-background, rgba(0, 0, 0, 0.2));border-radius:2px;cursor:pointer;display:inline-block;padding:0 4px;line-height:normal;margin:1px 0}.jse-tag.svelte-1n9xu6u.svelte-1n9xu6u.svelte-1n9xu6u:hover{opacity:0.8}.jse-tag.jse-expanded.svelte-1n9xu6u.svelte-1n9xu6u.svelte-1n9xu6u{opacity:0.7;cursor:inherit}.jse-identifier.svelte-1n9xu6u.svelte-1n9xu6u.svelte-1n9xu6u{vertical-align:top;position:relative}.jse-json-node.svelte-1n9xu6u.svelte-1n9xu6u.svelte-1n9xu6u{position:relative;color:var(--jse-text-color, #4d4d4d)}.jse-json-node.jse-root.svelte-1n9xu6u.svelte-1n9xu6u.svelte-1n9xu6u{min-height:100%;padding-bottom:2px;box-sizing:border-box}.jse-json-node.jse-root.svelte-1n9xu6u>.jse-contents-outer.svelte-1n9xu6u>.jse-contents.svelte-1n9xu6u{padding-left:0}.jse-json-node.svelte-1n9xu6u .jse-props.svelte-1n9xu6u.svelte-1n9xu6u,.jse-json-node.svelte-1n9xu6u .jse-items.svelte-1n9xu6u.svelte-1n9xu6u{position:relative}.jse-json-node.svelte-1n9xu6u .jse-header-outer.svelte-1n9xu6u.svelte-1n9xu6u,.jse-json-node.svelte-1n9xu6u .jse-footer-outer.svelte-1n9xu6u.svelte-1n9xu6u{display:flex;margin-left:calc(var(--level) * var(--jse-indent-size, calc(1em + 4px)))}.jse-json-node.svelte-1n9xu6u .jse-header.svelte-1n9xu6u.svelte-1n9xu6u{position:relative}.jse-json-node.svelte-1n9xu6u .jse-header .jse-meta.svelte-1n9xu6u>.jse-meta-inner.svelte-1n9xu6u{display:flex;justify-content:center}.jse-json-node.svelte-1n9xu6u .jse-contents-outer.svelte-1n9xu6u.svelte-1n9xu6u{display:flex;margin-left:calc(var(--level) * var(--jse-indent-size, calc(1em + 4px)))}.jse-json-node.svelte-1n9xu6u .jse-header.svelte-1n9xu6u.svelte-1n9xu6u,.jse-json-node.svelte-1n9xu6u .jse-contents.svelte-1n9xu6u.svelte-1n9xu6u{display:flex;flex-direction:row;align-items:flex-start}.jse-json-node.svelte-1n9xu6u .jse-contents.svelte-1n9xu6u.svelte-1n9xu6u{padding-left:var(--jse-indent-size, calc(1em + 4px));cursor:var(--jse-contents-cursor, pointer)}.jse-json-node.svelte-1n9xu6u .jse-contents .jse-value-outer.svelte-1n9xu6u.svelte-1n9xu6u{display:inline-flex}.jse-json-node.svelte-1n9xu6u .jse-footer.svelte-1n9xu6u.svelte-1n9xu6u{display:inline-flex;padding-left:calc(var(--jse-indent-size, calc(1em + 4px)) + 5px)}.jse-json-node.svelte-1n9xu6u .jse-header.svelte-1n9xu6u.svelte-1n9xu6u,.jse-json-node.svelte-1n9xu6u .jse-contents.svelte-1n9xu6u.svelte-1n9xu6u,.jse-json-node.svelte-1n9xu6u .jse-footer.svelte-1n9xu6u.svelte-1n9xu6u{background:var(--jse-contents-background-color, transparent)}.jse-json-node.svelte-1n9xu6u .jse-insert-selection-area.svelte-1n9xu6u.svelte-1n9xu6u{padding:0 calc(0.5 * var(--jse-padding, 10px));flex:1}.jse-json-node.svelte-1n9xu6u .jse-insert-selection-area.jse-inside.svelte-1n9xu6u.svelte-1n9xu6u{display:inline-flex;align-items:center}.jse-json-node.svelte-1n9xu6u .jse-insert-selection-area.jse-after.svelte-1n9xu6u.svelte-1n9xu6u{display:flex;align-items:flex-end}.jse-json-node.svelte-1n9xu6u .jse-context-menu-pointer-anchor.svelte-1n9xu6u.svelte-1n9xu6u{position:relative}.jse-json-node.svelte-1n9xu6u .jse-insert-area.svelte-1n9xu6u.svelte-1n9xu6u{display:flex;position:relative;z-index:1;margin-left:calc(var(--level) * var(--jse-indent-size, calc(1em + 4px)));max-width:250px;min-width:100px;height:0;margin-right:calc(0.5 * var(--jse-padding, 10px));outline:1px solid}.jse-json-node.svelte-1n9xu6u .jse-insert-area.jse-hovered.svelte-1n9xu6u.svelte-1n9xu6u{outline-color:var(--jse-context-menu-pointer-hover-background, #b2b2b2)}.jse-json-node.svelte-1n9xu6u .jse-key-outer.svelte-1n9xu6u.svelte-1n9xu6u{position:relative}.jse-json-node.svelte-1n9xu6u .jse-key-outer.svelte-1n9xu6u.svelte-1n9xu6u:hover,.jse-json-node.svelte-1n9xu6u .jse-value-outer.svelte-1n9xu6u.svelte-1n9xu6u:hover,.jse-json-node.svelte-1n9xu6u .jse-meta.svelte-1n9xu6u.svelte-1n9xu6u:hover,.jse-json-node.svelte-1n9xu6u .jse-footer.svelte-1n9xu6u.svelte-1n9xu6u:hover{background:var(--jse-hover-background-color, rgba(0, 0, 0, 0.06));cursor:var(--jse-contents-cursor, pointer)}.jse-json-node.jse-hovered.svelte-1n9xu6u:not(.jse-selected):not(.jse-selected-value) .jse-value-outer.svelte-1n9xu6u.svelte-1n9xu6u,.jse-json-node.jse-hovered.svelte-1n9xu6u:not(.jse-selected):not(.jse-selected-value) .jse-meta.svelte-1n9xu6u.svelte-1n9xu6u,.jse-json-node.jse-hovered.svelte-1n9xu6u:not(.jse-selected):not(.jse-selected-value) .jse-items .jse-header.svelte-1n9xu6u.svelte-1n9xu6u,.jse-json-node.jse-hovered.svelte-1n9xu6u:not(.jse-selected):not(.jse-selected-value) .jse-items .jse-contents.svelte-1n9xu6u.svelte-1n9xu6u,.jse-json-node.jse-hovered.svelte-1n9xu6u:not(.jse-selected):not(.jse-selected-value) .jse-props .jse-header.svelte-1n9xu6u.svelte-1n9xu6u,.jse-json-node.jse-hovered.svelte-1n9xu6u:not(.jse-selected):not(.jse-selected-value) .jse-props .jse-contents.svelte-1n9xu6u.svelte-1n9xu6u,.jse-json-node.jse-hovered.svelte-1n9xu6u:not(.jse-selected):not(.jse-selected-value) .jse-footer.svelte-1n9xu6u.svelte-1n9xu6u{background:var(--jse-hover-background-color, rgba(0, 0, 0, 0.06));cursor:var(--jse-contents-cursor, pointer)}.jse-json-node.jse-hovered.svelte-1n9xu6u:not(.jse-selected):not(.jse-selected-value) .jse-value-outer .jse-value-outer.svelte-1n9xu6u.svelte-1n9xu6u,.jse-json-node.jse-hovered.svelte-1n9xu6u:not(.jse-selected):not(.jse-selected-value) .jse-value-outer .jse-meta.svelte-1n9xu6u.svelte-1n9xu6u,.jse-json-node.jse-hovered.svelte-1n9xu6u:not(.jse-selected):not(.jse-selected-value) .jse-meta .jse-value-outer.svelte-1n9xu6u.svelte-1n9xu6u,.jse-json-node.jse-hovered.svelte-1n9xu6u:not(.jse-selected):not(.jse-selected-value) .jse-meta .jse-meta.svelte-1n9xu6u.svelte-1n9xu6u,.jse-json-node.jse-hovered.svelte-1n9xu6u:not(.jse-selected):not(.jse-selected-value) .jse-items .jse-header .jse-value-outer.svelte-1n9xu6u.svelte-1n9xu6u,.jse-json-node.jse-hovered.svelte-1n9xu6u:not(.jse-selected):not(.jse-selected-value) .jse-items .jse-header .jse-meta.svelte-1n9xu6u.svelte-1n9xu6u,.jse-json-node.jse-hovered.svelte-1n9xu6u:not(.jse-selected):not(.jse-selected-value) .jse-items .jse-contents .jse-value-outer.svelte-1n9xu6u.svelte-1n9xu6u,.jse-json-node.jse-hovered.svelte-1n9xu6u:not(.jse-selected):not(.jse-selected-value) .jse-items .jse-contents .jse-meta.svelte-1n9xu6u.svelte-1n9xu6u,.jse-json-node.jse-hovered.svelte-1n9xu6u:not(.jse-selected):not(.jse-selected-value) .jse-props .jse-header .jse-value-outer.svelte-1n9xu6u.svelte-1n9xu6u,.jse-json-node.jse-hovered.svelte-1n9xu6u:not(.jse-selected):not(.jse-selected-value) .jse-props .jse-header .jse-meta.svelte-1n9xu6u.svelte-1n9xu6u,.jse-json-node.jse-hovered.svelte-1n9xu6u:not(.jse-selected):not(.jse-selected-value) .jse-props .jse-contents .jse-value-outer.svelte-1n9xu6u.svelte-1n9xu6u,.jse-json-node.jse-hovered.svelte-1n9xu6u:not(.jse-selected):not(.jse-selected-value) .jse-props .jse-contents .jse-meta.svelte-1n9xu6u.svelte-1n9xu6u,.jse-json-node.jse-hovered.svelte-1n9xu6u:not(.jse-selected):not(.jse-selected-value) .jse-footer .jse-value-outer.svelte-1n9xu6u.svelte-1n9xu6u,.jse-json-node.jse-hovered.svelte-1n9xu6u:not(.jse-selected):not(.jse-selected-value) .jse-footer .jse-meta.svelte-1n9xu6u.svelte-1n9xu6u{background:none}.jse-json-node.jse-selected.svelte-1n9xu6u .jse-header.svelte-1n9xu6u.svelte-1n9xu6u,.jse-json-node.jse-selected.svelte-1n9xu6u .jse-contents.svelte-1n9xu6u.svelte-1n9xu6u,.jse-json-node.jse-selected.svelte-1n9xu6u .jse-footer.svelte-1n9xu6u.svelte-1n9xu6u{background:var(--jse-selection-background-color, #d3d3d3);cursor:var(--jse-contents-selected-cursor, grab)}.jse-json-node.jse-selected.svelte-1n9xu6u .jse-key-outer.svelte-1n9xu6u.svelte-1n9xu6u:hover,.jse-json-node.jse-selected.svelte-1n9xu6u .jse-value-outer.svelte-1n9xu6u.svelte-1n9xu6u:hover,.jse-json-node.jse-selected.svelte-1n9xu6u .jse-meta.svelte-1n9xu6u.svelte-1n9xu6u:hover,.jse-json-node.jse-selected.svelte-1n9xu6u .jse-footer.svelte-1n9xu6u.svelte-1n9xu6u:hover{background:inherit;cursor:inherit}.jse-json-node.svelte-1n9xu6u .jse-key-outer.jse-selected-key.svelte-1n9xu6u.svelte-1n9xu6u{background:var(--jse-selection-background-color, #d3d3d3);cursor:var(--jse-contents-selected-cursor, grab)}.jse-json-node.jse-selected-value.svelte-1n9xu6u .jse-value-outer.svelte-1n9xu6u.svelte-1n9xu6u,.jse-json-node.jse-selected-value.svelte-1n9xu6u .jse-meta.svelte-1n9xu6u.svelte-1n9xu6u,.jse-json-node.jse-selected-value.svelte-1n9xu6u .jse-items .jse-header.svelte-1n9xu6u.svelte-1n9xu6u,.jse-json-node.jse-selected-value.svelte-1n9xu6u .jse-items .jse-contents.svelte-1n9xu6u.svelte-1n9xu6u,.jse-json-node.jse-selected-value.svelte-1n9xu6u .jse-props .jse-header.svelte-1n9xu6u.svelte-1n9xu6u,.jse-json-node.jse-selected-value.svelte-1n9xu6u .jse-props .jse-contents.svelte-1n9xu6u.svelte-1n9xu6u,.jse-json-node.jse-selected-value.svelte-1n9xu6u .jse-footer.svelte-1n9xu6u.svelte-1n9xu6u{background:var(--jse-selection-background-color, #d3d3d3);cursor:var(--jse-contents-selected-cursor, grab)}.jse-json-node.jse-selected-value.svelte-1n9xu6u .jse-value-outer .jse-key-outer.svelte-1n9xu6u.svelte-1n9xu6u:hover,.jse-json-node.jse-selected-value.svelte-1n9xu6u .jse-meta .jse-key-outer.svelte-1n9xu6u.svelte-1n9xu6u:hover,.jse-json-node.jse-selected-value.svelte-1n9xu6u .jse-items .jse-header .jse-key-outer.svelte-1n9xu6u.svelte-1n9xu6u:hover,.jse-json-node.jse-selected-value.svelte-1n9xu6u .jse-items .jse-contents .jse-key-outer.svelte-1n9xu6u.svelte-1n9xu6u:hover,.jse-json-node.jse-selected-value.svelte-1n9xu6u .jse-props .jse-header .jse-key-outer.svelte-1n9xu6u.svelte-1n9xu6u:hover,.jse-json-node.jse-selected-value.svelte-1n9xu6u .jse-props .jse-contents .jse-key-outer.svelte-1n9xu6u.svelte-1n9xu6u:hover,.jse-json-node.jse-selected-value.svelte-1n9xu6u .jse-footer .jse-key-outer.svelte-1n9xu6u.svelte-1n9xu6u:hover{background:inherit;cursor:inherit}.jse-json-node.jse-readonly.svelte-1n9xu6u.svelte-1n9xu6u.svelte-1n9xu6u{--jse-contents-selected-cursor:pointer}.jse-json-node.svelte-1n9xu6u .jse-insert-area.jse-selected.svelte-1n9xu6u.svelte-1n9xu6u{outline-color:var(--jse-context-menu-pointer-background, var(--jse-context-menu-background, #656565))}');
}
var Lp = (e2) => ({});
var Dp = (e2) => ({});
function Jp(e2, t3, n2) {
  var r2 = e2.slice();
  r2[52] = t3[n2];
  var o2 = appendToJSONPointer(r2[0], r2[52]);
  r2[53] = o2;
  var a2 = wi(r2[4]) ? r2[4].properties[r2[52]] : void 0;
  r2[54] = a2;
  var i2 = wi(r2[3]) ? r2[3].properties[r2[52]] : void 0;
  r2[48] = i2;
  var s2 = r2[7].concat(r2[52]);
  r2[55] = s2;
  var l = Fs(r2[6].getJson(), r2[5], r2[55]);
  return r2[49] = l, r2;
}
var Vp = (e2) => ({});
var Hp = (e2) => ({});
function _p(e2, t3, n2) {
  var r2 = e2.slice();
  return r2[44] = t3[n2], r2[46] = n2, r2;
}
function Wp(e2, t3, n2) {
  var r2 = e2.slice();
  r2[47] = t3[n2];
  var o2 = Ci(r2[3]) ? r2[3].items[r2[47].index] : void 0;
  r2[48] = o2;
  var a2 = Fs(r2[6].getJson(), r2[5], r2[7].concat(String(r2[47].index)));
  return r2[49] = a2, r2;
}
var Qp = (e2) => ({});
var Yp = (e2) => ({});
function Kp(e2) {
  var t3, n2, r2, o2, a2, i2, s2, l, c, u, d = !e2[6].readOnly && e2[14] && e2[5] && (ls(e2[5]) || cs(e2[5])) && !Is(e2[5]) && isEqual_default(Ds(e2[5]), e2[7]), v = e2[32].identifier, p = _t(v, e2, e2[33], Dp), f = !e2[15] && Gp();
  i2 = new Pp({ props: { path: e2[7], value: e2[1], enforceString: e2[11], selection: e2[14] ? e2[5] : void 0, searchResultItems: jl(e2[4]), context: e2[6] } });
  var m3 = d && ef(e2), h2 = e2[13] && tf(e2), g = !e2[15] && nf(e2);
  return { c() {
    t3 = ln("div"), n2 = ln("div"), p && p.c(), r2 = dn(), f && f.c(), o2 = dn(), a2 = ln("div"), sr(i2.$$.fragment), s2 = dn(), m3 && m3.c(), l = dn(), h2 && h2.c(), c = dn(), g && g.c(), hn(a2, "class", "jse-value-outer svelte-1n9xu6u"), hn(n2, "class", "jse-contents svelte-1n9xu6u"), hn(t3, "class", "jse-contents-outer svelte-1n9xu6u");
  }, m(e3, d2) {
    on(e3, t3, d2), nn(t3, n2), p && p.m(n2, null), nn(n2, r2), f && f.m(n2, null), nn(n2, o2), nn(n2, a2), lr(i2, a2, null), nn(n2, s2), m3 && m3.m(n2, null), nn(t3, l), h2 && h2.m(t3, null), nn(t3, c), g && g.m(t3, null), u = true;
  }, p(e3, r3) {
    p && p.p && (!u || 4 & r3[1]) && Yt(p, v, e3, e3[33], u ? Qt(v, e3[33], r3, Lp) : Kt(e3[33]), Dp), e3[15] ? f && (f.d(1), f = null) : f || ((f = Gp()).c(), f.m(n2, o2));
    var a3 = {};
    128 & r3[0] && (a3.path = e3[7]), 2 & r3[0] && (a3.value = e3[1]), 2048 & r3[0] && (a3.enforceString = e3[11]), 16416 & r3[0] && (a3.selection = e3[14] ? e3[5] : void 0), 16 & r3[0] && (a3.searchResultItems = jl(e3[4])), 64 & r3[0] && (a3.context = e3[6]), i2.$set(a3), 16608 & r3[0] && (d = !e3[6].readOnly && e3[14] && e3[5] && (ls(e3[5]) || cs(e3[5])) && !Is(e3[5]) && isEqual_default(Ds(e3[5]), e3[7])), d ? m3 ? (m3.p(e3, r3), 16608 & r3[0] && Xn(m3, 1)) : ((m3 = ef(e3)).c(), Xn(m3, 1), m3.m(n2, null)) : m3 && (Kn(), Gn(m3, 1, 1, () => {
      m3 = null;
    }), Zn()), e3[13] ? h2 ? (h2.p(e3, r3), 8192 & r3[0] && Xn(h2, 1)) : ((h2 = tf(e3)).c(), Xn(h2, 1), h2.m(t3, c)) : h2 && (Kn(), Gn(h2, 1, 1, () => {
      h2 = null;
    }), Zn()), e3[15] ? g && (g.d(1), g = null) : g ? g.p(e3, r3) : ((g = nf(e3)).c(), g.m(t3, null));
  }, i(e3) {
    u || (Xn(p, e3), Xn(i2.$$.fragment, e3), Xn(m3), Xn(h2), u = true);
  }, o(e3) {
    Gn(p, e3), Gn(i2.$$.fragment, e3), Gn(m3), Gn(h2), u = false;
  }, d(e3) {
    e3 && an(t3), p && p.d(e3), f && f.d(), cr(i2), m3 && m3.d(), h2 && h2.d(), g && g.d();
  } };
}
function Zp(e2) {
  var t3, n2, r2, o2, a2, i2, s2, l, c, u, d, v, p, f, m3, h2, g, j, x = !e2[6].readOnly && e2[14] && e2[5] && (ls(e2[5]) || cs(e2[5])) && !Is(e2[5]) && isEqual_default(Ds(e2[5]), e2[7]), b2 = [of, rf], y = [];
  function $2(e3, t4) {
    return e3[10] ? 0 : 1;
  }
  o2 = $2(e2), a2 = y[o2] = b2[o2](e2);
  var w = e2[32].identifier, C3 = _t(w, e2, e2[33], Hp), k2 = !e2[15] && af();
  function S4(e3, t4) {
    return e3[10] ? lf : sf;
  }
  var O = S4(e2), z3 = O(e2), q2 = x && cf(e2), M3 = e2[13] && (!e2[10] || !e2[13].isChildError) && uf(e2);
  function R3(e3, t4) {
    return e3[10] ? vf : e3[15] ? void 0 : df;
  }
  var E3 = R3(e2), P3 = E3 && E3(e2), T3 = e2[10] && pf(e2);
  return { c() {
    t3 = ln("div"), n2 = ln("div"), r2 = ln("button"), a2.c(), i2 = dn(), C3 && C3.c(), s2 = dn(), k2 && k2.c(), l = dn(), c = ln("div"), u = ln("div"), z3.c(), d = dn(), q2 && q2.c(), v = dn(), M3 && M3.c(), p = dn(), P3 && P3.c(), f = dn(), T3 && T3.c(), m3 = vn(), hn(r2, "type", "button"), hn(r2, "class", "jse-expand svelte-1n9xu6u"), hn(r2, "title", "Expand or collapse this object (Ctrl+Click to expand/collapse recursively)"), hn(u, "class", "jse-meta-inner svelte-1n9xu6u"), hn(c, "class", "jse-meta svelte-1n9xu6u"), hn(c, "data-type", "selectable-value"), hn(n2, "class", "jse-header svelte-1n9xu6u"), hn(t3, "class", "jse-header-outer svelte-1n9xu6u");
  }, m(a3, x2) {
    on(a3, t3, x2), nn(t3, n2), nn(n2, r2), y[o2].m(r2, null), nn(n2, i2), C3 && C3.m(n2, null), nn(n2, s2), k2 && k2.m(n2, null), nn(n2, l), nn(n2, c), nn(c, u), z3.m(u, null), nn(n2, d), q2 && q2.m(n2, null), nn(t3, v), M3 && M3.m(t3, null), nn(t3, p), P3 && P3.m(t3, null), on(a3, f, x2), T3 && T3.m(a3, x2), on(a3, m3, x2), h2 = true, g || (j = pn(r2, "click", e2[19]), g = true);
  }, p(e3, i3) {
    var s3 = o2;
    (o2 = $2(e3)) !== s3 && (Kn(), Gn(y[s3], 1, 1, () => {
      y[s3] = null;
    }), Zn(), (a2 = y[o2]) || (a2 = y[o2] = b2[o2](e3)).c(), Xn(a2, 1), a2.m(r2, null)), C3 && C3.p && (!h2 || 4 & i3[1]) && Yt(C3, w, e3, e3[33], h2 ? Qt(w, e3[33], i3, Vp) : Kt(e3[33]), Hp), e3[15] ? k2 && (k2.d(1), k2 = null) : k2 || ((k2 = af()).c(), k2.m(n2, l)), O === (O = S4(e3)) && z3 ? z3.p(e3, i3) : (z3.d(1), (z3 = O(e3)) && (z3.c(), z3.m(u, null))), 16608 & i3[0] && (x = !e3[6].readOnly && e3[14] && e3[5] && (ls(e3[5]) || cs(e3[5])) && !Is(e3[5]) && isEqual_default(Ds(e3[5]), e3[7])), x ? q2 ? (q2.p(e3, i3), 16608 & i3[0] && Xn(q2, 1)) : ((q2 = cf(e3)).c(), Xn(q2, 1), q2.m(n2, null)) : q2 && (Kn(), Gn(q2, 1, 1, () => {
      q2 = null;
    }), Zn()), !e3[13] || e3[10] && e3[13].isChildError ? M3 && (Kn(), Gn(M3, 1, 1, () => {
      M3 = null;
    }), Zn()) : M3 ? (M3.p(e3, i3), 9216 & i3[0] && Xn(M3, 1)) : ((M3 = uf(e3)).c(), Xn(M3, 1), M3.m(t3, p)), E3 === (E3 = R3(e3)) && P3 ? P3.p(e3, i3) : (P3 && P3.d(1), (P3 = E3 && E3(e3)) && (P3.c(), P3.m(t3, null))), e3[10] ? T3 ? (T3.p(e3, i3), 1024 & i3[0] && Xn(T3, 1)) : ((T3 = pf(e3)).c(), Xn(T3, 1), T3.m(m3.parentNode, m3)) : T3 && (Kn(), Gn(T3, 1, 1, () => {
      T3 = null;
    }), Zn());
  }, i(e3) {
    h2 || (Xn(a2), Xn(C3, e3), Xn(q2), Xn(M3), Xn(T3), h2 = true);
  }, o(e3) {
    Gn(a2), Gn(C3, e3), Gn(q2), Gn(M3), Gn(T3), h2 = false;
  }, d(e3) {
    e3 && (an(t3), an(f), an(m3)), y[o2].d(), C3 && C3.d(e3), k2 && k2.d(), z3.d(), q2 && q2.d(), M3 && M3.d(), P3 && P3.d(), T3 && T3.d(e3), g = false, j();
  } };
}
function Xp(e2) {
  var t3, n2, r2, o2, a2, i2, s2, l, c, u, d, v, p, f, m3, h2, g, j, x = !e2[6].readOnly && e2[14] && e2[5] && (ls(e2[5]) || cs(e2[5])) && !Is(e2[5]) && isEqual_default(Ds(e2[5]), e2[7]), b2 = [xf, jf], y = [];
  function $2(e3, t4) {
    return e3[10] ? 0 : 1;
  }
  o2 = $2(e2), a2 = y[o2] = b2[o2](e2);
  var w = e2[32].identifier, C3 = _t(w, e2, e2[33], Yp), k2 = !e2[15] && bf();
  function S4(e3, t4) {
    return e3[10] ? $f : yf;
  }
  var O = S4(e2), z3 = O(e2), q2 = x && wf(e2), M3 = e2[13] && (!e2[10] || !e2[13].isChildError) && Cf(e2);
  function R3(e3, t4) {
    return e3[10] ? Sf : kf;
  }
  var E3 = R3(e2), P3 = E3(e2), T3 = e2[10] && Of(e2);
  return { c() {
    t3 = ln("div"), n2 = ln("div"), r2 = ln("button"), a2.c(), i2 = dn(), C3 && C3.c(), s2 = dn(), k2 && k2.c(), l = dn(), c = ln("div"), u = ln("div"), z3.c(), d = dn(), q2 && q2.c(), v = dn(), M3 && M3.c(), p = dn(), P3.c(), f = dn(), T3 && T3.c(), m3 = vn(), hn(r2, "type", "button"), hn(r2, "class", "jse-expand svelte-1n9xu6u"), hn(r2, "title", "Expand or collapse this array (Ctrl+Click to expand/collapse recursively)"), hn(u, "class", "jse-meta-inner svelte-1n9xu6u"), hn(u, "data-type", "selectable-value"), hn(c, "class", "jse-meta svelte-1n9xu6u"), hn(n2, "class", "jse-header svelte-1n9xu6u"), hn(t3, "class", "jse-header-outer svelte-1n9xu6u");
  }, m(a3, x2) {
    on(a3, t3, x2), nn(t3, n2), nn(n2, r2), y[o2].m(r2, null), nn(n2, i2), C3 && C3.m(n2, null), nn(n2, s2), k2 && k2.m(n2, null), nn(n2, l), nn(n2, c), nn(c, u), z3.m(u, null), nn(n2, d), q2 && q2.m(n2, null), nn(t3, v), M3 && M3.m(t3, null), nn(t3, p), P3.m(t3, null), on(a3, f, x2), T3 && T3.m(a3, x2), on(a3, m3, x2), h2 = true, g || (j = pn(r2, "click", e2[19]), g = true);
  }, p(e3, i3) {
    var s3 = o2;
    (o2 = $2(e3)) !== s3 && (Kn(), Gn(y[s3], 1, 1, () => {
      y[s3] = null;
    }), Zn(), (a2 = y[o2]) || (a2 = y[o2] = b2[o2](e3)).c(), Xn(a2, 1), a2.m(r2, null)), C3 && C3.p && (!h2 || 4 & i3[1]) && Yt(C3, w, e3, e3[33], h2 ? Qt(w, e3[33], i3, Qp) : Kt(e3[33]), Yp), e3[15] ? k2 && (k2.d(1), k2 = null) : k2 || ((k2 = bf()).c(), k2.m(n2, l)), O === (O = S4(e3)) && z3 ? z3.p(e3, i3) : (z3.d(1), (z3 = O(e3)) && (z3.c(), z3.m(u, null))), 16608 & i3[0] && (x = !e3[6].readOnly && e3[14] && e3[5] && (ls(e3[5]) || cs(e3[5])) && !Is(e3[5]) && isEqual_default(Ds(e3[5]), e3[7])), x ? q2 ? (q2.p(e3, i3), 16608 & i3[0] && Xn(q2, 1)) : ((q2 = wf(e3)).c(), Xn(q2, 1), q2.m(n2, null)) : q2 && (Kn(), Gn(q2, 1, 1, () => {
      q2 = null;
    }), Zn()), !e3[13] || e3[10] && e3[13].isChildError ? M3 && (Kn(), Gn(M3, 1, 1, () => {
      M3 = null;
    }), Zn()) : M3 ? (M3.p(e3, i3), 9216 & i3[0] && Xn(M3, 1)) : ((M3 = Cf(e3)).c(), Xn(M3, 1), M3.m(t3, p)), E3 === (E3 = R3(e3)) && P3 ? P3.p(e3, i3) : (P3.d(1), (P3 = E3(e3)) && (P3.c(), P3.m(t3, null))), e3[10] ? T3 ? (T3.p(e3, i3), 1024 & i3[0] && Xn(T3, 1)) : ((T3 = Of(e3)).c(), Xn(T3, 1), T3.m(m3.parentNode, m3)) : T3 && (Kn(), Gn(T3, 1, 1, () => {
      T3 = null;
    }), Zn());
  }, i(e3) {
    h2 || (Xn(a2), Xn(C3, e3), Xn(q2), Xn(M3), Xn(T3), h2 = true);
  }, o(e3) {
    Gn(a2), Gn(C3, e3), Gn(q2), Gn(M3), Gn(T3), h2 = false;
  }, d(e3) {
    e3 && (an(t3), an(f), an(m3)), y[o2].d(), C3 && C3.d(e3), k2 && k2.d(), z3.d(), q2 && q2.d(), M3 && M3.d(), P3.d(), T3 && T3.d(e3), g = false, j();
  } };
}
function Gp(e2) {
  var t3;
  return { c() {
    (t3 = ln("div")).textContent = ":", hn(t3, "class", "jse-separator svelte-1n9xu6u");
  }, m(e3, n2) {
    on(e3, t3, n2);
  }, d(e3) {
    e3 && an(t3);
  } };
}
function ef(e2) {
  var t3, n2, r2;
  return n2 = new mp({ props: { root: e2[15], selected: true, onContextMenu: e2[6].onContextMenu } }), { c() {
    t3 = ln("div"), sr(n2.$$.fragment), hn(t3, "class", "jse-context-menu-pointer-anchor svelte-1n9xu6u");
  }, m(e3, o2) {
    on(e3, t3, o2), lr(n2, t3, null), r2 = true;
  }, p(e3, t4) {
    var r3 = {};
    32768 & t4[0] && (r3.root = e3[15]), 64 & t4[0] && (r3.onContextMenu = e3[6].onContextMenu), n2.$set(r3);
  }, i(e3) {
    r2 || (Xn(n2.$$.fragment, e3), r2 = true);
  }, o(e3) {
    Gn(n2.$$.fragment, e3), r2 = false;
  }, d(e3) {
    e3 && an(t3), cr(n2);
  } };
}
function tf(e2) {
  var t3, n2;
  return t3 = new Fp({ props: { validationError: e2[13], onExpand: e2[20] } }), { c() {
    sr(t3.$$.fragment);
  }, m(e3, r2) {
    lr(t3, e3, r2), n2 = true;
  }, p(e3, n3) {
    var r2 = {};
    8192 & n3[0] && (r2.validationError = e3[13]), t3.$set(r2);
  }, i(e3) {
    n2 || (Xn(t3.$$.fragment, e3), n2 = true);
  }, o(e3) {
    Gn(t3.$$.fragment, e3), n2 = false;
  }, d(e3) {
    cr(t3, e3);
  } };
}
function nf(e2) {
  var t3, n2, r2;
  return { c() {
    hn(t3 = ln("div"), "role", "none"), hn(t3, "class", "jse-insert-selection-area jse-after svelte-1n9xu6u"), hn(t3, "data-type", "insert-selection-area-after");
  }, m(o2, a2) {
    on(o2, t3, a2), n2 || (r2 = pn(t3, "click", e2[28]), n2 = true);
  }, p: Bt, d(e3) {
    e3 && an(t3), n2 = false, r2();
  } };
}
function rf(e2) {
  var t3, n2;
  return t3 = new Ca({ props: { data: faCaretRight } }), { c() {
    sr(t3.$$.fragment);
  }, m(e3, r2) {
    lr(t3, e3, r2), n2 = true;
  }, i(e3) {
    n2 || (Xn(t3.$$.fragment, e3), n2 = true);
  }, o(e3) {
    Gn(t3.$$.fragment, e3), n2 = false;
  }, d(e3) {
    cr(t3, e3);
  } };
}
function of(e2) {
  var t3, n2;
  return t3 = new Ca({ props: { data: faCaretDown } }), { c() {
    sr(t3.$$.fragment);
  }, m(e3, r2) {
    lr(t3, e3, r2), n2 = true;
  }, i(e3) {
    n2 || (Xn(t3.$$.fragment, e3), n2 = true);
  }, o(e3) {
    Gn(t3.$$.fragment, e3), n2 = false;
  }, d(e3) {
    cr(t3, e3);
  } };
}
function af(e2) {
  var t3;
  return { c() {
    (t3 = ln("div")).textContent = ":", hn(t3, "class", "jse-separator svelte-1n9xu6u");
  }, m(e3, n2) {
    on(e3, t3, n2);
  }, d(e3) {
    e3 && an(t3);
  } };
}
function sf(e2) {
  var t3, n2, r2, o2, a2, i2, s2, l, c, u, d = Object.keys(e2[1]).length + "", v = 1 === Object.keys(e2[1]).length ? "prop" : "props";
  return { c() {
    (t3 = ln("div")).textContent = "{", n2 = dn(), r2 = ln("button"), o2 = un(d), a2 = dn(), i2 = un(v), s2 = dn(), (l = ln("div")).textContent = "}", hn(t3, "class", "jse-bracket svelte-1n9xu6u"), hn(r2, "type", "button"), hn(r2, "class", "jse-tag svelte-1n9xu6u"), hn(l, "class", "jse-bracket svelte-1n9xu6u");
  }, m(d2, v2) {
    on(d2, t3, v2), on(d2, n2, v2), on(d2, r2, v2), nn(r2, o2), nn(r2, a2), nn(r2, i2), on(d2, s2, v2), on(d2, l, v2), c || (u = pn(r2, "click", e2[20]), c = true);
  }, p(e3, t4) {
    2 & t4[0] && d !== (d = Object.keys(e3[1]).length + "") && yn(o2, d), 2 & t4[0] && v !== (v = 1 === Object.keys(e3[1]).length ? "prop" : "props") && yn(i2, v);
  }, d(e3) {
    e3 && (an(t3), an(n2), an(r2), an(s2), an(l)), c = false, u();
  } };
}
function lf(e2) {
  var t3;
  return { c() {
    (t3 = ln("div")).textContent = "{", hn(t3, "class", "jse-bracket jse-expanded svelte-1n9xu6u");
  }, m(e3, n2) {
    on(e3, t3, n2);
  }, p: Bt, d(e3) {
    e3 && an(t3);
  } };
}
function cf(e2) {
  var t3, n2, r2;
  return n2 = new mp({ props: { root: e2[15], selected: true, onContextMenu: e2[6].onContextMenu } }), { c() {
    t3 = ln("div"), sr(n2.$$.fragment), hn(t3, "class", "jse-context-menu-pointer-anchor svelte-1n9xu6u");
  }, m(e3, o2) {
    on(e3, t3, o2), lr(n2, t3, null), r2 = true;
  }, p(e3, t4) {
    var r3 = {};
    32768 & t4[0] && (r3.root = e3[15]), 64 & t4[0] && (r3.onContextMenu = e3[6].onContextMenu), n2.$set(r3);
  }, i(e3) {
    r2 || (Xn(n2.$$.fragment, e3), r2 = true);
  }, o(e3) {
    Gn(n2.$$.fragment, e3), r2 = false;
  }, d(e3) {
    e3 && an(t3), cr(n2);
  } };
}
function uf(e2) {
  var t3, n2;
  return t3 = new Fp({ props: { validationError: e2[13], onExpand: e2[20] } }), { c() {
    sr(t3.$$.fragment);
  }, m(e3, r2) {
    lr(t3, e3, r2), n2 = true;
  }, p(e3, n3) {
    var r2 = {};
    8192 & n3[0] && (r2.validationError = e3[13]), t3.$set(r2);
  }, i(e3) {
    n2 || (Xn(t3.$$.fragment, e3), n2 = true);
  }, o(e3) {
    Gn(t3.$$.fragment, e3), n2 = false;
  }, d(e3) {
    cr(t3, e3);
  } };
}
function df(e2) {
  var t3, n2, r2;
  return { c() {
    hn(t3 = ln("div"), "role", "none"), hn(t3, "class", "jse-insert-selection-area jse-after svelte-1n9xu6u"), hn(t3, "data-type", "insert-selection-area-after");
  }, m(o2, a2) {
    on(o2, t3, a2), n2 || (r2 = pn(t3, "click", e2[28]), n2 = true);
  }, p: Bt, d(e3) {
    e3 && an(t3), n2 = false, r2();
  } };
}
function vf(e2) {
  var t3, n2, r2;
  return { c() {
    hn(t3 = ln("div"), "role", "none"), hn(t3, "class", "jse-insert-selection-area jse-inside svelte-1n9xu6u"), hn(t3, "data-type", "insert-selection-area-inside");
  }, m(o2, a2) {
    on(o2, t3, a2), n2 || (r2 = pn(t3, "click", e2[27]), n2 = true);
  }, p: Bt, d(e3) {
    e3 && an(t3), n2 = false, r2();
  } };
}
function pf(e2) {
  for (var t3, n2, r2, o2, a2, i2, s2, l = !e2[6].readOnly && (e2[8] === Xa || e2[14] && is(e2[5])), c = l && ff(e2), u = er(e2[17](e2[1], e2[9])), d = [], v = 0; v < u.length; v += 1) d[v] = hf(Jp(e2, u, v));
  var p = (e3) => Gn(d[e3], 1, 1, () => {
    d[e3] = null;
  }), f = !e2[15] && gf(e2);
  return { c() {
    t3 = ln("div"), c && c.c(), n2 = dn();
    for (var e3 = 0; e3 < d.length; e3 += 1) d[e3].c();
    r2 = dn(), o2 = ln("div"), (a2 = ln("div")).innerHTML = '<div class="jse-bracket svelte-1n9xu6u">}</div>', i2 = dn(), f && f.c(), hn(t3, "class", "jse-props svelte-1n9xu6u"), hn(a2, "data-type", "selectable-value"), hn(a2, "class", "jse-footer svelte-1n9xu6u"), hn(o2, "class", "jse-footer-outer svelte-1n9xu6u");
  }, m(e3, l2) {
    on(e3, t3, l2), c && c.m(t3, null), nn(t3, n2);
    for (var u2 = 0; u2 < d.length; u2 += 1) d[u2] && d[u2].m(t3, null);
    on(e3, r2, l2), on(e3, o2, l2), nn(o2, a2), nn(o2, i2), f && f.m(o2, null), s2 = true;
  }, p(e3, r3) {
    if (16736 & r3[0] && (l = !e3[6].readOnly && (e3[8] === Xa || e3[14] && is(e3[5]))), l ? c ? (c.p(e3, r3), 16736 & r3[0] && Xn(c, 1)) : ((c = ff(e3)).c(), Xn(c, 1), c.m(t3, n2)) : c && (Kn(), Gn(c, 1, 1, () => {
      c = null;
    }), Zn()), 19006207 & r3[0]) {
      var a3;
      for (u = er(e3[17](e3[1], e3[9])), a3 = 0; a3 < u.length; a3 += 1) {
        var i3 = Jp(e3, u, a3);
        d[a3] ? (d[a3].p(i3, r3), Xn(d[a3], 1)) : (d[a3] = hf(i3), d[a3].c(), Xn(d[a3], 1), d[a3].m(t3, null));
      }
      for (Kn(), a3 = u.length; a3 < d.length; a3 += 1) p(a3);
      Zn();
    }
    e3[15] ? f && (f.d(1), f = null) : f ? f.p(e3, r3) : ((f = gf(e3)).c(), f.m(o2, null));
  }, i(e3) {
    if (!s2) {
      Xn(c);
      for (var t4 = 0; t4 < u.length; t4 += 1) Xn(d[t4]);
      s2 = true;
    }
  }, o(e3) {
    Gn(c), d = d.filter(Boolean);
    for (var t4 = 0; t4 < d.length; t4 += 1) Gn(d[t4]);
    s2 = false;
  }, d(e3) {
    e3 && (an(t3), an(r2), an(o2)), c && c.d(), sn(d, e3), f && f.d();
  } };
}
function ff(e2) {
  var t3, n2, r2;
  return n2 = new mp({ props: { insert: true, selected: e2[14] && is(e2[5]), onContextMenu: e2[29] } }), { c() {
    t3 = ln("div"), sr(n2.$$.fragment), hn(t3, "class", "jse-insert-area jse-inside svelte-1n9xu6u"), hn(t3, "data-type", "insert-selection-area-inside"), hn(t3, "title", Ka), kn(t3, "jse-hovered", e2[8] === Xa), kn(t3, "jse-selected", e2[14] && is(e2[5])), wn(t3, "--level", e2[7].length + 1);
  }, m(e3, o2) {
    on(e3, t3, o2), lr(n2, t3, null), r2 = true;
  }, p(e3, o2) {
    var a2 = {};
    16416 & o2[0] && (a2.selected = e3[14] && is(e3[5])), n2.$set(a2), (!r2 || 256 & o2[0]) && kn(t3, "jse-hovered", e3[8] === Xa), (!r2 || 16416 & o2[0]) && kn(t3, "jse-selected", e3[14] && is(e3[5])), 128 & o2[0] && wn(t3, "--level", e3[7].length + 1);
  }, i(e3) {
    r2 || (Xn(n2.$$.fragment, e3), r2 = true);
  }, o(e3) {
    Gn(n2.$$.fragment, e3), r2 = false;
  }, d(e3) {
    e3 && an(t3), cr(n2);
  } };
}
function mf(e2) {
  var t3, n2, r2, o2;
  return n2 = new Cp({ props: { pointer: e2[53], key: e2[52], selection: e2[49], searchResultItems: gl(e2[54]), context: e2[6], onUpdateKey: e2[21] } }), { c() {
    t3 = ln("div"), sr(n2.$$.fragment), r2 = dn(), hn(t3, "slot", "identifier"), hn(t3, "class", "jse-key-outer svelte-1n9xu6u"), kn(t3, "jse-selected-key", ss(e2[49]) && isEqual_default(e2[49].path, e2[55]));
  }, m(e3, a2) {
    on(e3, t3, a2), lr(n2, t3, null), nn(t3, r2), o2 = true;
  }, p(e3, r3) {
    var a2 = {};
    515 & r3[0] && (a2.pointer = e3[53]), 514 & r3[0] && (a2.key = e3[52]), 738 & r3[0] && (a2.selection = e3[49]), 530 & r3[0] && (a2.searchResultItems = gl(e3[54])), 64 & r3[0] && (a2.context = e3[6]), n2.$set(a2), (!o2 || 131810 & r3[0]) && kn(t3, "jse-selected-key", ss(e3[49]) && isEqual_default(e3[49].path, e3[55]));
  }, i(e3) {
    o2 || (Xn(n2.$$.fragment, e3), o2 = true);
  }, o(e3) {
    Gn(n2.$$.fragment, e3), o2 = false;
  }, d(e3) {
    e3 && an(t3), cr(n2);
  } };
}
function hf(e2) {
  var t3, n2;
  return t3 = new Nf({ props: { value: e2[1][e2[52]], pointer: e2[53], state: wi(e2[2]) ? e2[2].properties[e2[52]] : void 0, validationErrors: e2[48], searchResults: e2[54], selection: e2[49], context: e2[6], onDragSelectionStart: e2[24], $$slots: { identifier: [mf] }, $$scope: { ctx: e2 } } }), { c() {
    sr(t3.$$.fragment);
  }, m(e3, r2) {
    lr(t3, e3, r2), n2 = true;
  }, p(e3, n3) {
    var r2 = {};
    514 & n3[0] && (r2.value = e3[1][e3[52]]), 515 & n3[0] && (r2.pointer = e3[53]), 518 & n3[0] && (r2.state = wi(e3[2]) ? e3[2].properties[e3[52]] : void 0), 522 & n3[0] && (r2.validationErrors = e3[48]), 530 & n3[0] && (r2.searchResults = e3[54]), 738 & n3[0] && (r2.selection = e3[49]), 64 & n3[0] && (r2.context = e3[6]), 755 & n3[0] | 4 & n3[1] && (r2.$$scope = { dirty: n3, ctx: e3 }), t3.$set(r2);
  }, i(e3) {
    n2 || (Xn(t3.$$.fragment, e3), n2 = true);
  }, o(e3) {
    Gn(t3.$$.fragment, e3), n2 = false;
  }, d(e3) {
    cr(t3, e3);
  } };
}
function gf(e2) {
  var t3, n2, r2;
  return { c() {
    hn(t3 = ln("div"), "role", "none"), hn(t3, "class", "jse-insert-selection-area jse-after svelte-1n9xu6u"), hn(t3, "data-type", "insert-selection-area-after");
  }, m(o2, a2) {
    on(o2, t3, a2), n2 || (r2 = pn(t3, "click", e2[28]), n2 = true);
  }, p: Bt, d(e3) {
    e3 && an(t3), n2 = false, r2();
  } };
}
function jf(e2) {
  var t3, n2;
  return t3 = new Ca({ props: { data: faCaretRight } }), { c() {
    sr(t3.$$.fragment);
  }, m(e3, r2) {
    lr(t3, e3, r2), n2 = true;
  }, i(e3) {
    n2 || (Xn(t3.$$.fragment, e3), n2 = true);
  }, o(e3) {
    Gn(t3.$$.fragment, e3), n2 = false;
  }, d(e3) {
    cr(t3, e3);
  } };
}
function xf(e2) {
  var t3, n2;
  return t3 = new Ca({ props: { data: faCaretDown } }), { c() {
    sr(t3.$$.fragment);
  }, m(e3, r2) {
    lr(t3, e3, r2), n2 = true;
  }, i(e3) {
    n2 || (Xn(t3.$$.fragment, e3), n2 = true);
  }, o(e3) {
    Gn(t3.$$.fragment, e3), n2 = false;
  }, d(e3) {
    cr(t3, e3);
  } };
}
function bf(e2) {
  var t3;
  return { c() {
    (t3 = ln("div")).textContent = ":", hn(t3, "class", "jse-separator svelte-1n9xu6u");
  }, m(e3, n2) {
    on(e3, t3, n2);
  }, d(e3) {
    e3 && an(t3);
  } };
}
function yf(e2) {
  var t3, n2, r2, o2, a2, i2, s2, l, c, u, d = e2[1].length + "", v = 1 === e2[1].length ? "item" : "items";
  return { c() {
    (t3 = ln("div")).textContent = "[", n2 = dn(), r2 = ln("button"), o2 = un(d), a2 = dn(), i2 = un(v), s2 = dn(), (l = ln("div")).textContent = "]", hn(t3, "class", "jse-bracket svelte-1n9xu6u"), hn(r2, "type", "button"), hn(r2, "class", "jse-tag svelte-1n9xu6u"), hn(l, "class", "jse-bracket svelte-1n9xu6u");
  }, m(d2, v2) {
    on(d2, t3, v2), on(d2, n2, v2), on(d2, r2, v2), nn(r2, o2), nn(r2, a2), nn(r2, i2), on(d2, s2, v2), on(d2, l, v2), c || (u = pn(r2, "click", e2[20]), c = true);
  }, p(e3, t4) {
    2 & t4[0] && d !== (d = e3[1].length + "") && yn(o2, d), 2 & t4[0] && v !== (v = 1 === e3[1].length ? "item" : "items") && yn(i2, v);
  }, d(e3) {
    e3 && (an(t3), an(n2), an(r2), an(s2), an(l)), c = false, u();
  } };
}
function $f(e2) {
  var t3, n2, r2, o2, a2, i2, s2, l = e2[1].length + "", c = 1 === e2[1].length ? "item" : "items";
  return { c() {
    (t3 = ln("div")).textContent = "[", n2 = dn(), r2 = ln("span"), o2 = un(l), a2 = dn(), i2 = un(c), s2 = un("\n               "), hn(t3, "class", "jse-bracket svelte-1n9xu6u"), hn(r2, "class", "jse-tag jse-expanded svelte-1n9xu6u");
  }, m(e3, l2) {
    on(e3, t3, l2), on(e3, n2, l2), on(e3, r2, l2), nn(r2, o2), nn(r2, a2), nn(r2, i2), on(e3, s2, l2);
  }, p(e3, t4) {
    2 & t4[0] && l !== (l = e3[1].length + "") && yn(o2, l), 2 & t4[0] && c !== (c = 1 === e3[1].length ? "item" : "items") && yn(i2, c);
  }, d(e3) {
    e3 && (an(t3), an(n2), an(r2), an(s2));
  } };
}
function wf(e2) {
  var t3, n2, r2;
  return n2 = new mp({ props: { root: e2[15], selected: true, onContextMenu: e2[6].onContextMenu } }), { c() {
    t3 = ln("div"), sr(n2.$$.fragment), hn(t3, "class", "jse-context-menu-pointer-anchor svelte-1n9xu6u");
  }, m(e3, o2) {
    on(e3, t3, o2), lr(n2, t3, null), r2 = true;
  }, p(e3, t4) {
    var r3 = {};
    32768 & t4[0] && (r3.root = e3[15]), 64 & t4[0] && (r3.onContextMenu = e3[6].onContextMenu), n2.$set(r3);
  }, i(e3) {
    r2 || (Xn(n2.$$.fragment, e3), r2 = true);
  }, o(e3) {
    Gn(n2.$$.fragment, e3), r2 = false;
  }, d(e3) {
    e3 && an(t3), cr(n2);
  } };
}
function Cf(e2) {
  var t3, n2;
  return t3 = new Fp({ props: { validationError: e2[13], onExpand: e2[20] } }), { c() {
    sr(t3.$$.fragment);
  }, m(e3, r2) {
    lr(t3, e3, r2), n2 = true;
  }, p(e3, n3) {
    var r2 = {};
    8192 & n3[0] && (r2.validationError = e3[13]), t3.$set(r2);
  }, i(e3) {
    n2 || (Xn(t3.$$.fragment, e3), n2 = true);
  }, o(e3) {
    Gn(t3.$$.fragment, e3), n2 = false;
  }, d(e3) {
    cr(t3, e3);
  } };
}
function kf(e2) {
  var t3, n2, r2;
  return { c() {
    hn(t3 = ln("div"), "role", "none"), hn(t3, "class", "jse-insert-selection-area jse-after svelte-1n9xu6u"), hn(t3, "data-type", "insert-selection-area-after");
  }, m(o2, a2) {
    on(o2, t3, a2), n2 || (r2 = pn(t3, "click", e2[28]), n2 = true);
  }, p: Bt, d(e3) {
    e3 && an(t3), n2 = false, r2();
  } };
}
function Sf(e2) {
  var t3, n2, r2;
  return { c() {
    hn(t3 = ln("div"), "role", "none"), hn(t3, "class", "jse-insert-selection-area jse-inside svelte-1n9xu6u"), hn(t3, "data-type", "insert-selection-area-inside");
  }, m(o2, a2) {
    on(o2, t3, a2), n2 || (r2 = pn(t3, "click", e2[27]), n2 = true);
  }, p: Bt, d(e3) {
    e3 && an(t3), n2 = false, r2();
  } };
}
function Of(e2) {
  for (var t3, n2, r2, o2, a2, i2, s2, l = !e2[6].readOnly && (e2[8] === Xa || e2[14] && is(e2[5])), c = [], u = /* @__PURE__ */ new Map(), d = l && zf(e2), v = er(e2[12] || Ha), p = (e3) => e3[46], f = 0; f < v.length; f += 1) {
    var m3 = _p(e2, v, f), h2 = p(m3);
    u.set(h2, c[f] = Ef(h2, m3));
  }
  var g = !e2[15] && Pf(e2);
  return { c() {
    t3 = ln("div"), d && d.c(), n2 = dn();
    for (var e3 = 0; e3 < c.length; e3 += 1) c[e3].c();
    r2 = dn(), o2 = ln("div"), (a2 = ln("div")).innerHTML = '<span class="jse-bracket svelte-1n9xu6u">]</span>', i2 = dn(), g && g.c(), hn(t3, "class", "jse-items svelte-1n9xu6u"), hn(a2, "data-type", "selectable-value"), hn(a2, "class", "jse-footer svelte-1n9xu6u"), hn(o2, "class", "jse-footer-outer svelte-1n9xu6u");
  }, m(e3, l2) {
    on(e3, t3, l2), d && d.m(t3, null), nn(t3, n2);
    for (var u2 = 0; u2 < c.length; u2 += 1) c[u2] && c[u2].m(t3, null);
    on(e3, r2, l2), on(e3, o2, l2), nn(o2, a2), nn(o2, i2), g && g.m(o2, null), s2 = true;
  }, p(e3, r3) {
    16736 & r3[0] && (l = !e3[6].readOnly && (e3[8] === Xa || e3[14] && is(e3[5]))), l ? d ? (d.p(e3, r3), 16736 & r3[0] && Xn(d, 1)) : ((d = zf(e3)).c(), Xn(d, 1), d.m(t3, n2)) : d && (Kn(), Gn(d, 1, 1, () => {
      d = null;
    }), Zn()), 17044223 & r3[0] && (v = er(e3[12] || Ha), Kn(), c = rr(c, r3, p, 0, e3, v, u, t3, nr, Ef, null, _p), Zn()), e3[15] ? g && (g.d(1), g = null) : g ? g.p(e3, r3) : ((g = Pf(e3)).c(), g.m(o2, null));
  }, i(e3) {
    if (!s2) {
      Xn(d);
      for (var t4 = 0; t4 < v.length; t4 += 1) Xn(c[t4]);
      s2 = true;
    }
  }, o(e3) {
    Gn(d);
    for (var t4 = 0; t4 < c.length; t4 += 1) Gn(c[t4]);
    s2 = false;
  }, d(e3) {
    e3 && (an(t3), an(r2), an(o2)), d && d.d();
    for (var n3 = 0; n3 < c.length; n3 += 1) c[n3].d();
    g && g.d();
  } };
}
function zf(e2) {
  var t3, n2, r2;
  return n2 = new mp({ props: { insert: true, selected: e2[14] && is(e2[5]), onContextMenu: e2[29] } }), { c() {
    t3 = ln("div"), sr(n2.$$.fragment), hn(t3, "class", "jse-insert-area jse-inside svelte-1n9xu6u"), hn(t3, "data-type", "insert-selection-area-inside"), hn(t3, "title", Ka), kn(t3, "jse-hovered", e2[8] === Xa), kn(t3, "jse-selected", e2[14] && is(e2[5])), wn(t3, "--level", e2[7].length + 1);
  }, m(e3, o2) {
    on(e3, t3, o2), lr(n2, t3, null), r2 = true;
  }, p(e3, o2) {
    var a2 = {};
    16416 & o2[0] && (a2.selected = e3[14] && is(e3[5])), n2.$set(a2), (!r2 || 256 & o2[0]) && kn(t3, "jse-hovered", e3[8] === Xa), (!r2 || 16416 & o2[0]) && kn(t3, "jse-selected", e3[14] && is(e3[5])), 128 & o2[0] && wn(t3, "--level", e3[7].length + 1);
  }, i(e3) {
    r2 || (Xn(n2.$$.fragment, e3), r2 = true);
  }, o(e3) {
    Gn(n2.$$.fragment, e3), r2 = false;
  }, d(e3) {
    e3 && an(t3), cr(n2);
  } };
}
function qf(e2) {
  var t3, n2, r2, o2 = e2[47].gutterIndex + "";
  return { c() {
    t3 = ln("div"), n2 = ln("div"), r2 = un(o2), hn(n2, "class", "jse-index svelte-1n9xu6u"), hn(t3, "slot", "identifier"), hn(t3, "class", "jse-identifier svelte-1n9xu6u");
  }, m(e3, o3) {
    on(e3, t3, o3), nn(t3, n2), nn(n2, r2);
  }, p(e3, t4) {
    4610 & t4[0] && o2 !== (o2 = e3[47].gutterIndex + "") && yn(r2, o2);
  }, d(e3) {
    e3 && an(t3);
  } };
}
function Mf(e2, t3) {
  var n2, r2, o2;
  return r2 = new Nf({ props: { value: t3[1][t3[47].index], pointer: appendToJSONPointer(t3[0], t3[47].index), state: Ci(t3[2]) ? t3[2].items[t3[47].index] : void 0, validationErrors: t3[48], searchResults: Ci(t3[4]) ? t3[4].items[t3[47].index] : void 0, selection: t3[49], context: t3[6], onDragSelectionStart: t3[24], $$slots: { identifier: [qf] }, $$scope: { ctx: t3 } } }), { key: e2, first: null, c() {
    n2 = vn(), sr(r2.$$.fragment), this.first = n2;
  }, m(e3, t4) {
    on(e3, n2, t4), lr(r2, e3, t4), o2 = true;
  }, p(e3, n3) {
    t3 = e3;
    var o3 = {};
    4610 & n3[0] && (o3.value = t3[1][t3[47].index]), 4611 & n3[0] && (o3.pointer = appendToJSONPointer(t3[0], t3[47].index)), 4614 & n3[0] && (o3.state = Ci(t3[2]) ? t3[2].items[t3[47].index] : void 0), 4618 & n3[0] && (o3.validationErrors = t3[48]), 4626 & n3[0] && (o3.searchResults = Ci(t3[4]) ? t3[4].items[t3[47].index] : void 0), 4834 & n3[0] && (o3.selection = t3[49]), 64 & n3[0] && (o3.context = t3[6]), 4610 & n3[0] | 4 & n3[1] && (o3.$$scope = { dirty: n3, ctx: t3 }), r2.$set(o3);
  }, i(e3) {
    o2 || (Xn(r2.$$.fragment, e3), o2 = true);
  }, o(e3) {
    Gn(r2.$$.fragment, e3), o2 = false;
  }, d(e3) {
    e3 && an(n2), cr(r2, e3);
  } };
}
function Rf(e2) {
  var t3, n2;
  return t3 = new dp({ props: { visibleSections: e2[12] || Ha, sectionIndex: e2[46], total: e2[1].length, path: e2[7], onExpandSection: e2[6].onExpandSection, selection: e2[5], context: e2[6] } }), { c() {
    sr(t3.$$.fragment);
  }, m(e3, r2) {
    lr(t3, e3, r2), n2 = true;
  }, p(e3, n3) {
    var r2 = {};
    4096 & n3[0] && (r2.visibleSections = e3[12] || Ha), 4096 & n3[0] && (r2.sectionIndex = e3[46]), 2 & n3[0] && (r2.total = e3[1].length), 128 & n3[0] && (r2.path = e3[7]), 64 & n3[0] && (r2.onExpandSection = e3[6].onExpandSection), 32 & n3[0] && (r2.selection = e3[5]), 64 & n3[0] && (r2.context = e3[6]), t3.$set(r2);
  }, i(e3) {
    n2 || (Xn(t3.$$.fragment, e3), n2 = true);
  }, o(e3) {
    Gn(t3.$$.fragment, e3), n2 = false;
  }, d(e3) {
    cr(t3, e3);
  } };
}
function Ef(e2, t3) {
  for (var n2, r2, o2, a2, i2 = [], s2 = /* @__PURE__ */ new Map(), l = er(t3[18](t3[1], t3[44], t3[9])), c = (e3) => e3[47].index, u = 0; u < l.length; u += 1) {
    var d = Wp(t3, l, u), v = c(d);
    s2.set(v, i2[u] = Mf(v, d));
  }
  var p = t3[44].end < t3[1].length && Rf(t3);
  return { key: e2, first: null, c() {
    n2 = vn();
    for (var e3 = 0; e3 < i2.length; e3 += 1) i2[e3].c();
    r2 = dn(), p && p.c(), o2 = vn(), this.first = n2;
  }, m(e3, t4) {
    on(e3, n2, t4);
    for (var s3 = 0; s3 < i2.length; s3 += 1) i2[s3] && i2[s3].m(e3, t4);
    on(e3, r2, t4), p && p.m(e3, t4), on(e3, o2, t4), a2 = true;
  }, p(e3, n3) {
    t3 = e3, 17044223 & n3[0] && (l = er(t3[18](t3[1], t3[44], t3[9])), Kn(), i2 = rr(i2, n3, c, 0, t3, l, s2, r2.parentNode, nr, Mf, r2, Wp), Zn()), t3[44].end < t3[1].length ? p ? (p.p(t3, n3), 4098 & n3[0] && Xn(p, 1)) : ((p = Rf(t3)).c(), Xn(p, 1), p.m(o2.parentNode, o2)) : p && (Kn(), Gn(p, 1, 1, () => {
      p = null;
    }), Zn());
  }, i(e3) {
    if (!a2) {
      for (var t4 = 0; t4 < l.length; t4 += 1) Xn(i2[t4]);
      Xn(p), a2 = true;
    }
  }, o(e3) {
    for (var t4 = 0; t4 < i2.length; t4 += 1) Gn(i2[t4]);
    Gn(p), a2 = false;
  }, d(e3) {
    e3 && (an(n2), an(r2), an(o2));
    for (var t4 = 0; t4 < i2.length; t4 += 1) i2[t4].d(e3);
    p && p.d(e3);
  } };
}
function Pf(e2) {
  var t3, n2, r2;
  return { c() {
    hn(t3 = ln("div"), "role", "none"), hn(t3, "class", "jse-insert-selection-area jse-after svelte-1n9xu6u"), hn(t3, "data-type", "insert-selection-area-after");
  }, m(o2, a2) {
    on(o2, t3, a2), n2 || (r2 = pn(t3, "click", e2[28]), n2 = true);
  }, p: Bt, d(e3) {
    e3 && an(t3), n2 = false, r2();
  } };
}
function If(e2) {
  var t3, n2, r2;
  return n2 = new mp({ props: { insert: true, selected: e2[14] && as(e2[5]), onContextMenu: e2[30] } }), { c() {
    t3 = ln("div"), sr(n2.$$.fragment), hn(t3, "class", "jse-insert-area jse-after svelte-1n9xu6u"), hn(t3, "data-type", "insert-selection-area-after"), hn(t3, "title", Ka), kn(t3, "jse-hovered", e2[8] === Ga), kn(t3, "jse-selected", e2[14] && as(e2[5]));
  }, m(e3, o2) {
    on(e3, t3, o2), lr(n2, t3, null), r2 = true;
  }, p(e3, o2) {
    var a2 = {};
    16416 & o2[0] && (a2.selected = e3[14] && as(e3[5])), n2.$set(a2), (!r2 || 256 & o2[0]) && kn(t3, "jse-hovered", e3[8] === Ga), (!r2 || 16416 & o2[0]) && kn(t3, "jse-selected", e3[14] && as(e3[5]));
  }, i(e3) {
    r2 || (Xn(n2.$$.fragment, e3), r2 = true);
  }, o(e3) {
    Gn(n2.$$.fragment, e3), r2 = false;
  }, d(e3) {
    e3 && an(t3), cr(n2);
  } };
}
function Tf(e2) {
  var t3, n2, r2, o2, a2, i2, s2, l, c, u, d = !e2[6].readOnly && (e2[8] === Ga || e2[14] && as(e2[5])), v = [Xp, Zp, Kp], p = [];
  function f(e3, t4) {
    return 2 & t4[0] && (n2 = null), 2 & t4[0] && (r2 = null), null == n2 && (n2 = !!Array.isArray(e3[1])), n2 ? 0 : (null == r2 && (r2 = !!br(e3[1])), r2 ? 1 : 2);
  }
  o2 = f(e2, [-1, -1]), a2 = p[o2] = v[o2](e2);
  var m3 = d && If(e2);
  return { c() {
    t3 = ln("div"), a2.c(), i2 = dn(), m3 && m3.c(), hn(t3, "role", "treeitem"), hn(t3, "tabindex", "-1"), hn(t3, "class", s2 = Gt(Vs("jse-json-node", { "jse-expanded": e2[10] }, e2[6].onClassName(e2[7], e2[1]))) + " svelte-1n9xu6u"), hn(t3, "data-path", e2[16]), hn(t3, "aria-selected", e2[14]), kn(t3, "jse-root", e2[15]), kn(t3, "jse-selected", e2[14] && cs(e2[5])), kn(t3, "jse-selected-value", e2[14] && ls(e2[5])), kn(t3, "jse-readonly", e2[6].readOnly), kn(t3, "jse-hovered", e2[8] === ei), wn(t3, "--level", e2[7].length);
  }, m(n3, r3) {
    on(n3, t3, r3), p[o2].m(t3, null), nn(t3, i2), m3 && m3.m(t3, null), l = true, c || (u = [pn(t3, "mousedown", e2[22]), pn(t3, "mousemove", e2[23]), pn(t3, "mouseover", e2[25]), pn(t3, "mouseout", e2[26]), pn(t3, "focus", void 0), pn(t3, "blur", void 0)], c = true);
  }, p(e3, n3) {
    var r3 = o2;
    (o2 = f(e3, n3)) === r3 ? p[o2].p(e3, n3) : (Kn(), Gn(p[r3], 1, 1, () => {
      p[r3] = null;
    }), Zn(), (a2 = p[o2]) ? a2.p(e3, n3) : (a2 = p[o2] = v[o2](e3)).c(), Xn(a2, 1), a2.m(t3, i2)), 16736 & n3[0] && (d = !e3[6].readOnly && (e3[8] === Ga || e3[14] && as(e3[5]))), d ? m3 ? (m3.p(e3, n3), 16736 & n3[0] && Xn(m3, 1)) : ((m3 = If(e3)).c(), Xn(m3, 1), m3.m(t3, null)) : m3 && (Kn(), Gn(m3, 1, 1, () => {
      m3 = null;
    }), Zn()), (!l || 1218 & n3[0] && s2 !== (s2 = Gt(Vs("jse-json-node", { "jse-expanded": e3[10] }, e3[6].onClassName(e3[7], e3[1]))) + " svelte-1n9xu6u")) && hn(t3, "class", s2), (!l || 65536 & n3[0]) && hn(t3, "data-path", e3[16]), (!l || 16384 & n3[0]) && hn(t3, "aria-selected", e3[14]), (!l || 33986 & n3[0]) && kn(t3, "jse-root", e3[15]), (!l || 17634 & n3[0]) && kn(t3, "jse-selected", e3[14] && cs(e3[5])), (!l || 17634 & n3[0]) && kn(t3, "jse-selected-value", e3[14] && ls(e3[5])), (!l || 1218 & n3[0]) && kn(t3, "jse-readonly", e3[6].readOnly), (!l || 1474 & n3[0]) && kn(t3, "jse-hovered", e3[8] === ei), 128 & n3[0] && wn(t3, "--level", e3[7].length);
  }, i(e3) {
    l || (Xn(a2), Xn(m3), l = true);
  }, o(e3) {
    Gn(a2), Gn(m3), l = false;
  }, d(e3) {
    e3 && an(t3), p[o2].d(), m3 && m3.d(), c = false, Dt(u);
  } };
}
function Af(e2, t3, n2) {
  var r2, o2, a2, s2, c, u, d, v, { $$slots: p = {}, $$scope: f } = t3, { pointer: m3 } = t3, { value: h2 } = t3, { state: g } = t3, { validationErrors: j } = t3, { searchResults: x } = t3, { selection: b2 } = t3, { context: y } = t3, { onDragSelectionStart: $2 } = t3, w = vr("jsoneditor:JSONNode"), C3 = void 0, k2 = void 0, S4 = void 0;
  function O(e3) {
    y.onDrag(e3);
  }
  function z3(e3) {
    Ip.selecting && (Ip.selecting = false, e3.stopPropagation()), y.onDragEnd(), document.removeEventListener("mousemove", O, true), document.removeEventListener("mouseup", z3);
  }
  function q2() {
    var e3;
    return (null === (e3 = y.findElement([])) || void 0 === e3 || null === (e3 = e3.getBoundingClientRect()) || void 0 === e3 ? void 0 : e3.top) || 0;
  }
  function M3(e3, t4) {
    var n3 = q2() - e3.initialContentTop;
    return t4.clientY - e3.initialClientY - n3;
  }
  function R3(e3) {
    if (S4) {
      var t4 = y.getJson();
      if (void 0 === t4) return;
      var r3 = M3(S4, e3), { offset: o3 } = Tp({ json: t4, selection: y.getSelection(), deltaY: r3, items: S4.items });
      o3 !== S4.offset && (w("drag selection", o3, r3), n2(9, S4 = i(i({}, S4), {}, { offset: o3, didMoveItems: true })));
    }
  }
  function T3(e3) {
    if (S4) {
      var t4 = y.getJson();
      if (void 0 === t4) return;
      var r3 = M3(S4, e3), { operations: o3, updatedSelection: a3 } = Tp({ json: t4, selection: y.getSelection(), deltaY: r3, items: S4.items });
      if (o3) y.onPatch(o3, (e4, t5) => ({ state: t5, selection: null != a3 ? a3 : b2 }));
      else if (e3.target === S4.initialTarget && !S4.didMoveItems) {
        var i2 = No(e3.target), s3 = Fo(e3.target);
        s3 && y.onSelect(Bs(i2, s3));
      }
      n2(9, S4 = void 0), Ip.dragging = false, document.removeEventListener("mousemove", R3, true), document.removeEventListener("mouseup", T3);
    }
  }
  return e2.$$set = (e3) => {
    "pointer" in e3 && n2(0, m3 = e3.pointer), "value" in e3 && n2(1, h2 = e3.value), "state" in e3 && n2(2, g = e3.state), "validationErrors" in e3 && n2(3, j = e3.validationErrors), "searchResults" in e3 && n2(4, x = e3.searchResults), "selection" in e3 && n2(5, b2 = e3.selection), "context" in e3 && n2(6, y = e3.context), "onDragSelectionStart" in e3 && n2(31, $2 = e3.onDragSelectionStart), "$$scope" in e3 && n2(33, f = e3.$$scope);
  }, e2.$$.update = () => {
    var t4;
    (1 & e2.$$.dirty[0] && n2(7, a2 = parseJSONPointer(m3)), 1 & e2.$$.dirty[0] && n2(16, r2 = encodeURIComponent(m3)), 4 & e2.$$.dirty[0] && n2(10, s2 = !!Si(g) && g.expanded), 6 & e2.$$.dirty[0] && n2(11, c = Yi(h2, g, [])), 4 & e2.$$.dirty[0] && n2(12, u = Ci(g) ? g.visibleSections : void 0), 8 & e2.$$.dirty[0]) && n2(13, d = null === (t4 = j) || void 0 === t4 ? void 0 : t4.validationError);
    224 & e2.$$.dirty[0] && n2(14, v = Us(y.getJson(), b2, a2)), 128 & e2.$$.dirty[0] && n2(15, o2 = 0 === a2.length);
  }, [m3, h2, g, j, x, b2, y, a2, C3, S4, s2, c, u, d, v, o2, r2, function(e3, t4) {
    var n3 = Object.keys(e3);
    return t4 && 0 !== t4.offset ? Lr(n3, t4.selectionStartIndex, t4.selectionItemsCount, t4.offset) : n3;
  }, function(e3, t4, n3) {
    var r3 = t4.start, o3 = Math.min(t4.end, e3.length), a3 = range_default(r3, o3);
    return n3 && 0 !== n3.offset ? Lr(a3, n3.selectionStartIndex, n3.selectionItemsCount, n3.offset).map((e4, t5) => ({ index: e4, gutterIndex: t5 })) : a3.map((e4) => ({ index: e4, gutterIndex: e4 }));
  }, function(e3) {
    e3.stopPropagation();
    var t4 = Jo(e3);
    y.onExpand(a2, !s2, t4);
  }, function(e3) {
    e3.stopPropagation(), y.onExpand(a2, true);
  }, function(e3, t4) {
    var n3 = tl(a2, Object.keys(h2), e3, t4);
    return y.onPatch(n3), last_default(parseJSONPointer(n3[0].path));
  }, function(e3) {
    if ((1 === e3.buttons || 2 === e3.buttons) && !(function(e4) {
      return "DIV" === e4.nodeName && "true" === e4.contentEditable;
    }(e3.target) || 1 === e3.buttons && Mo(e3.target, "BUTTON"))) {
      e3.stopPropagation(), e3.preventDefault(), y.focus(), document.addEventListener("mousemove", O, true), document.addEventListener("mouseup", z3);
      var t4 = No(e3.target), n3 = y.getJson(), r3 = y.getDocumentState();
      if (!b2 || t4 === uo.after || t4 === uo.inside || b2.type !== t4 && b2.type !== uo.multi || !Us(n3, b2, a2)) if (Ip.selecting = true, Ip.selectionAnchor = a2, Ip.selectionAnchorType = t4, Ip.selectionFocus = a2, e3.shiftKey) {
        var i2 = y.getSelection();
        i2 && y.onSelect(Es(Js(i2), a2));
      } else if (t4 === uo.multi) if (o2 && e3.target.hasAttribute("data-path")) {
        var s3 = last_default(Xi(h2, r3));
        y.onSelect(Ns(s3));
      } else y.onSelect(Es(a2, a2));
      else void 0 !== n3 && y.onSelect(Bs(t4, a2));
      else 0 === e3.button && $2(e3);
    }
  }, function(e3) {
    if (Ip.selecting) {
      e3.preventDefault(), e3.stopPropagation(), void 0 === Ip.selectionFocus && window.getSelection && window.getSelection().empty();
      var t4 = No(e3.target);
      isEqual_default(a2, Ip.selectionFocus) && t4 === Ip.selectionAnchorType || (Ip.selectionFocus = a2, Ip.selectionAnchorType = t4, y.onSelect(Es(Ip.selectionAnchor || Ip.selectionFocus, Ip.selectionFocus)));
    }
  }, function(e3) {
    if (!y.readOnly && b2) {
      var t4 = initial_default(Ds(b2));
      if (isEqual_default(a2, t4)) {
        var r3 = function(e4, t5) {
          var n3 = [];
          function r4(e5) {
            var t6 = a2.concat(e5), r5 = y.findElement(t6);
            void 0 !== r5 && n3.push({ path: t6, height: r5.clientHeight });
          }
          if (Array.isArray(h2)) {
            var o4 = y.getJson();
            if (void 0 === o4) return;
            var i3 = ms(o4, e4), s4 = hs(o4, e4), l2 = parseInt(last_default(i3), 10), c2 = parseInt(last_default(s4), 10), u2 = t5.find((e5) => l2 >= e5.start && c2 <= e5.end);
            if (!u2) return;
            var { start: d2, end: v2 } = u2;
            Nr(d2, Math.min(h2.length, v2), (e5) => r4(String(e5)));
          } else Object.keys(h2).forEach(r4);
          return n3;
        }(b2, u || Ha);
        if (w("dragSelectionStart", { selection: b2, items: r3 }), r3) {
          var o3 = y.getJson();
          if (void 0 !== o3) {
            var i2 = ms(o3, b2), s3 = r3.findIndex((e4) => isEqual_default(e4.path, i2)), { offset: l } = Tp({ json: o3, selection: y.getSelection(), deltaY: 0, items: r3 });
            n2(9, S4 = { initialTarget: e3.target, initialClientY: e3.clientY, initialContentTop: q2(), selectionStartIndex: s3, selectionItemsCount: ps(o3, b2).length, items: r3, offset: l, didMoveItems: false }), Ip.dragging = true, document.addEventListener("mousemove", R3, true), document.addEventListener("mouseup", T3);
          }
        } else w("Cannot drag the current selection (probably spread over multiple sections)");
      } else $2(e3);
    }
  }, function(e3) {
    Ip.selecting || Ip.dragging || (e3.stopPropagation(), Ro(e3.target, "data-type", "selectable-value") ? n2(8, C3 = ei) : Ro(e3.target, "data-type", "selectable-key") ? n2(8, C3 = void 0) : Ro(e3.target, "data-type", "insert-selection-area-inside") ? n2(8, C3 = Xa) : Ro(e3.target, "data-type", "insert-selection-area-after") && n2(8, C3 = Ga), clearTimeout(k2));
  }, function(e3) {
    e3.stopPropagation(), k2 = window.setTimeout(() => n2(8, C3 = void 0));
  }, function(e3) {
    e3.shiftKey || (e3.stopPropagation(), e3.preventDefault(), y.onSelect(Ms(a2)));
  }, function(e3) {
    e3.shiftKey || (e3.stopPropagation(), e3.preventDefault(), y.onSelect(Rs(a2)));
  }, function(e3) {
    y.onSelect(Ms(a2)), y.onContextMenu(e3);
  }, function(e3) {
    y.onSelect(Rs(a2)), y.onContextMenu(e3);
  }, $2, p, f];
}
var Nf = class extends dr {
  constructor(e2) {
    super(), ur(this, e2, Af, Tf, Ht, { pointer: 0, value: 1, state: 2, validationErrors: 3, searchResults: 4, selection: 5, context: 6, onDragSelectionStart: 31 }, Up, [-1, -1]);
  }
};
var Bf = { prefix: "fas", iconName: "jsoneditor-expand", icon: [512, 512, [], "", "M 0,448 V 512 h 512 v -64 z M 0,0 V 64 H 512 V 0 Z M 256,96 128,224 h 256 z M 256,416 384,288 H 128 Z"] };
var Ff = { prefix: "fas", iconName: "jsoneditor-collapse", icon: [512, 512, [], "", "m 0,224 v 64 h 512 v -64 z M 256,192 384,64 H 128 Z M 256,320 128,448 h 256 z"] };
var Uf = { prefix: "fas", iconName: "jsoneditor-format", icon: [512, 512, [], "", "M 0,32 v 64 h 416 v -64 z M 160,160 v 64 h 352 v -64 z M 160,288 v 64 h 288 v -64 z M 0,416 v 64 h 320 v -64 z"] };
var Lf = { prefix: "fas", iconName: "jsoneditor-compact", icon: [512, 512, [], "", "M 0,32 v 64 h 512 v -64 z M 0,160 v 64 h 512 v -64 z M 0,288 v 64 h 352 v -64 z"] };
function Df(e2) {
  var t3, n2;
  return t3 = new Wv({ props: { items: e2[0] } }), { c() {
    sr(t3.$$.fragment);
  }, m(e3, r2) {
    lr(t3, e3, r2), n2 = true;
  }, p(e3, n3) {
    var [r2] = n3, o2 = {};
    1 & r2 && (o2.items = e3[0]), t3.$set(o2);
  }, i(e3) {
    n2 || (Xn(t3.$$.fragment, e3), n2 = true);
  }, o(e3) {
    Gn(t3.$$.fragment, e3), n2 = false;
  }, d(e3) {
    cr(t3, e3);
  } };
}
function Jf(e2, t3, n2) {
  var r2, o2, a2, i2, s2, l, c, { json: u } = t3, { selection: d } = t3, { readOnly: v } = t3, { showSearch: p = false } = t3, { historyState: f } = t3, { onExpandAll: m3 } = t3, { onCollapseAll: h2 } = t3, { onUndo: g } = t3, { onRedo: j } = t3, { onSort: x } = t3, { onTransform: b2 } = t3, { onContextMenu: y } = t3, { onCopy: $2 } = t3, { onRenderMenu: w } = t3;
  function C3() {
    n2(1, p = !p);
  }
  return e2.$$set = (e3) => {
    "json" in e3 && n2(2, u = e3.json), "selection" in e3 && n2(3, d = e3.selection), "readOnly" in e3 && n2(4, v = e3.readOnly), "showSearch" in e3 && n2(1, p = e3.showSearch), "historyState" in e3 && n2(5, f = e3.historyState), "onExpandAll" in e3 && n2(6, m3 = e3.onExpandAll), "onCollapseAll" in e3 && n2(7, h2 = e3.onCollapseAll), "onUndo" in e3 && n2(8, g = e3.onUndo), "onRedo" in e3 && n2(9, j = e3.onRedo), "onSort" in e3 && n2(10, x = e3.onSort), "onTransform" in e3 && n2(11, b2 = e3.onTransform), "onContextMenu" in e3 && n2(12, y = e3.onContextMenu), "onCopy" in e3 && n2(13, $2 = e3.onCopy), "onRenderMenu" in e3 && n2(14, w = e3.onRenderMenu);
  }, e2.$$.update = () => {
    4 & e2.$$.dirty && n2(20, r2 = void 0 !== u), 1048584 & e2.$$.dirty && n2(19, o2 = r2 && (cs(d) || ss(d) || ls(d))), 68 & e2.$$.dirty && n2(15, i2 = { type: "button", icon: Bf, title: "Expand all", className: "jse-expand-all", onClick: m3, disabled: !yr(u) }), 132 & e2.$$.dirty && n2(16, s2 = { type: "button", icon: Ff, title: "Collapse all", className: "jse-collapse-all", onClick: h2, disabled: !yr(u) }), 4 & e2.$$.dirty && n2(17, l = { type: "button", icon: faSearch, title: "Search (Ctrl+F)", className: "jse-search", onClick: C3, disabled: void 0 === u }), 769844 & e2.$$.dirty && n2(18, c = v ? [i2, s2, { type: "separator" }, { type: "button", icon: faCopy, title: "Copy (Ctrl+C)", className: "jse-copy", onClick: $2, disabled: !o2 }, { type: "separator" }, l, { type: "space" }] : [i2, s2, { type: "separator" }, { type: "button", icon: faSortAmountDownAlt, title: "Sort", className: "jse-sort", onClick: x, disabled: v || void 0 === u }, { type: "button", icon: faFilter, title: "Transform contents (filter, sort, project)", className: "jse-transform", onClick: b2, disabled: v || void 0 === u }, l, { type: "button", icon: faEllipsisV, title: Za, className: "jse-contextmenu", onClick: y }, { type: "separator" }, { type: "button", icon: faUndo, title: "Undo (Ctrl+Z)", className: "jse-undo", onClick: g, disabled: !f.canUndo }, { type: "button", icon: faRedo, title: "Redo (Ctrl+Shift+Z)", className: "jse-redo", onClick: j, disabled: !f.canRedo }, { type: "space" }]), 278528 & e2.$$.dirty && n2(0, a2 = w(c) || c);
  }, [a2, p, u, d, v, f, m3, h2, g, j, x, b2, y, $2, w, i2, s2, l, c, o2, r2];
}
var Vf = class extends dr {
  constructor(e2) {
    super(), ur(this, e2, Jf, Df, Ht, { json: 2, selection: 3, readOnly: 4, showSearch: 1, historyState: 5, onExpandAll: 6, onCollapseAll: 7, onUndo: 8, onRedo: 9, onSort: 10, onTransform: 11, onContextMenu: 12, onCopy: 13, onRenderMenu: 14 });
  }
};
function Hf(e2) {
  rn(e2, "svelte-1eamlhk", '.jse-welcome.svelte-1eamlhk.svelte-1eamlhk{flex:1;overflow:auto;font-family:var(--jse-font-family, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif);font-size:var(--jse-font-size, 16px);display:flex;flex-direction:column;align-items:center;border-left:var(--jse-main-border, 1px solid #d7d7d7);border-right:var(--jse-main-border, 1px solid #d7d7d7)}.jse-welcome.svelte-1eamlhk.svelte-1eamlhk:last-child{border-bottom:var(--jse-main-border, 1px solid #d7d7d7)}.jse-welcome.svelte-1eamlhk .jse-space.jse-before.svelte-1eamlhk{flex:1}.jse-welcome.svelte-1eamlhk .jse-space.jse-after.svelte-1eamlhk{flex:2}.jse-welcome.svelte-1eamlhk .jse-contents.svelte-1eamlhk{display:flex;flex-direction:column;max-width:300px;margin:2em var(--jse-padding, 10px);gap:var(--jse-padding, 10px)}.jse-welcome.svelte-1eamlhk .jse-contents .jse-welcome-info.svelte-1eamlhk{color:var(--jse-panel-color-readonly, #b2b2b2)}.jse-welcome.svelte-1eamlhk .jse-contents button.svelte-1eamlhk{border:none;background:transparent;color:inherit;cursor:pointer;font-family:var(--jse-font-family, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif);font-size:var(--jse-font-size, 16px);padding:5px;margin:0;background:var(--jse-button-primary-background, var(--jse-theme-color, #3883fa));color:var(--jse-button-primary-color, #fff);padding:var(--jse-padding, 10px) calc(2 * var(--jse-padding, 10px));border-radius:3px}.jse-welcome.svelte-1eamlhk .jse-contents button.svelte-1eamlhk:hover{background:var(--jse-button-primary-background-highlight, var(--jse-theme-color-highlight, #5f9dff))}.jse-welcome.svelte-1eamlhk .jse-contents button.svelte-1eamlhk:disabled{background:var(--jse-button-primary-background-disabled, #9d9d9d)}');
}
function _f(e2) {
  var t3, n2, r2, o2, a2, i2, s2;
  return { c() {
    (t3 = ln("div")).innerHTML = "You can paste clipboard data using <b>Ctrl+V</b>, or use the following options:", n2 = dn(), (r2 = ln("button")).textContent = "Create object", o2 = dn(), (a2 = ln("button")).textContent = "Create array", hn(t3, "class", "jse-welcome-info svelte-1eamlhk"), hn(r2, "title", "Create an empty JSON object (press '{')"), hn(r2, "class", "svelte-1eamlhk"), hn(a2, "title", "Create an empty JSON array (press '[')"), hn(a2, "class", "svelte-1eamlhk");
  }, m(l, c) {
    on(l, t3, c), on(l, n2, c), on(l, r2, c), on(l, o2, c), on(l, a2, c), i2 || (s2 = [pn(r2, "click", mn(e2[4])), pn(a2, "click", mn(e2[5]))], i2 = true);
  }, p: Bt, d(e3) {
    e3 && (an(t3), an(n2), an(r2), an(o2), an(a2)), i2 = false, Dt(s2);
  } };
}
function Wf(e2) {
  var t3, n2, r2, o2, a2, i2, s2, l, c, u, d = !e2[0] && _f(e2);
  return { c() {
    t3 = ln("div"), n2 = ln("div"), r2 = dn(), o2 = ln("div"), (a2 = ln("div")).textContent = "Empty document", i2 = dn(), d && d.c(), s2 = dn(), l = ln("div"), hn(n2, "class", "jse-space jse-before svelte-1eamlhk"), hn(a2, "class", "jse-welcome-title"), hn(o2, "class", "jse-contents svelte-1eamlhk"), hn(l, "class", "jse-space jse-after svelte-1eamlhk"), hn(t3, "class", "jse-welcome svelte-1eamlhk"), hn(t3, "role", "none");
  }, m(v, p) {
    on(v, t3, p), nn(t3, n2), nn(t3, r2), nn(t3, o2), nn(o2, a2), nn(o2, i2), d && d.m(o2, null), nn(t3, s2), nn(t3, l), c || (u = pn(t3, "click", e2[6]), c = true);
  }, p(e3, t4) {
    var [n3] = t4;
    e3[0] ? d && (d.d(1), d = null) : d ? d.p(e3, n3) : ((d = _f(e3)).c(), d.m(o2, null));
  }, i: Bt, o: Bt, d(e3) {
    e3 && an(t3), d && d.d(), c = false, u();
  } };
}
function Qf(e2, t3, n2) {
  var { readOnly: r2 } = t3, { onCreateArray: o2 } = t3, { onCreateObject: a2 } = t3, { onClick: i2 } = t3;
  return e2.$$set = (e3) => {
    "readOnly" in e3 && n2(0, r2 = e3.readOnly), "onCreateArray" in e3 && n2(1, o2 = e3.onCreateArray), "onCreateObject" in e3 && n2(2, a2 = e3.onCreateObject), "onClick" in e3 && n2(3, i2 = e3.onClick);
  }, [r2, o2, a2, i2, () => a2(), () => o2(), () => i2()];
}
var Yf = class extends dr {
  constructor(e2) {
    super(), ur(this, e2, Qf, Wf, Ht, { readOnly: 0, onCreateArray: 1, onCreateObject: 2, onClick: 3 }, Hf);
  }
};
function Kf(e2, t3) {
  var n2 = "string" == typeof e2 ? e2.toLowerCase() : e2, r2 = "string" == typeof t3 ? t3.toLowerCase() : t3;
  return (0, import_natural_compare_lite.default)(n2, r2);
}
function Zf(e2) {
  var t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [], n2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : [], r2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1;
  if (isJSONArray(getIn(e2, t3))) {
    if (void 0 === n2) throw new Error("Cannot sort: no property selected by which to sort the array");
    return function(e3) {
      var t4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [], n3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : [], r3 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1, o2 = /* @__PURE__ */ function(e4, t5) {
        return function(n4, r4) {
          var o3 = getIn(n4, e4), a3 = getIn(r4, e4);
          return void 0 === o3 ? t5 : void 0 === a3 ? -t5 : "string" != typeof o3 && "string" != typeof a3 ? o3 > a3 ? t5 : o3 < a3 ? -t5 : 0 : t5 * Kf(o3, a3);
        };
      }(n3, r3), a2 = getIn(e3, t4);
      return [{ op: "replace", path: compileJSONPointer(t4), value: a2.slice(0).sort(o2) }];
    }(e2, t3, n2, r2);
  }
  if (br(e2)) return function(e3) {
    var t4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [], n3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1, r3 = getIn(e3, t4), o2 = Object.keys(r3).slice();
    o2.sort((e4, t5) => n3 * Kf(e4, t5));
    for (var a2 = [], i2 = 0; i2 < o2.length; i2++) {
      var s2 = o2[i2], l = compileJSONPointer(t4.concat(s2));
      a2.push({ op: "move", from: l, path: l });
    }
    return a2;
  }(e2, t3, r2);
  throw new Error("Cannot sort: no array or object");
}
function Xf(e2) {
  rn(e2, "svelte-2nnd2m", '.jse-navigation-bar-dropdown.svelte-2nnd2m.svelte-2nnd2m{position:absolute;top:100%;left:0;z-index:3;background:var(--jse-navigation-bar-background, var(--jse-background-color, #fff));color:var(--jse-navigation-bar-dropdown-color, #656565);box-shadow:var(--jse-controls-box-shadow, 0 2px 6px 0 rgba(0, 0, 0, 0.24));display:flex;flex-direction:column;max-height:300px;overflow:auto;min-width:80px}.jse-navigation-bar-dropdown.svelte-2nnd2m button.jse-navigation-bar-dropdown-item.svelte-2nnd2m{font-family:var(--jse-font-family-mono, consolas, menlo, monaco, "Ubuntu Mono", "source-code-pro", monospace);font-size:var(--jse-font-size-mono, 14px);border:none;background:transparent;color:inherit;cursor:pointer;outline:none;text-align:left;white-space:nowrap;box-sizing:border-box;padding:calc(0.5 * var(--jse-padding, 10px)) 36px}.jse-navigation-bar-dropdown.svelte-2nnd2m button.jse-navigation-bar-dropdown-item.svelte-2nnd2m:focus,.jse-navigation-bar-dropdown.svelte-2nnd2m button.jse-navigation-bar-dropdown-item.svelte-2nnd2m:hover{background:var(--jse-navigation-bar-background-highlight, #e5e5e5)}.jse-navigation-bar-dropdown.svelte-2nnd2m button.jse-navigation-bar-dropdown-item.jse-selected.svelte-2nnd2m{background:var(--jse-navigation-bar-dropdown-color, #656565);color:var(--jse-navigation-bar-background, var(--jse-background-color, #fff))}');
}
function Gf(e2, t3, n2) {
  var r2 = e2.slice();
  return r2[4] = t3[n2], r2;
}
function em(e2, t3) {
  var n2, r2, o2, a2, i2, s2 = aa(t3[4].toString(), om) + "";
  function l() {
    return t3[3](t3[4]);
  }
  return { key: e2, first: null, c() {
    n2 = ln("button"), r2 = un(s2), hn(n2, "type", "button"), hn(n2, "class", "jse-navigation-bar-dropdown-item svelte-2nnd2m"), hn(n2, "title", o2 = t3[4].toString()), kn(n2, "jse-selected", t3[4] === t3[1]), this.first = n2;
  }, m(e3, t4) {
    on(e3, n2, t4), nn(n2, r2), a2 || (i2 = pn(n2, "click", mn(l)), a2 = true);
  }, p(e3, a3) {
    t3 = e3, 1 & a3 && s2 !== (s2 = aa(t3[4].toString(), om) + "") && yn(r2, s2), 1 & a3 && o2 !== (o2 = t3[4].toString()) && hn(n2, "title", o2), 3 & a3 && kn(n2, "jse-selected", t3[4] === t3[1]);
  }, d(e3) {
    e3 && an(n2), a2 = false, i2();
  } };
}
function tm(e2) {
  var t3, n2;
  return { c() {
    t3 = ln("button"), n2 = un("..."), hn(t3, "type", "button"), hn(t3, "class", "jse-navigation-bar-dropdown-item svelte-2nnd2m"), hn(t3, "title", "Limited to " + rm2 + " items");
  }, m(e3, r2) {
    on(e3, t3, r2), nn(t3, n2);
  }, p: Bt, d(e3) {
    e3 && an(t3);
  } };
}
function nm(e2) {
  for (var t3, n2, r2 = [], o2 = /* @__PURE__ */ new Map(), a2 = er(Br(e2[0], rm2)), i2 = (e3) => e3[4], s2 = 0; s2 < a2.length; s2 += 1) {
    var l = Gf(e2, a2, s2), c = i2(l);
    o2.set(c, r2[s2] = em(c, l));
  }
  var u = e2[0].length > rm2 && tm();
  return { c() {
    t3 = ln("div");
    for (var e3 = 0; e3 < r2.length; e3 += 1) r2[e3].c();
    n2 = dn(), u && u.c(), hn(t3, "class", "jse-navigation-bar-dropdown svelte-2nnd2m");
  }, m(e3, o3) {
    on(e3, t3, o3);
    for (var a3 = 0; a3 < r2.length; a3 += 1) r2[a3] && r2[a3].m(t3, null);
    nn(t3, n2), u && u.m(t3, null);
  }, p(e3, s3) {
    var [l2] = s3;
    7 & l2 && (a2 = er(Br(e3[0], rm2)), r2 = rr(r2, l2, i2, 0, e3, a2, o2, t3, tr, em, n2, Gf)), e3[0].length > rm2 ? u ? u.p(e3, l2) : ((u = tm()).c(), u.m(t3, null)) : u && (u.d(1), u = null);
  }, i: Bt, o: Bt, d(e3) {
    e3 && an(t3);
    for (var n3 = 0; n3 < r2.length; n3 += 1) r2[n3].d();
    u && u.d();
  } };
}
var rm2 = 100;
var om = 30;
function am(e2, t3, n2) {
  var { items: r2 } = t3, { selectedItem: o2 } = t3, { onSelect: a2 } = t3;
  return e2.$$set = (e3) => {
    "items" in e3 && n2(0, r2 = e3.items), "selectedItem" in e3 && n2(1, o2 = e3.selectedItem), "onSelect" in e3 && n2(2, a2 = e3.onSelect);
  }, [r2, o2, a2, (e3) => a2(e3)];
}
var im = class extends dr {
  constructor(e2) {
    super(), ur(this, e2, am, nm, Ht, { items: 0, selectedItem: 1, onSelect: 2 }, Xf);
  }
};
function sm(e2) {
  rn(e2, "svelte-752ro1", ".jse-navigation-bar-item.svelte-752ro1.svelte-752ro1{position:relative;display:flex}.jse-navigation-bar-item.svelte-752ro1 button.jse-navigation-bar-button.svelte-752ro1{font-family:inherit;font-size:inherit;padding:calc(0.5 * var(--jse-padding, 10px)) 2px;border:none;background:transparent;color:inherit;cursor:pointer;outline:none;min-width:2em;white-space:nowrap}.jse-navigation-bar-item.svelte-752ro1 button.jse-navigation-bar-button.svelte-752ro1:focus,.jse-navigation-bar-item.svelte-752ro1 button.jse-navigation-bar-button.svelte-752ro1:hover{background:var(--jse-panel-button-background-highlight, #e0e0e0);color:var(--panel-button-color-highlight, var(--jse-text-color, #4d4d4d))}.jse-navigation-bar-item.svelte-752ro1 button.jse-navigation-bar-button.jse-navigation-bar-arrow.svelte-752ro1{padding:2px var(--jse-padding, 10px) 0}.jse-navigation-bar-item.svelte-752ro1 button.jse-navigation-bar-button.jse-navigation-bar-arrow.jse-open.svelte-752ro1{background:var(--jse-navigation-bar-background, var(--jse-background-color, #fff));color:var(--jse-navigation-bar-dropdown-color, #656565)}.jse-navigation-bar-item.svelte-752ro1.svelte-752ro1:last-child{padding-right:var(--jse-padding, 10px)}");
}
function lm(e2) {
  var t3, n2, r2, o2;
  return { c() {
    t3 = ln("button"), n2 = un(e2[2]), hn(t3, "type", "button"), hn(t3, "class", "jse-navigation-bar-button svelte-752ro1");
  }, m(a2, i2) {
    on(a2, t3, i2), nn(t3, n2), r2 || (o2 = pn(t3, "click", e2[9]), r2 = true);
  }, p(e3, t4) {
    4 & t4 && yn(n2, e3[2]);
  }, d(e3) {
    e3 && an(t3), r2 = false, o2();
  } };
}
function cm(e2) {
  var t3, n2, r2, o2, a2, i2, s2;
  r2 = new Ca({ props: { data: faAngleRight } });
  var l = void 0 !== e2[2] && lm(e2);
  return { c() {
    t3 = ln("div"), n2 = ln("button"), sr(r2.$$.fragment), o2 = dn(), l && l.c(), hn(n2, "type", "button"), hn(n2, "class", "jse-navigation-bar-button jse-navigation-bar-arrow svelte-752ro1"), kn(n2, "jse-open", e2[1]), hn(t3, "class", "jse-navigation-bar-item svelte-752ro1");
  }, m(c, u) {
    on(c, t3, u), nn(t3, n2), lr(r2, n2, null), nn(t3, o2), l && l.m(t3, null), e2[10](t3), a2 = true, i2 || (s2 = pn(n2, "click", e2[4]), i2 = true);
  }, p(e3, r3) {
    var [o3] = r3;
    (!a2 || 2 & o3) && kn(n2, "jse-open", e3[1]), void 0 !== e3[2] ? l ? l.p(e3, o3) : ((l = lm(e3)).c(), l.m(t3, null)) : l && (l.d(1), l = null);
  }, i(e3) {
    a2 || (Xn(r2.$$.fragment, e3), a2 = true);
  }, o(e3) {
    Gn(r2.$$.fragment, e3), a2 = false;
  }, d(n3) {
    n3 && an(t3), cr(r2), l && l.d(), e2[10](null), i2 = false, s2();
  } };
}
function um(e2, t3, n2) {
  var r2, o2, a2, i2, { openAbsolutePopup: s2, closeAbsolutePopup: l } = En("absolute-popup"), { path: c } = t3, { index: u } = t3, { onSelect: d } = t3, { getItems: v } = t3, p = false;
  function f(e3) {
    l(i2), d(r2.concat(e3));
  }
  return e2.$$set = (e3) => {
    "path" in e3 && n2(5, c = e3.path), "index" in e3 && n2(6, u = e3.index), "onSelect" in e3 && n2(7, d = e3.onSelect), "getItems" in e3 && n2(8, v = e3.getItems);
  }, e2.$$.update = () => {
    96 & e2.$$.dirty && (r2 = c.slice(0, u)), 96 & e2.$$.dirty && n2(2, o2 = c[u]);
  }, [a2, p, o2, f, function() {
    if (a2) {
      n2(1, p = true);
      var e3 = { items: v(r2), selectedItem: o2, onSelect: f };
      i2 = s2(im, e3, { anchor: a2, closeOnOuterClick: true, onClose: () => {
        n2(1, p = false);
      } });
    }
  }, c, u, d, v, () => f(o2), function(e3) {
    Tn[e3 ? "unshift" : "push"](() => {
      n2(0, a2 = e3);
    });
  }];
}
var dm = class extends dr {
  constructor(e2) {
    super(), ur(this, e2, um, cm, Ht, { path: 5, index: 6, onSelect: 7, getItems: 8 }, sm);
  }
};
function vm(e2) {
  var t3, n2;
  if (navigator.clipboard) return navigator.clipboard.writeText(e2);
  if (null !== (t3 = (n2 = document).queryCommandSupported) && void 0 !== t3 && t3.call(n2, "copy")) {
    var r2 = document.createElement("textarea");
    r2.value = e2, r2.style.position = "fixed", r2.style.opacity = "0", document.body.appendChild(r2), r2.select();
    try {
      document.execCommand("copy");
    } catch (e3) {
      console.error(e3);
    } finally {
      document.body.removeChild(r2);
    }
    return Promise.resolve();
  }
  return console.error("Copy failed."), Promise.resolve();
}
function pm(e2) {
  rn(e2, "svelte-zc2wx7", ".jse-navigation-bar-path-editor.svelte-zc2wx7.svelte-zc2wx7{flex:1;display:flex;border:var(--jse-edit-outline, 2px solid #656565);background:var(--jse-background-color, #fff)}.jse-navigation-bar-path-editor.svelte-zc2wx7 input.jse-navigation-bar-text.svelte-zc2wx7{flex:1;font-family:inherit;font-size:inherit;padding:0 5px 1px;background:var(--jse-background-color, #fff);color:var(--jse-text-color, #4d4d4d);border:none;outline:none}.jse-navigation-bar-path-editor.svelte-zc2wx7 button.svelte-zc2wx7{border:none;background:var(--jse-background-color, #fff);cursor:pointer;font-family:inherit;font-size:80%;color:inherit}.jse-navigation-bar-path-editor.svelte-zc2wx7 button.jse-navigation-bar-copy.copied.svelte-zc2wx7{color:var(--message-success-background, #9ac45d)}.jse-navigation-bar-path-editor.svelte-zc2wx7 button.jse-navigation-bar-validation-error.svelte-zc2wx7{color:var(--jse-error-color, #ee5341)}.jse-navigation-bar-path-editor.error.svelte-zc2wx7.svelte-zc2wx7{border-color:var(--jse-error-color, #ee5341)}.jse-navigation-bar-path-editor.error.svelte-zc2wx7 input.jse-navigation-bar-text.svelte-zc2wx7{color:var(--jse-error-color, #ee5341)}.jse-navigation-bar-path-editor.svelte-zc2wx7 .jse-copied-text.svelte-zc2wx7{background:var(--message-success-background, #9ac45d);color:var(--jse-message-success-color, #fff);position:relative;margin:2px;padding:0 5px;border-radius:3px}");
}
function fm(e2) {
  var t3, n2, r2, o2, a2, s2;
  return n2 = new Ca({ props: { data: faExclamationTriangle } }), { c() {
    t3 = ln("button"), sr(n2.$$.fragment), hn(t3, "type", "button"), hn(t3, "class", "jse-navigation-bar-validation-error svelte-zc2wx7");
  }, m(l, c) {
    on(l, t3, c), lr(n2, t3, null), o2 = true, a2 || (s2 = en(r2 = Ul.call(null, t3, i({ text: String(e2[3] || "") }, e2[4]))), a2 = true);
  }, p(e3, t4) {
    r2 && Jt(r2.update) && 8 & t4 && r2.update.call(null, i({ text: String(e3[3] || "") }, e3[4]));
  }, i(e3) {
    o2 || (Xn(n2.$$.fragment, e3), o2 = true);
  }, o(e3) {
    Gn(n2.$$.fragment, e3), o2 = false;
  }, d(e3) {
    e3 && an(t3), cr(n2), a2 = false, s2();
  } };
}
function mm(e2) {
  var t3;
  return { c() {
    (t3 = ln("div")).textContent = "Copied!", hn(t3, "class", "jse-copied-text svelte-zc2wx7");
  }, m(e3, n2) {
    on(e3, t3, n2);
  }, d(e3) {
    e3 && an(t3);
  } };
}
function hm(e2) {
  var t3, n2, r2, o2, a2, i2, s2, l, c, u, d = e2[3] && fm(e2), v = e2[2] && mm();
  return s2 = new Ca({ props: { data: faCopy } }), { c() {
    t3 = ln("div"), n2 = ln("input"), r2 = dn(), d && d.c(), o2 = dn(), v && v.c(), a2 = dn(), i2 = ln("button"), sr(s2.$$.fragment), hn(n2, "type", "text"), hn(n2, "class", "jse-navigation-bar-text svelte-zc2wx7"), n2.value = e2[0], hn(i2, "type", "button"), hn(i2, "class", "jse-navigation-bar-copy svelte-zc2wx7"), hn(i2, "title", "Copy selected path to the clipboard"), kn(i2, "copied", e2[2]), hn(t3, "class", "jse-navigation-bar-path-editor svelte-zc2wx7"), kn(t3, "error", e2[3]);
  }, m(p, f) {
    on(p, t3, f), nn(t3, n2), e2[15](n2), nn(t3, r2), d && d.m(t3, null), nn(t3, o2), v && v.m(t3, null), nn(t3, a2), nn(t3, i2), lr(s2, i2, null), l = true, c || (u = [pn(n2, "keydown", mn(e2[6])), pn(n2, "input", e2[5]), pn(i2, "click", e2[7])], c = true);
  }, p(e3, r3) {
    var [s3] = r3;
    (!l || 1 & s3 && n2.value !== e3[0]) && (n2.value = e3[0]), e3[3] ? d ? (d.p(e3, s3), 8 & s3 && Xn(d, 1)) : ((d = fm(e3)).c(), Xn(d, 1), d.m(t3, o2)) : d && (Kn(), Gn(d, 1, 1, () => {
      d = null;
    }), Zn()), e3[2] ? v || ((v = mm()).c(), v.m(t3, a2)) : v && (v.d(1), v = null), (!l || 4 & s3) && kn(i2, "copied", e3[2]), (!l || 8 & s3) && kn(t3, "error", e3[3]);
  }, i(e3) {
    l || (Xn(d), Xn(s2.$$.fragment, e3), l = true);
  }, o(e3) {
    Gn(d), Gn(s2.$$.fragment, e3), l = false;
  }, d(n3) {
    n3 && an(t3), e2[15](null), d && d.d(), v && v.d(), cr(s2), c = false, Dt(u);
  } };
}
function gm(e2, t3, n2) {
  var r2, o2, a2, i2 = En("absolute-popup"), { path: s2 } = t3, { pathParser: l } = t3, { onChange: c } = t3, { onClose: u } = t3, { onError: d } = t3, { pathExists: v } = t3, p = false, f = void 0, m3 = false;
  function h2() {
    o2.focus();
  }
  function g(e3) {
    try {
      var t4 = l.parse(e3);
      return function(e4) {
        if (!v(e4)) throw new Error("Path does not exist in current document");
      }(t4), { path: t4, error: void 0 };
    } catch (e4) {
      return { path: void 0, error: e4 };
    }
  }
  return qn(() => {
    h2();
  }), Mn(() => {
    clearTimeout(f);
  }), e2.$$set = (e3) => {
    "path" in e3 && n2(8, s2 = e3.path), "pathParser" in e3 && n2(9, l = e3.pathParser), "onChange" in e3 && n2(10, c = e3.onChange), "onClose" in e3 && n2(11, u = e3.onClose), "onError" in e3 && n2(12, d = e3.onError), "pathExists" in e3 && n2(13, v = e3.pathExists);
  }, e2.$$.update = () => {
    768 & e2.$$.dirty && n2(0, a2 = l.stringify(s2)), 16385 & e2.$$.dirty && n2(3, r2 = p ? g(a2).error : void 0);
  }, [a2, o2, m3, r2, i2, function(e3) {
    n2(0, a2 = e3.currentTarget.value);
  }, function(e3) {
    var t4 = Do(e3);
    if ("Escape" === t4 && u(), "Enter" === t4) {
      n2(14, p = true);
      var r3 = g(a2);
      void 0 !== r3.path ? c(r3.path) : d(r3.error);
    }
  }, function() {
    vm(a2), n2(2, m3 = true), f = window.setTimeout(() => n2(2, m3 = false), 1e3), h2();
  }, s2, l, c, u, d, v, p, function(e3) {
    Tn[e3 ? "unshift" : "push"](() => {
      n2(1, o2 = e3);
    });
  }];
}
var jm = class extends dr {
  constructor(e2) {
    super(), ur(this, e2, gm, hm, Vt, { path: 8, pathParser: 9, onChange: 10, onClose: 11, onError: 12, pathExists: 13 }, pm);
  }
};
function xm(e2) {
  rn(e2, "svelte-xs03gj", '.jse-navigation-bar.svelte-xs03gj.svelte-xs03gj{font-family:var(--jse-font-family-mono, consolas, menlo, monaco, "Ubuntu Mono", "source-code-pro", monospace);font-size:var(--jse-font-size-mono, 14px);background:var(--jse-panel-background, #ebebeb);color:var(--jse-panel-button-color, inherit);padding:0;margin:0;display:flex;overflow:auto;border-left:var(--jse-main-border, 1px solid #d7d7d7);border-right:var(--jse-main-border, 1px solid #d7d7d7)}.jse-navigation-bar.svelte-xs03gj .jse-navigation-bar-edit.svelte-xs03gj{font-family:var(--jse-font-family-mono, consolas, menlo, monaco, "Ubuntu Mono", "source-code-pro", monospace);font-size:var(--jse-font-size-mono, 14px);padding:calc(0.5 * var(--jse-padding, 10px)) var(--jse-padding, 10px);color:var(--jse-panel-color-readonly, #b2b2b2);background:transparent;border:none;display:flex;cursor:pointer;outline:none;align-items:center}.jse-navigation-bar.svelte-xs03gj .jse-navigation-bar-edit.flex.svelte-xs03gj{flex:1}.jse-navigation-bar.svelte-xs03gj .jse-navigation-bar-edit.svelte-xs03gj:focus,.jse-navigation-bar.svelte-xs03gj .jse-navigation-bar-edit.svelte-xs03gj:hover,.jse-navigation-bar.svelte-xs03gj .jse-navigation-bar-edit.editing.svelte-xs03gj{background:var(--jse-panel-button-background-highlight, #e0e0e0);color:var(--panel-button-color-highlight, var(--jse-text-color, #4d4d4d));transition:color 0.2s ease-in, background 0.2s ease-in}.jse-navigation-bar.svelte-xs03gj .jse-navigation-bar-edit .jse-navigation-bar-space.svelte-xs03gj{flex:1;text-align:left}');
}
function bm(e2, t3, n2) {
  var r2 = e2.slice();
  return r2[18] = t3[n2], r2[20] = n2, r2;
}
function ym(e2) {
  var t3, n2;
  return t3 = new jm({ props: { path: e2[3], onClose: e2[11], onChange: e2[12], onError: e2[1], pathExists: e2[8], pathParser: e2[2] } }), { c() {
    sr(t3.$$.fragment);
  }, m(e3, r2) {
    lr(t3, e3, r2), n2 = true;
  }, p(e3, n3) {
    var r2 = {};
    8 & n3 && (r2.path = e3[3]), 2 & n3 && (r2.onError = e3[1]), 4 & n3 && (r2.pathParser = e3[2]), t3.$set(r2);
  }, i(e3) {
    n2 || (Xn(t3.$$.fragment, e3), n2 = true);
  }, o(e3) {
    Gn(t3.$$.fragment, e3), n2 = false;
  }, d(e3) {
    cr(t3, e3);
  } };
}
function $m(e2) {
  for (var t3, n2, r2, o2 = [], a2 = /* @__PURE__ */ new Map(), i2 = er(e2[3]), s2 = (e3) => e3[20], l = 0; l < i2.length; l += 1) {
    var c = bm(e2, i2, l), u = s2(c);
    a2.set(u, o2[l] = wm(u, c));
  }
  var d = e2[6] && Cm(e2);
  return { c() {
    for (var e3 = 0; e3 < o2.length; e3 += 1) o2[e3].c();
    t3 = dn(), d && d.c(), n2 = vn();
  }, m(e3, a3) {
    for (var i3 = 0; i3 < o2.length; i3 += 1) o2[i3] && o2[i3].m(e3, a3);
    on(e3, t3, a3), d && d.m(e3, a3), on(e3, n2, a3), r2 = true;
  }, p(e3, r3) {
    648 & r3 && (i2 = er(e3[3]), Kn(), o2 = rr(o2, r3, s2, 0, e3, i2, a2, t3.parentNode, nr, wm, t3, bm), Zn()), e3[6] ? d ? (d.p(e3, r3), 64 & r3 && Xn(d, 1)) : ((d = Cm(e3)).c(), Xn(d, 1), d.m(n2.parentNode, n2)) : d && (Kn(), Gn(d, 1, 1, () => {
      d = null;
    }), Zn());
  }, i(e3) {
    if (!r2) {
      for (var t4 = 0; t4 < i2.length; t4 += 1) Xn(o2[t4]);
      Xn(d), r2 = true;
    }
  }, o(e3) {
    for (var t4 = 0; t4 < o2.length; t4 += 1) Gn(o2[t4]);
    Gn(d), r2 = false;
  }, d(e3) {
    e3 && (an(t3), an(n2));
    for (var r3 = 0; r3 < o2.length; r3 += 1) o2[r3].d(e3);
    d && d.d(e3);
  } };
}
function wm(e2, t3) {
  var n2, r2, o2;
  return r2 = new dm({ props: { getItems: t3[7], path: t3[3], index: t3[20], onSelect: t3[9] } }), { key: e2, first: null, c() {
    n2 = vn(), sr(r2.$$.fragment), this.first = n2;
  }, m(e3, t4) {
    on(e3, n2, t4), lr(r2, e3, t4), o2 = true;
  }, p(e3, n3) {
    t3 = e3;
    var o3 = {};
    8 & n3 && (o3.path = t3[3]), 8 & n3 && (o3.index = t3[20]), r2.$set(o3);
  }, i(e3) {
    o2 || (Xn(r2.$$.fragment, e3), o2 = true);
  }, o(e3) {
    Gn(r2.$$.fragment, e3), o2 = false;
  }, d(e3) {
    e3 && an(n2), cr(r2, e3);
  } };
}
function Cm(e2) {
  var t3, n2;
  return t3 = new dm({ props: { getItems: e2[7], path: e2[3], index: e2[3].length, onSelect: e2[9] } }), { c() {
    sr(t3.$$.fragment);
  }, m(e3, r2) {
    lr(t3, e3, r2), n2 = true;
  }, p(e3, n3) {
    var r2 = {};
    8 & n3 && (r2.path = e3[3]), 8 & n3 && (r2.index = e3[3].length), t3.$set(r2);
  }, i(e3) {
    n2 || (Xn(t3.$$.fragment, e3), n2 = true);
  }, o(e3) {
    Gn(t3.$$.fragment, e3), n2 = false;
  }, d(e3) {
    cr(t3, e3);
  } };
}
function km(e2) {
  var t3, n2, r2, o2, a2, i2, s2, l, c, u, d, v, p, f = yr(e2[0]) || e2[5] ? " " : "Navigation bar", m3 = [$m, ym], h2 = [];
  function g(e3, t4) {
    return e3[5] ? 1 : 0;
  }
  return n2 = g(e2), r2 = h2[n2] = m3[n2](e2), c = new Ca({ props: { data: e2[5] ? faClose : faEdit } }), { c() {
    t3 = ln("div"), r2.c(), o2 = dn(), a2 = ln("button"), i2 = ln("span"), s2 = un(f), l = dn(), sr(c.$$.fragment), hn(i2, "class", "jse-navigation-bar-space svelte-xs03gj"), hn(a2, "type", "button"), hn(a2, "class", "jse-navigation-bar-edit svelte-xs03gj"), hn(a2, "title", u = e2[5] ? "Cancel editing the selected path" : "Edit the selected path"), kn(a2, "flex", !e2[5]), kn(a2, "editing", e2[5]), hn(t3, "class", "jse-navigation-bar svelte-xs03gj");
  }, m(r3, u2) {
    on(r3, t3, u2), h2[n2].m(t3, null), nn(t3, o2), nn(t3, a2), nn(a2, i2), nn(i2, s2), nn(a2, l), lr(c, a2, null), e2[15](t3), d = true, v || (p = pn(a2, "click", e2[10]), v = true);
  }, p(e3, i3) {
    var [l2] = i3, v2 = n2;
    (n2 = g(e3)) === v2 ? h2[n2].p(e3, l2) : (Kn(), Gn(h2[v2], 1, 1, () => {
      h2[v2] = null;
    }), Zn(), (r2 = h2[n2]) ? r2.p(e3, l2) : (r2 = h2[n2] = m3[n2](e3)).c(), Xn(r2, 1), r2.m(t3, o2)), (!d || 33 & l2) && f !== (f = yr(e3[0]) || e3[5] ? " " : "Navigation bar") && yn(s2, f);
    var p2 = {};
    32 & l2 && (p2.data = e3[5] ? faClose : faEdit), c.$set(p2), (!d || 32 & l2 && u !== (u = e3[5] ? "Cancel editing the selected path" : "Edit the selected path")) && hn(a2, "title", u), (!d || 32 & l2) && kn(a2, "flex", !e3[5]), (!d || 32 & l2) && kn(a2, "editing", e3[5]);
  }, i(e3) {
    d || (Xn(r2), Xn(c.$$.fragment, e3), d = true);
  }, o(e3) {
    Gn(r2), Gn(c.$$.fragment, e3), d = false;
  }, d(r3) {
    r3 && an(t3), h2[n2].d(), cr(c), e2[15](null), v = false, p();
  } };
}
function Sm(e2, t3, n2) {
  var r2, o2, a2, i2 = vr("jsoneditor:NavigationBar"), { json: s2 } = t3, { selection: l } = t3, { onSelect: c } = t3, { onError: d } = t3, { pathParser: v } = t3, p = false;
  function f(e3) {
    i2("select path", JSON.stringify(e3)), c(Es(e3, e3));
  }
  function m3() {
    n2(5, p = false);
  }
  return e2.$$set = (e3) => {
    "json" in e3 && n2(0, s2 = e3.json), "selection" in e3 && n2(13, l = e3.selection), "onSelect" in e3 && n2(14, c = e3.onSelect), "onError" in e3 && n2(1, d = e3.onError), "pathParser" in e3 && n2(2, v = e3.pathParser);
  }, e2.$$.update = () => {
    8192 & e2.$$.dirty && n2(3, r2 = l ? Ds(l) : []), 9 & e2.$$.dirty && n2(6, o2 = yr(getIn(s2, r2))), 8 & e2.$$.dirty && setTimeout(() => {
      if (a2 && a2.scrollTo) {
        var e3 = a2.scrollWidth - a2.clientWidth;
        e3 > 0 && (i2("scrollTo ", e3), a2.scrollTo({ left: e3, behavior: "smooth" }));
      }
    });
  }, [s2, d, v, r2, a2, p, o2, function(e3) {
    i2("get items for path", e3);
    var t4 = getIn(s2, e3);
    if (Array.isArray(t4)) return range_default(0, t4.length).map(String);
    if (br(t4)) {
      var n3 = Object.keys(t4).slice(0);
      return n3.sort(Kf), n3;
    }
    return [];
  }, function(e3) {
    return existsIn(s2, e3);
  }, f, function() {
    n2(5, p = !p);
  }, m3, function(e3) {
    m3(), f(e3);
  }, l, c, function(e3) {
    Tn[e3 ? "unshift" : "push"](() => {
      n2(4, a2 = e3);
    });
  }];
}
var Om = class extends dr {
  constructor(e2) {
    super(), ur(this, e2, Sm, km, Ht, { json: 0, selection: 13, onSelect: 14, onError: 1, pathParser: 2 }, xm);
  }
};
function zm(e2) {
  rn(e2, "svelte-1mxl2uo", '.jse-search-box.svelte-1mxl2uo.svelte-1mxl2uo{border:var(--jse-panel-border, var(--jse-main-border, 1px solid #d7d7d7));border-radius:3px;font-family:var(--jse-font-family, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif);font-size:var(--jse-font-size, 16px);background:var(--jse-panel-background, #ebebeb);color:var(--jse-panel-color-readonly, #b2b2b2);box-shadow:var(--jse-controls-box-shadow, 0 2px 6px 0 rgba(0, 0, 0, 0.24));display:inline-block;width:400px;max-width:100%;overflow:auto}.jse-search-box.svelte-1mxl2uo .jse-search-form.svelte-1mxl2uo{display:flex;align-items:stretch}.jse-search-box.svelte-1mxl2uo .jse-search-form button.svelte-1mxl2uo,.jse-search-box.svelte-1mxl2uo .jse-search-form input.svelte-1mxl2uo{font-family:inherit;font-size:inherit}.jse-search-box.svelte-1mxl2uo .jse-search-form button.svelte-1mxl2uo{display:block;text-align:center;border:none;padding:0 5px;margin:0;cursor:pointer;color:var(--jse-panel-button-color, inherit);background:var(--jse-panel-button-background, transparent)}.jse-search-box.svelte-1mxl2uo .jse-search-form button.svelte-1mxl2uo:hover{color:var(--panel-button-color-highlight, var(--jse-text-color, #4d4d4d));background:var(--jse-panel-button-background-highlight, #e0e0e0)}.jse-search-box.svelte-1mxl2uo .jse-search-form input.svelte-1mxl2uo{color:var(--jse-panel-color, var(--jse-text-color, #4d4d4d));border:var(--jse-input-border, 1px solid #d8dbdf);border-radius:3px;background:var(--jse-input-background, var(--jse-background-color, #fff));height:28px;padding:0 5px;margin:0;flex:1;width:0;min-width:50px;outline:none}.jse-search-box.svelte-1mxl2uo .jse-search-form .jse-replace-toggle.svelte-1mxl2uo{padding:var(--jse-padding, 10px) calc(0.5 * var(--jse-padding, 10px));min-width:20px;background:var(--jse-panel-button-background-highlight, #e0e0e0)}.jse-search-box.svelte-1mxl2uo .jse-search-form .jse-search-contents.svelte-1mxl2uo{flex:1;display:flex;flex-direction:column;padding:calc(0.5 * var(--jse-padding, 10px));gap:calc(0.5 * var(--jse-padding, 10px))}.jse-search-box.svelte-1mxl2uo .jse-search-form .jse-search-contents .jse-search-section.svelte-1mxl2uo{flex:1;display:flex;align-items:center;position:relative}.jse-search-box.svelte-1mxl2uo .jse-search-form .jse-search-contents .jse-search-section .jse-search-icon.svelte-1mxl2uo{color:inherit;cursor:inherit;background:inherit;width:32px;text-align:center}.jse-search-box.svelte-1mxl2uo .jse-search-form .jse-search-contents .jse-search-section label.jse-search-input-label.svelte-1mxl2uo{flex:1;display:flex}.jse-search-box.svelte-1mxl2uo .jse-search-form .jse-search-contents .jse-search-section .jse-search-count.svelte-1mxl2uo{color:inherit;font-size:80%;visibility:hidden;padding:0 5px;min-width:36px;text-align:center}.jse-search-box.svelte-1mxl2uo .jse-search-form .jse-search-contents .jse-search-section .jse-search-count.jse-visible.svelte-1mxl2uo{visibility:visible}.jse-search-box.svelte-1mxl2uo .jse-search-form .jse-search-contents .jse-replace-section.svelte-1mxl2uo{flex:1;display:flex;padding-left:32px}.jse-search-box.svelte-1mxl2uo .jse-search-form .jse-search-contents .jse-replace-section button.svelte-1mxl2uo{width:auto}');
}
function qm(e2) {
  var t3, n2, r2, o2, a2, i2, s2, l, c, u, d, v, p, f, m3, h2, g, j, x, b2, y, $2, w, C3, k2, S4, O, z3, q2 = (-1 !== e2[7] && e2[7] < e2[4] ? "".concat(e2[7] + 1, "/") : "") + "", M3 = !e2[2] && Mm(e2), R3 = [Em, Rm], E3 = [];
  function P3(e3, t4) {
    return e3[6] ? 0 : 1;
  }
  s2 = P3(e2), l = E3[s2] = R3[s2](e2), j = new Ca({ props: { data: faChevronDown } }), y = new Ca({ props: { data: faChevronUp } }), C3 = new Ca({ props: { data: faTimes } });
  var I3 = e2[0] && !e2[2] && Pm(e2);
  return { c() {
    t3 = ln("div"), n2 = ln("form"), M3 && M3.c(), r2 = dn(), o2 = ln("div"), a2 = ln("div"), i2 = ln("div"), l.c(), c = dn(), u = ln("label"), d = ln("input"), v = dn(), p = ln("div"), f = un(q2), m3 = un(e2[8]), h2 = dn(), g = ln("button"), sr(j.$$.fragment), x = dn(), b2 = ln("button"), sr(y.$$.fragment), $2 = dn(), w = ln("button"), sr(C3.$$.fragment), k2 = dn(), I3 && I3.c(), hn(i2, "class", "jse-search-icon svelte-1mxl2uo"), hn(d, "class", "jse-search-input svelte-1mxl2uo"), hn(d, "title", "Enter text to search"), hn(d, "type", "text"), hn(d, "placeholder", "Find"), hn(u, "class", "jse-search-input-label svelte-1mxl2uo"), hn(u, "about", "jse-search input"), hn(p, "class", "jse-search-count svelte-1mxl2uo"), kn(p, "jse-visible", "" !== e2[3]), hn(g, "type", "button"), hn(g, "class", "jse-search-next svelte-1mxl2uo"), hn(g, "title", "Go to next search result (Enter)"), hn(b2, "type", "button"), hn(b2, "class", "jse-search-previous svelte-1mxl2uo"), hn(b2, "title", "Go to previous search result (Shift+Enter)"), hn(w, "type", "button"), hn(w, "class", "jse-search-clear svelte-1mxl2uo"), hn(w, "title", "Close search box (Esc)"), hn(a2, "class", "jse-search-section svelte-1mxl2uo"), hn(o2, "class", "jse-search-contents svelte-1mxl2uo"), hn(n2, "class", "jse-search-form svelte-1mxl2uo"), hn(t3, "class", "jse-search-box svelte-1mxl2uo");
  }, m(l2, q3) {
    on(l2, t3, q3), nn(t3, n2), M3 && M3.m(n2, null), nn(n2, r2), nn(n2, o2), nn(o2, a2), nn(a2, i2), E3[s2].m(i2, null), nn(a2, c), nn(a2, u), nn(u, d), $n(d, e2[3]), nn(a2, v), nn(a2, p), nn(p, f), nn(p, m3), nn(a2, h2), nn(a2, g), lr(j, g, null), nn(a2, x), nn(a2, b2), lr(y, b2, null), nn(a2, $2), nn(a2, w), lr(C3, w, null), nn(o2, k2), I3 && I3.m(o2, null), S4 = true, O || (z3 = [pn(d, "input", e2[27]), en(Tm.call(null, d)), pn(d, "paste", e2[12]), pn(g, "click", e2[15]), pn(b2, "click", e2[16]), pn(w, "click", e2[17]), pn(n2, "keydown", e2[10])], O = true);
  }, p(e3, t4) {
    e3[2] ? M3 && (Kn(), Gn(M3, 1, 1, () => {
      M3 = null;
    }), Zn()) : M3 ? (M3.p(e3, t4), 4 & t4[0] && Xn(M3, 1)) : ((M3 = Mm(e3)).c(), Xn(M3, 1), M3.m(n2, r2));
    var a3 = s2;
    (s2 = P3(e3)) !== a3 && (Kn(), Gn(E3[a3], 1, 1, () => {
      E3[a3] = null;
    }), Zn(), (l = E3[s2]) || (l = E3[s2] = R3[s2](e3)).c(), Xn(l, 1), l.m(i2, null)), 8 & t4[0] && d.value !== e3[3] && $n(d, e3[3]), (!S4 || 144 & t4[0]) && q2 !== (q2 = (-1 !== e3[7] && e3[7] < e3[4] ? "".concat(e3[7] + 1, "/") : "") + "") && yn(f, q2), (!S4 || 256 & t4[0]) && yn(m3, e3[8]), (!S4 || 8 & t4[0]) && kn(p, "jse-visible", "" !== e3[3]), e3[0] && !e3[2] ? I3 ? I3.p(e3, t4) : ((I3 = Pm(e3)).c(), I3.m(o2, null)) : I3 && (I3.d(1), I3 = null);
  }, i(e3) {
    S4 || (Xn(M3), Xn(l), Xn(j.$$.fragment, e3), Xn(y.$$.fragment, e3), Xn(C3.$$.fragment, e3), S4 = true);
  }, o(e3) {
    Gn(M3), Gn(l), Gn(j.$$.fragment, e3), Gn(y.$$.fragment, e3), Gn(C3.$$.fragment, e3), S4 = false;
  }, d(e3) {
    e3 && an(t3), M3 && M3.d(), E3[s2].d(), cr(j), cr(y), cr(C3), I3 && I3.d(), O = false, Dt(z3);
  } };
}
function Mm(e2) {
  var t3, n2, r2, o2, a2;
  return n2 = new Ca({ props: { data: e2[0] ? faCaretDown : faCaretRight } }), { c() {
    t3 = ln("button"), sr(n2.$$.fragment), hn(t3, "type", "button"), hn(t3, "class", "jse-replace-toggle svelte-1mxl2uo"), hn(t3, "title", "Toggle visibility of replace options (Ctrl+H)");
  }, m(i2, s2) {
    on(i2, t3, s2), lr(n2, t3, null), r2 = true, o2 || (a2 = pn(t3, "click", e2[9]), o2 = true);
  }, p(e3, t4) {
    var r3 = {};
    1 & t4[0] && (r3.data = e3[0] ? faCaretDown : faCaretRight), n2.$set(r3);
  }, i(e3) {
    r2 || (Xn(n2.$$.fragment, e3), r2 = true);
  }, o(e3) {
    Gn(n2.$$.fragment, e3), r2 = false;
  }, d(e3) {
    e3 && an(t3), cr(n2), o2 = false, a2();
  } };
}
function Rm(e2) {
  var t3, n2;
  return t3 = new Ca({ props: { data: faSearch } }), { c() {
    sr(t3.$$.fragment);
  }, m(e3, r2) {
    lr(t3, e3, r2), n2 = true;
  }, i(e3) {
    n2 || (Xn(t3.$$.fragment, e3), n2 = true);
  }, o(e3) {
    Gn(t3.$$.fragment, e3), n2 = false;
  }, d(e3) {
    cr(t3, e3);
  } };
}
function Em(e2) {
  var t3, n2;
  return t3 = new Ca({ props: { data: faCircleNotch, spin: true } }), { c() {
    sr(t3.$$.fragment);
  }, m(e3, r2) {
    lr(t3, e3, r2), n2 = true;
  }, i(e3) {
    n2 || (Xn(t3.$$.fragment, e3), n2 = true);
  }, o(e3) {
    Gn(t3.$$.fragment, e3), n2 = false;
  }, d(e3) {
    cr(t3, e3);
  } };
}
function Pm(e2) {
  var t3, n2, r2, o2, a2, i2, s2, l;
  return { c() {
    t3 = ln("div"), n2 = ln("input"), r2 = dn(), (o2 = ln("button")).textContent = "Replace", a2 = dn(), (i2 = ln("button")).textContent = "All", hn(n2, "class", "jse-replace-input svelte-1mxl2uo"), hn(n2, "title", "Enter replacement text"), hn(n2, "type", "text"), hn(n2, "placeholder", "Replace"), hn(o2, "type", "button"), hn(o2, "title", "Replace current occurrence (Ctrl+Enter)"), hn(o2, "class", "svelte-1mxl2uo"), hn(i2, "type", "button"), hn(i2, "title", "Replace all occurrences"), hn(i2, "class", "svelte-1mxl2uo"), hn(t3, "class", "jse-replace-section svelte-1mxl2uo");
  }, m(c, u) {
    on(c, t3, u), nn(t3, n2), $n(n2, e2[5]), nn(t3, r2), nn(t3, o2), nn(t3, a2), nn(t3, i2), s2 || (l = [pn(n2, "input", e2[28]), pn(n2, "keydown", e2[11]), pn(o2, "click", e2[13]), pn(i2, "click", e2[14])], s2 = true);
  }, p(e3, t4) {
    32 & t4[0] && n2.value !== e3[5] && $n(n2, e3[5]);
  }, d(e3) {
    e3 && an(t3), s2 = false, Dt(l);
  } };
}
function Im(e2) {
  var t3, n2, r2 = e2[1] && qm(e2);
  return { c() {
    r2 && r2.c(), t3 = vn();
  }, m(e3, o2) {
    r2 && r2.m(e3, o2), on(e3, t3, o2), n2 = true;
  }, p(e3, n3) {
    e3[1] ? r2 ? (r2.p(e3, n3), 2 & n3[0] && Xn(r2, 1)) : ((r2 = qm(e3)).c(), Xn(r2, 1), r2.m(t3.parentNode, t3)) : r2 && (Kn(), Gn(r2, 1, 1, () => {
      r2 = null;
    }), Zn());
  }, i(e3) {
    n2 || (Xn(r2), n2 = true);
  }, o(e3) {
    Gn(r2), n2 = false;
  }, d(e3) {
    e3 && an(t3), r2 && r2.d(e3);
  } };
}
function Tm(e2) {
  e2.select();
}
function Am(e2, t3, n2) {
  var r2, a2, s2, l, d = vr("jsoneditor:SearchBox"), { json: v } = t3, { documentState: p } = t3, { parser: f } = t3, { showSearch: m3 } = t3, { showReplace: h2 } = t3, { readOnly: g } = t3, { columns: j } = t3, { onSearch: x } = t3, { onFocus: b2 } = t3, { onPatch: y } = t3, { onClose: $2 } = t3, w = "", C3 = "", k2 = "", S4 = false, O = debounce_default(function(e3) {
    return H2.apply(this, arguments);
  }, 300), z3 = debounce_default(function(e3) {
    return _2.apply(this, arguments);
  }, 300);
  function q2() {
    n2(0, h2 = !h2 && !g);
  }
  function M3() {
    return (M3 = o(function* () {
      yield Ln(), setTimeout(() => O.flush());
    })).apply(this, arguments);
  }
  function R3() {
    return T3.apply(this, arguments);
  }
  function T3() {
    return (T3 = o(function* () {
      var e3;
      if (!g) {
        var t4 = null === (e3 = l) || void 0 === e3 ? void 0 : e3.activeItem;
        if (d("handleReplace", { replaceText: k2, activeItem: t4 }), l && t4 && void 0 !== v) {
          n2(26, l = i(i({}, ul(l)), {}, { activeIndex: a2 }));
          var { operations: r3, newSelection: o2 } = ml(v, p, k2, t4, f);
          y(r3, (e4, t5) => ({ state: t5, selection: o2 })), yield Ln(), yield z3.flush(), yield L3();
        }
      }
    })).apply(this, arguments);
  }
  function A() {
    return A = o(function* () {
      if (!g) {
        d("handleReplaceAll", { text: w, replaceText: k2 });
        var { operations: e3, newSelection: t4 } = function(e4, t5, n3, r3, o2) {
          for (var a3 = dl(n3, e4, { maxResults: 1 / 0 }), i2 = [], s3 = 0; s3 < a3.length; s3++) {
            var l2 = a3[s3 - 1], d2 = a3[s3];
            0 !== s3 && d2.field === l2.field && isEqual_default(d2.path, l2.path) ? last_default(i2).items.push(d2) : i2.push({ path: d2.path, field: d2.field, items: [d2] });
          }
          i2.sort((e5, t6) => e5.field !== t6.field ? e5.field === fo.key ? 1 : -1 : t6.path.length - e5.path.length);
          var v2, p2 = [];
          return i2.forEach((n4) => {
            var { field: a4, path: i3, items: s4 } = n4;
            if (a4 === fo.key) {
              var l3 = initial_default(i3), d3 = getIn(e4, l3), f2 = last_default(i3), m4 = tl(l3, Object.keys(d3), f2, fl(f2, r3, s4));
              p2 = p2.concat(m4), v2 = bs(e4, m4);
            } else {
              if (a4 !== fo.value) throw new Error("Cannot replace: unknown type of search result field ".concat(a4));
              var h3 = getIn(e4, i3);
              if (void 0 === h3) throw new Error("Cannot replace: path not found ".concat(compileJSONPointer(i3)));
              var g2 = "string" == typeof h3 ? h3 : String(h3), j2 = Yi(e4, t5, i3), x2 = fl(g2, r3, s4), b3 = [{ op: "replace", path: compileJSONPointer(i3), value: j2 ? x2 : Mr(x2, o2) }];
              p2 = p2.concat(b3), v2 = bs(e4, b3);
            }
          }), { operations: p2, newSelection: v2 };
        }(v, p, w, k2, f);
        y(e3, (e4, n3) => ({ state: n3, selection: t4 })), yield L3();
      }
    }), A.apply(this, arguments);
  }
  function N3() {
    return B3.apply(this, arguments);
  }
  function B3() {
    return (B3 = o(function* () {
      n2(26, l = l ? ul(l) : void 0), yield L3();
    })).apply(this, arguments);
  }
  function F3() {
    return U3.apply(this, arguments);
  }
  function U3() {
    return (U3 = o(function* () {
      n2(26, l = l ? function(e3) {
        var t4 = e3.activeIndex > 0 ? e3.activeIndex - 1 : e3.items.length - 1, n3 = e3.items[t4], r3 = e3.items.map((e4, n4) => i(i({}, e4), {}, { active: n4 === t4 }));
        return i(i({}, e3), {}, { items: r3, activeItem: n3, activeIndex: t4 });
      }(l) : void 0), yield L3();
    })).apply(this, arguments);
  }
  function L3() {
    return J3.apply(this, arguments);
  }
  function J3() {
    return (J3 = o(function* () {
      var e3;
      d("handleFocus", l);
      var t4 = null === (e3 = l) || void 0 === e3 ? void 0 : e3.activeItem;
      t4 && void 0 !== v && (yield b2(t4.path));
    })).apply(this, arguments);
  }
  function V() {
    return V = o(function* (e3) {
      yield W3(e3, w, v);
    }), V.apply(this, arguments);
  }
  function H2() {
    return H2 = o(function* (e3) {
      yield W3(m3, e3, v), yield L3();
    }), H2.apply(this, arguments);
  }
  function _2() {
    return _2 = o(function* (e3) {
      yield W3(m3, w, e3);
    }), _2.apply(this, arguments);
  }
  function W3(e3, t4, n3) {
    return Q2.apply(this, arguments);
  }
  function Q2() {
    return Q2 = o(function* (e3, t4, r3) {
      return e3 ? (d("applySearch", { showSearch: e3, text: t4 }), "" === t4 ? (d("clearing search result"), void 0 !== l && n2(26, l = void 0), Promise.resolve()) : (C3 = t4, n2(6, S4 = true), new Promise((e4) => {
        setTimeout(() => {
          var o2 = dl(t4, r3, { maxResults: La, columns: j });
          n2(26, l = function(e5, t5) {
            var n3 = null != t5 && t5.activeItem ? hl(t5.activeItem) : void 0, r4 = e5.findIndex((e6) => isEqual_default(n3, hl(e6))), o3 = -1 !== r4 ? r4 : void 0 !== (null == t5 ? void 0 : t5.activeIndex) && (null == t5 ? void 0 : t5.activeIndex) < e5.length ? null == t5 ? void 0 : t5.activeIndex : e5.length > 0 ? 0 : -1, a3 = e5.map((e6, t6) => i(i({}, e6), {}, { active: t6 === o3 }));
            return { items: a3, activeItem: a3[o3], activeIndex: o3 };
          }(o2, l)), n2(6, S4 = false), e4();
        });
      }))) : (l && n2(26, l = void 0), Promise.resolve());
    }), Q2.apply(this, arguments);
  }
  function Y2() {
    d("handleClose"), O.cancel(), z3.cancel(), W3(false, w, v), $2();
  }
  return e2.$$set = (e3) => {
    "json" in e3 && n2(18, v = e3.json), "documentState" in e3 && n2(19, p = e3.documentState), "parser" in e3 && n2(20, f = e3.parser), "showSearch" in e3 && n2(1, m3 = e3.showSearch), "showReplace" in e3 && n2(0, h2 = e3.showReplace), "readOnly" in e3 && n2(2, g = e3.readOnly), "columns" in e3 && n2(21, j = e3.columns), "onSearch" in e3 && n2(22, x = e3.onSearch), "onFocus" in e3 && n2(23, b2 = e3.onFocus), "onPatch" in e3 && n2(24, y = e3.onPatch), "onClose" in e3 && n2(25, $2 = e3.onClose);
  }, e2.$$.update = () => {
    var t4, o2;
    67108864 & e2.$$.dirty[0] && n2(4, r2 = (null === (t4 = l) || void 0 === t4 || null === (t4 = t4.items) || void 0 === t4 ? void 0 : t4.length) || 0);
    67108864 & e2.$$.dirty[0] && n2(7, a2 = (null === (o2 = l) || void 0 === o2 ? void 0 : o2.activeIndex) || 0);
    16 & e2.$$.dirty[0] && n2(8, s2 = r2 >= La ? "".concat(999, "+") : String(r2)), 71303168 & e2.$$.dirty[0] && x(l), 2 & e2.$$.dirty[0] && function(e3) {
      V.apply(this, arguments);
    }(m3), 8 & e2.$$.dirty[0] && O(w), 262144 & e2.$$.dirty[0] && z3(v);
  }, [h2, m3, g, w, r2, k2, S4, a2, s2, q2, function(e3) {
    e3.stopPropagation();
    var t4 = Do(e3);
    "Enter" === t4 && (e3.preventDefault(), w !== C3 ? O.flush() : N3()), "Shift+Enter" === t4 && (e3.preventDefault(), F3()), "Ctrl+Enter" === t4 && (e3.preventDefault(), h2 ? R3() : N3()), "Ctrl+H" === t4 && (e3.preventDefault(), q2()), "Escape" === t4 && (e3.preventDefault(), Y2());
  }, function(e3) {
    "Enter" === Do(e3) && (e3.preventDefault(), e3.stopPropagation(), R3());
  }, function() {
    return M3.apply(this, arguments);
  }, R3, function() {
    return A.apply(this, arguments);
  }, N3, F3, Y2, v, p, f, j, x, b2, y, $2, l, function() {
    w = this.value, n2(3, w);
  }, function() {
    k2 = this.value, n2(5, k2);
  }];
}
var Nm = class extends dr {
  constructor(e2) {
    super(), ur(this, e2, Am, Im, Ht, { json: 18, documentState: 19, parser: 20, showSearch: 1, showReplace: 0, readOnly: 2, columns: 21, onSearch: 22, onFocus: 23, onPatch: 24, onClose: 25 }, zm, [-1, -1]);
  }
};
var Bm = Symbol("path");
function Fm(e2, t3) {
  var n2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1 / 0, r2 = {};
  Array.isArray(e2) && function(e3, t4, n3) {
    if (e3.length < t4) e3.forEach(n3);
    else for (var r3 = t4 > 1 ? (e3.length - 1) / (t4 - 1) : e3.length, o3 = 0; o3 < t4; o3++) {
      var a2 = Math.floor(o3 * r3);
      n3(e3[a2], a2, e3);
    }
  }(e2, n2, (e3) => {
    br(e3) ? Um(e3, r2, t3) : r2[Bm] = true;
  });
  var o2 = [];
  return Bm in r2 && o2.push([]), Lm(r2, [], o2, t3), o2;
}
function Um(e2, t3, n2) {
  for (var r2 in e2) {
    var o2 = e2[r2], a2 = t3[r2] || (t3[r2] = {});
    br(o2) && n2 ? Um(o2, a2, n2) : void 0 === a2[Bm] && (a2[Bm] = true);
  }
}
function Lm(e2, t3, n2, r2) {
  for (var o2 in e2) {
    var a2 = t3.concat(o2), i2 = e2[o2];
    i2 && true === i2[Bm] && n2.push(a2), isJSONObject(i2) && r2 && Lm(i2, a2, n2, r2);
  }
}
function Dm(e2, t3, n2, r2, o2, a2) {
  for (var i2 = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : 80, s2 = isJSONArray(n2) ? n2.length : 0, l = function(e3, t4) {
    var n3 = Object.values(e3);
    if (isEmpty_default(n3)) return t4;
    var r3 = (e4, t5) => e4 + t5;
    return n3.reduce(r3) / n3.length;
  }(r2, o2), c = e2 - i2, u = t3 + 2 * i2, d = (e3) => r2[e3] || o2, v = 0, p = a2; p < c && v < s2; ) p += d(v), v++;
  v > 0 && (p -= d(--v));
  for (var f = v, m3 = 0; m3 < u && f < s2; ) m3 += d(f), f++;
  for (var h2 = 0, g = f; g < s2; g++) h2 += d(g);
  return { startIndex: v, endIndex: f, startHeight: p, endHeight: h2, averageItemHeight: l, visibleHeight: m3, visibleItems: isJSONArray(n2) ? n2.slice(v, f) : [] };
}
function Jm(e2, t3, n2, r2) {
  for (var { rowIndex: o2 } = Vm(e2, t3), a2 = 0, i2 = 0; i2 < o2; i2++) a2 += n2[i2] || r2;
  return a2;
}
function Vm(e2, t3) {
  var [n2, ...r2] = e2, o2 = parseInt(n2, 10);
  return { rowIndex: isNaN(o2) ? -1 : o2, columnIndex: t3.findIndex((e3) => Cs(r2, e3)) };
}
function Hm(e2, t3) {
  var { rowIndex: n2, columnIndex: r2 } = e2;
  return [String(n2), ...t3[r2]];
}
function _m(e2, t3) {
  var [n2, r2] = partition_default(e2, (e3) => jr(e3.path[0])), o2 = groupBy_default(n2, Qm), a2 = mapValues_default(o2, (e3) => {
    var n3 = { row: [], columns: {} };
    return e3.forEach((e4) => {
      var r3 = function(e5, t4) {
        var n4 = Vm(e5.path, t4);
        if (-1 !== n4.columnIndex) return n4.columnIndex;
        return -1;
      }(e4, t3);
      -1 !== r3 ? (void 0 === n3.columns[r3] && (n3.columns[r3] = []), n3.columns[r3].push(e4)) : n3.row.push(e4);
    }), n3;
  });
  return { root: r2, rows: a2 };
}
function Wm(e2, t3) {
  if (t3 && 0 !== t3.length) return 1 === t3.length ? t3[0] : { path: e2, message: "Multiple validation issues: " + t3.map((e3) => _l(e3.path) + " " + e3.message).join(", "), severity: po.warning };
}
function Qm(e2) {
  return parseInt(e2.path[0], 10);
}
function Ym(e2, t3, n2) {
  var r2 = t3.some((t4) => function(e3, t5, n3) {
    if (!e3) return false;
    if ("replace" === t5.op) {
      var r3 = parseJSONPointer(t5.path), { rowIndex: o2, columnIndex: a2 } = Vm(r3, n3), i2 = n3.findIndex((t6) => isEqual_default(t6, e3.path));
      if (-1 !== o2 && -1 !== a2 && a2 !== i2) return false;
    }
    return true;
  }(e2, t4, n2));
  return r2 ? void 0 : e2;
}
var Km = vr("jsoneditor:actions");
function Zm(e2) {
  return Xm.apply(this, arguments);
}
function Xm() {
  return Xm = o(function* (e2) {
    var { json: t3, selection: n2, indentation: r2, readOnly: o2, parser: a2, onPatch: i2 } = e2;
    if (!o2 && void 0 !== t3 && n2 && Ts(n2)) {
      var s2 = Ps(t3, n2, r2, a2);
      if (void 0 !== s2) {
        Km("cut", { selection: n2, clipboard: s2, indentation: r2 }), yield vm(s2);
        var { operations: l, newSelection: c } = sl(t3, n2);
        i2(l, (e3, t4) => ({ state: t4, selection: c }));
      }
    }
  }), Xm.apply(this, arguments);
}
function Gm(e2) {
  return eh.apply(this, arguments);
}
function eh() {
  return eh = o(function* (e2) {
    var { json: t3, selection: n2, indentation: r2, parser: o2 } = e2, a2 = Ps(t3, n2, r2, o2);
    void 0 !== a2 && (Km("copy", { clipboard: a2, indentation: r2 }), yield vm(a2));
  }), eh.apply(this, arguments);
}
function th(e2) {
  var { clipboardText: t3, json: n2, selection: r2, readOnly: o2, parser: a2, onPatch: i2, onChangeText: s2, openRepairModal: l } = e2;
  if (!o2) try {
    c(t3);
  } catch (e3) {
    l(t3, (e4) => {
      Km("repaired pasted text: ", e4), c(e4);
    });
  }
  function c(e3) {
    if (void 0 !== n2) {
      var o3 = r2 || zs([]), l2 = rl(n2, o3, e3, a2);
      Km("paste", { pastedText: e3, operations: l2, ensureSelection: o3 }), i2(l2, (e4, t4) => {
        var r3 = t4;
        return l2.filter((e5) => (isJSONPatchAdd(e5) || isJSONPatchReplace(e5)) && yr(e5.value)).forEach((t5) => {
          var o4 = parsePath(n2, t5.path);
          r3 = es(e4, r3, o4);
        }), { state: r3 };
      });
    } else Km("paste text", { pastedText: e3 }), s2(t3, (e4, t4) => {
      if (e4) {
        return { state: es(e4, t4, []) };
      }
    });
  }
}
function nh(e2) {
  var { json: t3, text: n2, selection: r2, keepSelection: o2, readOnly: a2, onChange: i2, onPatch: s2 } = e2;
  if (!a2 && r2) {
    var l = void 0 !== t3 && (ss(r2) || ls(r2)) ? Es(r2.path, r2.path) : r2;
    if (isEmpty_default(Ds(r2))) Km("remove root", { selection: r2 }), i2 && i2({ text: "", json: void 0 }, void 0 !== t3 ? { text: void 0, json: t3 } : { text: n2 || "", json: t3 }, { contentErrors: void 0, patchResult: void 0 });
    else if (void 0 !== t3) {
      var { operations: c, newSelection: u } = sl(t3, l);
      Km("remove", { operations: c, selection: r2, newSelection: u }), s2(c, (e3, t4) => ({ state: t4, selection: o2 ? r2 : u }));
    }
  }
}
function rh(e2) {
  var { json: t3, selection: n2, columns: r2, readOnly: o2, onPatch: a2 } = e2;
  if (!o2 && void 0 !== t3 && n2 && Ts(n2)) {
    var { rowIndex: i2, columnIndex: s2 } = Vm(Ds(n2), r2);
    Km("duplicate row", { rowIndex: i2 });
    var l = [String(i2)];
    a2(nl(t3, [l]), (e3, n3) => ({ state: n3, selection: zs(Hm({ rowIndex: i2 < t3.length ? i2 + 1 : i2, columnIndex: s2 }, r2)) }));
  }
}
function oh(e2) {
  var { json: t3, selection: n2, columns: r2, readOnly: o2, onPatch: a2 } = e2;
  if (!o2 && void 0 !== t3 && n2 && Ts(n2)) {
    var { rowIndex: i2 } = Vm(Ds(n2), r2);
    Km("insert before row", { rowIndex: i2 }), a2(Gs(t3, [String(i2)], [{ key: "", value: isJSONObject(t3[0]) ? {} : "" }]));
  }
}
function ah(e2) {
  var { json: t3, selection: n2, columns: r2, readOnly: o2, onPatch: a2 } = e2;
  if (!o2 && void 0 !== t3 && n2 && Ts(n2)) {
    var { rowIndex: i2, columnIndex: s2 } = Vm(Ds(n2), r2);
    Km("insert after row", { rowIndex: i2 });
    var l = i2 + 1, c = [String(l)], u = [{ key: "", value: isJSONObject(t3[0]) ? {} : "" }];
    a2(l < t3.length ? Gs(t3, c, u) : el(t3, [], u), (e3, t4) => ({ state: t4, selection: zs(Hm({ rowIndex: l, columnIndex: s2 }, r2)) }));
  }
}
function ih(e2) {
  var { json: t3, selection: n2, columns: r2, readOnly: o2, onPatch: a2 } = e2;
  if (!o2 && void 0 !== t3 && n2 && Ts(n2)) {
    var { rowIndex: i2, columnIndex: s2 } = Vm(Ds(n2), r2);
    Km("remove row", { rowIndex: i2 }), a2(ol([[String(i2)]]), (e3, t4) => {
      var n3 = i2 < e3.length ? i2 : i2 > 0 ? i2 - 1 : void 0, o3 = void 0 !== n3 ? zs(Hm({ rowIndex: n3, columnIndex: s2 }, r2)) : void 0;
      return Km("remove row new selection", { rowIndex: i2, newRowIndex: n3, newSelection: o3 }), { state: t4, selection: o3 };
    });
  }
}
function sh(e2) {
  var { insertType: t3, selectInside: n2, initialValue: r2, json: o2, selection: a2, readOnly: i2, parser: s2, onPatch: l, onReplaceJson: c } = e2;
  if (!i2) {
    var d = function(e3, t4, n3) {
      if ("object" === n3) return {};
      if ("array" === n3) return [];
      if ("structure" === n3 && void 0 !== e3) {
        var r3 = t4 ? fs(t4) : [], o3 = getIn(e3, r3);
        if (Array.isArray(o3) && !isEmpty_default(o3)) {
          var a3 = head_default(o3);
          return yr(a3) ? cloneDeepWith_default(a3, (e4) => Array.isArray(e4) ? [] : br(e4) ? void 0 : "") : "";
        }
      }
      return "";
    }(o2, a2, t3);
    if (void 0 !== o2) {
      var v = s2.stringify(d), p = rl(o2, a2, v, s2);
      Km("onInsert", { insertType: t3, operations: p, newValue: d, data: v });
      var f = last_default(p.filter((e3) => "add" === e3.op || "replace" === e3.op));
      l(p, (e3, t4, o3) => {
        if (f) {
          var a3 = parsePath(e3, f.path);
          if (yr(d)) return { state: Ni(e3, t4, a3, rs), selection: n2 ? Ms(a3) : o3 };
          if ("" === d) {
            var i3 = isEmpty_default(a3) ? void 0 : getIn(e3, initial_default(a3));
            return { state: Ni(e3, t4, a3, os), selection: br(i3) ? Os(a3, r2) : qs(a3, r2) };
          }
        }
      }), Km("after patch");
    } else {
      Km("onInsert", { insertType: t3, newValue: d });
      var m3 = [];
      c(d, (e3, t4) => ({ state: es(e3, t4, m3), selection: yr(d) ? Ms(m3) : qs(m3) }));
    }
  }
}
function lh(e2) {
  return ch.apply(this, arguments);
}
function ch() {
  return ch = o(function* (e2) {
    var { char: t3, selectInside: n2, json: r2, selection: o2, readOnly: a2, parser: s2, onPatch: l, onReplaceJson: c, onSelect: d } = e2;
    a2 || (ss(o2) ? d(i(i({}, o2), {}, { edit: true, initialValue: t3 })) : "{" === t3 ? sh({ insertType: "object", selectInside: n2, initialValue: void 0, json: r2, selection: o2, readOnly: a2, parser: s2, onPatch: l, onReplaceJson: c }) : "[" === t3 ? sh({ insertType: "array", selectInside: n2, initialValue: void 0, json: r2, selection: o2, readOnly: a2, parser: s2, onPatch: l, onReplaceJson: c }) : ls(o2) && void 0 !== r2 ? yr(getIn(r2, o2.path)) || d(i(i({}, o2), {}, { edit: true, initialValue: t3 })) : (Km("onInsertValueWithCharacter", { char: t3 }), yield function(e3) {
      return uh.apply(this, arguments);
    }({ char: t3, json: r2, selection: o2, readOnly: a2, parser: s2, onPatch: l, onReplaceJson: c })));
  }), ch.apply(this, arguments);
}
function uh() {
  return uh = o(function* (e2) {
    var { char: t3, json: n2, selection: r2, readOnly: o2, parser: a2, onPatch: i2, onReplaceJson: s2 } = e2;
    o2 || sh({ insertType: "value", selectInside: false, initialValue: t3, json: n2, selection: r2, readOnly: o2, parser: a2, onPatch: i2, onReplaceJson: s2 });
  }), uh.apply(this, arguments);
}
function dh(e2) {
  rn(e2, "svelte-1vjn89h", '.jse-json-preview.svelte-1vjn89h{flex:1;font-family:var(--jse-font-family-mono, consolas, menlo, monaco, "Ubuntu Mono", "source-code-pro", monospace);font-size:var(--jse-font-size-mono, 14px);color:var(--jse-panel-color-readonly, #b2b2b2);overflow:auto;white-space:pre-wrap;padding:2px;border-left:var(--jse-main-border, 1px solid #d7d7d7);border-right:var(--jse-main-border, 1px solid #d7d7d7);border-bottom:var(--jse-main-border, 1px solid #d7d7d7)}');
}
function vh(e2) {
  var t3, n2;
  return { c() {
    t3 = ln("div"), n2 = un(e2[0]), hn(t3, "class", "jse-json-preview svelte-1vjn89h");
  }, m(e3, r2) {
    on(e3, t3, r2), nn(t3, n2);
  }, p(e3, t4) {
    var [r2] = t4;
    1 & r2 && yn(n2, e3[0]);
  }, i: Bt, o: Bt, d(e3) {
    e3 && an(t3);
  } };
}
function ph(e2, t3, n2) {
  var r2, o2, { text: a2 } = t3, { json: i2 } = t3, { indentation: s2 } = t3, { parser: l } = t3;
  return e2.$$set = (e3) => {
    "text" in e3 && n2(1, a2 = e3.text), "json" in e3 && n2(2, i2 = e3.json), "indentation" in e3 && n2(3, s2 = e3.indentation), "parser" in e3 && n2(4, l = e3.parser);
  }, e2.$$.update = () => {
    6 & e2.$$.dirty && n2(5, r2 = void 0 !== i2 ? { json: i2 } : { text: a2 || "" }), 56 & e2.$$.dirty && n2(0, o2 = aa(to(r2, s2, l), Va));
  }, [o2, a2, i2, s2, l, r2];
}
var fh = class extends dr {
  constructor(e2) {
    super(), ur(this, e2, ph, vh, Vt, { text: 1, json: 2, indentation: 3, parser: 4 }, dh);
  }
};
function mh(e2) {
  rn(e2, "svelte-1idfykj", 'button.jse-context-menu-button.svelte-1idfykj{border:none;background:transparent;color:inherit;cursor:pointer;font-family:var(--jse-font-family, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif);font-size:var(--jse-font-size, 16px);padding:5px;margin:0;flex:1;white-space:nowrap;padding:var(--jse-padding, 10px);color:inherit}button.jse-context-menu-button.svelte-1idfykj:hover{background:var(--jse-context-menu-background-highlight, #7a7a7a)}button.jse-context-menu-button.svelte-1idfykj:focus{background:var(--jse-context-menu-background-highlight, #7a7a7a);z-index:1}button.jse-context-menu-button.svelte-1idfykj:disabled{color:var(--jse-context-menu-color-disabled, #9d9d9d);background:unset}button.jse-context-menu-button.left.svelte-1idfykj{text-align:left}button.jse-context-menu-button.svelte-1idfykj svg{width:16px}');
}
function hh(e2) {
  var t3, n2;
  return t3 = new Ca({ props: { data: e2[0].icon } }), { c() {
    sr(t3.$$.fragment);
  }, m(e3, r2) {
    lr(t3, e3, r2), n2 = true;
  }, p(e3, n3) {
    var r2 = {};
    1 & n3 && (r2.data = e3[0].icon), t3.$set(r2);
  }, i(e3) {
    n2 || (Xn(t3.$$.fragment, e3), n2 = true);
  }, o(e3) {
    Gn(t3.$$.fragment, e3), n2 = false;
  }, d(e3) {
    cr(t3, e3);
  } };
}
function gh(e2) {
  var t3, n2 = e2[0].text + "";
  return { c() {
    t3 = un(n2);
  }, m(e3, n3) {
    on(e3, t3, n3);
  }, p(e3, r2) {
    1 & r2 && n2 !== (n2 = e3[0].text + "") && yn(t3, n2);
  }, d(e3) {
    e3 && an(t3);
  } };
}
function jh(e2) {
  var t3, n2, r2, o2, a2, i2, s2, l, c = e2[0].icon && hh(e2), u = e2[0].text && gh(e2);
  return { c() {
    t3 = ln("button"), c && c.c(), n2 = dn(), u && u.c(), hn(t3, "type", "button"), hn(t3, "class", r2 = Gt(Vs("jse-context-menu-button", e2[1], e2[0].className)) + " svelte-1idfykj"), hn(t3, "title", o2 = e2[0].title), t3.disabled = a2 = e2[0].disabled || false;
  }, m(r3, o3) {
    on(r3, t3, o3), c && c.m(t3, null), nn(t3, n2), u && u.m(t3, null), i2 = true, s2 || (l = pn(t3, "click", e2[3]), s2 = true);
  }, p(e3, s3) {
    var [l2] = s3;
    e3[0].icon ? c ? (c.p(e3, l2), 1 & l2 && Xn(c, 1)) : ((c = hh(e3)).c(), Xn(c, 1), c.m(t3, n2)) : c && (Kn(), Gn(c, 1, 1, () => {
      c = null;
    }), Zn()), e3[0].text ? u ? u.p(e3, l2) : ((u = gh(e3)).c(), u.m(t3, null)) : u && (u.d(1), u = null), (!i2 || 3 & l2 && r2 !== (r2 = Gt(Vs("jse-context-menu-button", e3[1], e3[0].className)) + " svelte-1idfykj")) && hn(t3, "class", r2), (!i2 || 1 & l2 && o2 !== (o2 = e3[0].title)) && hn(t3, "title", o2), (!i2 || 1 & l2 && a2 !== (a2 = e3[0].disabled || false)) && (t3.disabled = a2);
  }, i(e3) {
    i2 || (Xn(c), i2 = true);
  }, o(e3) {
    Gn(c), i2 = false;
  }, d(e3) {
    e3 && an(t3), c && c.d(), u && u.d(), s2 = false, l();
  } };
}
function xh(e2, t3, n2) {
  var { item: r2 } = t3, { className: o2 } = t3, { onRequestClose: a2 } = t3;
  return e2.$$set = (e3) => {
    "item" in e3 && n2(0, r2 = e3.item), "className" in e3 && n2(1, o2 = e3.className), "onRequestClose" in e3 && n2(2, a2 = e3.onRequestClose);
  }, [r2, o2, a2, (e3) => {
    a2(), r2.onClick(e3);
  }];
}
var bh = class extends dr {
  constructor(e2) {
    super(), ur(this, e2, xh, jh, Vt, { item: 0, className: 1, onRequestClose: 2 }, mh);
  }
};
function yh(e2) {
  rn(e2, "svelte-11rxb2m", '.jse-dropdown-button.svelte-11rxb2m.svelte-11rxb2m{flex:1;line-height:normal;border:none;background:transparent;color:inherit;cursor:pointer;font-family:var(--jse-font-family, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif);font-size:var(--jse-font-size, 16px);padding:5px;margin:0;position:relative;padding:0;display:flex}.jse-dropdown-button.svelte-11rxb2m ul.svelte-11rxb2m{margin:0;padding:0}.jse-dropdown-button.svelte-11rxb2m ul li.svelte-11rxb2m{margin:0;padding:0;list-style-type:none}.jse-dropdown-button.svelte-11rxb2m button.jse-open-dropdown.svelte-11rxb2m{border:none;background:transparent;color:inherit;cursor:pointer;font-family:var(--jse-font-family, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif);font-size:var(--jse-font-size, 16px);padding:5px;margin:0;width:2em;background:var(--jse-context-menu-background, #656565);color:var(--jse-context-menu-color, var(--jse-text-color-inverse, #fff));border-radius:0}.jse-dropdown-button.svelte-11rxb2m button.jse-open-dropdown.jse-visible.svelte-11rxb2m{background:var(--jse-context-menu-background, #656565)}.jse-dropdown-button.svelte-11rxb2m button.jse-open-dropdown.svelte-11rxb2m:hover{background:var(--jse-context-menu-background-highlight, #7a7a7a)}.jse-dropdown-button.svelte-11rxb2m button.jse-open-dropdown.svelte-11rxb2m:focus{z-index:1}.jse-dropdown-button.svelte-11rxb2m button.jse-open-dropdown.svelte-11rxb2m:disabled{color:var(--jse-context-menu-color-disabled, #9d9d9d);background:unset}.jse-dropdown-button.svelte-11rxb2m .jse-dropdown-items.svelte-11rxb2m{display:none;position:absolute;top:100%;left:0;z-index:1;background:var(--jse-context-menu-background, #656565);color:var(--jse-context-menu-color, var(--jse-text-color-inverse, #fff));box-shadow:var(--jse-controls-box-shadow, 0 2px 6px 0 rgba(0, 0, 0, 0.24))}.jse-dropdown-button.svelte-11rxb2m .jse-dropdown-items.jse-visible.svelte-11rxb2m{display:block}.jse-dropdown-button.svelte-11rxb2m .jse-dropdown-items button.svelte-11rxb2m{border:none;background:transparent;color:inherit;cursor:pointer;font-family:var(--jse-font-family, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif);font-size:var(--jse-font-size, 16px);padding:5px;margin:0;width:100%;text-align:left;padding:var(--jse-padding, 10px);margin:0}.jse-dropdown-button.svelte-11rxb2m .jse-dropdown-items button.svelte-11rxb2m:hover{background:var(--jse-context-menu-background-highlight, #7a7a7a)}.jse-dropdown-button.svelte-11rxb2m .jse-dropdown-items button.svelte-11rxb2m:disabled{color:var(--jse-context-menu-color-disabled, #9d9d9d);background:unset}');
}
function $h(e2, t3, n2) {
  var r2 = e2.slice();
  return r2[11] = t3[n2], r2;
}
var wh = (e2) => ({});
var Ch = (e2) => ({});
function kh(e2) {
  var t3, n2;
  return t3 = new Ca({ props: { data: e2[11].icon } }), { c() {
    sr(t3.$$.fragment);
  }, m(e3, r2) {
    lr(t3, e3, r2), n2 = true;
  }, p(e3, n3) {
    var r2 = {};
    1 & n3 && (r2.data = e3[11].icon), t3.$set(r2);
  }, i(e3) {
    n2 || (Xn(t3.$$.fragment, e3), n2 = true);
  }, o(e3) {
    Gn(t3.$$.fragment, e3), n2 = false;
  }, d(e3) {
    cr(t3, e3);
  } };
}
function Sh(e2) {
  var t3, n2, r2, o2, a2, i2, s2, l, c, u, d, v = e2[11].text + "", p = e2[11].icon && kh(e2);
  function f() {
    for (var t4 = arguments.length, n3 = new Array(t4), r3 = 0; r3 < t4; r3++) n3[r3] = arguments[r3];
    return e2[9](e2[11], ...n3);
  }
  return { c() {
    t3 = ln("li"), n2 = ln("button"), p && p.c(), r2 = dn(), o2 = un(v), l = dn(), hn(n2, "type", "button"), hn(n2, "title", a2 = e2[11].title), n2.disabled = i2 = e2[11].disabled, hn(n2, "class", s2 = Gt(e2[11].className) + " svelte-11rxb2m"), hn(t3, "class", "svelte-11rxb2m");
  }, m(e3, a3) {
    on(e3, t3, a3), nn(t3, n2), p && p.m(n2, null), nn(n2, r2), nn(n2, o2), nn(t3, l), c = true, u || (d = pn(n2, "click", f), u = true);
  }, p(t4, l2) {
    (e2 = t4)[11].icon ? p ? (p.p(e2, l2), 1 & l2 && Xn(p, 1)) : ((p = kh(e2)).c(), Xn(p, 1), p.m(n2, r2)) : p && (Kn(), Gn(p, 1, 1, () => {
      p = null;
    }), Zn()), (!c || 1 & l2) && v !== (v = e2[11].text + "") && yn(o2, v), (!c || 1 & l2 && a2 !== (a2 = e2[11].title)) && hn(n2, "title", a2), (!c || 1 & l2 && i2 !== (i2 = e2[11].disabled)) && (n2.disabled = i2), (!c || 1 & l2 && s2 !== (s2 = Gt(e2[11].className) + " svelte-11rxb2m")) && hn(n2, "class", s2);
  }, i(e3) {
    c || (Xn(p), c = true);
  }, o(e3) {
    Gn(p), c = false;
  }, d(e3) {
    e3 && an(t3), p && p.d(), u = false, d();
  } };
}
function Oh(e2) {
  var t3, n2, r2, o2, a2, i2, s2, l, c, u, d = e2[8].defaultItem, v = _t(d, e2, e2[7], Ch);
  o2 = new Ca({ props: { data: faCaretDown } });
  for (var p = er(e2[0]), f = [], m3 = 0; m3 < p.length; m3 += 1) f[m3] = Sh($h(e2, p, m3));
  var h2 = (e3) => Gn(f[e3], 1, 1, () => {
    f[e3] = null;
  });
  return { c() {
    t3 = ln("div"), v && v.c(), n2 = dn(), r2 = ln("button"), sr(o2.$$.fragment), a2 = dn(), i2 = ln("div"), s2 = ln("ul");
    for (var l2 = 0; l2 < f.length; l2 += 1) f[l2].c();
    hn(r2, "type", "button"), hn(r2, "class", "jse-open-dropdown svelte-11rxb2m"), hn(r2, "data-type", "jse-open-dropdown"), r2.disabled = e2[4], kn(r2, "jse-visible", e2[3]), hn(s2, "class", "svelte-11rxb2m"), hn(i2, "class", "jse-dropdown-items svelte-11rxb2m"), wn(i2, "width", e2[2]), kn(i2, "jse-visible", e2[3]), hn(t3, "role", "button"), hn(t3, "tabindex", "0"), hn(t3, "class", "jse-dropdown-button svelte-11rxb2m"), hn(t3, "title", e2[1]);
  }, m(d2, p2) {
    on(d2, t3, p2), v && v.m(t3, null), nn(t3, n2), nn(t3, r2), lr(o2, r2, null), nn(t3, a2), nn(t3, i2), nn(i2, s2);
    for (var m4 = 0; m4 < f.length; m4 += 1) f[m4] && f[m4].m(s2, null);
    l = true, c || (u = [pn(r2, "click", e2[5]), pn(t3, "click", e2[6])], c = true);
  }, p(e3, n3) {
    var [o3] = n3;
    if (v && v.p && (!l || 128 & o3) && Yt(v, d, e3, e3[7], l ? Qt(d, e3[7], o3, wh) : Kt(e3[7]), Ch), (!l || 16 & o3) && (r2.disabled = e3[4]), (!l || 8 & o3) && kn(r2, "jse-visible", e3[3]), 1 & o3) {
      var a3;
      for (p = er(e3[0]), a3 = 0; a3 < p.length; a3 += 1) {
        var c2 = $h(e3, p, a3);
        f[a3] ? (f[a3].p(c2, o3), Xn(f[a3], 1)) : (f[a3] = Sh(c2), f[a3].c(), Xn(f[a3], 1), f[a3].m(s2, null));
      }
      for (Kn(), a3 = p.length; a3 < f.length; a3 += 1) h2(a3);
      Zn();
    }
    (!l || 4 & o3) && wn(i2, "width", e3[2]), (!l || 8 & o3) && kn(i2, "jse-visible", e3[3]), (!l || 2 & o3) && hn(t3, "title", e3[1]);
  }, i(e3) {
    if (!l) {
      Xn(v, e3), Xn(o2.$$.fragment, e3);
      for (var t4 = 0; t4 < p.length; t4 += 1) Xn(f[t4]);
      l = true;
    }
  }, o(e3) {
    Gn(v, e3), Gn(o2.$$.fragment, e3), f = f.filter(Boolean);
    for (var t4 = 0; t4 < f.length; t4 += 1) Gn(f[t4]);
    l = false;
  }, d(e3) {
    e3 && an(t3), v && v.d(e3), cr(o2), sn(f, e3), c = false, Dt(u);
  } };
}
function zh(e2, t3, n2) {
  var r2, { $$slots: o2 = {}, $$scope: a2 } = t3, { items: i2 = [] } = t3, { title: s2 } = t3, { width: l = "120px" } = t3, c = false;
  function u() {
    n2(3, c = false);
  }
  function d(e3) {
    "Escape" === Do(e3) && (e3.preventDefault(), n2(3, c = false));
  }
  qn(() => {
    document.addEventListener("click", u), document.addEventListener("keydown", d);
  }), Mn(() => {
    document.removeEventListener("click", u), document.removeEventListener("keydown", d);
  });
  return e2.$$set = (e3) => {
    "items" in e3 && n2(0, i2 = e3.items), "title" in e3 && n2(1, s2 = e3.title), "width" in e3 && n2(2, l = e3.width), "$$scope" in e3 && n2(7, a2 = e3.$$scope);
  }, e2.$$.update = () => {
    1 & e2.$$.dirty && n2(4, r2 = i2.every((e3) => true === e3.disabled));
  }, [i2, s2, l, c, r2, function() {
    var e3 = c;
    setTimeout(() => n2(3, c = !e3));
  }, u, a2, o2, (e3, t4) => e3.onClick(t4)];
}
var qh = class extends dr {
  constructor(e2) {
    super(), ur(this, e2, zh, Oh, Ht, { items: 0, title: 1, width: 2 }, yh);
  }
};
function Mh(e2) {
  rn(e2, "svelte-1idfykj", 'button.jse-context-menu-button.svelte-1idfykj{border:none;background:transparent;color:inherit;cursor:pointer;font-family:var(--jse-font-family, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif);font-size:var(--jse-font-size, 16px);padding:5px;margin:0;flex:1;white-space:nowrap;padding:var(--jse-padding, 10px);color:inherit}button.jse-context-menu-button.svelte-1idfykj:hover{background:var(--jse-context-menu-background-highlight, #7a7a7a)}button.jse-context-menu-button.svelte-1idfykj:focus{background:var(--jse-context-menu-background-highlight, #7a7a7a);z-index:1}button.jse-context-menu-button.svelte-1idfykj:disabled{color:var(--jse-context-menu-color-disabled, #9d9d9d);background:unset}button.jse-context-menu-button.left.svelte-1idfykj{text-align:left}button.jse-context-menu-button.svelte-1idfykj svg{width:16px}');
}
function Rh(e2) {
  var t3, n2;
  return t3 = new Ca({ props: { data: e2[0].main.icon } }), { c() {
    sr(t3.$$.fragment);
  }, m(e3, r2) {
    lr(t3, e3, r2), n2 = true;
  }, p(e3, n3) {
    var r2 = {};
    1 & n3 && (r2.data = e3[0].main.icon), t3.$set(r2);
  }, i(e3) {
    n2 || (Xn(t3.$$.fragment, e3), n2 = true);
  }, o(e3) {
    Gn(t3.$$.fragment, e3), n2 = false;
  }, d(e3) {
    cr(t3, e3);
  } };
}
function Eh(e2) {
  var t3, n2, r2, o2, a2, i2, s2, l, c, u = e2[0].main.text + "", d = e2[0].main.icon && Rh(e2);
  return { c() {
    t3 = ln("button"), d && d.c(), n2 = dn(), r2 = un(u), hn(t3, "class", o2 = Gt(Vs("jse-context-menu-button", e2[1], e2[0].main.className)) + " svelte-1idfykj"), hn(t3, "type", "button"), hn(t3, "slot", "defaultItem"), hn(t3, "title", a2 = e2[0].main.title), t3.disabled = i2 = e2[0].main.disabled || false;
  }, m(o3, a3) {
    on(o3, t3, a3), d && d.m(t3, null), nn(t3, n2), nn(t3, r2), s2 = true, l || (c = pn(t3, "click", e2[4]), l = true);
  }, p(e3, l2) {
    e3[0].main.icon ? d ? (d.p(e3, l2), 1 & l2 && Xn(d, 1)) : ((d = Rh(e3)).c(), Xn(d, 1), d.m(t3, n2)) : d && (Kn(), Gn(d, 1, 1, () => {
      d = null;
    }), Zn()), (!s2 || 1 & l2) && u !== (u = e3[0].main.text + "") && yn(r2, u), (!s2 || 3 & l2 && o2 !== (o2 = Gt(Vs("jse-context-menu-button", e3[1], e3[0].main.className)) + " svelte-1idfykj")) && hn(t3, "class", o2), (!s2 || 1 & l2 && a2 !== (a2 = e3[0].main.title)) && hn(t3, "title", a2), (!s2 || 1 & l2 && i2 !== (i2 = e3[0].main.disabled || false)) && (t3.disabled = i2);
  }, i(e3) {
    s2 || (Xn(d), s2 = true);
  }, o(e3) {
    Gn(d), s2 = false;
  }, d(e3) {
    e3 && an(t3), d && d.d(), l = false, c();
  } };
}
function Ph(e2) {
  var t3, n2;
  return t3 = new qh({ props: { width: e2[0].width, items: e2[3], $$slots: { defaultItem: [Eh] }, $$scope: { ctx: e2 } } }), { c() {
    sr(t3.$$.fragment);
  }, m(e3, r2) {
    lr(t3, e3, r2), n2 = true;
  }, p(e3, n3) {
    var [r2] = n3, o2 = {};
    1 & r2 && (o2.width = e3[0].width), 8 & r2 && (o2.items = e3[3]), 39 & r2 && (o2.$$scope = { dirty: r2, ctx: e3 }), t3.$set(o2);
  }, i(e3) {
    n2 || (Xn(t3.$$.fragment, e3), n2 = true);
  }, o(e3) {
    Gn(t3.$$.fragment, e3), n2 = false;
  }, d(e3) {
    cr(t3, e3);
  } };
}
function Ih(e2, t3, n2) {
  var r2, { item: o2 } = t3, { className: a2 } = t3, { onRequestClose: s2 } = t3;
  return e2.$$set = (e3) => {
    "item" in e3 && n2(0, o2 = e3.item), "className" in e3 && n2(1, a2 = e3.className), "onRequestClose" in e3 && n2(2, s2 = e3.onRequestClose);
  }, e2.$$.update = () => {
    5 & e2.$$.dirty && n2(3, r2 = o2.items.map((e3) => i(i({}, e3), {}, { onClick: (t4) => {
      s2(), e3.onClick(t4);
    } })));
  }, [o2, a2, s2, r2, (e3) => {
    s2(), o2.main.onClick(e3);
  }];
}
var Th = class extends dr {
  constructor(e2) {
    super(), ur(this, e2, Ih, Ph, Vt, { item: 0, className: 1, onRequestClose: 2 }, Mh);
  }
};
function Ah(e2) {
  rn(e2, "svelte-12z7bz1", '.jse-contextmenu.svelte-12z7bz1.svelte-12z7bz1{box-shadow:var(--jse-controls-box-shadow, 0 2px 6px 0 rgba(0, 0, 0, 0.24));font-family:var(--jse-font-family, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif);font-size:var(--jse-font-size, 16px);background:var(--jse-context-menu-background, #656565);color:var(--jse-context-menu-color, var(--jse-text-color-inverse, #fff))}.jse-contextmenu.svelte-12z7bz1 .jse-row.svelte-12z7bz1{display:flex;flex-direction:row;align-items:flex-start;justify-content:stretch}.jse-contextmenu.svelte-12z7bz1 .jse-row div.jse-label.svelte-12z7bz1{flex:1;white-space:nowrap;padding:var(--jse-padding, 10px);color:var(--jse-context-menu-color-disabled, #9d9d9d);line-height:normal}.jse-contextmenu.svelte-12z7bz1 .jse-row div.jse-tip.svelte-12z7bz1{flex:1;background:var(--jse-context-menu-tip-background, rgba(255, 255, 255, 0.2));color:var(--context-menu-tip-color, inherit);margin:calc(0.5 * var(--jse-padding, 10px));padding:calc(0.5 * var(--jse-padding, 10px)) var(--jse-padding, 10px);font-size:80%;line-height:1.3em;display:flex;flex-direction:row;align-items:flex-start;gap:var(--jse-padding, 10px);border-radius:3px}.jse-contextmenu.svelte-12z7bz1 .jse-row div.jse-tip div.jse-tip-icon.svelte-12z7bz1{padding-top:calc(0.5 * var(--jse-padding, 10px))}.jse-contextmenu.svelte-12z7bz1 .jse-column.svelte-12z7bz1{flex:1;display:flex;flex-direction:column;align-items:stretch}.jse-contextmenu.svelte-12z7bz1 .jse-column.svelte-12z7bz1:not(:last-child){border-right:1px solid var(--jse-context-menu-separator-color, #7a7a7a)}.jse-contextmenu.svelte-12z7bz1 .jse-separator.svelte-12z7bz1{width:100%;height:1px;background:var(--jse-context-menu-separator-color, #7a7a7a)}');
}
function Nh(e2, t3, n2) {
  var r2 = e2.slice();
  return r2[7] = t3[n2], r2;
}
function Bh(e2, t3, n2) {
  var r2 = e2.slice();
  return r2[10] = t3[n2], r2;
}
function Fh(e2, t3, n2) {
  var r2 = e2.slice();
  return r2[13] = t3[n2], r2;
}
function Uh(e2) {
  var t3, n2 = ig(e2[7]) + "";
  return { c() {
    t3 = un(n2);
  }, m(e3, n3) {
    on(e3, t3, n3);
  }, p(e3, r2) {
    1 & r2 && n2 !== (n2 = ig(e3[7]) + "") && yn(t3, n2);
  }, i: Bt, o: Bt, d(e3) {
    e3 && an(t3);
  } };
}
function Lh(e2) {
  var t3;
  return { c() {
    hn(t3 = ln("div"), "class", "jse-separator svelte-12z7bz1");
  }, m(e3, n2) {
    on(e3, t3, n2);
  }, p: Bt, i: Bt, o: Bt, d(e3) {
    e3 && an(t3);
  } };
}
function Dh(e2) {
  for (var t3, n2, r2 = er(e2[7].items), o2 = [], a2 = 0; a2 < r2.length; a2 += 1) o2[a2] = ng(Bh(e2, r2, a2));
  var i2 = (e3) => Gn(o2[e3], 1, 1, () => {
    o2[e3] = null;
  });
  return { c() {
    t3 = ln("div");
    for (var e3 = 0; e3 < o2.length; e3 += 1) o2[e3].c();
    hn(t3, "class", "jse-row svelte-12z7bz1");
  }, m(e3, r3) {
    on(e3, t3, r3);
    for (var a3 = 0; a3 < o2.length; a3 += 1) o2[a3] && o2[a3].m(t3, null);
    n2 = true;
  }, p(e3, n3) {
    if (3 & n3) {
      var a3;
      for (r2 = er(e3[7].items), a3 = 0; a3 < r2.length; a3 += 1) {
        var s2 = Bh(e3, r2, a3);
        o2[a3] ? (o2[a3].p(s2, n3), Xn(o2[a3], 1)) : (o2[a3] = ng(s2), o2[a3].c(), Xn(o2[a3], 1), o2[a3].m(t3, null));
      }
      for (Kn(), a3 = r2.length; a3 < o2.length; a3 += 1) i2(a3);
      Zn();
    }
  }, i(e3) {
    if (!n2) {
      for (var t4 = 0; t4 < r2.length; t4 += 1) Xn(o2[t4]);
      n2 = true;
    }
  }, o(e3) {
    o2 = o2.filter(Boolean);
    for (var t4 = 0; t4 < o2.length; t4 += 1) Gn(o2[t4]);
    n2 = false;
  }, d(e3) {
    e3 && an(t3), sn(o2, e3);
  } };
}
function Jh(e2) {
  var t3, n2;
  return t3 = new Th({ props: { item: e2[7], onRequestClose: e2[1] } }), { c() {
    sr(t3.$$.fragment);
  }, m(e3, r2) {
    lr(t3, e3, r2), n2 = true;
  }, p(e3, n3) {
    var r2 = {};
    1 & n3 && (r2.item = e3[7]), 2 & n3 && (r2.onRequestClose = e3[1]), t3.$set(r2);
  }, i(e3) {
    n2 || (Xn(t3.$$.fragment, e3), n2 = true);
  }, o(e3) {
    Gn(t3.$$.fragment, e3), n2 = false;
  }, d(e3) {
    cr(t3, e3);
  } };
}
function Vh(e2) {
  var t3, n2;
  return t3 = new bh({ props: { item: e2[7], onRequestClose: e2[1] } }), { c() {
    sr(t3.$$.fragment);
  }, m(e3, r2) {
    lr(t3, e3, r2), n2 = true;
  }, p(e3, n3) {
    var r2 = {};
    1 & n3 && (r2.item = e3[7]), 2 & n3 && (r2.onRequestClose = e3[1]), t3.$set(r2);
  }, i(e3) {
    n2 || (Xn(t3.$$.fragment, e3), n2 = true);
  }, o(e3) {
    Gn(t3.$$.fragment, e3), n2 = false;
  }, d(e3) {
    cr(t3, e3);
  } };
}
function Hh(e2) {
  var t3, n2 = ig(e2[10]) + "";
  return { c() {
    t3 = un(n2);
  }, m(e3, n3) {
    on(e3, t3, n3);
  }, p(e3, r2) {
    1 & r2 && n2 !== (n2 = ig(e3[10]) + "") && yn(t3, n2);
  }, i: Bt, o: Bt, d(e3) {
    e3 && an(t3);
  } };
}
function _h(e2) {
  var t3;
  return { c() {
    hn(t3 = ln("div"), "class", "jse-separator svelte-12z7bz1");
  }, m(e3, n2) {
    on(e3, t3, n2);
  }, p: Bt, i: Bt, o: Bt, d(e3) {
    e3 && an(t3);
  } };
}
function Wh(e2) {
  for (var t3, n2, r2 = er(e2[10].items), o2 = [], a2 = 0; a2 < r2.length; a2 += 1) o2[a2] = tg(Fh(e2, r2, a2));
  var i2 = (e3) => Gn(o2[e3], 1, 1, () => {
    o2[e3] = null;
  });
  return { c() {
    t3 = ln("div");
    for (var e3 = 0; e3 < o2.length; e3 += 1) o2[e3].c();
    hn(t3, "class", "jse-column svelte-12z7bz1");
  }, m(e3, r3) {
    on(e3, t3, r3);
    for (var a3 = 0; a3 < o2.length; a3 += 1) o2[a3] && o2[a3].m(t3, null);
    n2 = true;
  }, p(e3, n3) {
    if (3 & n3) {
      var a3;
      for (r2 = er(e3[10].items), a3 = 0; a3 < r2.length; a3 += 1) {
        var s2 = Fh(e3, r2, a3);
        o2[a3] ? (o2[a3].p(s2, n3), Xn(o2[a3], 1)) : (o2[a3] = tg(s2), o2[a3].c(), Xn(o2[a3], 1), o2[a3].m(t3, null));
      }
      for (Kn(), a3 = r2.length; a3 < o2.length; a3 += 1) i2(a3);
      Zn();
    }
  }, i(e3) {
    if (!n2) {
      for (var t4 = 0; t4 < r2.length; t4 += 1) Xn(o2[t4]);
      n2 = true;
    }
  }, o(e3) {
    o2 = o2.filter(Boolean);
    for (var t4 = 0; t4 < o2.length; t4 += 1) Gn(o2[t4]);
    n2 = false;
  }, d(e3) {
    e3 && an(t3), sn(o2, e3);
  } };
}
function Qh(e2) {
  var t3, n2;
  return t3 = new Th({ props: { item: e2[10], onRequestClose: e2[1] } }), { c() {
    sr(t3.$$.fragment);
  }, m(e3, r2) {
    lr(t3, e3, r2), n2 = true;
  }, p(e3, n3) {
    var r2 = {};
    1 & n3 && (r2.item = e3[10]), 2 & n3 && (r2.onRequestClose = e3[1]), t3.$set(r2);
  }, i(e3) {
    n2 || (Xn(t3.$$.fragment, e3), n2 = true);
  }, o(e3) {
    Gn(t3.$$.fragment, e3), n2 = false;
  }, d(e3) {
    cr(t3, e3);
  } };
}
function Yh(e2) {
  var t3, n2;
  return t3 = new bh({ props: { item: e2[10], onRequestClose: e2[1] } }), { c() {
    sr(t3.$$.fragment);
  }, m(e3, r2) {
    lr(t3, e3, r2), n2 = true;
  }, p(e3, n3) {
    var r2 = {};
    1 & n3 && (r2.item = e3[10]), 2 & n3 && (r2.onRequestClose = e3[1]), t3.$set(r2);
  }, i(e3) {
    n2 || (Xn(t3.$$.fragment, e3), n2 = true);
  }, o(e3) {
    Gn(t3.$$.fragment, e3), n2 = false;
  }, d(e3) {
    cr(t3, e3);
  } };
}
function Kh(e2) {
  var t3, n2 = ig(e2[13]) + "";
  return { c() {
    t3 = un(n2);
  }, m(e3, n3) {
    on(e3, t3, n3);
  }, p(e3, r2) {
    1 & r2 && n2 !== (n2 = ig(e3[13]) + "") && yn(t3, n2);
  }, i: Bt, o: Bt, d(e3) {
    e3 && an(t3);
  } };
}
function Zh(e2) {
  var t3, n2, r2 = e2[13].text + "";
  return { c() {
    t3 = ln("div"), n2 = un(r2), hn(t3, "class", "jse-label svelte-12z7bz1");
  }, m(e3, r3) {
    on(e3, t3, r3), nn(t3, n2);
  }, p(e3, t4) {
    1 & t4 && r2 !== (r2 = e3[13].text + "") && yn(n2, r2);
  }, i: Bt, o: Bt, d(e3) {
    e3 && an(t3);
  } };
}
function Xh(e2) {
  var t3;
  return { c() {
    hn(t3 = ln("div"), "class", "jse-separator svelte-12z7bz1");
  }, m(e3, n2) {
    on(e3, t3, n2);
  }, p: Bt, i: Bt, o: Bt, d(e3) {
    e3 && an(t3);
  } };
}
function Gh(e2) {
  var t3, n2;
  return t3 = new Th({ props: { className: "left", item: e2[13], onRequestClose: e2[1] } }), { c() {
    sr(t3.$$.fragment);
  }, m(e3, r2) {
    lr(t3, e3, r2), n2 = true;
  }, p(e3, n3) {
    var r2 = {};
    1 & n3 && (r2.item = e3[13]), 2 & n3 && (r2.onRequestClose = e3[1]), t3.$set(r2);
  }, i(e3) {
    n2 || (Xn(t3.$$.fragment, e3), n2 = true);
  }, o(e3) {
    Gn(t3.$$.fragment, e3), n2 = false;
  }, d(e3) {
    cr(t3, e3);
  } };
}
function eg(e2) {
  var t3, n2;
  return t3 = new bh({ props: { className: "left", item: e2[13], onRequestClose: e2[1] } }), { c() {
    sr(t3.$$.fragment);
  }, m(e3, r2) {
    lr(t3, e3, r2), n2 = true;
  }, p(e3, n3) {
    var r2 = {};
    1 & n3 && (r2.item = e3[13]), 2 & n3 && (r2.onRequestClose = e3[1]), t3.$set(r2);
  }, i(e3) {
    n2 || (Xn(t3.$$.fragment, e3), n2 = true);
  }, o(e3) {
    Gn(t3.$$.fragment, e3), n2 = false;
  }, d(e3) {
    cr(t3, e3);
  } };
}
function tg(e2) {
  var t3, n2, r2, o2, a2, i2, s2, l, c = [eg, Gh, Xh, Zh, Kh], u = [];
  function d(e3, a3) {
    return 1 & a3 && (t3 = null), 1 & a3 && (n2 = null), 1 & a3 && (r2 = null), 1 & a3 && (o2 = null), null == t3 && (t3 = !!pi(e3[13])), t3 ? 0 : (null == n2 && (n2 = !!fi(e3[13])), n2 ? 1 : (null == r2 && (r2 = !!di(e3[13])), r2 ? 2 : (null == o2 && (o2 = !!vi(e3[13])), o2 ? 3 : 4)));
  }
  return a2 = d(e2, -1), i2 = u[a2] = c[a2](e2), { c() {
    i2.c(), s2 = vn();
  }, m(e3, t4) {
    u[a2].m(e3, t4), on(e3, s2, t4), l = true;
  }, p(e3, t4) {
    var n3 = a2;
    (a2 = d(e3, t4)) === n3 ? u[a2].p(e3, t4) : (Kn(), Gn(u[n3], 1, 1, () => {
      u[n3] = null;
    }), Zn(), (i2 = u[a2]) ? i2.p(e3, t4) : (i2 = u[a2] = c[a2](e3)).c(), Xn(i2, 1), i2.m(s2.parentNode, s2));
  }, i(e3) {
    l || (Xn(i2), l = true);
  }, o(e3) {
    Gn(i2), l = false;
  }, d(e3) {
    e3 && an(s2), u[a2].d(e3);
  } };
}
function ng(e2) {
  var t3, n2, r2, o2, a2, i2, s2, l, c = [Yh, Qh, Wh, _h, Hh], u = [];
  function d(e3, a3) {
    return 1 & a3 && (t3 = null), 1 & a3 && (n2 = null), 1 & a3 && (r2 = null), 1 & a3 && (o2 = null), null == t3 && (t3 = !!pi(e3[10])), t3 ? 0 : (null == n2 && (n2 = !!fi(e3[10])), n2 ? 1 : (null == r2 && (r2 = !!hi(e3[10])), r2 ? 2 : (null == o2 && (o2 = !!di(e3[10])), o2 ? 3 : 4)));
  }
  return a2 = d(e2, -1), i2 = u[a2] = c[a2](e2), { c() {
    i2.c(), s2 = vn();
  }, m(e3, t4) {
    u[a2].m(e3, t4), on(e3, s2, t4), l = true;
  }, p(e3, t4) {
    var n3 = a2;
    (a2 = d(e3, t4)) === n3 ? u[a2].p(e3, t4) : (Kn(), Gn(u[n3], 1, 1, () => {
      u[n3] = null;
    }), Zn(), (i2 = u[a2]) ? i2.p(e3, t4) : (i2 = u[a2] = c[a2](e3)).c(), Xn(i2, 1), i2.m(s2.parentNode, s2));
  }, i(e3) {
    l || (Xn(i2), l = true);
  }, o(e3) {
    Gn(i2), l = false;
  }, d(e3) {
    e3 && an(s2), u[a2].d(e3);
  } };
}
function rg(e2) {
  var t3, n2, r2, o2, a2, i2, s2, l, c = [Vh, Jh, Dh, Lh, Uh], u = [];
  function d(e3, a3) {
    return 1 & a3 && (t3 = null), 1 & a3 && (n2 = null), 1 & a3 && (r2 = null), 1 & a3 && (o2 = null), null == t3 && (t3 = !!pi(e3[7])), t3 ? 0 : (null == n2 && (n2 = !!fi(e3[7])), n2 ? 1 : (null == r2 && (r2 = !!mi(e3[7])), r2 ? 2 : (null == o2 && (o2 = !!di(e3[7])), o2 ? 3 : 4)));
  }
  return a2 = d(e2, -1), i2 = u[a2] = c[a2](e2), { c() {
    i2.c(), s2 = vn();
  }, m(e3, t4) {
    u[a2].m(e3, t4), on(e3, s2, t4), l = true;
  }, p(e3, t4) {
    var n3 = a2;
    (a2 = d(e3, t4)) === n3 ? u[a2].p(e3, t4) : (Kn(), Gn(u[n3], 1, 1, () => {
      u[n3] = null;
    }), Zn(), (i2 = u[a2]) ? i2.p(e3, t4) : (i2 = u[a2] = c[a2](e3)).c(), Xn(i2, 1), i2.m(s2.parentNode, s2));
  }, i(e3) {
    l || (Xn(i2), l = true);
  }, o(e3) {
    Gn(i2), l = false;
  }, d(e3) {
    e3 && an(s2), u[a2].d(e3);
  } };
}
function og(e2) {
  var t3, n2, r2, o2, a2, i2, s2, l;
  return o2 = new Ca({ props: { data: faLightbulb } }), { c() {
    t3 = ln("div"), n2 = ln("div"), r2 = ln("div"), sr(o2.$$.fragment), a2 = dn(), i2 = ln("div"), s2 = un(e2[2]), hn(r2, "class", "jse-tip-icon svelte-12z7bz1"), hn(i2, "class", "jse-tip-text"), hn(n2, "class", "jse-tip svelte-12z7bz1"), hn(t3, "class", "jse-row svelte-12z7bz1");
  }, m(e3, c) {
    on(e3, t3, c), nn(t3, n2), nn(n2, r2), lr(o2, r2, null), nn(n2, a2), nn(n2, i2), nn(i2, s2), l = true;
  }, p(e3, t4) {
    (!l || 4 & t4) && yn(s2, e3[2]);
  }, i(e3) {
    l || (Xn(o2.$$.fragment, e3), l = true);
  }, o(e3) {
    Gn(o2.$$.fragment, e3), l = false;
  }, d(e3) {
    e3 && an(t3), cr(o2);
  } };
}
function ag(e2) {
  for (var t3, n2, r2, o2, a2, i2 = er(e2[0]), s2 = [], l = 0; l < i2.length; l += 1) s2[l] = rg(Nh(e2, i2, l));
  var c = (e3) => Gn(s2[e3], 1, 1, () => {
    s2[e3] = null;
  }), u = e2[2] && og(e2);
  return { c() {
    t3 = ln("div");
    for (var e3 = 0; e3 < s2.length; e3 += 1) s2[e3].c();
    n2 = dn(), u && u.c(), hn(t3, "role", "menu"), hn(t3, "tabindex", "-1"), hn(t3, "class", "jse-contextmenu svelte-12z7bz1");
  }, m(i3, l2) {
    on(i3, t3, l2);
    for (var c2 = 0; c2 < s2.length; c2 += 1) s2[c2] && s2[c2].m(t3, null);
    nn(t3, n2), u && u.m(t3, null), e2[5](t3), r2 = true, o2 || (a2 = pn(t3, "keydown", e2[4]), o2 = true);
  }, p(e3, r3) {
    var [o3] = r3;
    if (3 & o3) {
      var a3;
      for (i2 = er(e3[0]), a3 = 0; a3 < i2.length; a3 += 1) {
        var l2 = Nh(e3, i2, a3);
        s2[a3] ? (s2[a3].p(l2, o3), Xn(s2[a3], 1)) : (s2[a3] = rg(l2), s2[a3].c(), Xn(s2[a3], 1), s2[a3].m(t3, n2));
      }
      for (Kn(), a3 = i2.length; a3 < s2.length; a3 += 1) c(a3);
      Zn();
    }
    e3[2] ? u ? (u.p(e3, o3), 4 & o3 && Xn(u, 1)) : ((u = og(e3)).c(), Xn(u, 1), u.m(t3, null)) : u && (Kn(), Gn(u, 1, 1, () => {
      u = null;
    }), Zn());
  }, i(e3) {
    if (!r2) {
      for (var t4 = 0; t4 < i2.length; t4 += 1) Xn(s2[t4]);
      Xn(u), r2 = true;
    }
  }, o(e3) {
    s2 = s2.filter(Boolean);
    for (var t4 = 0; t4 < s2.length; t4 += 1) Gn(s2[t4]);
    Gn(u), r2 = false;
  }, d(n3) {
    n3 && an(t3), sn(s2, n3), u && u.d(), e2[5](null), o2 = false, a2();
  } };
}
function ig(e2) {
  return console.error("Unknown type of context menu item", e2), "???";
}
function sg(e2, t3, n2) {
  var r2, { items: o2 } = t3, { onRequestClose: a2 } = t3, { tip: i2 } = t3;
  qn(() => {
    var e3 = Array.from(r2.querySelectorAll("button")).find((e4) => !e4.disabled);
    e3 && e3.focus();
  });
  var s2 = { ArrowUp: "Up", ArrowDown: "Down", ArrowLeft: "Left", ArrowRight: "Right" };
  return e2.$$set = (e3) => {
    "items" in e3 && n2(0, o2 = e3.items), "onRequestClose" in e3 && n2(1, a2 = e3.onRequestClose), "tip" in e3 && n2(2, i2 = e3.tip);
  }, [o2, a2, i2, r2, function(e3) {
    var t4 = Do(e3), n3 = s2[t4];
    if (n3 && e3.target) {
      e3.preventDefault();
      var o3 = Uo({ allElements: Array.from(r2.querySelectorAll("button:not([disabled])")), currentElement: e3.target, direction: n3, hasPrio: (e4) => "jse-open-dropdown" !== e4.getAttribute("data-type") });
      o3 && o3.focus();
    }
  }, function(e3) {
    Tn[e3 ? "unshift" : "push"](() => {
      n2(3, r2 = e3);
    });
  }];
}
var lg = class extends dr {
  constructor(e2) {
    super(), ur(this, e2, sg, ag, Ht, { items: 0, onRequestClose: 1, tip: 2 }, Ah);
  }
};
var { window: cg } = tn;
function ug(e2) {
  rn(e2, "svelte-vrx1dr", '.jse-tree-mode.svelte-vrx1dr.svelte-vrx1dr{flex:1;display:flex;flex-direction:column;position:relative;background:var(--jse-background-color, #fff);min-width:0;min-height:0;font-family:var(--jse-font-family-mono, consolas, menlo, monaco, "Ubuntu Mono", "source-code-pro", monospace);font-size:var(--jse-font-size-mono, 14px);color:var(--jse-text-color, #4d4d4d);line-height:var(--jse-line-height, calc(1em + 4px))}.jse-tree-mode.svelte-vrx1dr .jse-hidden-input-label .jse-hidden-input.svelte-vrx1dr{position:fixed;top:-10px;left:-10px;width:1px;height:1px;padding:0;border:0;outline:none}.jse-tree-mode.no-main-menu.svelte-vrx1dr.svelte-vrx1dr{border-top:var(--jse-main-border, 1px solid #d7d7d7)}.jse-tree-mode.svelte-vrx1dr .jse-search-box-container.svelte-vrx1dr{position:relative;height:0;top:var(--jse-padding, 10px);margin-right:calc(var(--jse-padding, 10px) + 20px);margin-left:var(--jse-padding, 10px);text-align:right;z-index:3}.jse-tree-mode.svelte-vrx1dr .jse-contents.svelte-vrx1dr{flex:1;overflow:auto;position:relative;padding:2px;display:flex;flex-direction:column;border-left:var(--jse-main-border, 1px solid #d7d7d7);border-right:var(--jse-main-border, 1px solid #d7d7d7)}.jse-tree-mode.svelte-vrx1dr .jse-contents.svelte-vrx1dr:last-child{border-bottom:var(--jse-main-border, 1px solid #d7d7d7)}.jse-tree-mode.svelte-vrx1dr .jse-contents .jse-loading-space.svelte-vrx1dr{flex:1}.jse-tree-mode.svelte-vrx1dr .jse-contents .jse-loading.svelte-vrx1dr{flex:2;text-align:center;color:var(--jse-panel-color-readonly, #b2b2b2);box-sizing:border-box;font-family:var(--jse-font-family, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif);font-size:var(--jse-font-size, 16px)}.jse-tree-mode.svelte-vrx1dr .jse-contents .jse-search-box-background.svelte-vrx1dr{border:50px solid var(--jse-modal-background, #f5f5f5);margin:-2px;margin-bottom:2px;display:inline-block}');
}
function dg(e2) {
  var t3, n2, r2;
  function o2(t4) {
    e2[79](t4);
  }
  var a2 = { json: e2[11], selection: e2[12], readOnly: e2[0], historyState: e2[24], onExpandAll: e2[41], onCollapseAll: e2[42], onUndo: e2[36], onRedo: e2[37], onSort: e2[38], onTransform: e2[39], onContextMenu: e2[46], onCopy: e2[33], onRenderMenu: e2[7] };
  return void 0 !== e2[13] && (a2.showSearch = e2[13]), t3 = new Vf({ props: a2 }), Tn.push(() => ir(t3, "showSearch", o2)), { c() {
    sr(t3.$$.fragment);
  }, m(e3, n3) {
    lr(t3, e3, n3), r2 = true;
  }, p(e3, r3) {
    var o3 = {};
    2048 & r3[0] && (o3.json = e3[11]), 4096 & r3[0] && (o3.selection = e3[12]), 1 & r3[0] && (o3.readOnly = e3[0]), 16777216 & r3[0] && (o3.historyState = e3[24]), 128 & r3[0] && (o3.onRenderMenu = e3[7]), !n2 && 8192 & r3[0] && (n2 = true, o3.showSearch = e3[13], Jn(() => n2 = false)), t3.$set(o3);
  }, i(e3) {
    r2 || (Xn(t3.$$.fragment, e3), r2 = true);
  }, o(e3) {
    Gn(t3.$$.fragment, e3), r2 = false;
  }, d(e3) {
    cr(t3, e3);
  } };
}
function vg(e2) {
  var t3, n2;
  return t3 = new Om({ props: { json: e2[11], selection: e2[12], onSelect: e2[50], onError: e2[6], pathParser: e2[4] } }), { c() {
    sr(t3.$$.fragment);
  }, m(e3, r2) {
    lr(t3, e3, r2), n2 = true;
  }, p(e3, n3) {
    var r2 = {};
    2048 & n3[0] && (r2.json = e3[11]), 4096 & n3[0] && (r2.selection = e3[12]), 64 & n3[0] && (r2.onError = e3[6]), 16 & n3[0] && (r2.pathParser = e3[4]), t3.$set(r2);
  }, i(e3) {
    n2 || (Xn(t3.$$.fragment, e3), n2 = true);
  }, o(e3) {
    Gn(t3.$$.fragment, e3), n2 = false;
  }, d(e3) {
    cr(t3, e3);
  } };
}
function pg(e2) {
  var t3;
  return { c() {
    (t3 = ln("div")).innerHTML = '<div class="jse-loading-space svelte-vrx1dr"></div> <div class="jse-loading svelte-vrx1dr">loading...</div>', hn(t3, "class", "jse-contents svelte-vrx1dr");
  }, m(e3, n2) {
    on(e3, t3, n2);
  }, p: Bt, i: Bt, o: Bt, d(e3) {
    e3 && an(t3);
  } };
}
function fg(e2) {
  var t3, n2, r2, o2, a2, i2, s2, l, c, u = [hg, mg], d = [];
  function v(e3, t4) {
    return void 0 === e3[11] ? 0 : 1;
  }
  return o2 = v(e2), a2 = d[o2] = u[o2](e2), { c() {
    t3 = ln("label"), n2 = ln("input"), r2 = dn(), a2.c(), i2 = vn(), hn(n2, "type", "text"), n2.readOnly = true, hn(n2, "tabindex", "-1"), hn(n2, "class", "jse-hidden-input svelte-vrx1dr"), hn(t3, "class", "jse-hidden-input-label");
  }, m(a3, u2) {
    on(a3, t3, u2), nn(t3, n2), e2[80](n2), on(a3, r2, u2), d[o2].m(a3, u2), on(a3, i2, u2), s2 = true, l || (c = pn(n2, "paste", e2[34]), l = true);
  }, p(e3, t4) {
    var n3 = o2;
    (o2 = v(e3)) === n3 ? d[o2].p(e3, t4) : (Kn(), Gn(d[n3], 1, 1, () => {
      d[n3] = null;
    }), Zn(), (a2 = d[o2]) ? a2.p(e3, t4) : (a2 = d[o2] = u[o2](e3)).c(), Xn(a2, 1), a2.m(i2.parentNode, i2));
  }, i(e3) {
    s2 || (Xn(a2), s2 = true);
  }, o(e3) {
    Gn(a2), s2 = false;
  }, d(n3) {
    n3 && (an(t3), an(r2), an(i2)), e2[80](null), d[o2].d(n3), l = false, c();
  } };
}
function mg(e2) {
  var t3, n2, r2, o2, a2, i2, s2, l, c, u, d;
  n2 = new Nm({ props: { json: e2[11], documentState: e2[20], parser: e2[3], showSearch: e2[13], showReplace: e2[23], readOnly: e2[0], columns: void 0, onSearch: e2[29], onFocus: e2[30], onPatch: e2[40], onClose: e2[31] } });
  var v = e2[13] && gg();
  i2 = new Nf({ props: { value: e2[11], pointer: "", state: e2[20], validationErrors: e2[27], searchResults: e2[22], selection: e2[12], context: e2[14], onDragSelectionStart: noop_default } });
  var p = e2[21] && jg(e2), f = e2[25] && xg(e2);
  return u = new bv({ props: { validationErrors: e2[26], selectError: e2[32] } }), { c() {
    t3 = ln("div"), sr(n2.$$.fragment), r2 = dn(), o2 = ln("div"), v && v.c(), a2 = dn(), sr(i2.$$.fragment), s2 = dn(), p && p.c(), l = dn(), f && f.c(), c = dn(), sr(u.$$.fragment), hn(t3, "class", "jse-search-box-container svelte-vrx1dr"), hn(o2, "class", "jse-contents svelte-vrx1dr"), hn(o2, "data-jsoneditor-scrollable-contents", true);
  }, m(m3, h2) {
    on(m3, t3, h2), lr(n2, t3, null), on(m3, r2, h2), on(m3, o2, h2), v && v.m(o2, null), nn(o2, a2), lr(i2, o2, null), e2[84](o2), on(m3, s2, h2), p && p.m(m3, h2), on(m3, l, h2), f && f.m(m3, h2), on(m3, c, h2), lr(u, m3, h2), d = true;
  }, p(e3, t4) {
    var r3 = {};
    2048 & t4[0] && (r3.json = e3[11]), 1048576 & t4[0] && (r3.documentState = e3[20]), 8 & t4[0] && (r3.parser = e3[3]), 8192 & t4[0] && (r3.showSearch = e3[13]), 8388608 & t4[0] && (r3.showReplace = e3[23]), 1 & t4[0] && (r3.readOnly = e3[0]), n2.$set(r3), e3[13] ? v || ((v = gg()).c(), v.m(o2, a2)) : v && (v.d(1), v = null);
    var s3 = {};
    2048 & t4[0] && (s3.value = e3[11]), 1048576 & t4[0] && (s3.state = e3[20]), 134217728 & t4[0] && (s3.validationErrors = e3[27]), 4194304 & t4[0] && (s3.searchResults = e3[22]), 4096 & t4[0] && (s3.selection = e3[12]), 16384 & t4[0] && (s3.context = e3[14]), i2.$set(s3), e3[21] ? p ? (p.p(e3, t4), 2097152 & t4[0] && Xn(p, 1)) : ((p = jg(e3)).c(), Xn(p, 1), p.m(l.parentNode, l)) : p && (Kn(), Gn(p, 1, 1, () => {
      p = null;
    }), Zn()), e3[25] ? f ? (f.p(e3, t4), 33554432 & t4[0] && Xn(f, 1)) : ((f = xg(e3)).c(), Xn(f, 1), f.m(c.parentNode, c)) : f && (Kn(), Gn(f, 1, 1, () => {
      f = null;
    }), Zn());
    var d2 = {};
    67108864 & t4[0] && (d2.validationErrors = e3[26]), u.$set(d2);
  }, i(e3) {
    d || (Xn(n2.$$.fragment, e3), Xn(i2.$$.fragment, e3), Xn(p), Xn(f), Xn(u.$$.fragment, e3), d = true);
  }, o(e3) {
    Gn(n2.$$.fragment, e3), Gn(i2.$$.fragment, e3), Gn(p), Gn(f), Gn(u.$$.fragment, e3), d = false;
  }, d(a3) {
    a3 && (an(t3), an(r2), an(o2), an(s2), an(l), an(c)), cr(n2), v && v.d(), cr(i2), e2[84](null), p && p.d(a3), f && f.d(a3), cr(u, a3);
  } };
}
function hg(e2) {
  var t3, n2, r2, o2, a2 = [yg, bg], i2 = [];
  function s2(e3, t4) {
    return "" === e3[19] || void 0 === e3[19] ? 0 : 1;
  }
  return t3 = s2(e2), n2 = i2[t3] = a2[t3](e2), { c() {
    n2.c(), r2 = vn();
  }, m(e3, n3) {
    i2[t3].m(e3, n3), on(e3, r2, n3), o2 = true;
  }, p(e3, o3) {
    var l = t3;
    (t3 = s2(e3)) === l ? i2[t3].p(e3, o3) : (Kn(), Gn(i2[l], 1, 1, () => {
      i2[l] = null;
    }), Zn(), (n2 = i2[t3]) ? n2.p(e3, o3) : (n2 = i2[t3] = a2[t3](e3)).c(), Xn(n2, 1), n2.m(r2.parentNode, r2));
  }, i(e3) {
    o2 || (Xn(n2), o2 = true);
  }, o(e3) {
    Gn(n2), o2 = false;
  }, d(e3) {
    e3 && an(r2), i2[t3].d(e3);
  } };
}
function gg(e2) {
  var t3;
  return { c() {
    hn(t3 = ln("div"), "class", "jse-search-box-background svelte-vrx1dr");
  }, m(e3, n2) {
    on(e3, t3, n2);
  }, d(e3) {
    e3 && an(t3);
  } };
}
function jg(e2) {
  var t3, n2;
  return t3 = new cv({ props: { type: "info", message: "You pasted a JSON ".concat(Array.isArray(e2[21].contents) ? "array" : "object", " as text"), actions: [{ icon: faWrench, text: "Paste as JSON instead", title: "Replace the value with the pasted JSON", onMouseDown: e2[47] }, { text: "Leave as is", title: "Keep the JSON embedded in the value", onClick: e2[48] }] } }), { c() {
    sr(t3.$$.fragment);
  }, m(e3, r2) {
    lr(t3, e3, r2), n2 = true;
  }, p(e3, n3) {
    var r2 = {};
    2097152 & n3[0] && (r2.message = "You pasted a JSON ".concat(Array.isArray(e3[21].contents) ? "array" : "object", " as text")), t3.$set(r2);
  }, i(e3) {
    n2 || (Xn(t3.$$.fragment, e3), n2 = true);
  }, o(e3) {
    Gn(t3.$$.fragment, e3), n2 = false;
  }, d(e3) {
    cr(t3, e3);
  } };
}
function xg(e2) {
  var t3, n2;
  return t3 = new cv({ props: { type: "success", message: "The loaded JSON document was invalid but is successfully repaired.", actions: e2[0] ? [] : [{ icon: faCheck, text: "Ok", title: "Accept the repaired document", onClick: e2[8] }, { icon: faCode, text: "Repair manually instead", title: "Leave the document unchanged and repair it manually instead", onClick: e2[49] }], onClose: e2[9] } }), { c() {
    sr(t3.$$.fragment);
  }, m(e3, r2) {
    lr(t3, e3, r2), n2 = true;
  }, p(e3, n3) {
    var r2 = {};
    1 & n3[0] && (r2.actions = e3[0] ? [] : [{ icon: faCheck, text: "Ok", title: "Accept the repaired document", onClick: e3[8] }, { icon: faCode, text: "Repair manually instead", title: "Leave the document unchanged and repair it manually instead", onClick: e3[49] }]), t3.$set(r2);
  }, i(e3) {
    n2 || (Xn(t3.$$.fragment, e3), n2 = true);
  }, o(e3) {
    Gn(t3.$$.fragment, e3), n2 = false;
  }, d(e3) {
    cr(t3, e3);
  } };
}
function bg(e2) {
  var t3, n2, r2, o2;
  return t3 = new cv({ props: { type: "error", message: "The loaded JSON document is invalid and could not be repaired automatically.", actions: e2[0] ? [] : [{ icon: faCode, text: "Repair manually", title: 'Open the document in "code" mode and repair it manually', onClick: e2[49] }] } }), r2 = new fh({ props: { text: e2[19], json: e2[11], indentation: e2[5], parser: e2[3] } }), { c() {
    sr(t3.$$.fragment), n2 = dn(), sr(r2.$$.fragment);
  }, m(e3, a2) {
    lr(t3, e3, a2), on(e3, n2, a2), lr(r2, e3, a2), o2 = true;
  }, p(e3, n3) {
    var o3 = {};
    1 & n3[0] && (o3.actions = e3[0] ? [] : [{ icon: faCode, text: "Repair manually", title: 'Open the document in "code" mode and repair it manually', onClick: e3[49] }]), t3.$set(o3);
    var a2 = {};
    524288 & n3[0] && (a2.text = e3[19]), 2048 & n3[0] && (a2.json = e3[11]), 32 & n3[0] && (a2.indentation = e3[5]), 8 & n3[0] && (a2.parser = e3[3]), r2.$set(a2);
  }, i(e3) {
    o2 || (Xn(t3.$$.fragment, e3), Xn(r2.$$.fragment, e3), o2 = true);
  }, o(e3) {
    Gn(t3.$$.fragment, e3), Gn(r2.$$.fragment, e3), o2 = false;
  }, d(e3) {
    e3 && an(n2), cr(t3, e3), cr(r2, e3);
  } };
}
function yg(e2) {
  var t3, n2;
  return t3 = new Yf({ props: { readOnly: e2[0], onCreateObject: e2[81], onCreateArray: e2[82], onClick: e2[83] } }), { c() {
    sr(t3.$$.fragment);
  }, m(e3, r2) {
    lr(t3, e3, r2), n2 = true;
  }, p(e3, n3) {
    var r2 = {};
    1 & n3[0] && (r2.readOnly = e3[0]), t3.$set(r2);
  }, i(e3) {
    n2 || (Xn(t3.$$.fragment, e3), n2 = true);
  }, o(e3) {
    Gn(t3.$$.fragment, e3), n2 = false;
  }, d(e3) {
    cr(t3, e3);
  } };
}
function $g(e2) {
  var t3, n2;
  return t3 = new Mv({ props: { onClose: e2[86] } }), { c() {
    sr(t3.$$.fragment);
  }, m(e3, r2) {
    lr(t3, e3, r2), n2 = true;
  }, p(e3, n3) {
    var r2 = {};
    131072 & n3[0] && (r2.onClose = e3[86]), t3.$set(r2);
  }, i(e3) {
    n2 || (Xn(t3.$$.fragment, e3), n2 = true);
  }, o(e3) {
    Gn(t3.$$.fragment, e3), n2 = false;
  }, d(e3) {
    cr(t3, e3);
  } };
}
function wg(e2) {
  for (var t3, n2, r2 = [e2[18], { onClose: e2[87] }], o2 = {}, a2 = 0; a2 < r2.length; a2 += 1) o2 = Ft(o2, r2[a2]);
  return t3 = new op({ props: o2 }), { c() {
    sr(t3.$$.fragment);
  }, m(e3, r3) {
    lr(t3, e3, r3), n2 = true;
  }, p(e3, n3) {
    var o3 = 262144 & n3[0] ? or(r2, [262144 & n3[0] && ar(e3[18]), { onClose: e3[87] }]) : {};
    t3.$set(o3);
  }, i(e3) {
    n2 || (Xn(t3.$$.fragment, e3), n2 = true);
  }, o(e3) {
    Gn(t3.$$.fragment, e3), n2 = false;
  }, d(e3) {
    cr(t3, e3);
  } };
}
function Cg(e2) {
  var t3, n2, r2, o2, a2, i2, s2, l, c, u, d, v = e2[1] && dg(e2), p = e2[2] && vg(e2), f = [fg, pg], m3 = [];
  o2 = function(e3) {
    return e3[28] ? 1 : 0;
  }(e2), a2 = m3[o2] = f[o2](e2);
  var h2 = e2[17] && $g(e2), g = e2[18] && wg(e2);
  return { c() {
    t3 = ln("div"), v && v.c(), n2 = dn(), p && p.c(), r2 = dn(), a2.c(), i2 = dn(), h2 && h2.c(), s2 = dn(), g && g.c(), l = vn(), hn(t3, "role", "tree"), hn(t3, "tabindex", "-1"), hn(t3, "class", "jse-tree-mode svelte-vrx1dr"), kn(t3, "no-main-menu", !e2[1]);
  }, m(a3, f2) {
    on(a3, t3, f2), v && v.m(t3, null), nn(t3, n2), p && p.m(t3, null), nn(t3, r2), m3[o2].m(t3, null), e2[85](t3), on(a3, i2, f2), h2 && h2.m(a3, f2), on(a3, s2, f2), g && g.m(a3, f2), on(a3, l, f2), c = true, u || (d = [pn(cg, "mousedown", e2[51]), pn(t3, "keydown", e2[43]), pn(t3, "mousedown", e2[44]), pn(t3, "contextmenu", e2[45])], u = true);
  }, p(e3, o3) {
    e3[1] ? v ? (v.p(e3, o3), 2 & o3[0] && Xn(v, 1)) : ((v = dg(e3)).c(), Xn(v, 1), v.m(t3, n2)) : v && (Kn(), Gn(v, 1, 1, () => {
      v = null;
    }), Zn()), e3[2] ? p ? (p.p(e3, o3), 4 & o3[0] && Xn(p, 1)) : ((p = vg(e3)).c(), Xn(p, 1), p.m(t3, r2)) : p && (Kn(), Gn(p, 1, 1, () => {
      p = null;
    }), Zn()), a2.p(e3, o3), (!c || 2 & o3[0]) && kn(t3, "no-main-menu", !e3[1]), e3[17] ? h2 ? (h2.p(e3, o3), 131072 & o3[0] && Xn(h2, 1)) : ((h2 = $g(e3)).c(), Xn(h2, 1), h2.m(s2.parentNode, s2)) : h2 && (Kn(), Gn(h2, 1, 1, () => {
      h2 = null;
    }), Zn()), e3[18] ? g ? (g.p(e3, o3), 262144 & o3[0] && Xn(g, 1)) : ((g = wg(e3)).c(), Xn(g, 1), g.m(l.parentNode, l)) : g && (Kn(), Gn(g, 1, 1, () => {
      g = null;
    }), Zn());
  }, i(e3) {
    c || (Xn(v), Xn(p), Xn(a2), Xn(h2), Xn(g), c = true);
  }, o(e3) {
    Gn(v), Gn(p), Gn(a2), Gn(h2), Gn(g), c = false;
  }, d(n3) {
    n3 && (an(t3), an(i2), an(s2), an(l)), v && v.d(), p && p.d(), m3[o2].d(), e2[85](null), h2 && h2.d(n3), g && g.d(n3), u = false, Dt(d);
  } };
}
function kg(e2, t3, n2) {
  var r2, a2 = vr("jsoneditor:TreeMode"), s2 = "undefined" == typeof window;
  a2("isSSR:", s2);
  var l, d, v, f, m3, h2 = uniqueId_default(), g = uniqueId_default(), { openAbsolutePopup: j, closeAbsolutePopup: x } = En("absolute-popup"), y = false, C3 = Vd(), { readOnly: k2 } = t3, { externalContent: S4 } = t3, { externalSelection: z3 } = t3, { mainMenuBar: q2 } = t3, { navigationBar: M3 } = t3, { escapeControlCharacters: R3 } = t3, { escapeUnicodeCharacters: A } = t3, { parser: N3 } = t3, { parseMemoizeOne: B3 } = t3, { validator: F3 } = t3, { validationParser: U3 } = t3, { pathParser: L3 } = t3, { indentation: D3 } = t3, { onError: J3 } = t3, { onChange: V } = t3, { onChangeMode: H2 } = t3, { onSelect: W3 } = t3, { onRenderValue: Q2 } = t3, { onRenderMenu: Y2 } = t3, { onRenderContextMenu: K3 } = t3, { onClassName: Z3 } = t3, { onFocus: X2 } = t3, { onBlur: G2 } = t3, { onSortModal: ee2 } = t3, { onTransformModal: te2 } = t3, { onJSONEditorModal: ne2 } = t3, re2 = false, oe2 = false, ae2 = void 0;
  tv({ onMount: qn, onDestroy: Mn, getWindow: () => Io(v), hasFocus: () => re2 && document.hasFocus() || To(v), onFocus: () => {
    y = true, X2 && X2();
  }, onBlur: () => {
    y = false, G2 && G2();
  } });
  var ie4, se2, le2, ce2, ue2, de2 = void 0, ve2 = false, pe2 = zi({ json: f });
  function he2(e3) {
    n2(12, ie4 = e3);
  }
  var ge2 = false, je2 = false;
  function be2() {
    return (be2 = o(function* (e3) {
      n2(20, pe2 = Ni(f, pe2, e3, os)), yield Ct2(e3);
    })).apply(this, arguments);
  }
  var ye2 = Wd({ onChange: (e3) => {
    n2(24, $e2 = e3);
  } }), $e2 = ye2.getState();
  function we2(e3) {
    var t4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : ns;
    a2("expand"), n2(20, pe2 = Ni(f, pe2, e3, t4));
  }
  function Ce2(e3, t4) {
    n2(20, pe2 = Bi(f, pe2, e3, t4)), ie4 && function(e4, t5) {
      return Cs(Ds(e4), t5) && (Ds(e4).length > t5.length || is(e4));
    }(ie4, e3) && n2(12, ie4 = void 0);
  }
  var Ne2, Be2, Fe2 = false, Ue2 = [], Le2 = memoizeOne(Xd);
  function De3(e3, t4, r3, o2) {
    Qd(() => {
      var s3;
      try {
        s3 = Le2(e3, t4, r3, o2);
      } catch (e4) {
        s3 = [{ path: [], message: "Failed to validate: " + e4.message, severity: po.warning }];
      }
      isEqual_default(s3, Ue2) || (a2("validationErrors changed:", s3), n2(26, Ue2 = s3), n2(27, Ne2 = function(e4, t5) {
        var n3;
        return t5.forEach((t6) => {
          n3 = Zd(e4, n3, t6.path, (e5, n4) => i(i({}, n4), {}, { validationError: t6 }));
        }), t5.forEach((t6) => {
          for (var r4 = t6.path; r4.length > 0; ) r4 = initial_default(r4), n3 = Zd(e4, n3, r4, (e5, t7) => t7.validationError ? t7 : i(i({}, t7), {}, { validationError: { isChildError: true, path: r4, message: "Contains invalid data", severity: po.warning } }));
        }), n3;
      }(e3, Ue2)));
    }, (e4) => a2("validationErrors updated in ".concat(e4, " ms")));
  }
  function Ve2() {
    return a2("validate"), de2 ? { parseError: de2, isRepairable: false } : (De3(f, F3, N3, U3), isEmpty_default(Ue2) ? void 0 : { validationErrors: Ue2 });
  }
  function He2() {
    return f;
  }
  function _e2() {
    return pe2;
  }
  function We2() {
    return ie4;
  }
  function Qe2(e3) {
    a2("applyExternalContent", { updatedContent: e3 }), Xr(e3) ? function(e4) {
      if (void 0 === e4) return;
      var t4 = !isEqual_default(f, e4);
      if (a2("update external json", { isChanged: t4, currentlyText: void 0 === f }), !t4) return;
      var r3 = { documentState: pe2, selection: ie4, json: f, text: m3, textIsRepaired: Fe2 };
      n2(11, f = e4), n2(20, pe2 = Pi(e4, pe2)), Ye2(f), n2(19, m3 = void 0), n2(25, Fe2 = false), de2 = void 0, Ke2(f), Ze2(r3);
    }(e3.json) : Zr(e3) && function(e4) {
      if (void 0 === e4 || Xr(S4)) return;
      var t4 = e4 !== m3;
      if (a2("update external text", { isChanged: t4 }), !t4) return;
      var r3 = { documentState: pe2, selection: ie4, json: f, text: m3, textIsRepaired: Fe2 };
      try {
        n2(11, f = B3(e4)), n2(20, pe2 = Pi(f, pe2)), Ye2(f), n2(19, m3 = e4), n2(25, Fe2 = false), de2 = void 0;
      } catch (t5) {
        try {
          n2(11, f = B3(jsonrepair(e4))), n2(20, pe2 = Pi(f, pe2)), Ye2(f), n2(19, m3 = e4), n2(25, Fe2 = true), de2 = void 0, Ke2(f);
        } catch (e5) {
          n2(11, f = void 0), n2(20, pe2 = void 0), n2(19, m3 = S4.text), n2(25, Fe2 = false), de2 = void 0 !== m3 && "" !== m3 ? Qr(m3, t5.message || String(t5)) : void 0;
        }
      }
      Ke2(f), Ze2(r3);
    }(e3.text);
  }
  function Ye2(e3) {
    ve2 || (ve2 = true, n2(20, pe2 = es(e3, pe2, [])));
  }
  function Ke2(e3) {
    ie4 && (existsIn(e3, Js(ie4)) && existsIn(e3, Ds(ie4)) || (a2("clearing selection: path does not exist anymore", ie4), n2(12, ie4 = xs(e3, pe2))));
  }
  function Ze2(e3) {
    if (void 0 !== e3.json || void 0 !== e3.text) {
      var t4 = void 0 !== f && void 0 !== e3.json;
      ye2.add({ undo: { patch: t4 ? [{ op: "replace", path: "", value: e3.json }] : void 0, json: e3.json, text: e3.text, documentState: e3.documentState, textIsRepaired: e3.textIsRepaired, selection: ks(e3.selection), sortedColumn: void 0 }, redo: { patch: t4 ? [{ op: "replace", path: "", value: f }] : void 0, json: f, text: m3, documentState: pe2, textIsRepaired: Fe2, selection: ks(ie4), sortedColumn: void 0 } });
    }
  }
  function Xe2(e3, t4) {
    var r3;
    if (a2("patch", e3, t4), void 0 === f) throw new Error("Cannot apply patch: no JSON");
    var o2 = f, s3 = { json: void 0, text: m3, documentState: pe2, selection: ks(ie4), textIsRepaired: Fe2, sortedColumn: void 0 }, l2 = ll(f, e3), c = Ui(f, pe2, e3), u = null !== (r3 = bs(f, e3)) && void 0 !== r3 ? r3 : ie4, d2 = "function" == typeof t4 ? t4(c.json, c.documentState, u) : void 0;
    return n2(11, f = void 0 !== (null == d2 ? void 0 : d2.json) ? d2.json : c.json), n2(20, pe2 = void 0 !== (null == d2 ? void 0 : d2.state) ? d2.state : c.documentState), n2(12, ie4 = void 0 !== (null == d2 ? void 0 : d2.selection) ? d2.selection : u), n2(19, m3 = void 0), n2(25, Fe2 = false), n2(21, le2 = void 0), de2 = void 0, Ke2(f), ye2.add({ undo: i({ patch: l2 }, s3), redo: { patch: e3, json: void 0, text: m3, documentState: pe2, selection: ks(ie4), sortedColumn: void 0, textIsRepaired: Fe2 } }), { json: f, previousJson: o2, undo: l2, redo: e3 };
  }
  function Ge2() {
    !k2 && ie4 && n2(12, ie4 = Os(Ds(ie4)));
  }
  function et2() {
    if (!k2 && ie4) {
      var e3 = Ds(ie4), t4 = getIn(f, e3);
      yr(t4) ? function(e4, t5) {
        a2("openJSONEditorModal", { path: e4, value: t5 }), re2 = true, ne2({ content: { json: t5 }, path: e4, onPatch: Be2.onPatch, onClose: () => {
          re2 = false, setTimeout(Ft3);
        } });
      }(e3, t4) : n2(12, ie4 = qs(e3));
    }
  }
  function tt2() {
    if (!k2 && ls(ie4)) {
      var e3 = Ds(ie4), t4 = compileJSONPointer(e3), n3 = getIn(f, e3), r3 = !Yi(f, pe2, e3), o2 = r3 ? String(n3) : Mr(String(n3), N3);
      a2("handleToggleEnforceString", { enforceString: r3, value: n3, updatedValue: o2 }), qt2([{ op: "replace", path: t4, value: o2 }], (t5, n4) => ({ state: Vi(f, n4, e3, { type: "value", enforceString: r3 }) }));
    }
  }
  function nt2() {
    return rt2.apply(this, arguments);
  }
  function rt2() {
    return rt2 = o(function* () {
      var e3 = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
      yield Zm({ json: f, selection: ie4, indentation: e3 ? D3 : void 0, readOnly: k2, parser: N3, onPatch: qt2 });
    }), rt2.apply(this, arguments);
  }
  function ot2() {
    return at2.apply(this, arguments);
  }
  function at2() {
    return at2 = o(function* () {
      var e3 = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
      void 0 !== f && (yield Gm({ json: f, selection: ie4, indentation: e3 ? D3 : void 0, parser: N3 }));
    }), at2.apply(this, arguments);
  }
  function it2() {
    n2(17, oe2 = true);
  }
  function st2(e3, t4) {
    n2(18, ae2 = { text: e3, onParse: (e4) => Hr(e4, (e5) => Jr(e5, N3)), onRepair: _r, onApply: t4, onClose: Ft3 });
  }
  function lt2() {
    nh({ json: f, text: m3, selection: ie4, keepSelection: false, readOnly: k2, onChange: V, onPatch: qt2 });
  }
  function ct2() {
    !k2 && void 0 !== f && ie4 && Ts && !isEmpty_default(Ds(ie4)) && (a2("duplicate", { selection: ie4 }), qt2(nl(f, ps(f, ie4))));
  }
  function ut2() {
    if (!k2 && ie4 && (cs(ie4) || ls(ie4)) && !isEmpty_default(Ds(ie4))) {
      a2("extract", { selection: ie4 });
      var e3 = function(e4, t4) {
        if (ls(t4)) return [{ op: "move", from: compileJSONPointer(t4.path), path: "" }];
        if (!cs(t4)) throw new Error("Cannot create extract operations: parent must be an Object or Array");
        var n3 = initial_default(t4.focusPath), r3 = getIn(e4, n3);
        if (isJSONArray(r3)) return [{ op: "replace", path: "", value: ps(e4, t4).map((e5) => {
          var t5 = gr(last_default(e5));
          return r3[t5];
        }) }];
        if (isJSONObject(r3)) {
          var o2 = {};
          return ps(e4, t4).forEach((e5) => {
            var t5 = String(last_default(e5));
            o2[t5] = r3[t5];
          }), [{ op: "replace", path: "", value: o2 }];
        }
        throw new Error("Cannot extract: unsupported type of selection " + JSON.stringify(t4));
      }(f, ie4);
      qt2(e3, (e4, t4) => {
        if (yr(e4)) {
          return { state: es(e4, t4, []) };
        }
      });
    }
  }
  function dt(e3) {
    sh({ insertType: e3, selectInside: true, initialValue: void 0, json: f, selection: ie4, readOnly: k2, parser: N3, onPatch: qt2, onReplaceJson: Mt2 });
  }
  function vt2(e3) {
    ss(ie4) && n2(12, ie4 = zs(ie4.path)), ie4 || n2(12, ie4 = xs(f, pe2)), dt(e3);
  }
  function pt(e3) {
    if (!k2 && ie4) if (As(ie4)) try {
      var t4 = Js(ie4), n3 = getIn(f, t4), r3 = function(e4, t5, n4) {
        if ("array" === t5) {
          if (Array.isArray(e4)) return e4;
          if (br(e4)) return Ur(e4);
          if ("string" == typeof e4) try {
            var r4 = n4.parse(e4);
            if (Array.isArray(r4)) return r4;
            if (br(r4)) return Ur(r4);
          } catch (t6) {
            return [e4];
          }
          return [e4];
        }
        if ("object" === t5) {
          if (Array.isArray(e4)) return Fr(e4);
          if (br(e4)) return e4;
          if ("string" == typeof e4) try {
            var o3 = n4.parse(e4);
            if (br(o3)) return o3;
            if (Array.isArray(o3)) return Fr(o3);
          } catch (t6) {
            return { value: e4 };
          }
          return { value: e4 };
        }
        if ("value" === t5) return yr(e4) ? n4.stringify(e4) : e4;
        throw new Error("Cannot convert ".concat(Or(e4, n4), " to ").concat(t5));
      }(n3, e3, N3);
      if (r3 === n3) return;
      var o2 = [{ op: "replace", path: compileJSONPointer(t4), value: r3 }];
      a2("handleConvert", { selection: ie4, path: t4, type: e3, operations: o2 }), qt2(o2, (e4, t5) => ({ state: ie4 ? es(e4, t5, Ds(ie4)) : pe2 }));
    } catch (e4) {
      J3(e4);
    }
    else J3(new Error("Cannot convert current selection to ".concat(e3)));
  }
  function ft2() {
    if (ie4) {
      var e3 = gs(f, pe2, ie4, false), t4 = initial_default(Ds(ie4));
      e3 && !isEmpty_default(Ds(e3)) && isEqual_default(t4, initial_default(Ds(e3))) ? n2(12, ie4 = Rs(Ds(e3))) : n2(12, ie4 = Ms(t4)), a2("insert before", { selection: ie4, selectionBefore: e3, parentPath: t4 }), Ln().then(() => Nt2());
    }
  }
  function mt2() {
    if (ie4) {
      var e3 = hs(f, ie4);
      a2("insert after", e3), n2(12, ie4 = Rs(e3)), Ln().then(() => Nt2());
    }
  }
  function ht2(e3) {
    return gt2.apply(this, arguments);
  }
  function gt2() {
    return (gt2 = o(function* (e3) {
      yield lh({ char: e3, selectInside: true, json: f, selection: ie4, readOnly: k2, parser: N3, onPatch: qt2, onReplaceJson: Mt2, onSelect: he2 });
    })).apply(this, arguments);
  }
  function jt2() {
    if (!k2 && ye2.getState().canUndo) {
      var e3 = ye2.undo();
      if (e3) {
        var t4 = { json: f, text: m3 };
        n2(11, f = e3.undo.patch ? immutableJSONPatch(f, e3.undo.patch) : e3.undo.json), n2(20, pe2 = e3.undo.documentState), n2(12, ie4 = e3.undo.selection), n2(19, m3 = e3.undo.text), n2(25, Fe2 = e3.undo.textIsRepaired), de2 = void 0, a2("undo", { item: e3, json: f, documentState: pe2, selection: ie4 }), zt2(t4, e3.undo.patch && e3.redo.patch ? { json: f, previousJson: t4.json, redo: e3.undo.patch, undo: e3.redo.patch } : void 0), Ft3(), ie4 && Ct2(Ds(ie4), false);
      }
    }
  }
  function xt2() {
    if (!k2 && ye2.getState().canRedo) {
      var e3 = ye2.redo();
      if (e3) {
        var t4 = { json: f, text: m3 };
        n2(11, f = e3.redo.patch ? immutableJSONPatch(f, e3.redo.patch) : e3.redo.json), n2(20, pe2 = e3.redo.documentState), n2(12, ie4 = e3.redo.selection), n2(19, m3 = e3.redo.text), n2(25, Fe2 = e3.redo.textIsRepaired), de2 = void 0, a2("redo", { item: e3, json: f, documentState: pe2, selection: ie4 }), zt2(t4, e3.undo.patch && e3.redo.patch ? { json: f, previousJson: t4.json, redo: e3.redo.patch, undo: e3.undo.patch } : void 0), Ft3(), ie4 && Ct2(Ds(ie4), false);
      }
    }
  }
  function bt2(e3) {
    var t4;
    k2 || void 0 === f || (re2 = true, ee2({ id: h2, json: f, rootPath: e3, onSort: (t4 = o(function* (t5) {
      var { operations: n3 } = t5;
      a2("onSort", e3, n3), qt2(n3, (t6, n4) => ({ state: es(t6, n4, e3), selection: zs(e3) }));
    }), function(e4) {
      return t4.apply(this, arguments);
    }), onClose: () => {
      re2 = false, setTimeout(Ft3);
    } }));
  }
  function yt2() {
    ie4 && bt2(ws(f, ie4));
  }
  function $t2(e3) {
    if (void 0 !== f) {
      var { id: t4, onTransform: n3, onClose: r3 } = e3, o2 = e3.rootPath || [];
      re2 = true, te2({ id: t4 || g, json: f, rootPath: o2, onTransform: (e4) => {
        n3 ? n3({ operations: e4, json: f, transformedJson: immutableJSONPatch(f, e4) }) : (a2("onTransform", o2, e4), qt2(e4, (e5, t5) => ({ state: es(e5, t5, o2), selection: zs(o2) })));
      }, onClose: () => {
        re2 = false, setTimeout(Ft3), r3 && r3();
      } });
    }
  }
  function wt2() {
    ie4 && $t2({ rootPath: ws(f, ie4) });
  }
  function Ct2(e3) {
    return kt2.apply(this, arguments);
  }
  function kt2() {
    return kt2 = o(function* (e3) {
      var t4 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
      n2(20, pe2 = Ni(f, pe2, e3, os)), yield Ln();
      var r3 = St(e3);
      if (a2("scrollTo", { path: e3, elem: r3, refContents: l }), !r3 || !l) return Promise.resolve();
      var o2 = l.getBoundingClientRect(), i2 = r3.getBoundingClientRect();
      if (!t4 && i2.bottom > o2.top && i2.top < o2.bottom) return Promise.resolve();
      var s3 = -o2.height / 4;
      return new Promise((e4) => {
        C3(r3, { container: l, offset: s3, duration: 300, callback: () => e4() });
      });
    }), kt2.apply(this, arguments);
  }
  function St(e3) {
    var t4, n3;
    return null !== (t4 = null === (n3 = l) || void 0 === n3 ? void 0 : n3.querySelector('div[data-path="'.concat(Bo(e3), '"]'))) && void 0 !== t4 ? t4 : void 0;
  }
  function Ot2(e3) {
    var t4 = St(e3);
    if (t4 && l) {
      var n3 = l.getBoundingClientRect(), r3 = t4.getBoundingClientRect(), o2 = yr(getIn(f, e3)) ? 20 : r3.height;
      r3.top < n3.top + 20 ? C3(t4, { container: l, offset: -20, duration: 0 }) : r3.top + o2 > n3.bottom - 20 && C3(t4, { container: l, offset: -(n3.height - o2 - 20), duration: 0 });
    }
  }
  function zt2(e3, t4) {
    var n3;
    if (void 0 !== e3.json || void 0 !== (null == e3 ? void 0 : e3.text)) {
      if (void 0 !== m3) null === (n3 = V) || void 0 === n3 || n3({ text: m3, json: void 0 }, e3, { contentErrors: Ve2(), patchResult: t4 });
      else if (void 0 !== f) {
        var r3;
        null === (r3 = V) || void 0 === r3 || r3({ text: void 0, json: f }, e3, { contentErrors: Ve2(), patchResult: t4 });
      }
    }
  }
  function qt2(e3, t4) {
    a2("handlePatch", e3, t4);
    var n3 = { json: f, text: m3 }, r3 = Xe2(e3, t4);
    return zt2(n3, r3), r3;
  }
  function Mt2(e3, t4) {
    var r3 = { json: f, text: m3 }, o2 = { documentState: pe2, selection: ie4, json: f, text: m3, textIsRepaired: Fe2 }, a3 = Ni(f, Pi(e3, pe2), [], ts), i2 = "function" == typeof t4 ? t4(e3, a3, ie4) : void 0;
    n2(11, f = void 0 !== (null == i2 ? void 0 : i2.json) ? i2.json : e3), n2(20, pe2 = void 0 !== (null == i2 ? void 0 : i2.state) ? i2.state : a3), n2(12, ie4 = void 0 !== (null == i2 ? void 0 : i2.selection) ? i2.selection : ie4), n2(19, m3 = void 0), n2(25, Fe2 = false), de2 = void 0, Ke2(f), Ze2(o2);
    zt2(r3, void 0);
  }
  function Rt2(e3, t4) {
    a2("handleChangeText");
    var r3 = { json: f, text: m3 }, o2 = { documentState: pe2, selection: ie4, json: f, text: m3, textIsRepaired: Fe2 };
    try {
      n2(11, f = B3(e3)), n2(20, pe2 = Ni(f, Pi(f, pe2), [], ts)), n2(19, m3 = void 0), n2(25, Fe2 = false), de2 = void 0;
    } catch (t5) {
      try {
        n2(11, f = B3(jsonrepair(e3))), n2(20, pe2 = Ni(f, Pi(f, pe2), [], ts)), n2(19, m3 = e3), n2(25, Fe2 = true), de2 = void 0;
      } catch (r4) {
        n2(11, f = void 0), n2(20, pe2 = zi({ json: f, expand: ts })), n2(19, m3 = e3), n2(25, Fe2 = false), de2 = "" !== m3 ? Qr(m3, t5.message || String(t5)) : void 0;
      }
    }
    if ("function" == typeof t4) {
      var i2 = t4(f, pe2, ie4);
      n2(11, f = void 0 !== (null == i2 ? void 0 : i2.json) ? i2.json : f), n2(20, pe2 = void 0 !== (null == i2 ? void 0 : i2.state) ? i2.state : pe2), n2(12, ie4 = void 0 !== (null == i2 ? void 0 : i2.selection) ? i2.selection : ie4);
    }
    Ke2(f), Ze2(o2);
    zt2(r3, void 0);
  }
  function Et2(e3, t4) {
    var n3 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
    a2("handleExpand", { path: e3, expanded: t4, recursive: n3 }), t4 ? we2(e3, n3 ? rs : ns) : Ce2(e3, n3), Ft3();
  }
  function Pt2(e3) {
    a2("openFind", { findAndReplace: e3 }), n2(13, ge2 = false), n2(23, je2 = false), Ln().then(() => {
      n2(13, ge2 = true), n2(23, je2 = e3);
    });
  }
  function It2(e3, t4) {
    a2("handleExpandSection", e3, t4), n2(20, pe2 = function(e4, t5, n3, r3) {
      return Hi(e4, t5, n3, (e5, t6) => {
        if (!Ci(t6)) return t6;
        var n4 = si(t6.visibleSections.concat(r3));
        return i(i({}, t6), {}, { visibleSections: n4 });
      });
    }(f, pe2, e3, t4));
  }
  function Tt3(e3) {
    a2("pasted json as text", e3), n2(21, le2 = e3);
  }
  function At3(e3) {
    var t4, { anchor: n3, left: r3, top: o2, width: a3, height: i2, offsetTop: s3, offsetLeft: l2, showTip: c } = e3, d2 = function(e4) {
      var { json: t5, documentState: n4, selection: r4, readOnly: o3, onEditKey: a4, onEditValue: i3, onToggleEnforceString: s4, onCut: l3, onCopy: c2, onPaste: d3, onRemove: v3, onDuplicate: p2, onExtract: f2, onInsertBefore: m5, onInsert: h3, onConvert: g2, onInsertAfter: j2, onSort: x2, onTransform: b2 } = e4, y2 = void 0 !== t5, $2 = !!r4, w = !!r4 && isEmpty_default(Ds(r4)), C4 = r4 ? getIn(t5, Ds(r4)) : void 0, k3 = Array.isArray(C4) ? "Edit array" : br(C4) ? "Edit object" : "Edit value", S5 = y2 && (cs(r4) || ss(r4) || ls(r4)), O = r4 && !w ? getIn(t5, initial_default(Ds(r4))) : void 0, z4 = !o3 && y2 && $s(r4) && !w && !Array.isArray(O), q3 = !o3 && y2 && void 0 !== r4 && $s(r4), M4 = q3 && !yr(C4), R4 = !o3 && S5, P3 = S5, I3 = !o3 && $2, A2 = !o3 && y2 && S5 && !w, N4 = !o3 && y2 && void 0 !== r4 && (cs(r4) || ls(r4)) && !w, B4 = S5, F4 = B4 ? "Convert to:" : "Insert:", U4 = !o3 && (is(r4) && Array.isArray(C4) || as(r4) && Array.isArray(O)), L4 = !o3 && (B4 ? As(r4) && !br(C4) : $2), D4 = !o3 && (B4 ? As(r4) && !Array.isArray(C4) : $2), J4 = !o3 && (B4 ? As(r4) && yr(C4) : $2), V2 = void 0 !== r4 && Yi(t5, n4, Ds(r4));
      function H3(e5) {
        S5 ? "structure" !== e5 && g2(e5) : h3(e5);
      }
      return [{ type: "row", items: [{ type: "button", onClick: () => a4(), icon: faPen, text: "Edit key", title: "Edit the key (Double-click on the key)", disabled: !z4 }, { type: "dropdown-button", main: { type: "button", onClick: () => i3(), icon: faPen, text: k3, title: "Edit the value (Double-click on the value)", disabled: !q3 }, width: "11em", items: [{ type: "button", icon: faPen, text: k3, title: "Edit the value (Double-click on the value)", onClick: () => i3(), disabled: !q3 }, { type: "button", icon: V2 ? faCheckSquare2 : faSquare2, text: "Enforce string", title: "Enforce keeping the value as string when it contains a numeric value", onClick: () => s4(), disabled: !M4 }] }] }, { type: "separator" }, { type: "row", items: [{ type: "dropdown-button", main: { type: "button", onClick: () => l3(true), icon: faCut, text: "Cut", title: "Cut selected contents, formatted with indentation (Ctrl+X)", disabled: !R4 }, width: "10em", items: [{ type: "button", icon: faCut, text: "Cut formatted", title: "Cut selected contents, formatted with indentation (Ctrl+X)", onClick: () => l3(true), disabled: !R4 }, { type: "button", icon: faCut, text: "Cut compacted", title: "Cut selected contents, without indentation (Ctrl+Shift+X)", onClick: () => l3(false), disabled: !R4 }] }, { type: "dropdown-button", main: { type: "button", onClick: () => c2(true), icon: faCopy, text: "Copy", title: "Copy selected contents, formatted with indentation (Ctrl+C)", disabled: !P3 }, width: "12em", items: [{ type: "button", icon: faCopy, text: "Copy formatted", title: "Copy selected contents, formatted with indentation (Ctrl+C)", onClick: () => c2(true), disabled: !P3 }, { type: "button", icon: faCopy, text: "Copy compacted", title: "Copy selected contents, without indentation (Ctrl+Shift+C)", onClick: () => c2(false), disabled: !P3 }] }, { type: "button", onClick: () => d3(), icon: faPaste, text: "Paste", title: "Paste clipboard contents (Ctrl+V)", disabled: !I3 }] }, { type: "separator" }, { type: "row", items: [{ type: "column", items: [{ type: "button", onClick: () => p2(), icon: faClone, text: "Duplicate", title: "Duplicate selected contents (Ctrl+D)", disabled: !A2 }, { type: "button", onClick: () => f2(), icon: faCropAlt, text: "Extract", title: "Extract selected contents", disabled: !N4 }, { type: "button", onClick: () => x2(), icon: faSortAmountDownAlt, text: "Sort", title: "Sort array or object contents", disabled: o3 || !S5 }, { type: "button", onClick: () => b2(), icon: faFilter, text: "Transform", title: "Transform array or object contents (filter, sort, project)", disabled: o3 || !S5 }, { type: "button", onClick: () => v3(), icon: faTrashCan, text: "Remove", title: "Remove selected contents (Delete)", disabled: o3 || !S5 }] }, { type: "column", items: [{ type: "label", text: F4 }, { type: "button", onClick: () => H3("structure"), icon: B4 ? faArrowRightArrowLeft : faPlus, text: "Structure", title: F4 + " structure like the first item in the array", disabled: !U4 }, { type: "button", onClick: () => H3("object"), icon: B4 ? faArrowRightArrowLeft : faPlus, text: "Object", title: F4 + " object", disabled: !L4 }, { type: "button", onClick: () => H3("array"), icon: B4 ? faArrowRightArrowLeft : faPlus, text: "Array", title: F4 + " array", disabled: !D4 }, { type: "button", onClick: () => H3("value"), icon: B4 ? faArrowRightArrowLeft : faPlus, text: "Value", title: F4 + " value", disabled: !J4 }] }] }, { type: "separator" }, { type: "row", items: [{ type: "button", onClick: () => m5(), icon: faCaretSquareUp, text: "Insert before", title: "Select area before current entry to insert or paste contents", disabled: o3 || !S5 || w }, { type: "button", onClick: () => j2(), icon: faCaretSquareDown, text: "Insert after", title: "Select area after current entry to insert or paste contents", disabled: o3 || !S5 || w }] }];
    }({ json: f, documentState: pe2, selection: ie4, readOnly: k2, onEditKey: Ge2, onEditValue: et2, onToggleEnforceString: tt2, onCut: nt2, onCopy: ot2, onPaste: it2, onRemove: lt2, onDuplicate: ct2, onExtract: ut2, onInsertBefore: ft2, onInsert: vt2, onInsertAfter: mt2, onConvert: pt, onSort: yt2, onTransform: wt2 }), v2 = null !== (t4 = K3(d2)) && void 0 !== t4 ? t4 : d2;
    if (false !== v2) {
      var p = { left: r3, top: o2, offsetTop: s3, offsetLeft: l2, width: a3, height: i2, anchor: n3, closeOnOuterClick: true, onClose: () => {
        re2 = false, Ft3();
      } };
      re2 = true;
      var m4 = j(lg, { tip: c ? "Tip: you can open this context menu via right-click or with Ctrl+Q" : void 0, items: v2, onRequestClose: () => x(m4) }, p);
    }
  }
  function Nt2(e3) {
    if (!Is(ie4)) if (e3 && (e3.stopPropagation(), e3.preventDefault()), e3 && "contextmenu" === e3.type && e3.target !== d) At3({ left: e3.clientX, top: e3.clientY, width: oi, height: ri, showTip: false });
    else {
      var t4, n3 = null === (t4 = l) || void 0 === t4 ? void 0 : t4.querySelector(".jse-context-menu-pointer.jse-selected");
      if (n3) At3({ anchor: n3, offsetTop: 2, width: oi, height: ri, showTip: false });
      else {
        var r3, o2 = null === (r3 = l) || void 0 === r3 ? void 0 : r3.getBoundingClientRect();
        o2 && At3({ top: o2.top + 2, left: o2.left + 2, width: oi, height: ri, showTip: false });
      }
    }
  }
  function Bt3() {
    return (Bt3 = o(function* () {
      if (a2("apply pasted json", le2), le2) {
        var { onPasteAsJson: e3 } = le2;
        n2(21, le2 = void 0), e3(), setTimeout(Ft3);
      }
    })).apply(this, arguments);
  }
  function Ft3() {
    a2("focus"), d && (d.focus(), d.select());
  }
  function Ut2(e3) {
    return function(e4, t4, n3) {
      var r3 = initial_default(n3), o2 = [last_default(n3)], a3 = getIn(e4, r3), i2 = a3 ? Gi(a3, t4, o2) : void 0;
      return i2 ? zs(r3.concat(i2)) : Rs(n3);
    }(f, pe2, e3);
  }
  function Lt3(e3) {
    r2 && r2.onDrag(e3);
  }
  function Dt3() {
    r2 && r2.onDragEnd();
  }
  return e2.$$set = (e3) => {
    "readOnly" in e3 && n2(0, k2 = e3.readOnly), "externalContent" in e3 && n2(52, S4 = e3.externalContent), "externalSelection" in e3 && n2(53, z3 = e3.externalSelection), "mainMenuBar" in e3 && n2(1, q2 = e3.mainMenuBar), "navigationBar" in e3 && n2(2, M3 = e3.navigationBar), "escapeControlCharacters" in e3 && n2(54, R3 = e3.escapeControlCharacters), "escapeUnicodeCharacters" in e3 && n2(55, A = e3.escapeUnicodeCharacters), "parser" in e3 && n2(3, N3 = e3.parser), "parseMemoizeOne" in e3 && n2(56, B3 = e3.parseMemoizeOne), "validator" in e3 && n2(57, F3 = e3.validator), "validationParser" in e3 && n2(58, U3 = e3.validationParser), "pathParser" in e3 && n2(4, L3 = e3.pathParser), "indentation" in e3 && n2(5, D3 = e3.indentation), "onError" in e3 && n2(6, J3 = e3.onError), "onChange" in e3 && n2(59, V = e3.onChange), "onChangeMode" in e3 && n2(60, H2 = e3.onChangeMode), "onSelect" in e3 && n2(61, W3 = e3.onSelect), "onRenderValue" in e3 && n2(62, Q2 = e3.onRenderValue), "onRenderMenu" in e3 && n2(7, Y2 = e3.onRenderMenu), "onRenderContextMenu" in e3 && n2(63, K3 = e3.onRenderContextMenu), "onClassName" in e3 && n2(64, Z3 = e3.onClassName), "onFocus" in e3 && n2(65, X2 = e3.onFocus), "onBlur" in e3 && n2(66, G2 = e3.onBlur), "onSortModal" in e3 && n2(67, ee2 = e3.onSortModal), "onTransformModal" in e3 && n2(68, te2 = e3.onTransformModal), "onJSONEditorModal" in e3 && n2(69, ne2 = e3.onJSONEditorModal);
  }, e2.$$.update = () => {
    var t4;
    4096 & e2.$$.dirty[0] && (isEqual_default(t4 = ie4, z3) || (a2("onSelect", t4), W3(t4))), 25165824 & e2.$$.dirty[1] && n2(78, se2 = jo({ escapeControlCharacters: R3, escapeUnicodeCharacters: A })), 8192 & e2.$$.dirty[0] && function(e3) {
      l && e3 && 0 === l.scrollTop && (n2(10, l.style.overflowAnchor = "none", l), n2(10, l.scrollTop += ai, l), setTimeout(() => {
        l && n2(10, l.style.overflowAnchor = "", l);
      }));
    }(ge2), 2097152 & e2.$$.dirty[1] && Qe2(S4), 4194304 & e2.$$.dirty[1] && function(e3) {
      isEqual_default(ie4, e3) || (a2("applyExternalSelection", { selection: ie4, externalSelection: e3 }), ds(e3) && n2(12, ie4 = e3));
    }(z3), 2056 & e2.$$.dirty[0] | 201326592 & e2.$$.dirty[1] && De3(f, F3, N3, U3), 1024 & e2.$$.dirty[0] && (r2 = l ? function(e3) {
      var t5, n3;
      function r3(e4) {
        return e4 < 20 ? Ba : e4 < 50 ? Fa : Ua;
      }
      function o2() {
        if (e3) {
          var n4 = (t5 || 0) * (Na / 1e3);
          e3.scrollTop += n4;
        }
      }
      function a3(e4) {
        n3 && e4 === t5 || (i2(), Dd("startAutoScroll", e4), t5 = e4, n3 = setInterval(o2, Na));
      }
      function i2() {
        n3 && (Dd("stopAutoScroll"), clearInterval(n3), n3 = void 0, t5 = void 0);
      }
      return Dd("createAutoScrollHandler", e3), { onDrag: function(t6) {
        if (e3) {
          var n4 = t6.clientY, { top: o3, bottom: s3 } = e3.getBoundingClientRect();
          n4 < o3 ? a3(-r3(o3 - n4)) : n4 > s3 ? a3(r3(n4 - s3)) : i2();
        }
      }, onDragEnd: function() {
        i2();
      } };
    }(l) : void 0), 9 & e2.$$.dirty[0] | 65541 & e2.$$.dirty[2] && n2(14, Be2 = { mode: co.tree, readOnly: k2, parser: N3, normalization: se2, getJson: He2, getDocumentState: _e2, getSelection: We2, findElement: St, findNextInside: Ut2, focus: Ft3, onPatch: qt2, onInsert: dt, onExpand: Et2, onSelect: he2, onFind: Pt2, onExpandSection: It2, onPasteJson: Tt3, onRenderValue: Q2, onContextMenu: At3, onClassName: Z3 || (() => {
    }), onDrag: Lt3, onDragEnd: Dt3 }), 16384 & e2.$$.dirty[0] && a2("context changed", Be2);
  }, [k2, q2, M3, N3, L3, D3, J3, Y2, function() {
    return Fe2 && void 0 !== f && Mt2(f), void 0 !== f ? { json: f } : { text: m3 || "" };
  }, Ft3, l, f, ie4, ge2, Be2, d, v, oe2, ae2, m3, pe2, le2, ue2, je2, $e2, Fe2, Ue2, Ne2, s2, function(e3) {
    n2(22, ue2 = (ce2 = e3) ? bl(f, ce2.items) : void 0);
  }, function(e3) {
    return be2.apply(this, arguments);
  }, function() {
    n2(13, ge2 = false), n2(23, je2 = false), Ft3();
  }, function(e3) {
    a2("select validation error", e3), n2(12, ie4 = zs(e3.path)), Ct2(e3.path);
  }, ot2, function(e3) {
    var t4;
    e3.preventDefault();
    var n3 = null === (t4 = e3.clipboardData) || void 0 === t4 ? void 0 : t4.getData("text/plain");
    void 0 !== n3 && th({ clipboardText: n3, json: f, selection: ie4, readOnly: k2, parser: N3, onPatch: qt2, onChangeText: Rt2, openRepairModal: st2 });
  }, ht2, jt2, xt2, function() {
    bt2([]);
  }, function() {
    $t2({ rootPath: [] });
  }, qt2, function() {
    Et2([], true, true);
  }, function() {
    Et2([], false, true);
  }, function(e3) {
    var t4 = Do(e3), r3 = e3.shiftKey;
    if (a2("keydown", { combo: t4, key: e3.key }), "Ctrl+X" === t4 && (e3.preventDefault(), nt2(true)), "Ctrl+Shift+X" === t4 && (e3.preventDefault(), nt2(false)), "Ctrl+C" === t4 && (e3.preventDefault(), ot2(true)), "Ctrl+Shift+C" === t4 && (e3.preventDefault(), ot2(false)), "Ctrl+D" === t4 && (e3.preventDefault(), ct2()), "Delete" !== t4 && "Backspace" !== t4 || (e3.preventDefault(), lt2()), "Insert" === t4 && (e3.preventDefault(), dt("structure")), "Ctrl+A" === t4 && (e3.preventDefault(), n2(12, ie4 = zs([]))), "Ctrl+Q" === t4 && Nt2(e3), "ArrowUp" === t4 || "Shift+ArrowUp" === t4) {
      e3.preventDefault();
      var o2 = ie4 ? gs(f, pe2, ie4, r3) || ie4 : xs(f, pe2);
      n2(12, ie4 = o2), Ot2(Ds(o2));
    }
    if ("ArrowDown" === t4 || "Shift+ArrowDown" === t4) {
      e3.preventDefault();
      var s3 = ie4 ? function(e4, t5, n3) {
        var r4 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
        if (n3) {
          var o3 = r4 ? Ds(n3) : hs(e4, n3), a3 = yr(getIn(e4, o3)) ? Bi(e4, t5, o3, true) : t5, i2 = Gi(e4, t5, o3), s4 = Gi(e4, a3, o3);
          if (r4) return is(n3) ? void 0 !== i2 ? Es(i2, i2) : void 0 : as(n3) ? void 0 !== s4 ? Es(s4, s4) : void 0 : void 0 !== s4 ? Es(Js(n3), s4) : void 0;
          if (as(n3)) return void 0 !== s4 ? zs(s4) : void 0;
          if (is(n3)) return void 0 !== i2 ? zs(i2) : void 0;
          if (ls(n3)) return void 0 !== i2 ? zs(i2) : void 0;
          if (ss(n3)) {
            if (void 0 === i2 || 0 === i2.length) return;
            var l3 = initial_default(i2), c2 = getIn(e4, l3);
            return Array.isArray(c2) ? zs(i2) : Ss(i2);
          }
          return cs(n3) ? void 0 !== s4 ? zs(s4) : void 0 !== i2 ? zs(i2) : void 0 : void 0;
        }
      }(f, pe2, ie4, r3) || ie4 : xs(f, pe2);
      n2(12, ie4 = s3), Ot2(Ds(s3));
    }
    if ("ArrowLeft" === t4 || "Shift+ArrowLeft" === t4) {
      e3.preventDefault();
      var l2 = ie4 ? function(e4, t5, n3) {
        var r4 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3], o3 = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4];
        if (n3) {
          var { caret: a3, previous: i2 } = js(e4, t5, n3, o3);
          if (r4) return cs(n3) ? void 0 : Es(n3.path, n3.path);
          if (a3 && i2) return Ns(i2);
          var s4 = initial_default(Ds(n3)), l3 = getIn(e4, s4);
          return ls(n3) && Array.isArray(l3) ? Es(n3.path, n3.path) : cs(n3) && !Array.isArray(l3) ? Ss(n3.focusPath) : void 0;
        }
      }(f, pe2, ie4, r3, !k2) || ie4 : xs(f, pe2);
      n2(12, ie4 = l2), Ot2(Ds(l2));
    }
    if ("ArrowRight" === t4 || "Shift+ArrowRight" === t4) {
      e3.preventDefault();
      var c = ie4 && void 0 !== f ? function(e4, t5, n3) {
        var r4 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3], o3 = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4];
        if (n3) {
          var { caret: a3, next: i2 } = js(e4, t5, n3, o3);
          return r4 ? cs(n3) ? void 0 : Es(n3.path, n3.path) : a3 && i2 ? Ns(i2) : cs(n3) ? zs(n3.focusPath) : void 0;
        }
      }(f, pe2, ie4, r3, !k2) || ie4 : xs(f, pe2);
      n2(12, ie4 = c), Ot2(Ds(c));
    }
    if ("Enter" === t4 && ie4) {
      if (us(ie4)) {
        var d2 = ie4.focusPath, v2 = getIn(f, initial_default(d2));
        Array.isArray(v2) && n2(12, ie4 = zs(d2));
      }
      if (ss(ie4) && (e3.preventDefault(), n2(12, ie4 = i(i({}, ie4), {}, { edit: true }))), ls(ie4)) e3.preventDefault(), yr(getIn(f, ie4.path)) ? Et2(ie4.path, true) : n2(12, ie4 = i(i({}, ie4), {}, { edit: true }));
    }
    if (1 === t4.replace(/^Shift\+/, "").length && ie4) return e3.preventDefault(), void ht2(e3.key);
    if ("Enter" === t4 && (as(ie4) || is(ie4))) return e3.preventDefault(), void ht2("");
    if ("Ctrl+Enter" === t4 && ls(ie4)) {
      var p = getIn(f, ie4.path);
      qr(p) && window.open(String(p), "_blank");
    }
    "Escape" === t4 && ie4 && (e3.preventDefault(), n2(12, ie4 = void 0)), "Ctrl+F" === t4 && (e3.preventDefault(), Pt2(false)), "Ctrl+H" === t4 && (e3.preventDefault(), Pt2(true)), "Ctrl+Z" === t4 && (e3.preventDefault(), jt2()), "Ctrl+Shift+Z" === t4 && (e3.preventDefault(), xt2());
  }, function(e3) {
    a2("handleMouseDown", e3);
    var t4 = e3.target;
    Mo(t4, "BUTTON") || t4.isContentEditable || (Ft3(), ie4 || void 0 !== f || "" !== m3 && void 0 !== m3 || (a2("createDefaultSelection"), n2(12, ie4 = zs([]))));
  }, Nt2, function(e3) {
    At3({ anchor: Ao(e3.target, "BUTTON"), offsetTop: 0, width: oi, height: ri, showTip: true });
  }, function() {
    return Bt3.apply(this, arguments);
  }, function() {
    a2("clear pasted json"), n2(21, le2 = void 0), Ft3();
  }, function() {
    H2(co.text);
  }, function(e3) {
    n2(12, ie4 = e3), Ft3(), Ct2(Ds(e3));
  }, function(e3) {
    var t4 = !Eo(e3.target, (e4) => e4 === v);
    t4 && Is(ie4) && (a2("click outside the editor, exit edit mode"), n2(12, ie4 = ks(ie4)), y && d && (d.focus(), d.blur()), a2("blur (outside editor)"), d && d.blur());
  }, S4, z3, R3, A, B3, F3, U3, V, H2, W3, Q2, K3, Z3, X2, G2, ee2, te2, ne2, we2, Ce2, Ve2, He2, Xe2, $t2, Ct2, St, se2, function(e3) {
    n2(13, ge2 = e3);
  }, function(e3) {
    Tn[e3 ? "unshift" : "push"](() => {
      n2(15, d = e3);
    });
  }, () => {
    Ft3(), ht2("{");
  }, () => {
    Ft3(), ht2("[");
  }, () => {
    Ft3();
  }, function(e3) {
    Tn[e3 ? "unshift" : "push"](() => {
      n2(10, l = e3);
    });
  }, function(e3) {
    Tn[e3 ? "unshift" : "push"](() => {
      n2(16, v = e3);
    });
  }, () => n2(17, oe2 = false), () => {
    var e3;
    null === (e3 = ae2) || void 0 === e3 || e3.onClose(), n2(18, ae2 = void 0);
  }];
}
var Sg = class extends dr {
  constructor(e2) {
    super(), ur(this, e2, kg, Cg, Ht, { readOnly: 0, externalContent: 52, externalSelection: 53, mainMenuBar: 1, navigationBar: 2, escapeControlCharacters: 54, escapeUnicodeCharacters: 55, parser: 3, parseMemoizeOne: 56, validator: 57, validationParser: 58, pathParser: 4, indentation: 5, onError: 6, onChange: 59, onChangeMode: 60, onSelect: 61, onRenderValue: 62, onRenderMenu: 7, onRenderContextMenu: 63, onClassName: 64, onFocus: 65, onBlur: 66, onSortModal: 67, onTransformModal: 68, onJSONEditorModal: 69, expand: 70, collapse: 71, validate: 72, getJson: 73, patch: 74, acceptAutoRepair: 8, openTransformModal: 75, scrollTo: 76, findElement: 77, focus: 9 }, ug, [-1, -1, -1, -1, -1]);
  }
  get expand() {
    return this.$$.ctx[70];
  }
  get collapse() {
    return this.$$.ctx[71];
  }
  get validate() {
    return this.$$.ctx[72];
  }
  get getJson() {
    return this.$$.ctx[73];
  }
  get patch() {
    return this.$$.ctx[74];
  }
  get acceptAutoRepair() {
    return this.$$.ctx[8];
  }
  get openTransformModal() {
    return this.$$.ctx[75];
  }
  get scrollTo() {
    return this.$$.ctx[76];
  }
  get findElement() {
    return this.$$.ctx[77];
  }
  get focus() {
    return this.$$.ctx[9];
  }
};
function Og(e2) {
  return "object" != typeof (t3 = e2) || null === t3 ? e2 : new Proxy(e2, { get: (e3, t4, n2) => Og(Reflect.get(e3, t4, n2)), set: () => false, deleteProperty: () => false });
  var t3;
}
function zg(e2) {
  rn(e2, "svelte-rrrjnb", '.jse-transform-modal-inner.svelte-rrrjnb.svelte-rrrjnb{flex:1;display:flex;flex-direction:column;min-width:0;min-height:0}.jse-transform-modal-inner.svelte-rrrjnb .jse-modal-contents.svelte-rrrjnb{color:inherit;flex:1;display:flex;flex-direction:column;padding:0;overflow:auto;min-width:0;min-height:0}.jse-transform-modal-inner.svelte-rrrjnb .jse-modal-contents .jse-actions.svelte-rrrjnb{display:flex;flex-direction:row;justify-content:flex-end;padding-top:var(--jse-padding, 10px)}.jse-transform-modal-inner.svelte-rrrjnb .jse-modal-contents .jse-actions button.jse-primary.svelte-rrrjnb{border:none;background:transparent;color:inherit;cursor:pointer;font-family:var(--jse-font-family, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif);font-size:var(--jse-font-size, 16px);padding:5px;margin:0;background:var(--jse-button-primary-background, var(--jse-theme-color, #3883fa));color:var(--jse-button-primary-color, #fff);padding:var(--jse-padding, 10px) calc(2 * var(--jse-padding, 10px));border-radius:3px}.jse-transform-modal-inner.svelte-rrrjnb .jse-modal-contents .jse-actions button.jse-primary.svelte-rrrjnb:hover{background:var(--jse-button-primary-background-highlight, var(--jse-theme-color-highlight, #5f9dff))}.jse-transform-modal-inner.svelte-rrrjnb .jse-modal-contents .jse-actions button.jse-primary.svelte-rrrjnb:disabled{background:var(--jse-button-primary-background-disabled, #9d9d9d)}.jse-transform-modal-inner.svelte-rrrjnb .jse-modal-contents .jse-main-contents.svelte-rrrjnb{flex:1;display:flex;gap:calc(2 * var(--jse-padding, 10px));min-height:0;box-sizing:border-box;padding:0 calc(2 * var(--jse-padding, 10px)) var(--jse-padding, 10px)}.jse-transform-modal-inner.svelte-rrrjnb .jse-modal-contents .jse-main-contents .jse-query-contents.svelte-rrrjnb{flex:1;display:flex;flex-direction:column}.jse-transform-modal-inner.svelte-rrrjnb .jse-modal-contents .jse-main-contents .jse-query-contents .jse-description.svelte-rrrjnb p{margin:var(--jse-padding, 10px) 0}.jse-transform-modal-inner.svelte-rrrjnb .jse-modal-contents .jse-main-contents .jse-query-contents .jse-description.svelte-rrrjnb p:first-child{margin-top:0}.jse-transform-modal-inner.svelte-rrrjnb .jse-modal-contents .jse-main-contents .jse-query-contents .jse-description.svelte-rrrjnb p:last-child{margin-bottom:0}.jse-transform-modal-inner.svelte-rrrjnb .jse-modal-contents .jse-main-contents .jse-query-contents .jse-description.svelte-rrrjnb code{background:var(--jse-modal-code-background, rgba(0, 0, 0, 0.05));font-family:var(--jse-font-family-mono, consolas, menlo, monaco, "Ubuntu Mono", "source-code-pro", monospace);font-size:var(--jse-font-size-mono, 14px)}.jse-transform-modal-inner.svelte-rrrjnb .jse-modal-contents .jse-main-contents .jse-query-contents .query-error.svelte-rrrjnb{color:var(--jse-error-color, #ee5341)}.jse-transform-modal-inner.svelte-rrrjnb .jse-modal-contents .jse-main-contents .jse-query-contents textarea.jse-query.svelte-rrrjnb{flex:1;outline:none;resize:vertical}.jse-transform-modal-inner.svelte-rrrjnb .jse-modal-contents .jse-main-contents .jse-data-contents.svelte-rrrjnb{flex:1;display:flex;flex-direction:column;gap:calc(2 * var(--jse-padding, 10px))}.jse-transform-modal-inner.svelte-rrrjnb .jse-modal-contents .jse-main-contents .jse-data-contents .jse-original-data.svelte-rrrjnb{flex:1;display:flex;flex-direction:column;min-height:0;box-sizing:border-box}.jse-transform-modal-inner.svelte-rrrjnb .jse-modal-contents .jse-main-contents .jse-data-contents .jse-original-data.jse-hide.svelte-rrrjnb{flex:none}.jse-transform-modal-inner.svelte-rrrjnb .jse-modal-contents .jse-main-contents .jse-data-contents .jse-preview-data.svelte-rrrjnb{flex:1;display:flex;flex-direction:column;min-height:0;box-sizing:border-box}.jse-transform-modal-inner.svelte-rrrjnb .jse-modal-contents .jse-main-contents .jse-data-contents.jse-hide-original-data.svelte-rrrjnb{flex-direction:column;gap:0;margin-bottom:0}.jse-transform-modal-inner.svelte-rrrjnb .jse-modal-contents .jse-actions.svelte-rrrjnb{padding:var(--jse-padding, 10px) calc(2 * var(--jse-padding, 10px)) calc(2 * var(--jse-padding, 10px))}@media screen and (max-width: 1200px){.jse-transform-modal-inner.svelte-rrrjnb .jse-modal-contents .jse-main-contents.svelte-rrrjnb{flex-direction:column;overflow:auto}.jse-transform-modal-inner.svelte-rrrjnb .jse-modal-contents .jse-main-contents .jse-query-contents textarea.jse-query.svelte-rrrjnb{min-height:150px;flex:none}.jse-transform-modal-inner.svelte-rrrjnb .jse-modal-contents .jse-main-contents .jse-data-contents.svelte-rrrjnb .jse-tree-mode{height:300px;flex:none}}.jse-transform-modal-inner.svelte-rrrjnb .jse-label.svelte-rrrjnb{font-weight:bold;display:block;box-sizing:border-box}.jse-transform-modal-inner.svelte-rrrjnb .jse-label .jse-label-inner.svelte-rrrjnb{margin-top:calc(2 * var(--jse-padding, 10px));margin-bottom:calc(0.5 * var(--jse-padding, 10px));box-sizing:border-box}.jse-transform-modal-inner.svelte-rrrjnb .jse-label .jse-label-inner button.svelte-rrrjnb{border:none;background:transparent;color:inherit;cursor:pointer;font-family:var(--jse-font-family, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif);font-size:var(--jse-font-size, 16px);padding:5px;margin:0;font-weight:bold;padding:0}.jse-transform-modal-inner.svelte-rrrjnb .jse-tree-mode{flex:1;background:var(--jse-input-background-readonly, transparent);box-shadow:none;box-sizing:border-box;--jse-main-border:var(--jse-input-border, 1px solid #d8dbdf)}.jse-transform-modal-inner.svelte-rrrjnb input.svelte-rrrjnb,.jse-transform-modal-inner.svelte-rrrjnb textarea.svelte-rrrjnb{border:var(--jse-input-border, 1px solid #d8dbdf);outline:none;box-sizing:border-box;padding:calc(0.5 * var(--jse-padding, 10px));font-family:var(--jse-font-family-mono, consolas, menlo, monaco, "Ubuntu Mono", "source-code-pro", monospace);font-size:var(--jse-font-size-mono, 14px);color:inherit;background:var(--jse-input-background, var(--jse-background-color, #fff))}.jse-transform-modal-inner.svelte-rrrjnb input.svelte-rrrjnb:focus,.jse-transform-modal-inner.svelte-rrrjnb textarea.svelte-rrrjnb:focus{border:var(--jse-input-border-focus, 1px solid var(--jse-input-border-focus, var(--jse-theme-color, #3883fa)))}.jse-transform-modal-inner.svelte-rrrjnb input.svelte-rrrjnb:read-only,.jse-transform-modal-inner.svelte-rrrjnb textarea.svelte-rrrjnb:read-only{background:var(--jse-input-background-readonly, transparent)}.jse-transform-modal-inner.svelte-rrrjnb .jse-preview.jse-error.svelte-rrrjnb{flex:1;background:var(--jse-input-background-readonly, transparent);border:var(--jse-input-border, 1px solid #d8dbdf);color:var(--jse-error-color, #ee5341);padding:calc(0.5 * var(--jse-padding, 10px))}.jse-transform-modal-inner.svelte-rrrjnb a{color:var(--jse-a-color, #156fc5)}.jse-transform-modal-inner.svelte-rrrjnb a:hover{color:var(--jse-a-color-highlight, #0f508d)}');
}
function qg(e2) {
  var t3, n2, r2, o2, a2, i2 = [Rg, Mg], s2 = [];
  function l(e3, n3) {
    return 32768 & n3[0] && (t3 = null), null == t3 && (t3 = !!Array.isArray(e3[15])), t3 ? 0 : 1;
  }
  return n2 = l(e2, [-1, -1]), r2 = s2[n2] = i2[n2](e2), { c() {
    r2.c(), o2 = vn();
  }, m(e3, t4) {
    s2[n2].m(e3, t4), on(e3, o2, t4), a2 = true;
  }, p(e3, t4) {
    var a3 = n2;
    (n2 = l(e3, t4)) === a3 ? s2[n2].p(e3, t4) : (Kn(), Gn(s2[a3], 1, 1, () => {
      s2[a3] = null;
    }), Zn(), (r2 = s2[n2]) ? r2.p(e3, t4) : (r2 = s2[n2] = i2[n2](e3)).c(), Xn(r2, 1), r2.m(o2.parentNode, o2));
  }, i(e3) {
    a2 || (Xn(r2), a2 = true);
  }, o(e3) {
    Gn(r2), a2 = false;
  }, d(e3) {
    e3 && an(o2), s2[n2].d(e3);
  } };
}
function Mg(e2) {
  var t3;
  return { c() {
    t3 = un("(Only available for arrays, not for objects)");
  }, m(e3, n2) {
    on(e3, t3, n2);
  }, p: Bt, i: Bt, o: Bt, d(e3) {
    e3 && an(t3);
  } };
}
function Rg(e2) {
  var t3, n2, r2, o2;
  t3 = new yd({ props: { queryOptions: e2[16], json: e2[15], onChange: e2[27] } });
  var a2 = e2[23] && Eg(e2);
  return { c() {
    sr(t3.$$.fragment), n2 = dn(), a2 && a2.c(), r2 = vn();
  }, m(e3, i2) {
    lr(t3, e3, i2), on(e3, n2, i2), a2 && a2.m(e3, i2), on(e3, r2, i2), o2 = true;
  }, p(e3, n3) {
    var o3 = {};
    65536 & n3[0] && (o3.queryOptions = e3[16]), 32768 & n3[0] && (o3.json = e3[15]), t3.$set(o3), e3[23] ? a2 ? a2.p(e3, n3) : ((a2 = Eg(e3)).c(), a2.m(r2.parentNode, r2)) : a2 && (a2.d(1), a2 = null);
  }, i(e3) {
    o2 || (Xn(t3.$$.fragment, e3), o2 = true);
  }, o(e3) {
    Gn(t3.$$.fragment, e3), o2 = false;
  }, d(e3) {
    e3 && (an(n2), an(r2)), cr(t3, e3), a2 && a2.d(e3);
  } };
}
function Eg(e2) {
  var t3, n2;
  return { c() {
    t3 = ln("div"), n2 = un(e2[23]), hn(t3, "class", "query-error svelte-rrrjnb");
  }, m(e3, r2) {
    on(e3, t3, r2), nn(t3, n2);
  }, p(e3, t4) {
    8388608 & t4[0] && yn(n2, e3[23]);
  }, d(e3) {
    e3 && an(t3);
  } };
}
function Pg(e2) {
  var t3, n2;
  return t3 = new Sg({ props: { externalContent: e2[19], externalSelection: void 0, readOnly: true, mainMenuBar: false, navigationBar: false, indentation: e2[2], escapeControlCharacters: e2[3], escapeUnicodeCharacters: e2[4], parser: e2[5], parseMemoizeOne: e2[6], onRenderValue: e2[10], onRenderMenu: e2[11], onRenderContextMenu: e2[12], onError: console.error, onChange: noop_default, onChangeMode: noop_default, onSelect: noop_default, onFocus: noop_default, onBlur: noop_default, onSortModal: noop_default, onTransformModal: noop_default, onJSONEditorModal: noop_default, onClassName: e2[13], validator: void 0, validationParser: e2[7], pathParser: e2[8] } }), { c() {
    sr(t3.$$.fragment);
  }, m(e3, r2) {
    lr(t3, e3, r2), n2 = true;
  }, p(e3, n3) {
    var r2 = {};
    524288 & n3[0] && (r2.externalContent = e3[19]), 4 & n3[0] && (r2.indentation = e3[2]), 8 & n3[0] && (r2.escapeControlCharacters = e3[3]), 16 & n3[0] && (r2.escapeUnicodeCharacters = e3[4]), 32 & n3[0] && (r2.parser = e3[5]), 64 & n3[0] && (r2.parseMemoizeOne = e3[6]), 1024 & n3[0] && (r2.onRenderValue = e3[10]), 2048 & n3[0] && (r2.onRenderMenu = e3[11]), 4096 & n3[0] && (r2.onRenderContextMenu = e3[12]), 8192 & n3[0] && (r2.onClassName = e3[13]), 128 & n3[0] && (r2.validationParser = e3[7]), 256 & n3[0] && (r2.pathParser = e3[8]), t3.$set(r2);
  }, i(e3) {
    n2 || (Xn(t3.$$.fragment, e3), n2 = true);
  }, o(e3) {
    Gn(t3.$$.fragment, e3), n2 = false;
  }, d(e3) {
    cr(t3, e3);
  } };
}
function Ig(e2) {
  var t3, n2;
  return { c() {
    t3 = ln("div"), n2 = un(e2[24]), hn(t3, "class", "jse-preview jse-error svelte-rrrjnb");
  }, m(e3, r2) {
    on(e3, t3, r2), nn(t3, n2);
  }, p(e3, t4) {
    16777216 & t4[0] && yn(n2, e3[24]);
  }, i: Bt, o: Bt, d(e3) {
    e3 && an(t3);
  } };
}
function Tg(e2) {
  var t3, n2;
  return t3 = new Sg({ props: { externalContent: e2[25], externalSelection: void 0, readOnly: true, mainMenuBar: false, navigationBar: false, indentation: e2[2], escapeControlCharacters: e2[3], escapeUnicodeCharacters: e2[4], parser: e2[5], parseMemoizeOne: e2[6], onRenderValue: e2[10], onRenderMenu: e2[11], onRenderContextMenu: e2[12], onError: console.error, onChange: noop_default, onChangeMode: noop_default, onSelect: noop_default, onFocus: noop_default, onBlur: noop_default, onSortModal: noop_default, onTransformModal: noop_default, onJSONEditorModal: noop_default, onClassName: e2[13], validator: void 0, validationParser: e2[7], pathParser: e2[8] } }), { c() {
    sr(t3.$$.fragment);
  }, m(e3, r2) {
    lr(t3, e3, r2), n2 = true;
  }, p(e3, n3) {
    var r2 = {};
    33554432 & n3[0] && (r2.externalContent = e3[25]), 4 & n3[0] && (r2.indentation = e3[2]), 8 & n3[0] && (r2.escapeControlCharacters = e3[3]), 16 & n3[0] && (r2.escapeUnicodeCharacters = e3[4]), 32 & n3[0] && (r2.parser = e3[5]), 64 & n3[0] && (r2.parseMemoizeOne = e3[6]), 1024 & n3[0] && (r2.onRenderValue = e3[10]), 2048 & n3[0] && (r2.onRenderMenu = e3[11]), 4096 & n3[0] && (r2.onRenderContextMenu = e3[12]), 8192 & n3[0] && (r2.onClassName = e3[13]), 128 & n3[0] && (r2.validationParser = e3[7]), 256 & n3[0] && (r2.pathParser = e3[8]), t3.$set(r2);
  }, i(e3) {
    n2 || (Xn(t3.$$.fragment, e3), n2 = true);
  }, o(e3) {
    Gn(t3.$$.fragment, e3), n2 = false;
  }, d(e3) {
    cr(t3, e3);
  } };
}
function Ag(e2) {
  var t3, n2, r2, o2, a2, i2, s2, l, c, u, d, v, p, f, m3, h2, g, j, x, b2, y, $2, w, C3, k2, S4, O, z3, q2, M3, R3, E3, P3, I3, A, N3, B3, F3, U3, L3, D3, J3, V, H2, _2, W3, Q2, Y2, K3 = e2[26](e2[0]).description + "";
  function Z3(t4) {
    e2[40](t4);
  }
  var X2 = { queryLanguages: e2[9], queryLanguageId: e2[0], onChangeQueryLanguage: e2[32], onClose: e2[14] };
  void 0 !== e2[20] && (X2.fullscreen = e2[20]), t3 = new Ld({ props: X2 }), Tn.push(() => ir(t3, "fullscreen", Z3)), x = new Ca({ props: { data: e2[21] ? faCaretDown : faCaretRight } });
  var G2 = e2[21] && qg(e2);
  E3 = new Ca({ props: { data: e2[22] ? faCaretDown : faCaretRight } });
  var ee2 = e2[22] && Pg(e2), te2 = [Tg, Ig], ne2 = [];
  function re2(e3, t4) {
    return e3[24] ? 1 : 0;
  }
  return U3 = re2(e2), L3 = ne2[U3] = te2[U3](e2), { c() {
    sr(t3.$$.fragment), r2 = dn(), o2 = ln("div"), a2 = ln("div"), i2 = ln("div"), (s2 = ln("div")).innerHTML = '<div class="jse-label-inner svelte-rrrjnb">Language</div>', l = dn(), c = ln("div"), u = dn(), (d = ln("div")).innerHTML = '<div class="jse-label-inner svelte-rrrjnb">Path</div>', v = dn(), p = ln("input"), m3 = dn(), h2 = ln("div"), g = ln("div"), j = ln("button"), sr(x.$$.fragment), b2 = un("\n                  Wizard"), y = dn(), G2 && G2.c(), $2 = dn(), (w = ln("div")).innerHTML = '<div class="jse-label-inner svelte-rrrjnb">Query</div>', C3 = dn(), k2 = ln("textarea"), S4 = dn(), O = ln("div"), z3 = ln("div"), q2 = ln("div"), M3 = ln("div"), R3 = ln("button"), sr(E3.$$.fragment), P3 = un("\n                    Original"), I3 = dn(), ee2 && ee2.c(), A = dn(), N3 = ln("div"), (B3 = ln("div")).innerHTML = '<div class="jse-label-inner svelte-rrrjnb">Preview</div>', F3 = dn(), L3.c(), D3 = dn(), J3 = ln("div"), V = ln("button"), H2 = un("Transform"), hn(s2, "class", "jse-label svelte-rrrjnb"), hn(c, "class", "jse-description svelte-rrrjnb"), hn(d, "class", "jse-label svelte-rrrjnb"), hn(p, "class", "jse-path svelte-rrrjnb"), hn(p, "type", "text"), p.readOnly = true, hn(p, "title", "Selected path"), p.value = f = isEmpty_default(e2[1]) ? "(document root)" : _l(e2[1]), hn(j, "type", "button"), hn(j, "class", "svelte-rrrjnb"), hn(g, "class", "jse-label-inner svelte-rrrjnb"), hn(h2, "class", "jse-label svelte-rrrjnb"), hn(w, "class", "jse-label svelte-rrrjnb"), hn(k2, "class", "jse-query svelte-rrrjnb"), hn(k2, "spellcheck", "false"), k2.value = e2[17], hn(i2, "class", "jse-query-contents svelte-rrrjnb"), hn(R3, "type", "button"), hn(R3, "class", "svelte-rrrjnb"), hn(M3, "class", "jse-label-inner svelte-rrrjnb"), hn(q2, "class", "jse-label svelte-rrrjnb"), hn(z3, "class", "jse-original-data svelte-rrrjnb"), kn(z3, "jse-hide", !e2[22]), hn(B3, "class", "jse-label svelte-rrrjnb"), hn(N3, "class", "jse-preview-data svelte-rrrjnb"), hn(O, "class", "jse-data-contents svelte-rrrjnb"), kn(O, "jse-hide-original-data", !e2[22]), hn(a2, "class", "jse-main-contents svelte-rrrjnb"), hn(V, "type", "button"), hn(V, "class", "jse-primary svelte-rrrjnb"), V.disabled = _2 = !!e2[24], hn(J3, "class", "jse-actions svelte-rrrjnb"), hn(o2, "class", "jse-modal-contents svelte-rrrjnb");
  }, m(n3, f2) {
    lr(t3, n3, f2), on(n3, r2, f2), on(n3, o2, f2), nn(o2, a2), nn(a2, i2), nn(i2, s2), nn(i2, l), nn(i2, c), c.innerHTML = K3, nn(i2, u), nn(i2, d), nn(i2, v), nn(i2, p), nn(i2, m3), nn(i2, h2), nn(h2, g), nn(g, j), lr(x, j, null), nn(j, b2), nn(i2, y), G2 && G2.m(i2, null), nn(i2, $2), nn(i2, w), nn(i2, C3), nn(i2, k2), e2[41](k2), nn(a2, S4), nn(a2, O), nn(O, z3), nn(z3, q2), nn(q2, M3), nn(M3, R3), lr(E3, R3, null), nn(R3, P3), nn(z3, I3), ee2 && ee2.m(z3, null), nn(O, A), nn(O, N3), nn(N3, B3), nn(N3, F3), ne2[U3].m(N3, null), nn(o2, D3), nn(o2, J3), nn(J3, V), nn(V, H2), W3 = true, Q2 || (Y2 = [pn(j, "click", e2[30]), pn(k2, "input", e2[28]), pn(R3, "click", e2[31]), pn(V, "click", e2[29]), en(Fg.call(null, V))], Q2 = true);
  }, p(e3, r3) {
    var o3 = {};
    512 & r3[0] && (o3.queryLanguages = e3[9]), 1 & r3[0] && (o3.queryLanguageId = e3[0]), 16384 & r3[0] && (o3.onClose = e3[14]), !n2 && 1048576 & r3[0] && (n2 = true, o3.fullscreen = e3[20], Jn(() => n2 = false)), t3.$set(o3), (!W3 || 1 & r3[0]) && K3 !== (K3 = e3[26](e3[0]).description + "") && (c.innerHTML = K3), (!W3 || 2 & r3[0] && f !== (f = isEmpty_default(e3[1]) ? "(document root)" : _l(e3[1])) && p.value !== f) && (p.value = f);
    var a3 = {};
    2097152 & r3[0] && (a3.data = e3[21] ? faCaretDown : faCaretRight), x.$set(a3), e3[21] ? G2 ? (G2.p(e3, r3), 2097152 & r3[0] && Xn(G2, 1)) : ((G2 = qg(e3)).c(), Xn(G2, 1), G2.m(i2, $2)) : G2 && (Kn(), Gn(G2, 1, 1, () => {
      G2 = null;
    }), Zn()), (!W3 || 131072 & r3[0]) && (k2.value = e3[17]);
    var s3 = {};
    4194304 & r3[0] && (s3.data = e3[22] ? faCaretDown : faCaretRight), E3.$set(s3), e3[22] ? ee2 ? (ee2.p(e3, r3), 4194304 & r3[0] && Xn(ee2, 1)) : ((ee2 = Pg(e3)).c(), Xn(ee2, 1), ee2.m(z3, null)) : ee2 && (Kn(), Gn(ee2, 1, 1, () => {
      ee2 = null;
    }), Zn()), (!W3 || 4194304 & r3[0]) && kn(z3, "jse-hide", !e3[22]);
    var l2 = U3;
    (U3 = re2(e3)) === l2 ? ne2[U3].p(e3, r3) : (Kn(), Gn(ne2[l2], 1, 1, () => {
      ne2[l2] = null;
    }), Zn(), (L3 = ne2[U3]) ? L3.p(e3, r3) : (L3 = ne2[U3] = te2[U3](e3)).c(), Xn(L3, 1), L3.m(N3, null)), (!W3 || 4194304 & r3[0]) && kn(O, "jse-hide-original-data", !e3[22]), (!W3 || 16777216 & r3[0] && _2 !== (_2 = !!e3[24])) && (V.disabled = _2);
  }, i(e3) {
    W3 || (Xn(t3.$$.fragment, e3), Xn(x.$$.fragment, e3), Xn(G2), Xn(E3.$$.fragment, e3), Xn(ee2), Xn(L3), W3 = true);
  }, o(e3) {
    Gn(t3.$$.fragment, e3), Gn(x.$$.fragment, e3), Gn(G2), Gn(E3.$$.fragment, e3), Gn(ee2), Gn(L3), W3 = false;
  }, d(n3) {
    n3 && (an(r2), an(o2)), cr(t3, n3), cr(x), G2 && G2.d(), e2[41](null), cr(E3), ee2 && ee2.d(), ne2[U3].d(), Q2 = false, Dt(Y2);
  } };
}
function Ng(e2) {
  var t3, n2, r2, o2, a2;
  return n2 = new ra({ props: { $$slots: { default: [Ag] }, $$scope: { ctx: e2 } } }), { c() {
    t3 = ln("div"), sr(n2.$$.fragment), hn(t3, "class", "jse-transform-modal-inner svelte-rrrjnb");
  }, m(i2, s2) {
    on(i2, t3, s2), lr(n2, t3, null), r2 = true, o2 || (a2 = en(yv.call(null, t3, e2[33])), o2 = true);
  }, p(e3, t4) {
    var r3 = {};
    67108863 & t4[0] | 131072 & t4[1] && (r3.$$scope = { dirty: t4, ctx: e3 }), n2.$set(r3);
  }, i(e3) {
    r2 || (Xn(n2.$$.fragment, e3), r2 = true);
  }, o(e3) {
    Gn(n2.$$.fragment, e3), r2 = false;
  }, d(e3) {
    e3 && an(t3), cr(n2), o2 = false, a2();
  } };
}
function Bg(e2) {
  var t3, n2;
  return t3 = new kv({ props: { onClose: e2[14], className: "jse-transform-modal", fullscreen: e2[20], $$slots: { default: [Ng] }, $$scope: { ctx: e2 } } }), { c() {
    sr(t3.$$.fragment);
  }, m(e3, r2) {
    lr(t3, e3, r2), n2 = true;
  }, p(e3, n3) {
    var r2 = {};
    16384 & n3[0] && (r2.onClose = e3[14]), 1048576 & n3[0] && (r2.fullscreen = e3[20]), 67108863 & n3[0] | 131072 & n3[1] && (r2.$$scope = { dirty: n3, ctx: e3 }), t3.$set(r2);
  }, i(e3) {
    n2 || (Xn(t3.$$.fragment, e3), n2 = true);
  }, o(e3) {
    Gn(t3.$$.fragment, e3), n2 = false;
  }, d(e3) {
    cr(t3, e3);
  } };
}
function Fg(e2) {
  e2.focus();
}
function Ug(e2, t3, n2) {
  var r2, o2, a2, i2, s2, l, d = vr("jsoneditor:TransformModal"), { id: v = "transform-modal-" + hr() } = t3, { json: p } = t3, { rootPath: f = [] } = t3, { indentation: m3 } = t3, { escapeControlCharacters: h2 } = t3, { escapeUnicodeCharacters: g } = t3, { parser: j } = t3, { parseMemoizeOne: x } = t3, { validationParser: b2 } = t3, { pathParser: y } = t3, { queryLanguages: $2 } = t3, { queryLanguageId: w } = t3, { onChangeQueryLanguage: C3 } = t3, { onRenderValue: k2 } = t3, { onRenderMenu: S4 } = t3, { onRenderContextMenu: O } = t3, { onClassName: z3 } = t3, { onTransform: q2 } = t3, { onClose: M3 } = t3, R3 = false, E3 = "".concat(v, ":").concat(compileJSONPointer(f)), P3 = null !== (r2 = Gl[E3]) && void 0 !== r2 ? r2 : {}, I3 = false !== ec.showWizard, T3 = false !== ec.showOriginal, A = null !== (o2 = P3.queryOptions) && void 0 !== o2 ? o2 : {}, N3 = w === P3.queryLanguageId && P3.query ? P3.query : "", B3 = null !== (a2 = P3.isManual) && void 0 !== a2 && a2, F3 = void 0, U3 = void 0, L3 = { text: "" };
  function J3(e3) {
    var t4;
    return null !== (t4 = $2.find((t5) => t5.id === e3)) && void 0 !== t4 ? t4 : $2[0];
  }
  function V(e3) {
    try {
      n2(16, A = e3), n2(17, N3 = J3(w).createQuery(s2, e3)), n2(23, F3 = void 0), n2(39, B3 = false), d("updateQueryByWizard", { queryOptions: A, query: N3, isManual: B3 });
    } catch (e4) {
      n2(23, F3 = String(e4));
    }
  }
  B3 || V(A), qn(() => {
    var e3;
    null === (e3 = i2) || void 0 === e3 || e3.focus();
  });
  var H2 = debounce_default(function(e3, t4) {
    if (void 0 === e3) return n2(25, L3 = { text: "" }), void n2(24, U3 = "Error: No JSON");
    if ("" !== t4.trim()) try {
      d("previewTransform", { query: t4 });
      var r3 = J3(w).executeQuery(e3, t4, j);
      n2(25, L3 = { json: r3 }), n2(24, U3 = void 0);
    } catch (e4) {
      n2(25, L3 = { text: "" }), n2(24, U3 = String(e4));
    }
    else n2(25, L3 = { json: e3 });
  }, 300);
  return e2.$$set = (e3) => {
    "id" in e3 && n2(34, v = e3.id), "json" in e3 && n2(35, p = e3.json), "rootPath" in e3 && n2(1, f = e3.rootPath), "indentation" in e3 && n2(2, m3 = e3.indentation), "escapeControlCharacters" in e3 && n2(3, h2 = e3.escapeControlCharacters), "escapeUnicodeCharacters" in e3 && n2(4, g = e3.escapeUnicodeCharacters), "parser" in e3 && n2(5, j = e3.parser), "parseMemoizeOne" in e3 && n2(6, x = e3.parseMemoizeOne), "validationParser" in e3 && n2(7, b2 = e3.validationParser), "pathParser" in e3 && n2(8, y = e3.pathParser), "queryLanguages" in e3 && n2(9, $2 = e3.queryLanguages), "queryLanguageId" in e3 && n2(0, w = e3.queryLanguageId), "onChangeQueryLanguage" in e3 && n2(36, C3 = e3.onChangeQueryLanguage), "onRenderValue" in e3 && n2(10, k2 = e3.onRenderValue), "onRenderMenu" in e3 && n2(11, S4 = e3.onRenderMenu), "onRenderContextMenu" in e3 && n2(12, O = e3.onRenderContextMenu), "onClassName" in e3 && n2(13, z3 = e3.onClassName), "onTransform" in e3 && n2(37, q2 = e3.onTransform), "onClose" in e3 && n2(14, M3 = e3.onClose);
  }, e2.$$.update = () => {
    2 & e2.$$.dirty[0] | 16 & e2.$$.dirty[1] && n2(15, s2 = Og(getIn(p, f))), 32768 & e2.$$.dirty[0] && n2(19, l = s2 ? { json: s2 } : { text: "" }), 163840 & e2.$$.dirty[0] && H2(s2, N3), 196609 & e2.$$.dirty[0] | 384 & e2.$$.dirty[1] && (n2(38, Gl[E3] = { queryOptions: A, query: N3, queryLanguageId: w, isManual: B3 }, Gl), d("store state in memory", E3, Gl[E3]));
  }, [w, f, m3, h2, g, j, x, b2, y, $2, k2, S4, O, z3, M3, s2, A, N3, i2, l, R3, I3, T3, F3, U3, L3, J3, V, function(e3) {
    n2(17, N3 = e3.target.value), n2(39, B3 = true), d("handleChangeQuery", { query: N3, isManual: B3 });
  }, function() {
    if (void 0 === s2) return n2(25, L3 = { text: "" }), void n2(24, U3 = "Error: No JSON");
    try {
      d("handleTransform", { query: N3 });
      var e3 = J3(w).executeQuery(s2, N3, j);
      q2([{ op: "replace", path: compileJSONPointer(f), value: e3 }]), M3();
    } catch (e4) {
      console.error(e4), n2(25, L3 = { text: "" }), n2(24, U3 = String(e4));
    }
  }, function() {
    n2(21, I3 = !I3), ec.showWizard = I3;
  }, function() {
    n2(22, T3 = !T3), ec.showOriginal = T3;
  }, function(e3) {
    d("handleChangeQueryLanguage", e3), n2(0, w = e3), C3(e3), V(A);
  }, function() {
    R3 ? n2(20, R3 = !R3) : M3();
  }, v, p, C3, q2, Gl, B3, function(e3) {
    n2(20, R3 = e3);
  }, function(e3) {
    Tn[e3 ? "unshift" : "push"](() => {
      n2(18, i2 = e3);
    });
  }];
}
var Lg = class extends dr {
  constructor(e2) {
    super(), ur(this, e2, Ug, Bg, Ht, { id: 34, json: 35, rootPath: 1, indentation: 2, escapeControlCharacters: 3, escapeUnicodeCharacters: 4, parser: 5, parseMemoizeOne: 6, validationParser: 7, pathParser: 8, queryLanguages: 9, queryLanguageId: 0, onChangeQueryLanguage: 36, onRenderValue: 10, onRenderMenu: 11, onRenderContextMenu: 12, onClassName: 13, onTransform: 37, onClose: 14 }, zg, [-1, -1]);
  }
};
function Dg() {
}
function Jg(e2) {
  var t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1e3;
  if (e2 < 0.9 * t3) return e2.toFixed() + " B";
  var n2 = e2 / t3;
  if (n2 < 0.9 * t3) return n2.toFixed(1) + " KB";
  var r2 = n2 / t3;
  if (r2 < 0.9 * t3) return r2.toFixed(1) + " MB";
  var o2 = r2 / t3;
  return o2 < 0.9 * t3 ? o2.toFixed(1) + " GB" : (o2 / t3).toFixed(1) + " TB";
}
function Vg(e2) {
  var t3, n2;
  return t3 = new Wv({ props: { items: e2[0] } }), { c() {
    sr(t3.$$.fragment);
  }, m(e3, r2) {
    lr(t3, e3, r2), n2 = true;
  }, p(e3, n3) {
    var [r2] = n3, o2 = {};
    1 & r2 && (o2.items = e3[0]), t3.$set(o2);
  }, i(e3) {
    n2 || (Xn(t3.$$.fragment, e3), n2 = true);
  }, o(e3) {
    Gn(t3.$$.fragment, e3), n2 = false;
  }, d(e3) {
    cr(t3, e3);
  } };
}
function Hg(e2, t3, n2) {
  var r2, o2, { readOnly: a2 = false } = t3, { onFormat: i2 } = t3, { onCompact: s2 } = t3, { onSort: l } = t3, { onTransform: c } = t3, { onToggleSearch: u } = t3, { onUndo: d } = t3, { onRedo: v } = t3, { canUndo: p } = t3, { canRedo: f } = t3, { canFormat: m3 } = t3, { canCompact: h2 } = t3, { canSort: g } = t3, { canTransform: j } = t3, { onRenderMenu: x } = t3, b2 = { type: "button", icon: faSearch, title: "Search (Ctrl+F)", className: "jse-search", onClick: u };
  return e2.$$set = (e3) => {
    "readOnly" in e3 && n2(1, a2 = e3.readOnly), "onFormat" in e3 && n2(2, i2 = e3.onFormat), "onCompact" in e3 && n2(3, s2 = e3.onCompact), "onSort" in e3 && n2(4, l = e3.onSort), "onTransform" in e3 && n2(5, c = e3.onTransform), "onToggleSearch" in e3 && n2(6, u = e3.onToggleSearch), "onUndo" in e3 && n2(7, d = e3.onUndo), "onRedo" in e3 && n2(8, v = e3.onRedo), "canUndo" in e3 && n2(9, p = e3.canUndo), "canRedo" in e3 && n2(10, f = e3.canRedo), "canFormat" in e3 && n2(11, m3 = e3.canFormat), "canCompact" in e3 && n2(12, h2 = e3.canCompact), "canSort" in e3 && n2(13, g = e3.canSort), "canTransform" in e3 && n2(14, j = e3.canTransform), "onRenderMenu" in e3 && n2(15, x = e3.onRenderMenu);
  }, e2.$$.update = () => {
    32702 & e2.$$.dirty && n2(16, o2 = a2 ? [b2, { type: "space" }] : [{ type: "button", icon: Uf, title: "Format JSON: add proper indentation and new lines (Ctrl+I)", className: "jse-format", onClick: i2, disabled: a2 || !m3 }, { type: "button", icon: Lf, title: "Compact JSON: remove all white spacing and new lines (Ctrl+Shift+I)", className: "jse-compact", onClick: s2, disabled: a2 || !h2 }, { type: "separator" }, { type: "button", icon: faSortAmountDownAlt, title: "Sort", className: "jse-sort", onClick: l, disabled: a2 || !g }, { type: "button", icon: faFilter, title: "Transform contents (filter, sort, project)", className: "jse-transform", onClick: c, disabled: a2 || !j }, b2, { type: "separator" }, { type: "button", icon: faUndo, title: "Undo (Ctrl+Z)", className: "jse-undo", onClick: d, disabled: !p }, { type: "button", icon: faRedo, title: "Redo (Ctrl+Shift+Z)", className: "jse-redo", onClick: v, disabled: !f }, { type: "space" }]), 98304 & e2.$$.dirty && n2(0, r2 = x(o2) || o2);
  }, [r2, a2, i2, s2, l, c, u, d, v, p, f, m3, h2, g, j, x, o2];
}
var _g = class extends dr {
  constructor(e2) {
    super(), ur(this, e2, Hg, Vg, Ht, { readOnly: 1, onFormat: 2, onCompact: 3, onSort: 4, onTransform: 5, onToggleSearch: 6, onUndo: 7, onRedo: 8, canUndo: 9, canRedo: 10, canFormat: 11, canCompact: 12, canSort: 13, canTransform: 14, onRenderMenu: 15 });
  }
};
function Wg(e2) {
  rn(e2, "svelte-1ulj7zd", '.jse-status-bar.svelte-1ulj7zd.svelte-1ulj7zd{background:var(--jse-panel-background, #ebebeb);color:var(--jse-panel-color-readonly, #b2b2b2);font-family:var(--jse-font-family-mono, consolas, menlo, monaco, "Ubuntu Mono", "source-code-pro", monospace);font-size:var(--jse-font-size-mono, 14px);margin:0;border-top:var(--jse-panel-border, var(--jse-main-border, 1px solid #d7d7d7));border-left:var(--jse-main-border, 1px solid #d7d7d7);border-right:var(--jse-main-border, 1px solid #d7d7d7);display:flex;gap:var(--jse-padding, 10px)}.jse-status-bar.svelte-1ulj7zd.svelte-1ulj7zd:last-child{border-bottom:var(--jse-main-border, 1px solid #d7d7d7)}.jse-status-bar.svelte-1ulj7zd .jse-status-bar-info.svelte-1ulj7zd{padding:2px}');
}
function Qg(e2) {
  var t3, n2, r2;
  return { c() {
    t3 = ln("div"), n2 = un("Line: "), r2 = un(e2[0]), hn(t3, "class", "jse-status-bar-info svelte-1ulj7zd");
  }, m(e3, o2) {
    on(e3, t3, o2), nn(t3, n2), nn(t3, r2);
  }, p(e3, t4) {
    1 & t4 && yn(r2, e3[0]);
  }, d(e3) {
    e3 && an(t3);
  } };
}
function Yg(e2) {
  var t3, n2, r2;
  return { c() {
    t3 = ln("div"), n2 = un("Column: "), r2 = un(e2[1]), hn(t3, "class", "jse-status-bar-info svelte-1ulj7zd");
  }, m(e3, o2) {
    on(e3, t3, o2), nn(t3, n2), nn(t3, r2);
  }, p(e3, t4) {
    2 & t4 && yn(r2, e3[1]);
  }, d(e3) {
    e3 && an(t3);
  } };
}
function Kg(e2) {
  var t3, n2, r2, o2;
  return { c() {
    t3 = ln("div"), n2 = un("Selection: "), r2 = un(e2[2]), o2 = un(" characters"), hn(t3, "class", "jse-status-bar-info svelte-1ulj7zd");
  }, m(e3, a2) {
    on(e3, t3, a2), nn(t3, n2), nn(t3, r2), nn(t3, o2);
  }, p(e3, t4) {
    4 & t4 && yn(r2, e3[2]);
  }, d(e3) {
    e3 && an(t3);
  } };
}
function Zg(e2) {
  var t3, n2, r2, o2 = void 0 !== e2[0] && Qg(e2), a2 = void 0 !== e2[1] && Yg(e2), i2 = void 0 !== e2[2] && e2[2] > 0 && Kg(e2);
  return { c() {
    t3 = ln("div"), o2 && o2.c(), n2 = dn(), a2 && a2.c(), r2 = dn(), i2 && i2.c(), hn(t3, "class", "jse-status-bar svelte-1ulj7zd");
  }, m(e3, s2) {
    on(e3, t3, s2), o2 && o2.m(t3, null), nn(t3, n2), a2 && a2.m(t3, null), nn(t3, r2), i2 && i2.m(t3, null);
  }, p(e3, s2) {
    var [l] = s2;
    void 0 !== e3[0] ? o2 ? o2.p(e3, l) : ((o2 = Qg(e3)).c(), o2.m(t3, n2)) : o2 && (o2.d(1), o2 = null), void 0 !== e3[1] ? a2 ? a2.p(e3, l) : ((a2 = Yg(e3)).c(), a2.m(t3, r2)) : a2 && (a2.d(1), a2 = null), void 0 !== e3[2] && e3[2] > 0 ? i2 ? i2.p(e3, l) : ((i2 = Kg(e3)).c(), i2.m(t3, null)) : i2 && (i2.d(1), i2 = null);
  }, i: Bt, o: Bt, d(e3) {
    e3 && an(t3), o2 && o2.d(), a2 && a2.d(), i2 && i2.d();
  } };
}
function Xg(e2, t3, n2) {
  var r2, o2, a2, i2, s2, { editorState: l } = t3;
  return e2.$$set = (e3) => {
    "editorState" in e3 && n2(3, l = e3.editorState);
  }, e2.$$.update = () => {
    var t4, c, u;
    8 & e2.$$.dirty && n2(4, r2 = null === (t4 = l) || void 0 === t4 || null === (t4 = t4.selection) || void 0 === t4 || null === (t4 = t4.main) || void 0 === t4 ? void 0 : t4.head);
    24 & e2.$$.dirty && n2(5, o2 = void 0 !== r2 ? null === (c = l) || void 0 === c || null === (c = c.doc) || void 0 === c ? void 0 : c.lineAt(r2) : void 0);
    (32 & e2.$$.dirty && n2(0, a2 = void 0 !== o2 ? o2.number : void 0), 48 & e2.$$.dirty && n2(1, i2 = void 0 !== o2 && void 0 !== r2 ? r2 - o2.from + 1 : void 0), 8 & e2.$$.dirty) && n2(2, s2 = null === (u = l) || void 0 === u || null === (u = u.selection) || void 0 === u || null === (u = u.ranges) || void 0 === u ? void 0 : u.reduce((e3, t5) => e3 + t5.to - t5.from, 0));
  }, [a2, i2, s2, l, r2, o2];
}
var Gg = class extends dr {
  constructor(e2) {
    super(), ur(this, e2, Xg, Zg, Vt, { editorState: 3 }, Wg);
  }
};
var ej;
var tj;
var nj = HighlightStyle.define([{ tag: tags.propertyName, color: "var(--internal-key-color)" }, { tag: tags.number, color: "var(--internal-value-color-number)" }, { tag: tags.bool, color: "var(--internal-value-color-boolean)" }, { tag: tags.string, color: "var(--internal-value-color-string)" }, { tag: tags.keyword, color: "var(--internal-value-color-null)" }]);
var rj = syntaxHighlighting(nj);
var oj = nj.style;
function aj(e2) {
  rn(e2, "svelte-xt61xw", '.jse-text-mode.svelte-xt61xw.svelte-xt61xw{--internal-key-color:var(--jse-key-color, #1a1a1a);--internal-value-color-number:var(--jse-value-color-number, #ee422e);--internal-value-color-boolean:var(--jse-value-color-boolean, #ff8c00);--internal-value-color-string:var(--jse-value-color-string, #008000);--internal-value-color-null:var(--jse-value-color-null, #004ed0);flex:1;box-sizing:border-box;display:flex;flex-direction:column;background:var(--jse-background-color, #fff)}.jse-text-mode.no-main-menu.svelte-xt61xw.svelte-xt61xw{border-top:var(--jse-main-border, 1px solid #d7d7d7)}.jse-text-mode.svelte-xt61xw .jse-contents.svelte-xt61xw{flex:1;display:flex;position:relative;flex-direction:column;overflow:hidden;min-width:0;min-height:0;border-left:var(--jse-main-border, 1px solid #d7d7d7);border-right:var(--jse-main-border, 1px solid #d7d7d7)}.jse-text-mode.svelte-xt61xw .jse-contents.svelte-xt61xw:last-child{border-bottom:var(--jse-main-border, 1px solid #d7d7d7)}.jse-text-mode.svelte-xt61xw .jse-contents.jse-hidden.svelte-xt61xw{visibility:hidden;position:absolute;top:0;left:0}.jse-text-mode.svelte-xt61xw .jse-contents.svelte-xt61xw .cm-editor{flex:1;overflow:hidden}.jse-text-mode.svelte-xt61xw .jse-contents.svelte-xt61xw .cm-editor .cm-scroller{font-family:var(--jse-font-family-mono, consolas, menlo, monaco, "Ubuntu Mono", "source-code-pro", monospace);font-size:var(--jse-font-size-mono, 14px);line-height:var(--jse-line-height, calc(1em + 4px));color:var(--jse-delimiter-color, rgba(0, 0, 0, 0.38))}.jse-text-mode.svelte-xt61xw .jse-contents.svelte-xt61xw .cm-editor .cm-gutters{background:var(--jse-panel-background, #ebebeb);color:var(--jse-panel-color-readonly, #b2b2b2);border-right:var(--jse-panel-border, var(--jse-main-border, 1px solid #d7d7d7))}.jse-text-mode.svelte-xt61xw .jse-contents.svelte-xt61xw .cm-editor .cm-activeLine,.jse-text-mode.svelte-xt61xw .jse-contents.svelte-xt61xw .cm-editor .cm-activeLineGutter{background:var(--jse-active-line-background-color, rgba(0, 0, 0, 0.06))}.jse-text-mode.svelte-xt61xw .jse-contents.svelte-xt61xw .cm-editor .cm-selectionBackground{background:var(--jse-selection-background-color, #d3d3d3)}.jse-text-mode.svelte-xt61xw .jse-contents.svelte-xt61xw .cm-editor .cm-searchMatch{background-color:var(--jse-search-match-color, #ffe665);outline:var(--jse-search-match-outline, none)}.jse-text-mode.svelte-xt61xw .jse-contents.svelte-xt61xw .cm-editor .cm-searchMatch.cm-searchMatch-selected{background-color:var(--jse-search-match-active-color, var(--jse-search-match-color, #ffe665));outline:var(--jse-search-match-outline, 2px solid #e0be00)}.jse-text-mode.svelte-xt61xw .jse-contents.svelte-xt61xw .cm-editor .cm-selectionMatch{background-color:var(--jse-search-match-background-color, rgba(153, 255, 119, 0.5019607843))}.jse-text-mode.svelte-xt61xw .jse-contents.svelte-xt61xw .cm-editor .cm-foldPlaceholder{background:var(--jse-tag-background, rgba(0, 0, 0, 0.2));color:var(--jse-tag-color, var(--jse-text-color-inverse, #fff));border:none;padding:0 var(--jse-padding, 10px)}.jse-text-mode.svelte-xt61xw .jse-contents.svelte-xt61xw .cm-editor .cm-tooltip{font-size:var(--jse-font-size, 16px);font-family:var(--jse-font-family, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif);color:var(--jse-tooltip-color, var(--jse-text-color, #4d4d4d));background:var(--jse-tooltip-background, var(--jse-modal-background, #f5f5f5));border:var(--jse-tooltip-border, var(--jse-main-border, 1px solid #d7d7d7))}.jse-text-mode.svelte-xt61xw .jse-contents.svelte-xt61xw .cm-editor .cm-diagnosticAction{background:var(--jse-tooltip-action-button-color, var(--jse-text-color-inverse, #fff));background:var(--jse-tooltip-action-button-background, #4d4d4d)}.jse-text-mode.svelte-xt61xw .jse-contents.svelte-xt61xw .cm-editor .cm-panels{border-bottom:var(--jse-panel-border, var(--jse-main-border, 1px solid #d7d7d7))}.jse-text-mode.svelte-xt61xw .jse-contents.svelte-xt61xw .cm-editor .cm-search{background:var(--jse-panel-background, #ebebeb);color:var(--jse-panel-color, var(--jse-text-color, #4d4d4d));font-family:var(--jse-font-family, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif);font-size:var(--jse-font-size, 16px)}.jse-text-mode.svelte-xt61xw .jse-contents.svelte-xt61xw .cm-editor .cm-search input{font-family:var(--jse-font-family, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif);font-size:var(--jse-font-size-text-mode-search, 80%);color:var(--jse-input-color, var(--jse-text-color, #4d4d4d));border:var(--jse-input-border, 1px solid #d8dbdf);background:var(--jse-input-background, var(--jse-background-color, #fff));margin-right:2px}.jse-text-mode.svelte-xt61xw .jse-contents.svelte-xt61xw .cm-editor .cm-search button{font-family:var(--jse-font-family, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif);font-size:var(--jse-font-size-text-mode-search, 80%);color:var(--jse-panel-button-color, inherit);background:var(--jse-panel-button-background, transparent);border:none;cursor:pointer;text-transform:capitalize;padding:calc(0.5 * var(--jse-padding, 10px)) var(--jse-padding, 10px);margin:0}.jse-text-mode.svelte-xt61xw .jse-contents.svelte-xt61xw .cm-editor .cm-search button:hover{color:var(--panel-button-color-highlight, var(--jse-text-color, #4d4d4d));background:var(--jse-panel-button-background-highlight, #e0e0e0)}.jse-text-mode.svelte-xt61xw .jse-contents.svelte-xt61xw .cm-editor .cm-search label{font-family:var(--jse-font-family, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif);font-size:var(--jse-font-size-text-mode-search, 80%);padding-left:var(--jse-padding, 10px)}.jse-text-mode.svelte-xt61xw .jse-contents.svelte-xt61xw .cm-editor .cm-search label input{margin-right:2px}.jse-text-mode.svelte-xt61xw .jse-contents.svelte-xt61xw .cm-editor .cm-search button[name="close"]{width:32px;height:32px;font-size:24px;line-height:24px;padding:0;right:0;top:-4px}.jse-text-mode.svelte-xt61xw .jse-contents.svelte-xt61xw .cm-editor .cm-cursor-primary{border-color:var(--jse-text-color, #4d4d4d)}.jse-text-mode.svelte-xt61xw .jse-contents .jse-loading-space.svelte-xt61xw{flex:1}.jse-text-mode.svelte-xt61xw .jse-contents .jse-loading.svelte-xt61xw{flex:2;text-align:center;color:var(--jse-panel-color-readonly, #b2b2b2);box-sizing:border-box;font-family:var(--jse-font-family, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif);font-size:var(--jse-font-size, 16px)}.jse-text-mode.svelte-xt61xw .jse-contents.jse-preview.svelte-xt61xw{flex:1;font-family:var(--jse-font-family-mono, consolas, menlo, monaco, "Ubuntu Mono", "source-code-pro", monospace);font-size:var(--jse-font-size-mono, 14px);color:var(--jse-panel-color-readonly, #b2b2b2);overflow:auto;white-space:pre-wrap;word-break:break-word;padding:2px}');
}
function ij(e2) {
  var t3 = e2.slice(), n2 = 0 === t3[11].length;
  return t3[101] = n2, t3;
}
function sj(e2) {
  var t3, n2;
  return t3 = new _g({ props: { readOnly: e2[0], onFormat: e2[17], onCompact: e2[18], onSort: e2[19], onTransform: e2[20], onToggleSearch: e2[21], onUndo: e2[22], onRedo: e2[23], canFormat: !e2[101], canCompact: !e2[101], canSort: !e2[101], canTransform: !e2[101], canUndo: e2[12], canRedo: e2[13], onRenderMenu: e2[3] } }), { c() {
    sr(t3.$$.fragment);
  }, m(e3, r2) {
    lr(t3, e3, r2), n2 = true;
  }, p(e3, n3) {
    var r2 = {};
    1 & n3[0] && (r2.readOnly = e3[0]), 2048 & n3[0] && (r2.canFormat = !e3[101]), 2048 & n3[0] && (r2.canCompact = !e3[101]), 2048 & n3[0] && (r2.canSort = !e3[101]), 2048 & n3[0] && (r2.canTransform = !e3[101]), 4096 & n3[0] && (r2.canUndo = e3[12]), 8192 & n3[0] && (r2.canRedo = e3[13]), 8 & n3[0] && (r2.onRenderMenu = e3[3]), t3.$set(r2);
  }, i(e3) {
    n2 || (Xn(t3.$$.fragment, e3), n2 = true);
  }, o(e3) {
    Gn(t3.$$.fragment, e3), n2 = false;
  }, d(e3) {
    cr(t3, e3);
  } };
}
function lj(e2) {
  var t3;
  return { c() {
    (t3 = ln("div")).innerHTML = '<div class="jse-loading-space svelte-xt61xw"></div> <div class="jse-loading svelte-xt61xw">loading...</div>', hn(t3, "class", "jse-contents svelte-xt61xw");
  }, m(e3, n2) {
    on(e3, t3, n2);
  }, p: Bt, i: Bt, o: Bt, d(e3) {
    e3 && an(t3);
  } };
}
function cj(e2) {
  var t3, n2, r2, o2, a2, i2 = e2[100] && uj(e2), s2 = !e2[100] && dj(e2);
  return { c() {
    t3 = ln("div"), n2 = dn(), i2 && i2.c(), r2 = dn(), s2 && s2.c(), o2 = vn(), hn(t3, "class", "jse-contents svelte-xt61xw"), kn(t3, "jse-hidden", e2[100]);
  }, m(l, c) {
    on(l, t3, c), e2[54](t3), on(l, n2, c), i2 && i2.m(l, c), on(l, r2, c), s2 && s2.m(l, c), on(l, o2, c), a2 = true;
  }, p(e3, n3) {
    (!a2 || 268437760 & n3[0]) && kn(t3, "jse-hidden", e3[100]), e3[100] ? i2 ? (i2.p(e3, n3), 2304 & n3[0] && Xn(i2, 1)) : ((i2 = uj(e3)).c(), Xn(i2, 1), i2.m(r2.parentNode, r2)) : i2 && (Kn(), Gn(i2, 1, 1, () => {
      i2 = null;
    }), Zn()), e3[100] ? s2 && (Kn(), Gn(s2, 1, 1, () => {
      s2 = null;
    }), Zn()) : s2 ? (s2.p(e3, n3), 2304 & n3[0] && Xn(s2, 1)) : ((s2 = dj(e3)).c(), Xn(s2, 1), s2.m(o2.parentNode, o2));
  }, i(e3) {
    a2 || (Xn(i2), Xn(s2), a2 = true);
  }, o(e3) {
    Gn(i2), Gn(s2), a2 = false;
  }, d(a3) {
    a3 && (an(t3), an(n2), an(r2), an(o2)), e2[54](null), i2 && i2.d(a3), s2 && s2.d(a3);
  } };
}
function uj(e2) {
  var t3, n2, r2, o2, a2, i2 = aa(e2[11] || "", Va) + "";
  return t3 = new cv({ props: { icon: faExclamationTriangle, type: "error", message: "The JSON document is larger than ".concat(Jg(Qa, 1024), ", ") + "and may crash your browser when loading it in text mode. Actual size: ".concat(Jg(e2[11].length, 1024), "."), actions: [{ text: "Open anyway", title: "Open the document in text mode. This may freeze or crash your browser.", onClick: e2[24] }, { text: "Open in tree mode", title: "Open the document in tree mode. Tree mode can handle large documents.", onClick: e2[25] }, { text: "Cancel", title: "Cancel opening this large document.", onClick: e2[26] }], onClose: e2[4] } }), { c() {
    sr(t3.$$.fragment), n2 = dn(), r2 = ln("div"), o2 = un(i2), hn(r2, "class", "jse-contents jse-preview svelte-xt61xw");
  }, m(e3, i3) {
    lr(t3, e3, i3), on(e3, n2, i3), on(e3, r2, i3), nn(r2, o2), a2 = true;
  }, p(e3, n3) {
    var r3 = {};
    2048 & n3[0] && (r3.message = "The JSON document is larger than ".concat(Jg(Qa, 1024), ", ") + "and may crash your browser when loading it in text mode. Actual size: ".concat(Jg(e3[11].length, 1024), ".")), t3.$set(r3), (!a2 || 2048 & n3[0]) && i2 !== (i2 = aa(e3[11] || "", Va) + "") && yn(o2, i2);
  }, i(e3) {
    a2 || (Xn(t3.$$.fragment, e3), a2 = true);
  }, o(e3) {
    Gn(t3.$$.fragment, e3), a2 = false;
  }, d(e3) {
    e3 && (an(n2), an(r2)), cr(t3, e3);
  } };
}
function dj(e2) {
  var t3, n2, r2, o2, a2, i2 = !e2[14] && e2[9] && lo(e2[11]), s2 = e2[2] && vj(e2), l = e2[14] && pj(e2), c = i2 && fj(e2);
  return o2 = new bv({ props: { validationErrors: e2[10], selectError: e2[27] } }), { c() {
    s2 && s2.c(), t3 = dn(), l && l.c(), n2 = dn(), c && c.c(), r2 = dn(), sr(o2.$$.fragment);
  }, m(e3, i3) {
    s2 && s2.m(e3, i3), on(e3, t3, i3), l && l.m(e3, i3), on(e3, n2, i3), c && c.m(e3, i3), on(e3, r2, i3), lr(o2, e3, i3), a2 = true;
  }, p(e3, a3) {
    e3[2] ? s2 ? (s2.p(e3, a3), 4 & a3[0] && Xn(s2, 1)) : ((s2 = vj(e3)).c(), Xn(s2, 1), s2.m(t3.parentNode, t3)) : s2 && (Kn(), Gn(s2, 1, 1, () => {
      s2 = null;
    }), Zn()), e3[14] ? l ? (l.p(e3, a3), 16384 & a3[0] && Xn(l, 1)) : ((l = pj(e3)).c(), Xn(l, 1), l.m(n2.parentNode, n2)) : l && (Kn(), Gn(l, 1, 1, () => {
      l = null;
    }), Zn()), 18944 & a3[0] && (i2 = !e3[14] && e3[9] && lo(e3[11])), i2 ? c ? (c.p(e3, a3), 18944 & a3[0] && Xn(c, 1)) : ((c = fj(e3)).c(), Xn(c, 1), c.m(r2.parentNode, r2)) : c && (Kn(), Gn(c, 1, 1, () => {
      c = null;
    }), Zn());
    var u = {};
    1024 & a3[0] && (u.validationErrors = e3[10]), o2.$set(u);
  }, i(e3) {
    a2 || (Xn(s2), Xn(l), Xn(c), Xn(o2.$$.fragment, e3), a2 = true);
  }, o(e3) {
    Gn(s2), Gn(l), Gn(c), Gn(o2.$$.fragment, e3), a2 = false;
  }, d(e3) {
    e3 && (an(t3), an(n2), an(r2)), s2 && s2.d(e3), l && l.d(e3), c && c.d(e3), cr(o2, e3);
  } };
}
function vj(e2) {
  var t3, n2;
  return t3 = new Gg({ props: { editorState: e2[7] } }), { c() {
    sr(t3.$$.fragment);
  }, m(e3, r2) {
    lr(t3, e3, r2), n2 = true;
  }, p(e3, n3) {
    var r2 = {};
    128 & n3[0] && (r2.editorState = e3[7]), t3.$set(r2);
  }, i(e3) {
    n2 || (Xn(t3.$$.fragment, e3), n2 = true);
  }, o(e3) {
    Gn(t3.$$.fragment, e3), n2 = false;
  }, d(e3) {
    cr(t3, e3);
  } };
}
function pj(e2) {
  var t3, n2;
  return t3 = new cv({ props: { type: "error", icon: faExclamationTriangle, message: e2[14].message, actions: e2[15], onClick: e2[29], onClose: e2[4] } }), { c() {
    sr(t3.$$.fragment);
  }, m(e3, r2) {
    lr(t3, e3, r2), n2 = true;
  }, p(e3, n3) {
    var r2 = {};
    16384 & n3[0] && (r2.message = e3[14].message), 32768 & n3[0] && (r2.actions = e3[15]), t3.$set(r2);
  }, i(e3) {
    n2 || (Xn(t3.$$.fragment, e3), n2 = true);
  }, o(e3) {
    Gn(t3.$$.fragment, e3), n2 = false;
  }, d(e3) {
    cr(t3, e3);
  } };
}
function fj(e2) {
  var t3, n2;
  return t3 = new cv({ props: { type: "success", message: "Do you want to format the JSON?", actions: [{ icon: Uf, text: "Format", title: "Format JSON: add proper indentation and new lines (Ctrl+I)", onClick: e2[17] }, { icon: faTimes, text: "No thanks", title: "Close this message", onClick: e2[55] }], onClose: e2[4] } }), { c() {
    sr(t3.$$.fragment);
  }, m(e3, r2) {
    lr(t3, e3, r2), n2 = true;
  }, p(e3, n3) {
    var r2 = {};
    512 & n3[0] && (r2.actions = [{ icon: Uf, text: "Format", title: "Format JSON: add proper indentation and new lines (Ctrl+I)", onClick: e3[17] }, { icon: faTimes, text: "No thanks", title: "Close this message", onClick: e3[55] }]), t3.$set(r2);
  }, i(e3) {
    n2 || (Xn(t3.$$.fragment, e3), n2 = true);
  }, o(e3) {
    Gn(t3.$$.fragment, e3), n2 = false;
  }, d(e3) {
    cr(t3, e3);
  } };
}
function mj(e2) {
  var t3, n2, r2, o2, a2, i2 = e2[1] && sj(ij(e2)), s2 = [cj, lj], l = [];
  function c(e3, t4) {
    return 0 === t4 ? function(e4) {
      var t5 = e4.slice(), n3 = t5[28](t5[11], t5[8]);
      return t5[100] = n3, t5;
    }(e3) : e3;
  }
  return r2 = function(e3) {
    return e3[16] ? 1 : 0;
  }(e2), o2 = l[r2] = s2[r2](c(e2, r2)), { c() {
    t3 = ln("div"), i2 && i2.c(), n2 = dn(), o2.c(), hn(t3, "class", "jse-text-mode svelte-xt61xw"), kn(t3, "no-main-menu", !e2[1]);
  }, m(o3, s3) {
    on(o3, t3, s3), i2 && i2.m(t3, null), nn(t3, n2), l[r2].m(t3, null), e2[56](t3), a2 = true;
  }, p(e3, s3) {
    e3[1] ? i2 ? (i2.p(ij(e3), s3), 2 & s3[0] && Xn(i2, 1)) : ((i2 = sj(ij(e3))).c(), Xn(i2, 1), i2.m(t3, n2)) : i2 && (Kn(), Gn(i2, 1, 1, () => {
      i2 = null;
    }), Zn()), o2.p(c(e3, r2), s3), (!a2 || 2 & s3[0]) && kn(t3, "no-main-menu", !e3[1]);
  }, i(e3) {
    a2 || (Xn(i2), Xn(o2), a2 = true);
  }, o(e3) {
    Gn(i2), Gn(o2), a2 = false;
  }, d(n3) {
    n3 && an(t3), i2 && i2.d(), l[r2].d(), e2[56](null);
  } };
}
function hj(e2) {
  return { from: e2.from || 0, to: e2.to || 0, message: e2.message || "", actions: e2.actions, severity: e2.severity };
}
function gj(e2, t3, n2) {
  var r2, a2, s2, l, u, d, { readOnly: v } = t3, { mainMenuBar: f } = t3, { statusBar: m3 } = t3, { askToFormat: h2 } = t3, { externalContent: g } = t3, { externalSelection: j } = t3, { indentation: x } = t3, { tabSize: b2 } = t3, { escapeUnicodeCharacters: y } = t3, { parser: $2 } = t3, { validator: w } = t3, { validationParser: k2 } = t3, { onChange: z3 } = t3, { onChangeMode: q2 } = t3, { onSelect: M3 } = t3, { onError: R3 } = t3, { onFocus: E3 } = t3, { onBlur: P3 } = t3, { onRenderMenu: T3 } = t3, { onSortModal: A } = t3, { onTransformModal: N3 } = t3, B3 = vr("jsoneditor:TextMode"), F3 = { key: "Mod-i", run: se2, shift: le2, preventDefault: true }, U3 = "undefined" == typeof window;
  B3("isSSR:", U3);
  var L3 = false, J3 = h2, V = [], H2 = new Compartment(), W3 = new Compartment(), Q2 = new Compartment(), Y2 = new Compartment(), K3 = new Compartment(), Z3 = g, X2 = to(Z3, x, $2), G2 = y;
  qn(o(function* () {
    if (!U3) try {
      u = function(e3) {
        var { target: t4, initialText: r3, readOnly: o2, indentation: a3 } = e3;
        B3("Create CodeMirror editor", { readOnly: o2, indentation: a3 });
        var i2 = EditorState.create({ doc: r3, selection: he2(j, r3) ? be2(j) : void 0, extensions: [keymap.of([indentWithTab, F3]), H2.of(fe2()), lintGutter(), lineNumbers(), highlightActiveLineGutter(), highlightSpecialChars(), history(), foldGutter(), drawSelection(), dropCursor(), EditorState.allowMultipleSelections.of(true), indentOnInput(), syntaxHighlighting(defaultHighlightStyle, { fallback: true }), bracketMatching(), closeBrackets(), autocompletion(), rectangularSelection(), crosshairCursor(), highlightActiveLine(), highlightSelectionMatches(), keymap.of([...closeBracketsKeymap, ...defaultKeymap, ...searchKeymap, ...historyKeymap, ...foldKeymap, ...completionKeymap, ...lintKeymap]), rj, indentationMarkers({ hideFirstIndent: true }), EditorView.domEventHandlers({ dblclick: pe2 }), EditorView.updateListener.of((e4) => {
          n2(7, d = e4.state), e4.docChanged ? Se2() : e4.selectionSet && qe2();
        }), json(), search({ top: true }), EditorView.lineWrapping, W3.of(EditorState.readOnly.of(o2)), Y2.of(EditorState.tabSize.of(b2)), Q2.of(Ce2(a3)), K3.of(EditorView.theme({}, { dark: me2() }))] });
        return u = new EditorView({ state: i2, parent: t4 });
      }({ target: s2, initialText: Me2(X2, L3) ? "" : r2.escapeValue(X2), readOnly: v, indentation: x });
    } catch (e3) {
      console.error(e3);
    }
  })), Mn(() => {
    u && (B3("Destroy CodeMirror editor"), u.destroy());
  });
  var ee2 = false, te2 = false, ne2 = uniqueId_default(), re2 = uniqueId_default();
  function oe2() {
    u && (B3("focus"), u.focus());
  }
  var ae2 = false;
  function ie4(e3, t4) {
    B3("handlePatch", e3, t4);
    var n3 = $2.parse(X2), r3 = immutableJSONPatch(n3, e3), o2 = revertJSONPatch(n3, e3);
    return xe2({ text: $2.stringify(r3, null, x) }, t4, false), { json: r3, previousJson: n3, undo: o2, redo: e3 };
  }
  function se2() {
    if (B3("format"), v) return false;
    try {
      var e3 = $2.parse(X2);
      return xe2({ text: $2.stringify(e3, null, x) }, true, false), n2(9, J3 = h2), true;
    } catch (e4) {
      R3(e4);
    }
    return false;
  }
  function le2() {
    if (B3("compact"), v) return false;
    try {
      var e3 = $2.parse(X2);
      return xe2({ text: $2.stringify(e3) }, true, false), n2(9, J3 = false), true;
    } catch (e4) {
      R3(e4);
    }
    return false;
  }
  function ce2() {
    if (B3("repair"), !v) try {
      xe2({ text: jsonrepair(X2) }, true, false), n2(53, Ee2 = ti), n2(14, Re2 = void 0);
    } catch (e3) {
      R3(e3);
    }
  }
  function de2(e3) {
    var { id: t4, rootPath: n3, onTransform: r3, onClose: o2 } = e3;
    try {
      var a3 = $2.parse(X2);
      ae2 = true, N3({ id: t4 || re2, json: a3, rootPath: n3 || [], onTransform: (e4) => {
        r3 ? r3({ operations: e4, json: a3, transformedJson: immutableJSONPatch(a3, e4) }) : (B3("onTransform", e4), ie4(e4, true));
      }, onClose: () => {
        ae2 = false, oe2(), o2 && o2();
      } });
    } catch (e4) {
      R3(e4);
    }
  }
  function ve2(e3, t4) {
    B3("setSelection", { anchor: e3, head: t4 }), u && u.dispatch(u.state.update({ selection: { anchor: e3, head: t4 }, scrollIntoView: true }));
  }
  function pe2(e3, t4) {
    if (1 === t4.state.selection.ranges.length) {
      var n3 = t4.state.selection.ranges[0], r3 = X2.slice(n3.from, n3.to);
      if ("{" === r3 || "[" === r3) {
        var o2 = import_json_source_map.default.parse(X2), a3 = Object.keys(o2.pointers).find((e4) => {
          var t5;
          return (null === (t5 = o2.pointers[e4].value) || void 0 === t5 ? void 0 : t5.pos) === n3.from;
        }), i2 = o2.pointers[a3];
        if (a3 && i2 && i2.value && i2.valueEnd) B3("pointer found, selecting inner contents of path:", a3, i2), ve2(i2.value.pos + 1, i2.valueEnd.pos - 1);
      }
    }
  }
  function fe2() {
    return linter(Pe2, { delay: 300 });
  }
  function me2() {
    return !!s2 && getComputedStyle(s2).getPropertyValue("--jse-theme").includes("dark");
  }
  function he2(e3, t4) {
    return !!vs(e3) && e3.ranges.every((e4) => e4.anchor < t4.length && e4.head < t4.length);
  }
  function ge2(e3) {
    var { path: t4, message: n3, severity: o2 } = e3, { line: a3, column: i2, from: s3, to: l2 } = function(e4, t5) {
      try {
        var n4 = import_json_source_map.default.parse(e4), r3 = compileJSONPointer(t5), o3 = n4.pointers[r3];
        if (o3) return { path: t5, line: o3.key ? o3.key.line : o3.value ? o3.value.line : 0, column: o3.key ? o3.key.column : o3.value ? o3.value.column : 0, from: o3.key ? o3.key.pos : o3.value ? o3.value.pos : 0, to: o3.keyEnd ? o3.keyEnd.pos : o3.valueEnd ? o3.valueEnd.pos : 0 };
      } catch (e5) {
        console.error(e5);
      }
      return { path: t5, line: 0, column: 0, from: 0, to: 0 };
    }(r2.escapeValue(X2), t4);
    return { path: t4, line: a3, column: i2, from: s3, to: l2, message: n3, severity: o2, actions: [] };
  }
  function je2(e3, t4) {
    var { line: n3, column: r3, position: o2, message: a3 } = e3;
    return { path: [], line: n3, column: r3, from: o2, to: o2, severity: po.error, message: a3, actions: t4 && !v ? [{ name: "Auto repair", apply: () => ce2() }] : void 0 };
  }
  function xe2(e3, t4, o2) {
    var a3 = to(e3, x, $2), i2 = !isEqual_default(e3, Z3), s3 = Z3;
    B3("setCodeMirrorContent", { isChanged: i2, emitChange: t4, forceUpdate: o2 }), u && (i2 || o2) && (Z3 = e3, n2(11, X2 = a3), Me2(X2, L3) || u.dispatch({ changes: { from: 0, to: u.state.doc.length, insert: r2.escapeValue(X2) } }), ke2(), i2 && t4 && ze2(Z3, s3));
  }
  function be2(e3) {
    return vs(e3) ? EditorSelection.fromJSON(e3) : void 0;
  }
  function ye2() {
    return ye2 = o(function* () {
      B3("refresh"), yield function() {
        return we2.apply(this, arguments);
      }();
    }), ye2.apply(this, arguments);
  }
  function $e2() {
    if (u) {
      var e3 = u ? r2.unescapeValue(u.state.doc.toString()) : "", t4 = e3 !== X2;
      if (B3("onChangeCodeMirrorValue", { isChanged: t4 }), t4) {
        var o2 = Z3;
        n2(11, X2 = e3), Z3 = { text: X2 }, ke2(), ze2(Z3, o2), Ln().then(qe2);
      }
    }
  }
  function we2() {
    return (we2 = o(function* () {
      if (yield Ln(), u) {
        var e3 = me2();
        B3("updateTheme", { dark: e3 }), u.dispatch({ effects: [K3.reconfigure(EditorView.theme({}, { dark: e3 }))] });
      }
    })).apply(this, arguments);
  }
  function Ce2(e3) {
    var t4 = indentUnit.of("number" == typeof e3 ? " ".repeat(e3) : e3);
    return "	" === e3 ? [t4] : [t4, wrappedLineIndent];
  }
  function ke2() {
    n2(12, ee2 = undoDepth(u.state) > 0), n2(13, te2 = redoDepth(u.state) > 0), B3({ canUndo: ee2, canRedo: te2 });
  }
  Mn(() => {
    Oe2();
  }), tv({ onMount: qn, onDestroy: Mn, getWindow: () => Io(l), hasFocus: () => ae2 && document.hasFocus() || To(l), onFocus: E3, onBlur: () => {
    Oe2(), P3();
  } });
  var Se2 = debounce_default($e2, 300);
  function Oe2() {
    Se2.flush();
  }
  function ze2(e3, t4) {
    z3 && z3(e3, t4, { contentErrors: Ie2(), patchResult: void 0 });
  }
  function qe2() {
    M3(i({ type: uo.text }, d.selection.toJSON()));
  }
  function Me2(e3, t4) {
    return !!e3 && e3.length > Qa && !t4;
  }
  var Re2, Ee2 = ti;
  function Pe2() {
    if (Me2(X2, L3)) return [];
    var e3 = Ie2();
    if (gi(e3)) {
      var { parseError: t4, isRepairable: n3 } = e3;
      return [hj(je2(t4, n3))];
    }
    return ji(e3) ? e3.validationErrors.map(ge2).map(hj) : [];
  }
  function Ie2() {
    B3("validate:start"), Oe2();
    var e3 = Te2(r2.escapeValue(X2), w, $2, k2);
    return gi(e3) ? (n2(53, Ee2 = e3.isRepairable ? ni : "invalid"), n2(14, Re2 = e3.parseError), n2(10, V = [])) : (n2(53, Ee2 = ti), n2(14, Re2 = void 0), n2(10, V = (null == e3 ? void 0 : e3.validationErrors) || [])), B3("validate:end"), e3;
  }
  var Te2 = memoizeOne(Gd);
  function Ae2() {
    Re2 && function(e3) {
      B3("select parse error", e3);
      var t4 = je2(e3, false);
      ve2(null != t4.from ? t4.from : 0, null != t4.to ? t4.to : 0), oe2();
    }(Re2);
  }
  var Ne2 = { icon: faEye, text: "Show me", title: "Move to the parse error location", onClick: Ae2 };
  return e2.$$set = (e3) => {
    "readOnly" in e3 && n2(0, v = e3.readOnly), "mainMenuBar" in e3 && n2(1, f = e3.mainMenuBar), "statusBar" in e3 && n2(2, m3 = e3.statusBar), "askToFormat" in e3 && n2(30, h2 = e3.askToFormat), "externalContent" in e3 && n2(31, g = e3.externalContent), "externalSelection" in e3 && n2(32, j = e3.externalSelection), "indentation" in e3 && n2(33, x = e3.indentation), "tabSize" in e3 && n2(34, b2 = e3.tabSize), "escapeUnicodeCharacters" in e3 && n2(35, y = e3.escapeUnicodeCharacters), "parser" in e3 && n2(36, $2 = e3.parser), "validator" in e3 && n2(37, w = e3.validator), "validationParser" in e3 && n2(38, k2 = e3.validationParser), "onChange" in e3 && n2(39, z3 = e3.onChange), "onChangeMode" in e3 && n2(40, q2 = e3.onChangeMode), "onSelect" in e3 && n2(41, M3 = e3.onSelect), "onError" in e3 && n2(42, R3 = e3.onError), "onFocus" in e3 && n2(43, E3 = e3.onFocus), "onBlur" in e3 && n2(44, P3 = e3.onBlur), "onRenderMenu" in e3 && n2(3, T3 = e3.onRenderMenu), "onSortModal" in e3 && n2(45, A = e3.onSortModal), "onTransformModal" in e3 && n2(46, N3 = e3.onTransformModal);
  }, e2.$$.update = () => {
    16 & e2.$$.dirty[1] && (r2 = jo({ escapeControlCharacters: false, escapeUnicodeCharacters: y })), 1 & e2.$$.dirty[1] && xe2(g, false, false), 2 & e2.$$.dirty[1] && function(e3) {
      if (vs(e3)) {
        var t4 = be2(e3);
        !u || !t4 || d && d.selection.eq(t4) || (B3("applyExternalSelection", t4), u.dispatch({ selection: t4 }));
      }
    }(j), 64 & e2.$$.dirty[1] && function(e3) {
      B3("updateLinter", e3), u && u.dispatch({ effects: H2.reconfigure(fe2()) });
    }(w), 4 & e2.$$.dirty[1] && function(e3) {
      u && (B3("updateIndentation", e3), u.dispatch({ effects: Q2.reconfigure(Ce2(e3)) }));
    }(x), 8 & e2.$$.dirty[1] && function(e3) {
      u && (B3("updateTabSize", e3), u.dispatch({ effects: Y2.reconfigure(EditorState.tabSize.of(e3)) }));
    }(b2), 1 & e2.$$.dirty[0] && function(e3) {
      u && (B3("updateReadOnly", e3), u.dispatch({ effects: [W3.reconfigure(EditorState.readOnly.of(e3))] }));
    }(v), 2097168 & e2.$$.dirty[1] && G2 !== y && (n2(52, G2 = y), B3("forceUpdateText", { escapeUnicodeCharacters: y }), u && u.dispatch({ changes: { from: 0, to: u.state.doc.length, insert: r2.escapeValue(X2) } })), 1 & e2.$$.dirty[0] | 4194304 & e2.$$.dirty[1] && n2(15, a2 = Ee2 !== ni || v ? [Ne2] : [{ icon: faWrench, text: "Auto repair", title: "Automatically repair JSON", onClick: ce2 }, Ne2]);
  }, [v, f, m3, T3, oe2, s2, l, d, L3, J3, V, X2, ee2, te2, Re2, a2, U3, se2, le2, function() {
    var e3;
    if (!v) try {
      var t4 = $2.parse(X2);
      ae2 = true, A({ id: ne2, json: t4, rootPath: [], onSort: (e3 = o(function* (e4) {
        var { operations: t5 } = e4;
        B3("onSort", t5), ie4(t5, true);
      }), function(t5) {
        return e3.apply(this, arguments);
      }), onClose: () => {
        ae2 = false, oe2();
      } });
    } catch (e4) {
      R3(e4);
    }
  }, function() {
    v || de2({ rootPath: [] });
  }, function() {
    u && (s2 && s2.querySelector(".cm-search") ? closeSearchPanel(u) : openSearchPanel(u));
  }, function() {
    v || u && (undo(u), oe2());
  }, function() {
    v || u && (redo(u), oe2());
  }, function() {
    n2(8, L3 = true), xe2(g, true, true);
  }, function() {
    q2(co.tree);
  }, function() {
    $e2();
  }, function(e3) {
    B3("select validation error", e3);
    var { from: t4, to: n3 } = ge2(e3);
    void 0 !== t4 && void 0 !== n3 && (ve2(t4, n3), oe2());
  }, Me2, Ae2, h2, g, j, x, b2, y, $2, w, k2, z3, q2, M3, R3, E3, P3, A, N3, function(e3) {
    return ie4(e3, false);
  }, ie4, de2, function() {
    return ye2.apply(this, arguments);
  }, Ie2, G2, Ee2, function(e3) {
    Tn[e3 ? "unshift" : "push"](() => {
      n2(5, s2 = e3);
    });
  }, () => n2(9, J3 = false), function(e3) {
    Tn[e3 ? "unshift" : "push"](() => {
      n2(6, l = e3);
    });
  }];
}
nj.style = (e2) => oj(e2 || []);
var jj = class extends dr {
  constructor(e2) {
    super(), ur(this, e2, gj, mj, Ht, { readOnly: 0, mainMenuBar: 1, statusBar: 2, askToFormat: 30, externalContent: 31, externalSelection: 32, indentation: 33, tabSize: 34, escapeUnicodeCharacters: 35, parser: 36, validator: 37, validationParser: 38, onChange: 39, onChangeMode: 40, onSelect: 41, onError: 42, onFocus: 43, onBlur: 44, onRenderMenu: 3, onSortModal: 45, onTransformModal: 46, focus: 4, patch: 47, handlePatch: 48, openTransformModal: 49, refresh: 50, validate: 51 }, aj, [-1, -1, -1, -1]);
  }
  get focus() {
    return this.$$.ctx[4];
  }
  get patch() {
    return this.$$.ctx[47];
  }
  get handlePatch() {
    return this.$$.ctx[48];
  }
  get openTransformModal() {
    return this.$$.ctx[49];
  }
  get refresh() {
    return this.$$.ctx[50];
  }
  get validate() {
    return this.$$.ctx[51];
  }
};
function xj(e2) {
  var t3, n2;
  return t3 = new Wv({ props: { items: e2[0] } }), { c() {
    sr(t3.$$.fragment);
  }, m(e3, r2) {
    lr(t3, e3, r2), n2 = true;
  }, p(e3, n3) {
    var [r2] = n3, o2 = {};
    1 & r2 && (o2.items = e3[0]), t3.$set(o2);
  }, i(e3) {
    n2 || (Xn(t3.$$.fragment, e3), n2 = true);
  }, o(e3) {
    Gn(t3.$$.fragment, e3), n2 = false;
  }, d(e3) {
    cr(t3, e3);
  } };
}
function bj(e2, t3, n2) {
  var r2, o2, { containsValidArray: a2 } = t3, { readOnly: i2 } = t3, { showSearch: s2 = false } = t3, { historyState: l } = t3, { onSort: c } = t3, { onTransform: u } = t3, { onContextMenu: d } = t3, { onUndo: v } = t3, { onRedo: p } = t3, { onRenderMenu: f } = t3;
  function m3() {
    n2(1, s2 = !s2);
  }
  return e2.$$set = (e3) => {
    "containsValidArray" in e3 && n2(2, a2 = e3.containsValidArray), "readOnly" in e3 && n2(3, i2 = e3.readOnly), "showSearch" in e3 && n2(1, s2 = e3.showSearch), "historyState" in e3 && n2(4, l = e3.historyState), "onSort" in e3 && n2(5, c = e3.onSort), "onTransform" in e3 && n2(6, u = e3.onTransform), "onContextMenu" in e3 && n2(7, d = e3.onContextMenu), "onUndo" in e3 && n2(8, v = e3.onUndo), "onRedo" in e3 && n2(9, p = e3.onRedo), "onRenderMenu" in e3 && n2(10, f = e3.onRenderMenu);
  }, e2.$$.update = () => {
    1020 & e2.$$.dirty && n2(11, r2 = i2 ? [{ type: "space" }] : [{ type: "button", icon: faSortAmountDownAlt, title: "Sort", className: "jse-sort", onClick: c, disabled: i2 || !a2 }, { type: "button", icon: faFilter, title: "Transform contents (filter, sort, project)", className: "jse-transform", onClick: u, disabled: i2 || !a2 }, { type: "button", icon: faSearch, title: "Search (Ctrl+F)", className: "jse-search", onClick: m3, disabled: !a2 }, { type: "button", icon: faEllipsisV, title: Za, className: "jse-contextmenu", onClick: d }, { type: "separator" }, { type: "button", icon: faUndo, title: "Undo (Ctrl+Z)", className: "jse-undo", onClick: v, disabled: !l.canUndo }, { type: "button", icon: faRedo, title: "Redo (Ctrl+Shift+Z)", className: "jse-redo", onClick: p, disabled: !l.canRedo }, { type: "space" }]), 3072 & e2.$$.dirty && n2(0, o2 = f(r2) || r2);
  }, [o2, s2, a2, i2, l, c, u, d, v, p, f, r2];
}
var yj = class extends dr {
  constructor(e2) {
    super(), ur(this, e2, bj, xj, Ht, { containsValidArray: 2, readOnly: 3, showSearch: 1, historyState: 4, onSort: 5, onTransform: 6, onContextMenu: 7, onUndo: 8, onRedo: 9, onRenderMenu: 10 });
  }
};
function $j(e2) {
  rn(e2, "svelte-h57m0p", '.jse-inline-value.svelte-h57m0p{font-family:var(--jse-font-family-mono, consolas, menlo, monaco, "Ubuntu Mono", "source-code-pro", monospace);font-size:var(--jse-font-size-mono, 14px);line-height:var(--jse-line-height, calc(1em + 4px));border:none;padding:0 calc(0.5 * var(--jse-padding, 10px));background:transparent;color:inherit;cursor:inherit}.jse-inline-value.jse-highlight.svelte-h57m0p{background-color:var(--jse-search-match-color, #ffe665);outline:var(--jse-search-match-outline, none)}.jse-inline-value.jse-highlight.jse-active.svelte-h57m0p{background-color:var(--jse-search-match-active-color, var(--jse-search-match-color, #ffe665));outline:var(--jse-search-match-outline, 2px solid #e0be00)}');
}
function wj(e2) {
  var t3, n2, r2, o2, a2, i2 = aa(null !== (t3 = e2[2].stringify(e2[1])) && void 0 !== t3 ? t3 : "", 50) + "";
  return { c() {
    n2 = ln("button"), r2 = un(i2), hn(n2, "type", "button"), hn(n2, "class", "jse-inline-value svelte-h57m0p"), kn(n2, "jse-selected", e2[3]), kn(n2, "jse-highlight", e2[4]), kn(n2, "jse-active", e2[5]);
  }, m(t4, i3) {
    on(t4, n2, i3), nn(n2, r2), o2 || (a2 = pn(n2, "dblclick", e2[7]), o2 = true);
  }, p(e3, t4) {
    var o3, [a3] = t4;
    6 & a3 && i2 !== (i2 = aa(null !== (o3 = e3[2].stringify(e3[1])) && void 0 !== o3 ? o3 : "", 50) + "") && yn(r2, i2), 8 & a3 && kn(n2, "jse-selected", e3[3]), 16 & a3 && kn(n2, "jse-highlight", e3[4]), 32 & a3 && kn(n2, "jse-active", e3[5]);
  }, i: Bt, o: Bt, d(e3) {
    e3 && an(n2), o2 = false, a2();
  } };
}
function Cj(e2, t3, n2) {
  var { path: r2 } = t3, { value: o2 } = t3, { parser: a2 } = t3, { isSelected: i2 } = t3, { containsSearchResult: s2 } = t3, { containsActiveSearchResult: l } = t3, { onEdit: c } = t3;
  return e2.$$set = (e3) => {
    "path" in e3 && n2(0, r2 = e3.path), "value" in e3 && n2(1, o2 = e3.value), "parser" in e3 && n2(2, a2 = e3.parser), "isSelected" in e3 && n2(3, i2 = e3.isSelected), "containsSearchResult" in e3 && n2(4, s2 = e3.containsSearchResult), "containsActiveSearchResult" in e3 && n2(5, l = e3.containsActiveSearchResult), "onEdit" in e3 && n2(6, c = e3.onEdit);
  }, [r2, o2, a2, i2, s2, l, c, () => c(r2)];
}
var kj = class extends dr {
  constructor(e2) {
    super(), ur(this, e2, Cj, wj, Ht, { path: 0, value: 1, parser: 2, isSelected: 3, containsSearchResult: 4, containsActiveSearchResult: 5, onEdit: 6 }, $j);
  }
};
function Sj(e2) {
  rn(e2, "svelte-2i3vdx", ".jse-column-header.svelte-2i3vdx.svelte-2i3vdx{background:none;border:none;font-family:inherit;font-size:inherit;color:inherit;display:flex;gap:var(--jse-padding, 10px);padding:calc(0.5 * var(--jse-padding, 10px)) var(--jse-padding, 10px) calc(0.5 * var(--jse-padding, 10px)) calc(0.5 * var(--jse-padding, 10px));width:100%}.jse-column-header.svelte-2i3vdx.svelte-2i3vdx:hover{background:var(--jse-table-header-background-highlight, #e8e8e8)}.jse-column-header.svelte-2i3vdx.svelte-2i3vdx:not(.jse-column-header.jse-readonly){cursor:pointer}.jse-column-header.svelte-2i3vdx span.jse-column-sort-icon.svelte-2i3vdx{height:1em}");
}
function Oj(e2) {
  var t3, n2, r2, o2;
  return n2 = new Ca({ props: { data: e2[1] === mo.asc ? faCaretDown : faCaretUp } }), { c() {
    t3 = ln("span"), sr(n2.$$.fragment), hn(t3, "class", "jse-column-sort-icon svelte-2i3vdx"), hn(t3, "title", r2 = "Currently sorted in ".concat(e2[2], " order"));
  }, m(e3, r3) {
    on(e3, t3, r3), lr(n2, t3, null), o2 = true;
  }, p(e3, a2) {
    var i2 = {};
    2 & a2 && (i2.data = e3[1] === mo.asc ? faCaretDown : faCaretUp), n2.$set(i2), (!o2 || 4 & a2 && r2 !== (r2 = "Currently sorted in ".concat(e3[2], " order"))) && hn(t3, "title", r2);
  }, i(e3) {
    o2 || (Xn(n2.$$.fragment, e3), o2 = true);
  }, o(e3) {
    Gn(n2.$$.fragment, e3), o2 = false;
  }, d(e3) {
    e3 && an(t3), cr(n2);
  } };
}
function zj(e2) {
  var t3, n2, r2, o2, a2, i2, s2, l, c = aa(e2[3], 50) + "", u = void 0 !== e2[1] && Oj(e2);
  return { c() {
    t3 = ln("button"), n2 = ln("span"), r2 = un(c), o2 = dn(), u && u.c(), hn(n2, "class", "jse-column-name"), hn(t3, "type", "button"), hn(t3, "class", "jse-column-header svelte-2i3vdx"), hn(t3, "title", a2 = e2[0] ? e2[3] : e2[3] + " (Click to sort the data by this column)"), kn(t3, "jse-readonly", e2[0]);
  }, m(a3, c2) {
    on(a3, t3, c2), nn(t3, n2), nn(n2, r2), nn(t3, o2), u && u.m(t3, null), i2 = true, s2 || (l = pn(t3, "click", e2[4]), s2 = true);
  }, p(e3, n3) {
    var [o3] = n3;
    (!i2 || 8 & o3) && c !== (c = aa(e3[3], 50) + "") && yn(r2, c), void 0 !== e3[1] ? u ? (u.p(e3, o3), 2 & o3 && Xn(u, 1)) : ((u = Oj(e3)).c(), Xn(u, 1), u.m(t3, null)) : u && (Kn(), Gn(u, 1, 1, () => {
      u = null;
    }), Zn()), (!i2 || 9 & o3 && a2 !== (a2 = e3[0] ? e3[3] : e3[3] + " (Click to sort the data by this column)")) && hn(t3, "title", a2), (!i2 || 1 & o3) && kn(t3, "jse-readonly", e3[0]);
  }, i(e3) {
    i2 || (Xn(u), i2 = true);
  }, o(e3) {
    Gn(u), i2 = false;
  }, d(e3) {
    e3 && an(t3), u && u.d(), s2 = false, l();
  } };
}
function qj(e2, t3, n2) {
  var r2, o2, a2, { path: i2 } = t3, { sortedColumn: s2 } = t3, { readOnly: l } = t3, { onSort: c } = t3;
  return e2.$$set = (e3) => {
    "path" in e3 && n2(5, i2 = e3.path), "sortedColumn" in e3 && n2(6, s2 = e3.sortedColumn), "readOnly" in e3 && n2(0, l = e3.readOnly), "onSort" in e3 && n2(7, c = e3.onSort);
  }, e2.$$.update = () => {
    var t4;
    (32 & e2.$$.dirty && n2(3, r2 = isEmpty_default(i2) ? "values" : _l(i2)), 96 & e2.$$.dirty) && n2(1, o2 = s2 && isEqual_default(i2, null === (t4 = s2) || void 0 === t4 ? void 0 : t4.path) ? s2.sortDirection : void 0);
    2 & e2.$$.dirty && n2(2, a2 = o2 ? ii[o2] : void 0);
  }, [l, o2, a2, r2, function() {
    l || c({ path: i2, sortDirection: o2 === mo.asc ? mo.desc : mo.asc });
  }, i2, s2, c];
}
var Mj = class extends dr {
  constructor(e2) {
    super(), ur(this, e2, qj, zj, Ht, { path: 5, sortedColumn: 6, readOnly: 0, onSort: 7 }, Sj);
  }
};
function Rj(e2, t3) {
  return ej || (tj = /* @__PURE__ */ new WeakMap(), ej = new ResizeObserver((e3) => {
    for (var t4 of e3) {
      var n2 = tj.get(t4.target);
      n2 && n2(t4.target);
    }
  })), tj.set(e2, t3), ej.observe(e2), { destroy: () => {
    tj.delete(e2), ej.unobserve(e2);
  } };
}
function Ej(e2) {
  rn(e2, "svelte-1q0ce0e", '.jse-table-mode-welcome.svelte-1q0ce0e.svelte-1q0ce0e{flex:1;display:flex;flex-direction:column;overflow:auto;align-items:center;border-left:var(--jse-main-border, 1px solid #d7d7d7);border-right:var(--jse-main-border, 1px solid #d7d7d7)}.jse-table-mode-welcome.svelte-1q0ce0e.svelte-1q0ce0e:last-child{border-bottom:var(--jse-main-border, 1px solid #d7d7d7)}.jse-table-mode-welcome.svelte-1q0ce0e .jse-space.jse-before.svelte-1q0ce0e{flex:1}.jse-table-mode-welcome.svelte-1q0ce0e .jse-nested-arrays.svelte-1q0ce0e{display:flex;flex-direction:column;gap:var(--jse-padding, 10px);max-width:300px;margin:2em var(--jse-padding, 10px);font-family:var(--jse-font-family, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif);font-size:var(--jse-font-size, 16px)}.jse-table-mode-welcome.svelte-1q0ce0e .jse-nested-arrays .jse-nested-arrays-info.svelte-1q0ce0e{color:var(--jse-panel-color-readonly, #b2b2b2)}.jse-table-mode-welcome.svelte-1q0ce0e .jse-nested-arrays button.jse-nested-array-action.svelte-1q0ce0e{text-align:left;border:none;background:transparent;color:inherit;cursor:pointer;font-family:var(--jse-font-family, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif);font-size:var(--jse-font-size, 16px);padding:5px;margin:0;background:var(--jse-button-primary-background, var(--jse-theme-color, #3883fa));color:var(--jse-button-primary-color, #fff);padding:var(--jse-padding, 10px) calc(2 * var(--jse-padding, 10px));border-radius:3px}.jse-table-mode-welcome.svelte-1q0ce0e .jse-nested-arrays button.jse-nested-array-action.svelte-1q0ce0e:hover{background:var(--jse-button-primary-background-highlight, var(--jse-theme-color-highlight, #5f9dff))}.jse-table-mode-welcome.svelte-1q0ce0e .jse-nested-arrays button.jse-nested-array-action.svelte-1q0ce0e:disabled{background:var(--jse-button-primary-background-disabled, #9d9d9d)}.jse-table-mode-welcome.svelte-1q0ce0e .jse-nested-arrays button.jse-nested-array-action .jse-nested-array-count.svelte-1q0ce0e{opacity:0.5;white-space:nowrap}.jse-table-mode-welcome.svelte-1q0ce0e .jse-space.jse-after.svelte-1q0ce0e{flex:2}');
}
function Pj(e2, t3, n2) {
  var r2 = e2.slice();
  r2[16] = t3[n2];
  var o2 = r2[9](r2[16]);
  return r2[17] = o2, r2;
}
function Ij(e2) {
  var t3, n2;
  return { c() {
    t3 = un(e2[7]), n2 = un(" cannot be opened in table mode.");
  }, m(e3, r2) {
    on(e3, t3, r2), on(e3, n2, r2);
  }, p(e3, n3) {
    128 & n3 && yn(t3, e3[7]);
  }, d(e3) {
    e3 && (an(t3), an(n2));
  } };
}
function Tj(e2) {
  var t3;
  return { c() {
    t3 = un("An object cannot be opened in table mode. You can open a nested array instead, or open the\n        document in tree mode.");
  }, m(e3, n2) {
    on(e3, t3, n2);
  }, p: Bt, d(e3) {
    e3 && an(t3);
  } };
}
function Aj(e2) {
  var t3;
  return { c() {
    t3 = un("You can open the document in tree mode instead.");
  }, m(e3, n2) {
    on(e3, t3, n2);
  }, d(e3) {
    e3 && an(t3);
  } };
}
function Nj(e2) {
  var t3, n2, r2;
  return { c() {
    t3 = un("You can open the document in tree mode instead, or paste a JSON Array using "), (n2 = ln("b")).textContent = "Ctrl+V", r2 = un(".");
  }, m(e3, o2) {
    on(e3, t3, o2), on(e3, n2, o2), on(e3, r2, o2);
  }, d(e3) {
    e3 && (an(t3), an(n2), an(r2));
  } };
}
function Bj(e2) {
  var t3, n2, r2, o2, a2, i2, s2, l, c, u, d, v, p, f = _l(e2[16]) + "", m3 = e2[17] + "", h2 = 1 !== e2[17] ? "items" : "item";
  function g() {
    return e2[13](e2[16]);
  }
  return { c() {
    t3 = ln("button"), n2 = un(e2[8]), r2 = un(' "'), o2 = un(f), a2 = un('"\n        '), i2 = ln("span"), s2 = un("("), l = un(m3), c = dn(), u = un(h2), d = un(")"), hn(i2, "class", "jse-nested-array-count svelte-1q0ce0e"), hn(t3, "type", "button"), hn(t3, "class", "jse-nested-array-action svelte-1q0ce0e");
  }, m(e3, f2) {
    on(e3, t3, f2), nn(t3, n2), nn(t3, r2), nn(t3, o2), nn(t3, a2), nn(t3, i2), nn(i2, s2), nn(i2, l), nn(i2, c), nn(i2, u), nn(i2, d), v || (p = pn(t3, "click", g), v = true);
  }, p(t4, r3) {
    e2 = t4, 256 & r3 && yn(n2, e2[8]), 16 & r3 && f !== (f = _l(e2[16]) + "") && yn(o2, f), 16 & r3 && m3 !== (m3 = e2[17] + "") && yn(l, m3), 16 & r3 && h2 !== (h2 = 1 !== e2[17] ? "items" : "item") && yn(u, h2);
  }, d(e3) {
    e3 && an(t3), v = false, p();
  } };
}
function Fj(e2) {
  var t3, n2, r2, o2, a2, i2, s2, l, c, u, d, v, p, f, m3, h2, g, j;
  function x(e3, t4) {
    return e3[6] ? Tj : Ij;
  }
  var b2 = x(e2), y = b2(e2);
  function $2(e3, t4) {
    return e3[5] && !e3[0] ? Nj : Aj;
  }
  for (var w = $2(e2), C3 = w(e2), k2 = er(e2[4]), S4 = [], O = 0; O < k2.length; O += 1) S4[O] = Bj(Pj(e2, k2, O));
  return { c() {
    t3 = ln("div"), n2 = ln("div"), r2 = dn(), o2 = ln("div"), a2 = ln("div"), i2 = un(e2[7]), s2 = dn(), l = ln("div"), y.c(), c = dn(), C3.c(), u = dn();
    for (var g2 = 0; g2 < S4.length; g2 += 1) S4[g2].c();
    d = dn(), v = ln("button"), p = un(e2[8]), f = un(" in tree mode"), m3 = dn(), h2 = ln("div"), hn(n2, "class", "jse-space jse-before svelte-1q0ce0e"), hn(a2, "class", "jse-nested-arrays-title"), hn(l, "class", "jse-nested-arrays-info svelte-1q0ce0e"), hn(v, "type", "button"), hn(v, "class", "jse-nested-array-action svelte-1q0ce0e"), hn(o2, "class", "jse-nested-arrays svelte-1q0ce0e"), hn(h2, "class", "jse-space jse-after svelte-1q0ce0e"), hn(t3, "class", "jse-table-mode-welcome svelte-1q0ce0e"), hn(t3, "role", "none");
  }, m(x2, b3) {
    on(x2, t3, b3), nn(t3, n2), nn(t3, r2), nn(t3, o2), nn(o2, a2), nn(a2, i2), nn(o2, s2), nn(o2, l), y.m(l, null), nn(l, c), C3.m(l, null), nn(o2, u);
    for (var $3 = 0; $3 < S4.length; $3 += 1) S4[$3] && S4[$3].m(o2, null);
    nn(o2, d), nn(o2, v), nn(v, p), nn(v, f), nn(t3, m3), nn(t3, h2), g || (j = [pn(v, "click", e2[14]), pn(t3, "click", e2[15])], g = true);
  }, p(e3, t4) {
    var [n3] = t4;
    if (128 & n3 && yn(i2, e3[7]), b2 === (b2 = x(e3)) && y ? y.p(e3, n3) : (y.d(1), (y = b2(e3)) && (y.c(), y.m(l, c))), w !== (w = $2(e3)) && (C3.d(1), (C3 = w(e3)) && (C3.c(), C3.m(l, null))), 786 & n3) {
      var r3;
      for (k2 = er(e3[4]), r3 = 0; r3 < k2.length; r3 += 1) {
        var a3 = Pj(e3, k2, r3);
        S4[r3] ? S4[r3].p(a3, n3) : (S4[r3] = Bj(a3), S4[r3].c(), S4[r3].m(o2, d));
      }
      for (; r3 < S4.length; r3 += 1) S4[r3].d(1);
      S4.length = k2.length;
    }
    256 & n3 && yn(p, e3[8]);
  }, i: Bt, o: Bt, d(e3) {
    e3 && an(t3), y.d(), C3.d(), sn(S4, e3), g = false, Dt(j);
  } };
}
function Uj(e2, t3, n2) {
  var r2, o2, a2, i2, s2, { text: l } = t3, { json: c } = t3, { readOnly: d } = t3, { parser: v } = t3, { openJSONEditorModal: p } = t3, { onChangeMode: f } = t3, { onClick: m3 } = t3;
  return e2.$$set = (e3) => {
    "text" in e3 && n2(10, l = e3.text), "json" in e3 && n2(11, c = e3.json), "readOnly" in e3 && n2(0, d = e3.readOnly), "parser" in e3 && n2(12, v = e3.parser), "openJSONEditorModal" in e3 && n2(1, p = e3.openJSONEditorModal), "onChangeMode" in e3 && n2(2, f = e3.onChangeMode), "onClick" in e3 && n2(3, m3 = e3.onClick);
  }, e2.$$.update = () => {
    1 & e2.$$.dirty && n2(8, r2 = d ? "View" : "Edit"), 2048 & e2.$$.dirty && n2(4, s2 = c ? function(e3) {
      var t4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 2, n3 = [];
      return function e4(r3, o3) {
        isJSONObject(r3) && o3.length < t4 && Object.keys(r3).forEach((t5) => {
          e4(r3[t5], o3.concat(t5));
        }), isJSONArray(r3) && n3.push(o3);
      }(e3, []), n3;
    }(c).slice(0, 99).filter((e3) => e3.length > 0) : []), 16 & e2.$$.dirty && n2(6, o2 = !isEmpty_default(s2)), 3072 & e2.$$.dirty && n2(5, a2 = void 0 === c && ("" === l || void 0 === l)), 6240 & e2.$$.dirty && n2(7, i2 = o2 ? "Object with nested arrays" : a2 ? "An empty document" : isJSONObject(c) ? "An object" : isJSONArray(c) ? "An empty array" : "A ".concat(Or(c, v)));
  }, [d, p, f, m3, s2, a2, o2, i2, r2, function(e3) {
    return getIn(c, e3).length;
  }, l, c, v, (e3) => p(e3), () => f(co.tree), () => m3()];
}
var Lj = class extends dr {
  constructor(e2) {
    super(), ur(this, e2, Uj, Fj, Ht, { text: 10, json: 11, readOnly: 0, parser: 12, openJSONEditorModal: 1, onChangeMode: 2, onClick: 3 }, Ej);
  }
};
function Dj(e2) {
  rn(e2, "svelte-fzj761", ".jse-column-header.svelte-fzj761{background:none;border:none;font-family:inherit;font-size:inherit;color:inherit;display:flex;gap:var(--jse-padding, 10px);padding:calc(0.5 * var(--jse-padding, 10px)) var(--jse-padding, 10px) calc(0.5 * var(--jse-padding, 10px)) calc(0.5 * var(--jse-padding, 10px));width:100%}.jse-column-header.svelte-fzj761:hover{background:var(--jse-table-header-background-highlight, #e8e8e8)}.jse-column-header.svelte-fzj761:not(.jse-column-header.jse-readonly){cursor:pointer}");
}
function Jj(e2) {
  var t3, n2, r2, o2, a2, i2;
  return n2 = new Ca({ props: { data: faRotate } }), { c() {
    t3 = ln("button"), sr(n2.$$.fragment), hn(t3, "type", "button"), hn(t3, "class", "jse-column-header svelte-fzj761"), hn(t3, "title", r2 = "The Columns are created by sampling ".concat(e2[1], " items out of ").concat(e2[0], ". ") + "If you're missing a column, click here to sample all of the items instead of a subset. This is slower.");
  }, m(r3, s2) {
    on(r3, t3, s2), lr(n2, t3, null), o2 = true, a2 || (i2 = pn(t3, "click", e2[3]), a2 = true);
  }, p(e3, n3) {
    var [a3] = n3;
    (!o2 || 3 & a3 && r2 !== (r2 = "The Columns are created by sampling ".concat(e3[1], " items out of ").concat(e3[0], ". ") + "If you're missing a column, click here to sample all of the items instead of a subset. This is slower.")) && hn(t3, "title", r2);
  }, i(e3) {
    o2 || (Xn(n2.$$.fragment, e3), o2 = true);
  }, o(e3) {
    Gn(n2.$$.fragment, e3), o2 = false;
  }, d(e3) {
    e3 && an(t3), cr(n2), a2 = false, i2();
  } };
}
function Vj(e2, t3, n2) {
  var { count: r2 } = t3, { maxSampleCount: o2 } = t3, { onRefresh: a2 } = t3;
  return e2.$$set = (e3) => {
    "count" in e3 && n2(0, r2 = e3.count), "maxSampleCount" in e3 && n2(1, o2 = e3.maxSampleCount), "onRefresh" in e3 && n2(2, a2 = e3.onRefresh);
  }, [r2, o2, a2, () => a2()];
}
var Hj = class extends dr {
  constructor(e2) {
    super(), ur(this, e2, Vj, Jj, Ht, { count: 0, maxSampleCount: 1, onRefresh: 2 }, Dj);
  }
};
var { window: _j } = tn;
function Wj(e2) {
  rn(e2, "svelte-u14cgx", '.jse-table-mode.svelte-u14cgx.svelte-u14cgx{flex:1;display:flex;flex-direction:column;position:relative;background:var(--jse-background-color, #fff);min-width:0;min-height:0;font-family:var(--jse-font-family-mono, consolas, menlo, monaco, "Ubuntu Mono", "source-code-pro", monospace);font-size:var(--jse-font-size-mono, 14px);color:var(--jse-text-color, #4d4d4d);line-height:var(--jse-line-height, calc(1em + 4px))}.jse-table-mode.no-main-menu.svelte-u14cgx.svelte-u14cgx{border-top:var(--jse-main-border, 1px solid #d7d7d7)}.jse-table-mode.svelte-u14cgx .jse-search-box-container.svelte-u14cgx{position:relative;height:0;top:calc(var(--jse-line-height, calc(1em + 4px)) + 2 * var(--jse-padding, 10px));margin-right:calc(var(--jse-padding, 10px) + 20px);margin-left:var(--jse-padding, 10px);text-align:right;z-index:3}.jse-table-mode.svelte-u14cgx .jse-hidden-input-label.svelte-u14cgx{position:fixed;right:0;top:0;width:0;height:0}.jse-table-mode.svelte-u14cgx .jse-hidden-input-label .jse-hidden-input.svelte-u14cgx{width:0;height:0;padding:0;border:0;outline:none}.jse-table-mode.svelte-u14cgx .jse-contents.svelte-u14cgx{flex:1;align-items:flex-start;flex-direction:column;display:flex;overflow:auto;overflow-anchor:none;scrollbar-gutter:stable;border-left:var(--jse-main-border, 1px solid #d7d7d7);border-right:var(--jse-main-border, 1px solid #d7d7d7)}.jse-table-mode.svelte-u14cgx .jse-contents.svelte-u14cgx:last-child{border-bottom:var(--jse-main-border, 1px solid #d7d7d7)}.jse-table-mode.svelte-u14cgx .jse-contents table.jse-table-main.svelte-u14cgx{border-collapse:collapse;border-spacing:0}.jse-table-mode.svelte-u14cgx .jse-contents table.jse-table-main .jse-table-invisible-start-section td.svelte-u14cgx,.jse-table-mode.svelte-u14cgx .jse-contents table.jse-table-main .jse-table-invisible-end-section td.svelte-u14cgx{margin:0;padding:0}.jse-table-mode.svelte-u14cgx .jse-contents table.jse-table-main .jse-search-box-background.svelte-u14cgx{background:var(--jse-table-header-background, #f5f5f5)}.jse-table-mode.svelte-u14cgx .jse-contents table.jse-table-main .jse-table-invisible-end-section td.svelte-u14cgx{padding-bottom:var(--jse-padding, 10px)}.jse-table-mode.svelte-u14cgx .jse-contents table.jse-table-main .jse-table-row.svelte-u14cgx:hover{background-color:var(--jse-table-row-odd-background, rgba(0, 0, 0, 0.05))}.jse-table-mode.svelte-u14cgx .jse-contents table.jse-table-main .jse-table-row .jse-table-cell.svelte-u14cgx{padding:0 var(--jse-padding, 10px) 0 0;vertical-align:top;white-space:nowrap;height:var(--jse-line-height, calc(1em + 4px))}.jse-table-mode.svelte-u14cgx .jse-contents table.jse-table-main .jse-table-row .jse-table-cell.jse-table-cell-header.svelte-u14cgx,.jse-table-mode.svelte-u14cgx .jse-contents table.jse-table-main .jse-table-row .jse-table-cell.jse-table-cell-gutter.svelte-u14cgx{font-weight:normal;text-align:left;color:var(--jse-text-readonly, #8d8d8d);background:var(--jse-table-header-background, #f5f5f5)}.jse-table-mode.svelte-u14cgx .jse-contents table.jse-table-main .jse-table-row .jse-table-cell.jse-table-cell-header.svelte-u14cgx{padding:0;position:sticky;top:0}.jse-table-mode.svelte-u14cgx .jse-contents table.jse-table-main .jse-table-row .jse-table-cell.jse-table-cell-header .jse-table-root-error.svelte-u14cgx{padding:calc(0.5 * var(--jse-padding, 10px)) var(--jse-padding, 10px) calc(0.5 * var(--jse-padding, 10px)) calc(0.5 * var(--jse-padding, 10px))}.jse-table-mode.svelte-u14cgx .jse-contents table.jse-table-main .jse-table-row .jse-table-cell.jse-table-cell-gutter.svelte-u14cgx{padding:0 var(--jse-padding, 10px) 0 calc(0.5 * var(--jse-padding, 10px))}.jse-table-mode.svelte-u14cgx .jse-contents table.jse-table-main .jse-table-row .jse-table-cell .jse-value-outer.svelte-u14cgx{display:inline-block;cursor:var(--jse-contents-cursor, pointer)}.jse-table-mode.svelte-u14cgx .jse-contents table.jse-table-main .jse-table-row .jse-table-cell .jse-value-outer.svelte-u14cgx:hover{background:var(--jse-hover-background-color, rgba(0, 0, 0, 0.06))}.jse-table-mode.svelte-u14cgx .jse-contents table.jse-table-main .jse-table-row .jse-table-cell .jse-value-outer.jse-selected-value.svelte-u14cgx{background:var(--jse-selection-background-color, #d3d3d3)}.jse-table-mode.svelte-u14cgx .jse-contents table.jse-table-main .jse-table-row .jse-table-cell .jse-context-menu-anchor.svelte-u14cgx{display:inline-flex;position:relative;vertical-align:top}.jse-table-mode.svelte-u14cgx .jse-contents.jse-contents-loading.svelte-u14cgx{align-items:unset}.jse-table-mode.svelte-u14cgx .jse-contents.jse-contents-loading .jse-loading-space.svelte-u14cgx{flex:1}.jse-table-mode.svelte-u14cgx .jse-contents.jse-contents-loading .jse-loading.svelte-u14cgx{flex:2;text-align:center;color:var(--jse-panel-color-readonly, #b2b2b2);box-sizing:border-box;font-family:var(--jse-font-family, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif);font-size:var(--jse-font-size, 16px)}');
}
function Qj(e2, t3, n2) {
  var r2, o2 = e2.slice();
  o2[138] = t3[n2], o2[144] = n2;
  var a2 = o2[31].startIndex + o2[144];
  o2[139] = a2;
  var i2 = o2[30].rows[o2[139]];
  o2[140] = i2;
  var s2 = Wm([String(o2[139])], null === (r2 = o2[140]) || void 0 === r2 ? void 0 : r2.row);
  o2[141] = s2;
  var l = Di(o2[8], o2[22], [String(o2[139])]);
  return o2[142] = l, o2;
}
function Yj(e2, t3, n2) {
  var r2, o2 = e2.slice();
  o2[145] = t3[n2], o2[151] = n2;
  var a2 = [String(o2[139])].concat(o2[145]);
  o2[146] = a2;
  var i2 = getIn(o2[138], o2[145]);
  o2[147] = i2;
  var s2 = ls(o2[13]) && Cs(o2[13].path, o2[146]);
  o2[148] = s2;
  var l = null === (r2 = o2[140]) || void 0 === r2 ? void 0 : r2.columns[o2[151]];
  o2[149] = l;
  var c = Wm(o2[146], o2[149]);
  return o2[141] = c, o2;
}
function Kj(e2, t3, n2) {
  var r2 = e2.slice();
  return r2[145] = t3[n2], r2;
}
function Zj(e2) {
  var t3, n2 = e2.slice(), r2 = Wm([], null === (t3 = n2[30]) || void 0 === t3 ? void 0 : t3.root);
  return n2[141] = r2, n2;
}
function Xj(e2) {
  var t3, n2, r2;
  function o2(t4) {
    e2[84](t4);
  }
  var a2 = { containsValidArray: e2[24], readOnly: e2[0], historyState: e2[28], onSort: e2[52], onTransform: e2[53], onUndo: e2[54], onRedo: e2[55], onContextMenu: e2[44], onRenderMenu: e2[5] };
  return void 0 !== e2[9] && (a2.showSearch = e2[9]), t3 = new yj({ props: a2 }), Tn.push(() => ir(t3, "showSearch", o2)), { c() {
    sr(t3.$$.fragment);
  }, m(e3, n3) {
    lr(t3, e3, n3), r2 = true;
  }, p(e3, r3) {
    var o3 = {};
    16777216 & r3[0] && (o3.containsValidArray = e3[24]), 1 & r3[0] && (o3.readOnly = e3[0]), 268435456 & r3[0] && (o3.historyState = e3[28]), 32 & r3[0] && (o3.onRenderMenu = e3[5]), !n2 && 512 & r3[0] && (n2 = true, o3.showSearch = e3[9], Jn(() => n2 = false)), t3.$set(o3);
  }, i(e3) {
    r2 || (Xn(t3.$$.fragment, e3), r2 = true);
  }, o(e3) {
    Gn(t3.$$.fragment, e3), r2 = false;
  }, d(e3) {
    cr(t3, e3);
  } };
}
function Gj(e2) {
  var t3;
  return { c() {
    (t3 = ln("div")).innerHTML = '<div class="jse-loading-space svelte-u14cgx"></div> <div class="jse-loading svelte-u14cgx">loading...</div>', hn(t3, "class", "jse-contents jse-contents-loading svelte-u14cgx");
  }, m(e3, n2) {
    on(e3, t3, n2);
  }, p: Bt, i: Bt, o: Bt, d(e3) {
    e3 && an(t3);
  } };
}
function ex(e2) {
  var t3, n2, r2, o2, a2, i2, s2, l, c, u = [rx, nx, tx], d = [];
  function v(e3, t4) {
    return e3[24] ? 0 : e3[20] && void 0 !== e3[19] && "" !== e3[19] ? 1 : 2;
  }
  return o2 = v(e2), a2 = d[o2] = u[o2](e2), { c() {
    t3 = ln("label"), n2 = ln("input"), r2 = dn(), a2.c(), i2 = vn(), hn(n2, "type", "text"), n2.readOnly = true, hn(n2, "tabindex", "-1"), hn(n2, "class", "jse-hidden-input svelte-u14cgx"), hn(t3, "class", "jse-hidden-input-label svelte-u14cgx");
  }, m(a3, u2) {
    on(a3, t3, u2), nn(t3, n2), e2[85](n2), on(a3, r2, u2), d[o2].m(a3, u2), on(a3, i2, u2), s2 = true, l || (c = pn(n2, "paste", e2[49]), l = true);
  }, p(e3, t4) {
    var n3 = o2;
    (o2 = v(e3)) === n3 ? d[o2].p(e3, t4) : (Kn(), Gn(d[n3], 1, 1, () => {
      d[n3] = null;
    }), Zn(), (a2 = d[o2]) ? a2.p(e3, t4) : (a2 = d[o2] = u[o2](e3)).c(), Xn(a2, 1), a2.m(i2.parentNode, i2));
  }, i(e3) {
    s2 || (Xn(a2), s2 = true);
  }, o(e3) {
    Gn(a2), s2 = false;
  }, d(n3) {
    n3 && (an(t3), an(r2), an(i2)), e2[85](null), d[o2].d(n3), l = false, c();
  } };
}
function tx(e2) {
  var t3, n2;
  return t3 = new Lj({ props: { text: e2[19], json: e2[8], readOnly: e2[0], parser: e2[2], openJSONEditorModal: e2[51], onChangeMode: e2[4], onClick: e2[89] } }), { c() {
    sr(t3.$$.fragment);
  }, m(e3, r2) {
    lr(t3, e3, r2), n2 = true;
  }, p(e3, n3) {
    var r2 = {};
    524288 & n3[0] && (r2.text = e3[19]), 256 & n3[0] && (r2.json = e3[8]), 1 & n3[0] && (r2.readOnly = e3[0]), 4 & n3[0] && (r2.parser = e3[2]), 16 & n3[0] && (r2.onChangeMode = e3[4]), t3.$set(r2);
  }, i(e3) {
    n2 || (Xn(t3.$$.fragment, e3), n2 = true);
  }, o(e3) {
    Gn(t3.$$.fragment, e3), n2 = false;
  }, d(e3) {
    cr(t3, e3);
  } };
}
function nx(e2) {
  var t3, n2, r2, o2;
  return t3 = new cv({ props: { type: "error", message: "The loaded JSON document is invalid and could not be repaired automatically.", actions: e2[0] ? [] : [{ icon: faCode, text: "Repair manually", title: 'Open the document in "code" mode and repair it manually', onClick: e2[47] }] } }), r2 = new fh({ props: { text: e2[19], json: e2[8], indentation: e2[3], parser: e2[2] } }), { c() {
    sr(t3.$$.fragment), n2 = dn(), sr(r2.$$.fragment);
  }, m(e3, a2) {
    lr(t3, e3, a2), on(e3, n2, a2), lr(r2, e3, a2), o2 = true;
  }, p(e3, n3) {
    var o3 = {};
    1 & n3[0] && (o3.actions = e3[0] ? [] : [{ icon: faCode, text: "Repair manually", title: 'Open the document in "code" mode and repair it manually', onClick: e3[47] }]), t3.$set(o3);
    var a2 = {};
    524288 & n3[0] && (a2.text = e3[19]), 256 & n3[0] && (a2.json = e3[8]), 8 & n3[0] && (a2.indentation = e3[3]), 4 & n3[0] && (a2.parser = e3[2]), r2.$set(a2);
  }, i(e3) {
    o2 || (Xn(t3.$$.fragment, e3), Xn(r2.$$.fragment, e3), o2 = true);
  }, o(e3) {
    Gn(t3.$$.fragment, e3), Gn(r2.$$.fragment, e3), o2 = false;
  }, d(e3) {
    e3 && an(n2), cr(t3, e3), cr(r2, e3);
  } };
}
function rx(e2) {
  var t3, n2, r2, o2, a2, i2, s2, l, c, u, d, v, p, f, m3, h2, g, j, x, b2, y, $2, w, C3, k2, S4, O, z3 = !isEmpty_default(null === (t3 = e2[30]) || void 0 === t3 ? void 0 : t3.root);
  r2 = new Nm({ props: { json: e2[8], documentState: e2[12], parser: e2[2], showSearch: e2[9], showReplace: e2[23], readOnly: e2[0], columns: e2[11], onSearch: e2[34], onFocus: e2[35], onPatch: e2[38], onClose: e2[36] } });
  for (var q2 = z3 && ox(Zj(e2)), M3 = er(e2[11]), R3 = [], E3 = 0; E3 < M3.length; E3 += 1) R3[E3] = ix(Kj(e2, M3, E3));
  for (var P3 = (e3) => Gn(R3[e3], 1, 1, () => {
    R3[e3] = null;
  }), I3 = e2[32] && sx(e2), A = er(e2[31].visibleItems), N3 = [], B3 = 0; B3 < A.length; B3 += 1) N3[B3] = hx(Qj(e2, A, B3));
  var F3 = (e3) => Gn(N3[e3], 1, 1, () => {
    N3[e3] = null;
  }), U3 = e2[21] && gx(e2), L3 = e2[27] && jx(e2);
  return C3 = new bv({ props: { validationErrors: e2[14], selectError: e2[50] } }), { c() {
    n2 = ln("div"), sr(r2.$$.fragment), o2 = dn(), a2 = ln("div"), i2 = ln("table"), s2 = ln("tbody"), l = ln("tr"), c = ln("th"), q2 && q2.c(), u = dn();
    for (var t4 = 0; t4 < R3.length; t4 += 1) R3[t4].c();
    d = dn(), I3 && I3.c(), v = dn(), p = ln("tr"), f = ln("td"), h2 = dn();
    for (var k3 = 0; k3 < N3.length; k3 += 1) N3[k3].c();
    g = dn(), j = ln("tr"), x = ln("td"), y = dn(), U3 && U3.c(), $2 = dn(), L3 && L3.c(), w = dn(), sr(C3.$$.fragment), hn(n2, "class", "jse-search-box-container svelte-u14cgx"), hn(c, "class", "jse-table-cell jse-table-cell-header svelte-u14cgx"), hn(l, "class", "jse-table-row jse-table-row-header svelte-u14cgx"), hn(f, "colspan", m3 = e2[11].length), hn(f, "class", "svelte-u14cgx"), wn(f, "height", e2[31].startHeight + "px"), hn(p, "class", "jse-table-invisible-start-section svelte-u14cgx"), kn(p, "jse-search-box-background", e2[9]), hn(x, "colspan", b2 = e2[11].length), hn(x, "class", "svelte-u14cgx"), wn(x, "height", e2[31].endHeight + "px"), hn(j, "class", "jse-table-invisible-end-section"), hn(i2, "class", "jse-table-main svelte-u14cgx"), hn(a2, "class", "jse-contents svelte-u14cgx");
  }, m(t4, m4) {
    on(t4, n2, m4), lr(r2, n2, null), on(t4, o2, m4), on(t4, a2, m4), nn(a2, i2), nn(i2, s2), nn(s2, l), nn(l, c), q2 && q2.m(c, null), nn(l, u);
    for (var b3 = 0; b3 < R3.length; b3 += 1) R3[b3] && R3[b3].m(l, null);
    nn(l, d), I3 && I3.m(l, null), nn(s2, v), nn(s2, p), nn(p, f), nn(s2, h2);
    for (var z4 = 0; z4 < N3.length; z4 += 1) N3[z4] && N3[z4].m(s2, null);
    nn(s2, g), nn(s2, j), nn(j, x), e2[88](a2), on(t4, y, m4), U3 && U3.m(t4, m4), on(t4, $2, m4), L3 && L3.m(t4, m4), on(t4, w, m4), lr(C3, t4, m4), k2 = true, S4 || (O = [en(Rj.call(null, a2, e2[56])), pn(a2, "scroll", e2[40])], S4 = true);
  }, p(e3, t4) {
    var n3, o3 = {};
    if (256 & t4[0] && (o3.json = e3[8]), 4096 & t4[0] && (o3.documentState = e3[12]), 4 & t4[0] && (o3.parser = e3[2]), 512 & t4[0] && (o3.showSearch = e3[9]), 8388608 & t4[0] && (o3.showReplace = e3[23]), 1 & t4[0] && (o3.readOnly = e3[0]), 2048 & t4[0] && (o3.columns = e3[11]), r2.$set(o3), 1073741824 & t4[0] && (z3 = !isEmpty_default(null === (n3 = e3[30]) || void 0 === n3 ? void 0 : n3.root)), z3 ? q2 ? (q2.p(Zj(e3), t4), 1073741824 & t4[0] && Xn(q2, 1)) : ((q2 = ox(Zj(e3))).c(), Xn(q2, 1), q2.m(c, null)) : q2 && (Kn(), Gn(q2, 1, 1, () => {
      q2 = null;
    }), Zn()), 67110913 & t4[0] | 64 & t4[1]) {
      var a3;
      for (M3 = er(e3[11]), a3 = 0; a3 < M3.length; a3 += 1) {
        var i3 = Kj(e3, M3, a3);
        R3[a3] ? (R3[a3].p(i3, t4), Xn(R3[a3], 1)) : (R3[a3] = ix(i3), R3[a3].c(), Xn(R3[a3], 1), R3[a3].m(l, d));
      }
      for (Kn(), a3 = M3.length; a3 < R3.length; a3 += 1) P3(a3);
      Zn();
    }
    if (e3[32] ? I3 ? (I3.p(e3, t4), 2 & t4[1] && Xn(I3, 1)) : ((I3 = sx(e3)).c(), Xn(I3, 1), I3.m(l, null)) : I3 && (Kn(), Gn(I3, 1, 1, () => {
      I3 = null;
    }), Zn()), (!k2 || 2048 & t4[0] && m3 !== (m3 = e3[11].length)) && hn(f, "colspan", m3), 1 & t4[1] && wn(f, "height", e3[31].startHeight + "px"), (!k2 || 512 & t4[0]) && kn(p, "jse-search-box-background", e3[9]), 1614821637 & t4[0] | 68159491 & t4[1]) {
      var u2;
      for (A = er(e3[31].visibleItems), u2 = 0; u2 < A.length; u2 += 1) {
        var v2 = Qj(e3, A, u2);
        N3[u2] ? (N3[u2].p(v2, t4), Xn(N3[u2], 1)) : (N3[u2] = hx(v2), N3[u2].c(), Xn(N3[u2], 1), N3[u2].m(s2, g));
      }
      for (Kn(), u2 = A.length; u2 < N3.length; u2 += 1) F3(u2);
      Zn();
    }
    (!k2 || 2048 & t4[0] && b2 !== (b2 = e3[11].length)) && hn(x, "colspan", b2), 1 & t4[1] && wn(x, "height", e3[31].endHeight + "px"), e3[21] ? U3 ? (U3.p(e3, t4), 2097152 & t4[0] && Xn(U3, 1)) : ((U3 = gx(e3)).c(), Xn(U3, 1), U3.m($2.parentNode, $2)) : U3 && (Kn(), Gn(U3, 1, 1, () => {
      U3 = null;
    }), Zn()), e3[27] ? L3 ? (L3.p(e3, t4), 134217728 & t4[0] && Xn(L3, 1)) : ((L3 = jx(e3)).c(), Xn(L3, 1), L3.m(w.parentNode, w)) : L3 && (Kn(), Gn(L3, 1, 1, () => {
      L3 = null;
    }), Zn());
    var h3 = {};
    16384 & t4[0] && (h3.validationErrors = e3[14]), C3.$set(h3);
  }, i(e3) {
    if (!k2) {
      Xn(r2.$$.fragment, e3), Xn(q2);
      for (var t4 = 0; t4 < M3.length; t4 += 1) Xn(R3[t4]);
      Xn(I3);
      for (var n3 = 0; n3 < A.length; n3 += 1) Xn(N3[n3]);
      Xn(U3), Xn(L3), Xn(C3.$$.fragment, e3), k2 = true;
    }
  }, o(e3) {
    Gn(r2.$$.fragment, e3), Gn(q2), R3 = R3.filter(Boolean);
    for (var t4 = 0; t4 < R3.length; t4 += 1) Gn(R3[t4]);
    Gn(I3), N3 = N3.filter(Boolean);
    for (var n3 = 0; n3 < N3.length; n3 += 1) Gn(N3[n3]);
    Gn(U3), Gn(L3), Gn(C3.$$.fragment, e3), k2 = false;
  }, d(t4) {
    t4 && (an(n2), an(o2), an(a2), an(y), an($2), an(w)), cr(r2), q2 && q2.d(), sn(R3, t4), I3 && I3.d(), sn(N3, t4), e2[88](null), U3 && U3.d(t4), L3 && L3.d(t4), cr(C3, t4), S4 = false, Dt(O);
  } };
}
function ox(e2) {
  var t3, n2, r2 = e2[141] && ax(e2);
  return { c() {
    r2 && r2.c(), t3 = vn();
  }, m(e3, o2) {
    r2 && r2.m(e3, o2), on(e3, t3, o2), n2 = true;
  }, p(e3, n3) {
    e3[141] ? r2 ? (r2.p(e3, n3), 1073741824 & n3[0] && Xn(r2, 1)) : ((r2 = ax(e3)).c(), Xn(r2, 1), r2.m(t3.parentNode, t3)) : r2 && (Kn(), Gn(r2, 1, 1, () => {
      r2 = null;
    }), Zn());
  }, i(e3) {
    n2 || (Xn(r2), n2 = true);
  }, o(e3) {
    Gn(r2), n2 = false;
  }, d(e3) {
    e3 && an(t3), r2 && r2.d(e3);
  } };
}
function ax(e2) {
  var t3, n2, r2;
  return n2 = new Fp({ props: { validationError: e2[141], onExpand: Dg } }), { c() {
    t3 = ln("div"), sr(n2.$$.fragment), hn(t3, "class", "jse-table-root-error svelte-u14cgx");
  }, m(e3, o2) {
    on(e3, t3, o2), lr(n2, t3, null), r2 = true;
  }, p(e3, t4) {
    var r3 = {};
    1073741824 & t4[0] && (r3.validationError = e3[141]), n2.$set(r3);
  }, i(e3) {
    r2 || (Xn(n2.$$.fragment, e3), r2 = true);
  }, o(e3) {
    Gn(n2.$$.fragment, e3), r2 = false;
  }, d(e3) {
    e3 && an(t3), cr(n2);
  } };
}
function ix(e2) {
  var t3, n2, r2;
  return n2 = new Mj({ props: { path: e2[145], sortedColumn: e2[26], readOnly: e2[0], onSort: e2[37] } }), { c() {
    t3 = ln("th"), sr(n2.$$.fragment), hn(t3, "class", "jse-table-cell jse-table-cell-header svelte-u14cgx");
  }, m(e3, o2) {
    on(e3, t3, o2), lr(n2, t3, null), r2 = true;
  }, p(e3, t4) {
    var r3 = {};
    2048 & t4[0] && (r3.path = e3[145]), 67108864 & t4[0] && (r3.sortedColumn = e3[26]), 1 & t4[0] && (r3.readOnly = e3[0]), n2.$set(r3);
  }, i(e3) {
    r2 || (Xn(n2.$$.fragment, e3), r2 = true);
  }, o(e3) {
    Gn(n2.$$.fragment, e3), r2 = false;
  }, d(e3) {
    e3 && an(t3), cr(n2);
  } };
}
function sx(e2) {
  var t3, n2, r2;
  return n2 = new Hj({ props: { count: Array.isArray(e2[8]) ? e2[8].length : 0, maxSampleCount: e2[10], onRefresh: e2[86] } }), { c() {
    t3 = ln("th"), sr(n2.$$.fragment), hn(t3, "class", "jse-table-cell jse-table-cell-header svelte-u14cgx");
  }, m(e3, o2) {
    on(e3, t3, o2), lr(n2, t3, null), r2 = true;
  }, p(e3, t4) {
    var r3 = {};
    256 & t4[0] && (r3.count = Array.isArray(e3[8]) ? e3[8].length : 0), 1024 & t4[0] && (r3.maxSampleCount = e3[10]), 1024 & t4[0] && (r3.onRefresh = e3[86]), n2.$set(r3);
  }, i(e3) {
    r2 || (Xn(n2.$$.fragment, e3), r2 = true);
  }, o(e3) {
    Gn(n2.$$.fragment, e3), r2 = false;
  }, d(e3) {
    e3 && an(t3), cr(n2);
  } };
}
function lx(e2) {
  var t3, n2;
  return t3 = new Fp({ props: { validationError: e2[141], onExpand: Dg } }), { c() {
    sr(t3.$$.fragment);
  }, m(e3, r2) {
    lr(t3, e3, r2), n2 = true;
  }, p(e3, n3) {
    var r2 = {};
    1073741824 & n3[0] | 1 & n3[1] && (r2.validationError = e3[141]), t3.$set(r2);
  }, i(e3) {
    n2 || (Xn(t3.$$.fragment, e3), n2 = true);
  }, o(e3) {
    Gn(t3.$$.fragment, e3), n2 = false;
  }, d(e3) {
    cr(t3, e3);
  } };
}
function cx(e2) {
  var t3, n2, r2, o2, a2, i2, s2, l = e2[139] + "", c = e2[141] && lx(e2);
  function u() {
    for (var t4 = arguments.length, n3 = new Array(t4), r3 = 0; r3 < t4; r3++) n3[r3] = arguments[r3];
    return e2[87](e2[139], ...n3);
  }
  return { c() {
    t3 = ln("th"), n2 = un(l), r2 = dn(), c && c.c(), hn(t3, "class", "jse-table-cell jse-table-cell-gutter svelte-u14cgx");
  }, m(e3, l2) {
    on(e3, t3, l2), nn(t3, n2), nn(t3, r2), c && c.m(t3, null), a2 = true, i2 || (s2 = en(o2 = Rj.call(null, t3, u)), i2 = true);
  }, p(r3, i3) {
    e2 = r3, (!a2 || 1 & i3[1]) && l !== (l = e2[139] + "") && yn(n2, l), e2[141] ? c ? (c.p(e2, i3), 1073741824 & i3[0] | 1 & i3[1] && Xn(c, 1)) : ((c = lx(e2)).c(), Xn(c, 1), c.m(t3, null)) : c && (Kn(), Gn(c, 1, 1, () => {
      c = null;
    }), Zn()), o2 && Jt(o2.update) && 1 & i3[1] && o2.update.call(null, u);
  }, i(e3) {
    a2 || (Xn(c), a2 = true);
  }, o(e3) {
    Gn(c), a2 = false;
  }, d(e3) {
    e3 && an(t3), c && c.d(), i2 = false, s2();
  } };
}
function ux(e2) {
  var t3, n2;
  return t3 = new Pp({ props: { path: e2[146], value: void 0 !== e2[147] ? e2[147] : "", enforceString: Yi(e2[8], e2[12], e2[146]), selection: e2[148] ? e2[13] : void 0, searchResultItems: e2[154], context: e2[29] } }), { c() {
    sr(t3.$$.fragment);
  }, m(e3, r2) {
    lr(t3, e3, r2), n2 = true;
  }, p(e3, n3) {
    var r2 = {};
    2048 & n3[0] | 1 & n3[1] && (r2.path = e3[146]), 2048 & n3[0] | 1 & n3[1] && (r2.value = void 0 !== e3[147] ? e3[147] : ""), 6400 & n3[0] | 1 & n3[1] && (r2.enforceString = Yi(e3[8], e3[12], e3[146])), 10240 & n3[0] | 1 & n3[1] && (r2.selection = e3[148] ? e3[13] : void 0), 4196608 & n3[0] | 1 & n3[1] && (r2.searchResultItems = e3[154]), 536870912 & n3[0] && (r2.context = e3[29]), t3.$set(r2);
  }, i(e3) {
    n2 || (Xn(t3.$$.fragment, e3), n2 = true);
  }, o(e3) {
    Gn(t3.$$.fragment, e3), n2 = false;
  }, d(e3) {
    cr(t3, e3);
  } };
}
function dx(e2) {
  var t3, n2;
  return t3 = new kj({ props: { path: e2[146], value: e2[147], parser: e2[2], isSelected: e2[148], containsSearchResult: !isEmpty_default(e2[152]), containsActiveSearchResult: e2[153], onEdit: e2[51] } }), { c() {
    sr(t3.$$.fragment);
  }, m(e3, r2) {
    lr(t3, e3, r2), n2 = true;
  }, p(e3, n3) {
    var r2 = {};
    2048 & n3[0] | 1 & n3[1] && (r2.path = e3[146]), 2048 & n3[0] | 1 & n3[1] && (r2.value = e3[147]), 4 & n3[0] && (r2.parser = e3[2]), 10240 & n3[0] | 1 & n3[1] && (r2.isSelected = e3[148]), 4196608 & n3[0] | 1 & n3[1] && (r2.containsSearchResult = !isEmpty_default(e3[152])), 4196608 & n3[0] | 1 & n3[1] && (r2.containsActiveSearchResult = e3[153]), t3.$set(r2);
  }, i(e3) {
    n2 || (Xn(t3.$$.fragment, e3), n2 = true);
  }, o(e3) {
    Gn(t3.$$.fragment, e3), n2 = false;
  }, d(e3) {
    cr(t3, e3);
  } };
}
function vx(e2) {
  var t3, n2, r2;
  return n2 = new mp({ props: { selected: true, onContextMenu: e2[42] } }), { c() {
    t3 = ln("div"), sr(n2.$$.fragment), hn(t3, "class", "jse-context-menu-anchor svelte-u14cgx");
  }, m(e3, o2) {
    on(e3, t3, o2), lr(n2, t3, null), r2 = true;
  }, p: Bt, i(e3) {
    r2 || (Xn(n2.$$.fragment, e3), r2 = true);
  }, o(e3) {
    Gn(n2.$$.fragment, e3), r2 = false;
  }, d(e3) {
    e3 && an(t3), cr(n2);
  } };
}
function px(e2) {
  var t3, n2;
  return t3 = new Fp({ props: { validationError: e2[141], onExpand: Dg } }), { c() {
    sr(t3.$$.fragment);
  }, m(e3, r2) {
    lr(t3, e3, r2), n2 = true;
  }, p(e3, n3) {
    var r2 = {};
    1073743872 & n3[0] | 1 & n3[1] && (r2.validationError = e3[141]), t3.$set(r2);
  }, i(e3) {
    n2 || (Xn(t3.$$.fragment, e3), n2 = true);
  }, o(e3) {
    Gn(t3.$$.fragment, e3), n2 = false;
  }, d(e3) {
    cr(t3, e3);
  } };
}
function fx(e2) {
  var t3, n2, r2, o2, a2, i2, s2, l, c, u = !e2[0] && e2[148] && !Is(e2[13]), d = [dx, ux], v = [];
  function p(e3, t4) {
    return 2048 & t4[0] | 1 & t4[1] && (r2 = null), null == r2 && (r2 = !!yr(e3[147])), r2 ? 0 : 1;
  }
  function f(e3, t4) {
    return 0 === t4 ? function(e4) {
      var t5 = e4.slice(), n3 = yl(Di(t5[138], t5[142], t5[145]));
      t5[152] = n3;
      var r3 = !!t5[152] && t5[152].some((e5) => e5.active);
      return t5[153] = r3, t5;
    }(e3) : function(e4) {
      var t5, n3 = e4.slice(), r3 = null === (t5 = Di(n3[8], n3[22], n3[146])) || void 0 === t5 ? void 0 : t5.searchResults;
      return n3[154] = r3, n3;
    }(e3);
  }
  o2 = p(e2, [-1, -1, -1, -1, -1, -1]), a2 = v[o2] = d[o2](f(e2, o2));
  var m3 = u && vx(e2), h2 = e2[141] && px(e2);
  return { c() {
    t3 = ln("td"), n2 = ln("div"), a2.c(), i2 = vn(), m3 && m3.c(), s2 = dn(), h2 && h2.c(), hn(n2, "class", "jse-value-outer svelte-u14cgx"), kn(n2, "jse-selected-value", e2[148]), hn(t3, "class", "jse-table-cell svelte-u14cgx"), hn(t3, "data-path", l = Bo(e2[146]));
  }, m(e3, r3) {
    on(e3, t3, r3), nn(t3, n2), v[o2].m(n2, null), nn(n2, i2), m3 && m3.m(n2, null), nn(t3, s2), h2 && h2.m(t3, null), c = true;
  }, p(e3, r3) {
    var s3 = o2;
    (o2 = p(e3, r3)) === s3 ? v[o2].p(f(e3, o2), r3) : (Kn(), Gn(v[s3], 1, 1, () => {
      v[s3] = null;
    }), Zn(), (a2 = v[o2]) ? a2.p(f(e3, o2), r3) : (a2 = v[o2] = d[o2](f(e3, o2))).c(), Xn(a2, 1), a2.m(n2, i2)), 10241 & r3[0] | 1 & r3[1] && (u = !e3[0] && e3[148] && !Is(e3[13])), u ? m3 ? (m3.p(e3, r3), 10241 & r3[0] | 1 & r3[1] && Xn(m3, 1)) : ((m3 = vx(e3)).c(), Xn(m3, 1), m3.m(n2, null)) : m3 && (Kn(), Gn(m3, 1, 1, () => {
      m3 = null;
    }), Zn()), (!c || 10240 & r3[0] | 1 & r3[1]) && kn(n2, "jse-selected-value", e3[148]), e3[141] ? h2 ? (h2.p(e3, r3), 1073743872 & r3[0] | 1 & r3[1] && Xn(h2, 1)) : ((h2 = px(e3)).c(), Xn(h2, 1), h2.m(t3, null)) : h2 && (Kn(), Gn(h2, 1, 1, () => {
      h2 = null;
    }), Zn()), (!c || 2048 & r3[0] | 1 & r3[1] && l !== (l = Bo(e3[146]))) && hn(t3, "data-path", l);
  }, i(e3) {
    c || (Xn(a2), Xn(m3), Xn(h2), c = true);
  }, o(e3) {
    Gn(a2), Gn(m3), Gn(h2), c = false;
  }, d(e3) {
    e3 && an(t3), v[o2].d(), m3 && m3.d(), h2 && h2.d();
  } };
}
function mx(e2) {
  var t3;
  return { c() {
    hn(t3 = ln("td"), "class", "jse-table-cell svelte-u14cgx");
  }, m(e3, n2) {
    on(e3, t3, n2);
  }, d(e3) {
    e3 && an(t3);
  } };
}
function hx(e2) {
  for (var t3, n2, r2, o2, a2 = e2[139], i2 = cx(e2), s2 = er(e2[11]), l = [], c = 0; c < s2.length; c += 1) l[c] = fx(Yj(e2, s2, c));
  var u = (e3) => Gn(l[e3], 1, 1, () => {
    l[e3] = null;
  }), d = e2[32] && mx();
  return { c() {
    t3 = ln("tr"), i2.c(), n2 = dn();
    for (var e3 = 0; e3 < l.length; e3 += 1) l[e3].c();
    r2 = dn(), d && d.c(), hn(t3, "class", "jse-table-row svelte-u14cgx");
  }, m(e3, a3) {
    on(e3, t3, a3), i2.m(t3, null), nn(t3, n2);
    for (var s3 = 0; s3 < l.length; s3 += 1) l[s3] && l[s3].m(t3, null);
    nn(t3, r2), d && d.m(t3, null), o2 = true;
  }, p(e3, o3) {
    if (1 & o3[1] && Ht(a2, a2 = e3[139]) ? (Kn(), Gn(i2, 1, 1, Bt), Zn(), (i2 = cx(e3)).c(), Xn(i2, 1), i2.m(t3, n2)) : i2.p(e3, o3), 1614821637 & o3[0] | 1050625 & o3[1]) {
      var c2;
      for (s2 = er(e3[11]), c2 = 0; c2 < s2.length; c2 += 1) {
        var v = Yj(e3, s2, c2);
        l[c2] ? (l[c2].p(v, o3), Xn(l[c2], 1)) : (l[c2] = fx(v), l[c2].c(), Xn(l[c2], 1), l[c2].m(t3, r2));
      }
      for (Kn(), c2 = s2.length; c2 < l.length; c2 += 1) u(c2);
      Zn();
    }
    e3[32] ? d || ((d = mx()).c(), d.m(t3, null)) : d && (d.d(1), d = null);
  }, i(e3) {
    if (!o2) {
      Xn(i2);
      for (var t4 = 0; t4 < s2.length; t4 += 1) Xn(l[t4]);
      o2 = true;
    }
  }, o(e3) {
    Gn(i2), l = l.filter(Boolean);
    for (var t4 = 0; t4 < l.length; t4 += 1) Gn(l[t4]);
    o2 = false;
  }, d(e3) {
    e3 && an(t3), i2.d(e3), sn(l, e3), d && d.d();
  } };
}
function gx(e2) {
  var t3, n2;
  return t3 = new cv({ props: { type: "info", message: "You pasted a JSON ".concat(Array.isArray(e2[21].contents) ? "array" : "object", " as text"), actions: [{ icon: faWrench, text: "Paste as JSON instead", title: "Paste the text as JSON instead of a single value", onMouseDown: e2[45] }, { text: "Leave as is", title: "Keep the pasted content as a single value", onClick: e2[46] }] } }), { c() {
    sr(t3.$$.fragment);
  }, m(e3, r2) {
    lr(t3, e3, r2), n2 = true;
  }, p(e3, n3) {
    var r2 = {};
    2097152 & n3[0] && (r2.message = "You pasted a JSON ".concat(Array.isArray(e3[21].contents) ? "array" : "object", " as text")), t3.$set(r2);
  }, i(e3) {
    n2 || (Xn(t3.$$.fragment, e3), n2 = true);
  }, o(e3) {
    Gn(t3.$$.fragment, e3), n2 = false;
  }, d(e3) {
    cr(t3, e3);
  } };
}
function jx(e2) {
  var t3, n2;
  return t3 = new cv({ props: { type: "success", message: "The loaded JSON document was invalid but is successfully repaired.", actions: e2[0] ? [] : [{ icon: faCheck, text: "Ok", title: "Accept the repaired document", onClick: e2[7] }, { icon: faCode, text: "Repair manually instead", title: "Leave the document unchanged and repair it manually instead", onClick: e2[47] }], onClose: e2[6] } }), { c() {
    sr(t3.$$.fragment);
  }, m(e3, r2) {
    lr(t3, e3, r2), n2 = true;
  }, p(e3, n3) {
    var r2 = {};
    1 & n3[0] && (r2.actions = e3[0] ? [] : [{ icon: faCheck, text: "Ok", title: "Accept the repaired document", onClick: e3[7] }, { icon: faCode, text: "Repair manually instead", title: "Leave the document unchanged and repair it manually instead", onClick: e3[47] }]), t3.$set(r2);
  }, i(e3) {
    n2 || (Xn(t3.$$.fragment, e3), n2 = true);
  }, o(e3) {
    Gn(t3.$$.fragment, e3), n2 = false;
  }, d(e3) {
    cr(t3, e3);
  } };
}
function xx(e2) {
  var t3, n2;
  return t3 = new Mv({ props: { onClose: e2[91] } }), { c() {
    sr(t3.$$.fragment);
  }, m(e3, r2) {
    lr(t3, e3, r2), n2 = true;
  }, p(e3, n3) {
    var r2 = {};
    33554432 & n3[0] && (r2.onClose = e3[91]), t3.$set(r2);
  }, i(e3) {
    n2 || (Xn(t3.$$.fragment, e3), n2 = true);
  }, o(e3) {
    Gn(t3.$$.fragment, e3), n2 = false;
  }, d(e3) {
    cr(t3, e3);
  } };
}
function bx(e2) {
  for (var t3, n2, r2 = [e2[18], { onClose: e2[92] }], o2 = {}, a2 = 0; a2 < r2.length; a2 += 1) o2 = Ft(o2, r2[a2]);
  return t3 = new op({ props: o2 }), { c() {
    sr(t3.$$.fragment);
  }, m(e3, r3) {
    lr(t3, e3, r3), n2 = true;
  }, p(e3, n3) {
    var o3 = 262144 & n3[0] ? or(r2, [262144 & n3[0] && ar(e3[18]), { onClose: e3[92] }]) : {};
    t3.$set(o3);
  }, i(e3) {
    n2 || (Xn(t3.$$.fragment, e3), n2 = true);
  }, o(e3) {
    Gn(t3.$$.fragment, e3), n2 = false;
  }, d(e3) {
    cr(t3, e3);
  } };
}
function yx(e2) {
  var t3, n2, r2, o2, a2, i2, s2, l, c, u, d = e2[1] && Xj(e2), v = [ex, Gj], p = [];
  r2 = function(e3) {
    return e3[33] ? 1 : 0;
  }(e2), o2 = p[r2] = v[r2](e2);
  var f = e2[25] && xx(e2), m3 = e2[18] && bx(e2);
  return { c() {
    t3 = ln("div"), d && d.c(), n2 = dn(), o2.c(), a2 = dn(), f && f.c(), i2 = dn(), m3 && m3.c(), s2 = vn(), hn(t3, "role", "table"), hn(t3, "class", "jse-table-mode svelte-u14cgx"), kn(t3, "no-main-menu", !e2[1]);
  }, m(o3, v2) {
    on(o3, t3, v2), d && d.m(t3, null), nn(t3, n2), p[r2].m(t3, null), e2[90](t3), on(o3, a2, v2), f && f.m(o3, v2), on(o3, i2, v2), m3 && m3.m(o3, v2), on(o3, s2, v2), l = true, c || (u = [pn(_j, "mousedown", e2[39]), pn(t3, "mousedown", e2[41]), pn(t3, "keydown", e2[48]), pn(t3, "contextmenu", e2[43])], c = true);
  }, p(e3, r3) {
    e3[1] ? d ? (d.p(e3, r3), 2 & r3[0] && Xn(d, 1)) : ((d = Xj(e3)).c(), Xn(d, 1), d.m(t3, n2)) : d && (Kn(), Gn(d, 1, 1, () => {
      d = null;
    }), Zn()), o2.p(e3, r3), (!l || 2 & r3[0]) && kn(t3, "no-main-menu", !e3[1]), e3[25] ? f ? (f.p(e3, r3), 33554432 & r3[0] && Xn(f, 1)) : ((f = xx(e3)).c(), Xn(f, 1), f.m(i2.parentNode, i2)) : f && (Kn(), Gn(f, 1, 1, () => {
      f = null;
    }), Zn()), e3[18] ? m3 ? (m3.p(e3, r3), 262144 & r3[0] && Xn(m3, 1)) : ((m3 = bx(e3)).c(), Xn(m3, 1), m3.m(s2.parentNode, s2)) : m3 && (Kn(), Gn(m3, 1, 1, () => {
      m3 = null;
    }), Zn());
  }, i(e3) {
    l || (Xn(d), Xn(o2), Xn(f), Xn(m3), l = true);
  }, o(e3) {
    Gn(d), Gn(o2), Gn(f), Gn(m3), l = false;
  }, d(n3) {
    n3 && (an(t3), an(a2), an(i2), an(s2)), d && d.d(), p[r2].d(), e2[90](null), f && f.d(n3), m3 && m3.d(n3), c = false, Dt(u);
  } };
}
var $x = 18;
function wx(e2, t3, n2) {
  var r2, a2, s2, d = vr("jsoneditor:TableMode"), { openAbsolutePopup: v, closeAbsolutePopup: f } = En("absolute-popup"), m3 = Vd(), g = uniqueId_default(), j = uniqueId_default(), x = "undefined" == typeof window;
  d("isSSR:", x);
  var y, w, C3, k2, S4, z3, { readOnly: q2 } = t3, { externalContent: M3 } = t3, { externalSelection: R3 } = t3, { mainMenuBar: P3 } = t3, { escapeControlCharacters: A } = t3, { escapeUnicodeCharacters: N3 } = t3, { flattenColumns: B3 } = t3, { parser: F3 } = t3, { parseMemoizeOne: U3 } = t3, { validator: L3 } = t3, { validationParser: D3 } = t3, { indentation: J3 } = t3, { onChange: V } = t3, { onChangeMode: H2 } = t3, { onSelect: W3 } = t3, { onRenderValue: Q2 } = t3, { onRenderMenu: Y2 } = t3, { onRenderContextMenu: K3 } = t3, { onFocus: Z3 } = t3, { onBlur: X2 } = t3, { onSortModal: G2 } = t3, { onTransformModal: ee2 } = t3, { onJSONEditorModal: te2 } = t3, ne2 = void 0;
  tv({ onMount: qn, onDestroy: Mn, getWindow: () => Io(w), hasFocus: () => pe2 && document.hasFocus() || To(w), onFocus: () => {
    fe2 = true, Z3 && Z3();
  }, onBlur: () => {
    fe2 = false, X2 && X2();
  } });
  var re2, oe2, ae2, ie4 = void 0, se2 = false, le2 = false;
  function ce2() {
    return (ce2 = o(function* (e3) {
      n2(13, $e2 = void 0), yield Ke2(e3);
    })).apply(this, arguments);
  }
  var ue2, de2 = 1e4, ve2 = [], pe2 = false, fe2 = false, me2 = false, he2 = {}, ge2 = 600, je2 = 0;
  function be2(e3) {
    n2(13, $e2 = e3);
  }
  function ye2(e3) {
    $e2 && void 0 !== e3 && (existsIn(e3, Js($e2)) && existsIn(e3, Ds($e2)) || (d("clearing selection: path does not exist anymore", $e2), n2(13, $e2 = void 0)));
  }
  var $e2, we2, Ce2 = void 0 !== S4 ? zi({ json: S4 }) : void 0, Re2 = false;
  var Pe2, Te2 = Wd({ onChange: (e3) => {
    n2(28, Ae2 = e3);
  } }), Ae2 = Te2.getState();
  function Ne2(e3) {
    if (void 0 !== e3.json || void 0 !== e3.text) {
      var t4 = void 0 !== S4 && void 0 !== e3.json;
      Te2.add({ undo: { patch: t4 ? [{ op: "replace", path: "", value: e3.json }] : void 0, json: e3.json, text: e3.text, documentState: e3.documentState, textIsRepaired: e3.textIsRepaired, selection: ks(e3.selection), sortedColumn: e3.sortedColumn }, redo: { patch: t4 ? [{ op: "replace", path: "", value: S4 }] : void 0, json: S4, text: z3, documentState: Ce2, textIsRepaired: Re2, selection: ks($e2), sortedColumn: we2 } });
    }
  }
  var Be2 = [], Fe2 = memoizeOne(Xd);
  function Ue2(e3, t4, r3, o2) {
    Qd(() => {
      var a3;
      try {
        a3 = Fe2(e3, t4, r3, o2);
      } catch (e4) {
        a3 = [{ path: [], message: "Failed to validate: " + e4.message, severity: po.warning }];
      }
      isEqual_default(a3, Be2) || (d("validationErrors changed:", a3), n2(14, Be2 = a3));
    }, (e4) => d("validationErrors updated in ".concat(e4, " ms")));
  }
  function Le2() {
    return d("validate"), ie4 ? { parseError: ie4, isRepairable: false } : (Ue2(S4, L3, F3, D3), isEmpty_default(Be2) ? void 0 : { validationErrors: Be2 });
  }
  function De3(e3, t4) {
    if (d("patch", e3, t4), void 0 === S4) throw new Error("Cannot apply patch: no JSON");
    var r3 = S4, o2 = { json: void 0, text: z3, documentState: Ce2, selection: ks($e2), sortedColumn: we2, textIsRepaired: Re2 }, a3 = ll(S4, e3), s3 = Ui(S4, Ce2, e3), l = Ym(we2, e3, ve2), c = "function" == typeof t4 ? t4(s3.json, s3.documentState, $e2) : void 0;
    return n2(8, S4 = void 0 !== (null == c ? void 0 : c.json) ? c.json : s3.json), n2(12, Ce2 = void 0 !== (null == c ? void 0 : c.state) ? c.state : s3.documentState), n2(13, $e2 = void 0 !== (null == c ? void 0 : c.selection) ? c.selection : $e2), n2(26, we2 = void 0 !== (null == c ? void 0 : c.sortedColumn) ? c.sortedColumn : l), n2(19, z3 = void 0), n2(27, Re2 = false), n2(21, re2 = void 0), n2(20, ie4 = void 0), Te2.add({ undo: i({ patch: a3 }, o2), redo: { patch: e3, json: void 0, text: void 0, documentState: Ce2, selection: ks($e2), sortedColumn: we2, textIsRepaired: Re2 } }), { json: S4, previousJson: r3, undo: a3, redo: e3 };
  }
  function Ve2(e3, t4) {
    d("handlePatch", e3, t4);
    var n3 = { json: S4, text: z3 }, r3 = De3(e3, t4);
    return He2(n3, r3), r3;
  }
  function He2(e3, t4) {
    if ((void 0 !== e3.json || void 0 !== (null == e3 ? void 0 : e3.text)) && V) {
      if (void 0 !== z3) V({ text: z3, json: void 0 }, e3, { contentErrors: Le2(), patchResult: t4 });
      else if (void 0 !== S4) {
        V({ text: void 0, json: S4 }, e3, { contentErrors: Le2(), patchResult: t4 });
      }
    }
  }
  function _e2(e3) {
    d("pasted json as text", e3), n2(21, re2 = e3);
  }
  function We2(e3) {
    var t4 = parseInt(e3[0], 10), n3 = [String(t4 + 1), ...e3.slice(1)];
    return existsIn(S4, n3) ? zs(n3) : zs(e3);
  }
  function Qe2() {
    d("focus"), k2 && (k2.focus(), k2.select());
  }
  function Ye2() {
    $e2 || n2(13, $e2 = function() {
      if (isJSONArray(S4) && !isEmpty_default(S4) && !isEmpty_default(ve2)) return zs(["0", ...ve2[0]]);
    }());
  }
  function Ke2(e3) {
    var t4 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], n3 = se2 ? ai : 0, r3 = Jm(e3, ve2, he2, $x), a3 = r3 - je2 + n3 + $x, i2 = Ge2(e3);
    if (d("scrollTo", { path: e3, top: r3, scrollTop: je2, elem: i2 }), !C3) return Promise.resolve();
    var s3 = C3.getBoundingClientRect();
    if (i2 && !t4) {
      var l = i2.getBoundingClientRect();
      if (l.bottom > s3.top && l.top < s3.bottom) return Promise.resolve();
    }
    var c = -Math.max(n3 + 36, s3.height / 4);
    return new Promise(i2 ? (t5) => {
      m3(i2, { container: C3, offset: c, duration: 300, callback: () => {
        Ze2(e3), t5();
      } });
    } : (t5) => {
      var n4;
      m3(a3, { container: C3, offset: c, duration: 300, callback: (n4 = o(function* () {
        yield Ln(), Ze2(e3), t5();
      }), function() {
        return n4.apply(this, arguments);
      }) });
    });
  }
  function Ze2(e3) {
    var t4 = Ge2(e3);
    if (t4 && C3) {
      var r3 = C3.getBoundingClientRect(), o2 = t4.getBoundingClientRect();
      if (o2.right > r3.right) {
        var a3 = o2.right - r3.right;
        n2(16, C3.scrollLeft += a3, C3);
      }
      if (o2.left < r3.left) {
        var i2 = r3.left - o2.left;
        n2(16, C3.scrollLeft -= i2, C3);
      }
    }
  }
  function Xe2(e3) {
    !function(e4) {
      if (C3) {
        var { rowIndex: t4 } = Vm(e4, ve2), r3 = Jm(e4, ve2, he2, $x), o2 = r3 + (he2[t4] || $x), a3 = C3.getBoundingClientRect(), i2 = je2, s3 = je2 + a3.height - 18;
        if (o2 > s3) {
          var l = o2 - s3;
          n2(16, C3.scrollTop += l, C3);
        }
        if (r3 < i2) {
          var c = i2 - r3;
          n2(16, C3.scrollTop -= c, C3);
        }
      }
    }(e3), Ze2(e3);
  }
  function Ge2(e3) {
    var t4, n3, r3 = ve2.find((t5) => Cs(e3.slice(1), t5)), o2 = r3 ? e3.slice(0, 1).concat(r3) : e3;
    return null !== (t4 = null === (n3 = C3) || void 0 === n3 ? void 0 : n3.querySelector('td[data-path="'.concat(Bo(o2), '"]'))) && void 0 !== t4 ? t4 : void 0;
  }
  function et2(e3) {
    var t4, { anchor: n3, left: r3, top: o2, width: a3, height: i2, offsetTop: s3, offsetLeft: l, showTip: c } = e3, d2 = function(e4) {
      var { json: t5, documentState: n4, selection: r4, readOnly: o3, onEditValue: a4, onEditRow: i3, onToggleEnforceString: s4, onCut: l2, onCopy: c2, onPaste: d3, onRemove: v2, onDuplicateRow: p2, onInsertBeforeRow: f2, onInsertAfterRow: m5, onRemoveRow: h3 } = e4, g2 = void 0 !== t5, j2 = !!r4, x2 = void 0 !== t5 && r4 ? getIn(t5, Ds(r4)) : void 0, b2 = g2 && (cs(r4) || ss(r4) || ls(r4)), y2 = !o3 && g2 && void 0 !== r4 && $s(r4), $2 = y2 && !yr(x2), w2 = !o3 && b2, C4 = void 0 !== r4 && Yi(t5, n4, Ds(r4));
      return [{ type: "separator" }, { type: "row", items: [{ type: "column", items: [{ type: "label", text: "Table cell:" }, { type: "dropdown-button", main: { type: "button", onClick: () => a4(), icon: faPen, text: "Edit", title: "Edit the value (Double-click on the value)", disabled: !y2 }, width: "11em", items: [{ type: "button", icon: faPen, text: "Edit", title: "Edit the value (Double-click on the value)", onClick: () => a4(), disabled: !y2 }, { type: "button", icon: C4 ? faCheckSquare2 : faSquare2, text: "Enforce string", title: "Enforce keeping the value as string when it contains a numeric value", onClick: () => s4(), disabled: !$2 }] }, { type: "dropdown-button", main: { type: "button", onClick: () => l2(true), icon: faCut, text: "Cut", title: "Cut selected contents, formatted with indentation (Ctrl+X)", disabled: !w2 }, width: "10em", items: [{ type: "button", icon: faCut, text: "Cut formatted", title: "Cut selected contents, formatted with indentation (Ctrl+X)", onClick: () => l2(true), disabled: o3 || !b2 }, { type: "button", icon: faCut, text: "Cut compacted", title: "Cut selected contents, without indentation (Ctrl+Shift+X)", onClick: () => l2(false), disabled: o3 || !b2 }] }, { type: "dropdown-button", main: { type: "button", onClick: () => c2(true), icon: faCopy, text: "Copy", title: "Copy selected contents, formatted with indentation (Ctrl+C)", disabled: !b2 }, width: "12em", items: [{ type: "button", icon: faCopy, text: "Copy formatted", title: "Copy selected contents, formatted with indentation (Ctrl+C)", onClick: () => c2(false), disabled: !b2 }, { type: "button", icon: faCopy, text: "Copy compacted", title: "Copy selected contents, without indentation (Ctrl+Shift+C)", onClick: () => c2(false), disabled: !b2 }] }, { type: "button", onClick: () => d3(), icon: faPaste, text: "Paste", title: "Paste clipboard contents (Ctrl+V)", disabled: o3 || !j2 }, { type: "button", onClick: () => v2(), icon: faTrashCan, text: "Remove", title: "Remove selected contents (Delete)", disabled: o3 || !b2 }] }, { type: "column", items: [{ type: "label", text: "Table row:" }, { type: "button", onClick: () => i3(), icon: faPen, text: "Edit row", title: "Edit the current row", disabled: o3 || !j2 || !g2 }, { type: "button", onClick: () => p2(), icon: faClone, text: "Duplicate row", title: "Duplicate the current row", disabled: o3 || !j2 || !g2 }, { type: "button", onClick: () => f2(), icon: faPlus, text: "Insert before", title: "Insert a row before the current row", disabled: o3 || !j2 || !g2 }, { type: "button", onClick: () => m5(), icon: faPlus, text: "Insert after", title: "Insert a row after the current row", disabled: o3 || !j2 || !g2 }, { type: "button", onClick: () => h3(), icon: faTrashCan, text: "Remove row", title: "Remove current row", disabled: o3 || !j2 || !g2 }] }] }];
    }({ json: S4, documentState: Ce2, selection: $e2, readOnly: q2, onEditValue: nt2, onEditRow: rt2, onToggleEnforceString: ot2, onCut: st2, onCopy: ct2, onPaste: it2, onRemove: dt, onDuplicateRow: vt2, onInsertBeforeRow: pt, onInsertAfterRow: ft2, onRemoveRow: mt2 }), p = null !== (t4 = K3(d2)) && void 0 !== t4 ? t4 : d2;
    if (false !== p) {
      var m4 = { left: r3, top: o2, offsetTop: s3, offsetLeft: l, width: a3, height: i2, anchor: n3, closeOnOuterClick: true, onClose: () => {
        pe2 = false, Qe2();
      } };
      pe2 = true;
      var h2 = v(lg, { tip: c ? "Tip: you can open this context menu via right-click or with Ctrl+Q" : void 0, items: p, onRequestClose() {
        f(h2), Qe2();
      } }, m4);
    }
  }
  function tt2(e3) {
    if (!Is($e2)) if (e3 && (e3.stopPropagation(), e3.preventDefault()), e3 && "contextmenu" === e3.type && e3.target !== k2) et2({ left: e3.clientX, top: e3.clientY, width: oi, height: ri, showTip: false });
    else {
      var t4, n3 = null === (t4 = C3) || void 0 === t4 ? void 0 : t4.querySelector(".jse-table-cell.jse-selected-value");
      if (n3) et2({ anchor: n3, offsetTop: 2, width: oi, height: ri, showTip: false });
      else {
        var r3, o2 = null === (r3 = C3) || void 0 === r3 ? void 0 : r3.getBoundingClientRect();
        o2 && et2({ top: o2.top + 2, left: o2.left + 2, width: oi, height: ri, showTip: false });
      }
    }
  }
  function nt2() {
    if (!q2 && $e2) {
      var e3 = Ds($e2);
      yr(getIn(S4, e3)) ? bt2(e3) : n2(13, $e2 = zs(e3));
    }
  }
  function rt2() {
    !q2 && $e2 && bt2(Ds($e2).slice(0, 1));
  }
  function ot2() {
    if (!q2 && ls($e2)) {
      var e3 = $e2.path, t4 = compileJSONPointer(e3), n3 = getIn(S4, e3), r3 = !Yi(S4, Ce2, e3), o2 = r3 ? String(n3) : Mr(String(n3), F3);
      d("handleToggleEnforceString", { enforceString: r3, value: n3, updatedValue: o2 }), Ve2([{ op: "replace", path: t4, value: o2 }], (t5, n4) => ({ state: Vi(S4, n4, e3, { type: "value", enforceString: r3 }) }));
    }
  }
  function at2() {
    return (at2 = o(function* () {
      if (d("apply pasted json", re2), re2) {
        var { onPasteAsJson: e3 } = re2;
        e3(), setTimeout(Qe2);
      }
    })).apply(this, arguments);
  }
  function it2() {
    n2(25, me2 = true);
  }
  function st2(e3) {
    return lt2.apply(this, arguments);
  }
  function lt2() {
    return (lt2 = o(function* (e3) {
      yield Zm({ json: S4, selection: $e2, indentation: e3 ? J3 : void 0, readOnly: q2, parser: F3, onPatch: Ve2 });
    })).apply(this, arguments);
  }
  function ct2() {
    return ut2.apply(this, arguments);
  }
  function ut2() {
    return ut2 = o(function* () {
      var e3 = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
      void 0 !== S4 && (yield Gm({ json: S4, selection: $e2, indentation: e3 ? J3 : void 0, parser: F3 }));
    }), ut2.apply(this, arguments);
  }
  function dt() {
    nh({ json: S4, text: z3, selection: $e2, keepSelection: true, readOnly: q2, onChange: V, onPatch: Ve2 });
  }
  function vt2() {
    rh({ json: S4, selection: $e2, columns: ve2, readOnly: q2, onPatch: Ve2 });
  }
  function pt() {
    oh({ json: S4, selection: $e2, columns: ve2, readOnly: q2, onPatch: Ve2 });
  }
  function ft2() {
    ah({ json: S4, selection: $e2, columns: ve2, readOnly: q2, onPatch: Ve2 });
  }
  function mt2() {
    ih({ json: S4, selection: $e2, columns: ve2, readOnly: q2, onPatch: Ve2 });
  }
  function ht2() {
    return (ht2 = o(function* (e3) {
      yield lh({ char: e3, selectInside: false, json: S4, selection: $e2, readOnly: q2, parser: F3, onPatch: Ve2, onReplaceJson: gt2, onSelect: be2 });
    })).apply(this, arguments);
  }
  function gt2(e3, t4) {
    var r3 = { json: S4, text: z3 }, o2 = { json: S4, documentState: Ce2, selection: $e2, sortedColumn: we2, text: z3, textIsRepaired: Re2 }, a3 = Pi(e3, Ce2), i2 = "function" == typeof t4 ? t4(e3, a3, $e2) : void 0;
    n2(8, S4 = void 0 !== (null == i2 ? void 0 : i2.json) ? i2.json : e3), n2(12, Ce2 = void 0 !== (null == i2 ? void 0 : i2.state) ? i2.state : a3), n2(13, $e2 = void 0 !== (null == i2 ? void 0 : i2.selection) ? i2.selection : $e2), n2(26, we2 = void 0), n2(19, z3 = void 0), n2(27, Re2 = false), n2(20, ie4 = void 0), ye2(S4), Ne2(o2);
    He2(r3, void 0);
  }
  function jt2(e3, t4) {
    d("handleChangeText");
    var r3 = { json: S4, text: z3 }, o2 = { json: S4, documentState: Ce2, selection: $e2, sortedColumn: we2, text: z3, textIsRepaired: Re2 };
    try {
      n2(8, S4 = U3(e3)), n2(12, Ce2 = Pi(S4, Ce2)), n2(19, z3 = void 0), n2(27, Re2 = false), n2(20, ie4 = void 0);
    } catch (t5) {
      try {
        n2(8, S4 = U3(jsonrepair(e3))), n2(12, Ce2 = Pi(S4, Ce2)), n2(19, z3 = e3), n2(27, Re2 = true), n2(20, ie4 = void 0);
      } catch (r4) {
        n2(8, S4 = void 0), n2(12, Ce2 = void 0), n2(19, z3 = e3), n2(27, Re2 = false), n2(20, ie4 = "" !== z3 ? Qr(z3, t5.message || String(t5)) : void 0);
      }
    }
    if ("function" == typeof t4) {
      var a3 = t4(S4, Ce2, $e2);
      n2(8, S4 = void 0 !== (null == a3 ? void 0 : a3.json) ? a3.json : S4), n2(12, Ce2 = void 0 !== (null == a3 ? void 0 : a3.state) ? a3.state : Ce2), n2(13, $e2 = void 0 !== (null == a3 ? void 0 : a3.selection) ? a3.selection : $e2);
    }
    ye2(S4), Ne2(o2);
    He2(r3, void 0);
  }
  function xt2(e3) {
    if (void 0 !== S4) {
      var { id: t4, onTransform: n3, onClose: r3 } = e3, o2 = e3.rootPath || [];
      pe2 = true, ee2({ id: t4 || j, json: S4, rootPath: o2 || [], onTransform: (e4) => {
        n3 ? n3({ operations: e4, json: S4, transformedJson: immutableJSONPatch(S4, e4) }) : (d("onTransform", o2, e4), Ve2(e4));
      }, onClose: () => {
        pe2 = false, setTimeout(Qe2), r3 && r3();
      } });
    }
  }
  function bt2(e3) {
    d("openJSONEditorModal", { path: e3 }), pe2 = true, te2({ content: { json: getIn(S4, e3) }, path: e3, onPatch: Ve2, onClose: () => {
      pe2 = false, setTimeout(Qe2);
    } });
  }
  function yt2(e3, t4) {
    n2(18, ne2 = { text: e3, onParse: (e4) => Hr(e4, (e5) => Jr(e5, F3)), onRepair: _r, onApply: t4, onClose: Qe2 });
  }
  function $t2(e3) {
    d("openFind", { findAndReplace: e3 }), n2(9, se2 = false), n2(23, le2 = false), Ln().then(() => {
      n2(9, se2 = true), n2(23, le2 = e3);
    });
  }
  function wt2() {
    if (!q2 && Te2.getState().canUndo) {
      var e3 = Te2.undo();
      if (e3) {
        var t4 = { json: S4, text: z3 };
        n2(8, S4 = e3.undo.patch ? immutableJSONPatch(S4, e3.undo.patch) : e3.undo.json), n2(12, Ce2 = e3.undo.documentState), n2(13, $e2 = e3.undo.selection), n2(26, we2 = e3.undo.sortedColumn), n2(19, z3 = e3.undo.text), n2(27, Re2 = e3.undo.textIsRepaired), n2(20, ie4 = void 0), d("undo", { item: e3, json: S4 }), He2(t4, e3.undo.patch && e3.redo.patch ? { json: S4, previousJson: t4.json, redo: e3.undo.patch, undo: e3.redo.patch } : void 0), Qe2(), $e2 && Ke2(Ds($e2), false);
      }
    }
  }
  function Ct2() {
    if (!q2 && Te2.getState().canRedo) {
      var e3 = Te2.redo();
      if (e3) {
        var t4 = { json: S4, text: z3 };
        n2(8, S4 = e3.redo.patch ? immutableJSONPatch(S4, e3.redo.patch) : e3.redo.json), n2(12, Ce2 = e3.redo.documentState), n2(13, $e2 = e3.redo.selection), n2(26, we2 = e3.redo.sortedColumn), n2(19, z3 = e3.redo.text), n2(27, Re2 = e3.redo.textIsRepaired), n2(20, ie4 = void 0), d("redo", { item: e3, json: S4 }), He2(t4, e3.undo.patch && e3.redo.patch ? { json: S4, previousJson: t4.json, redo: e3.redo.patch, undo: e3.undo.patch } : void 0), Qe2(), $e2 && Ke2(Ds($e2), false);
      }
    }
  }
  function kt2(e3, t4) {
    n2(81, he2[t4] = e3.getBoundingClientRect().height, he2);
  }
  return e2.$$set = (e3) => {
    "readOnly" in e3 && n2(0, q2 = e3.readOnly), "externalContent" in e3 && n2(58, M3 = e3.externalContent), "externalSelection" in e3 && n2(59, R3 = e3.externalSelection), "mainMenuBar" in e3 && n2(1, P3 = e3.mainMenuBar), "escapeControlCharacters" in e3 && n2(60, A = e3.escapeControlCharacters), "escapeUnicodeCharacters" in e3 && n2(61, N3 = e3.escapeUnicodeCharacters), "flattenColumns" in e3 && n2(62, B3 = e3.flattenColumns), "parser" in e3 && n2(2, F3 = e3.parser), "parseMemoizeOne" in e3 && n2(63, U3 = e3.parseMemoizeOne), "validator" in e3 && n2(64, L3 = e3.validator), "validationParser" in e3 && n2(65, D3 = e3.validationParser), "indentation" in e3 && n2(3, J3 = e3.indentation), "onChange" in e3 && n2(66, V = e3.onChange), "onChangeMode" in e3 && n2(4, H2 = e3.onChangeMode), "onSelect" in e3 && n2(67, W3 = e3.onSelect), "onRenderValue" in e3 && n2(68, Q2 = e3.onRenderValue), "onRenderMenu" in e3 && n2(5, Y2 = e3.onRenderMenu), "onRenderContextMenu" in e3 && n2(69, K3 = e3.onRenderContextMenu), "onFocus" in e3 && n2(70, Z3 = e3.onFocus), "onBlur" in e3 && n2(71, X2 = e3.onBlur), "onSortModal" in e3 && n2(72, G2 = e3.onSortModal), "onTransformModal" in e3 && n2(73, ee2 = e3.onTransformModal), "onJSONEditorModal" in e3 && n2(74, te2 = e3.onJSONEditorModal);
  }, e2.$$.update = () => {
    var t4;
    1610612736 & e2.$$.dirty[1] && n2(80, y = jo({ escapeControlCharacters: A, escapeUnicodeCharacters: N3 })), 512 & e2.$$.dirty[0] && function(e3) {
      if (C3) {
        var t5 = e3 ? ai : -100;
        C3.scrollTo({ top: n2(16, C3.scrollTop += t5, C3), left: C3.scrollLeft });
      }
    }(se2), 134217728 & e2.$$.dirty[1] && function(e3) {
      var t5 = S4, r3 = Zr(e3) ? e3.text !== z3 : !isEqual_default(t5, e3.json);
      if (d("update external content", { isChanged: r3 }), r3) {
        var o2 = { json: S4, documentState: Ce2, selection: $e2, sortedColumn: we2, text: z3, textIsRepaired: Re2 };
        if (Zr(e3)) try {
          n2(8, S4 = U3(e3.text)), n2(12, Ce2 = Pi(S4, Ce2)), n2(19, z3 = e3.text), n2(27, Re2 = false), n2(20, ie4 = void 0);
        } catch (t6) {
          try {
            n2(8, S4 = U3(jsonrepair(e3.text))), n2(12, Ce2 = Pi(S4, Ce2)), n2(19, z3 = e3.text), n2(27, Re2 = true), n2(20, ie4 = void 0);
          } catch (r4) {
            n2(8, S4 = void 0), n2(12, Ce2 = void 0), n2(19, z3 = e3.text), n2(27, Re2 = false), n2(20, ie4 = "" !== z3 ? Qr(z3, t6.message || String(t6)) : void 0);
          }
        }
        else n2(8, S4 = e3.json), n2(12, Ce2 = Pi(S4, Ce2)), n2(19, z3 = void 0), n2(27, Re2 = false), n2(20, ie4 = void 0);
        ye2(S4), n2(26, we2 = void 0), Ne2(o2);
      }
    }(M3), 268435456 & e2.$$.dirty[1] && function(e3) {
      isEqual_default($e2, e3) || (d("applyExternalSelection", { selection: $e2, externalSelection: e3 }), ds(e3) && n2(13, $e2 = e3));
    }(R3), 3328 & e2.$$.dirty[0] | 1 & e2.$$.dirty[2] && n2(11, ve2 = isJSONArray(S4) ? function(e3, t5) {
      var n3 = new Set(t5.map(compileJSONPointer)), r3 = new Set(e3.map(compileJSONPointer));
      for (var o2 of n3) r3.has(o2) || n3.delete(o2);
      for (var a3 of r3) n3.has(a3) || n3.add(a3);
      return [...n3].map(parseJSONPointer);
    }(Fm(S4, B3, de2), ve2) : []), 2304 & e2.$$.dirty[0] && n2(24, ue2 = !(!S4 || isEmpty_default(ve2))), 1280 & e2.$$.dirty[0] && n2(32, r2 = Array.isArray(S4) && S4.length > de2), 768 & e2.$$.dirty[0] | 3670016 & e2.$$.dirty[2] && n2(31, a2 = Dm(je2, ge2, S4, he2, $x, se2 ? ai : 0)), 256 & e2.$$.dirty[0] && C3 && C3.scrollTo({ top: C3.scrollTop, left: C3.scrollLeft }), 8192 & e2.$$.dirty[0] && (isEqual_default(t4 = $e2, R3) || (d("onSelect", t4), W3(t4))), 4357 & e2.$$.dirty[0] | 262208 & e2.$$.dirty[2] && n2(29, Pe2 = { mode: co.table, readOnly: q2, parser: F3, normalization: y, getJson: () => S4, getDocumentState: () => Ce2, findElement: Ge2, findNextInside: We2, focus: Qe2, onPatch: (e3, t5) => Ve2(function(e4, t6) {
      return e4.flatMap((e5) => {
        if (isJSONPatchReplace(e5)) {
          var n3 = parseJSONPointer(e5.path);
          if (n3.length > 0) {
            for (var r3 = [e5], o2 = initial_default(n3); o2.length > 0 && !existsIn(t6, o2); ) r3.unshift({ op: "add", path: compileJSONPointer(o2), value: {} }), o2 = initial_default(o2);
            return r3;
          }
        }
        return e5;
      });
    }(e3, S4), t5), onSelect: be2, onFind: $t2, onPasteJson: _e2, onRenderValue: Q2 }), 260 & e2.$$.dirty[0] | 12 & e2.$$.dirty[2] && Ue2(S4, L3, F3, D3), 18432 & e2.$$.dirty[0] && n2(30, s2 = _m(Be2, ve2));
  }, [q2, P3, F3, J3, H2, Y2, Qe2, function() {
    if (Re2 && void 0 !== S4) {
      var e3 = { json: S4, text: z3 }, t4 = { json: S4, documentState: Ce2, selection: $e2, sortedColumn: we2, text: z3, textIsRepaired: Re2 };
      n2(19, z3 = void 0), n2(27, Re2 = false), ye2(S4), Ne2(t4);
      He2(e3, void 0);
    }
    return { json: S4, text: z3 };
  }, S4, se2, de2, ve2, Ce2, $e2, Be2, w, C3, k2, ne2, z3, ie4, re2, ae2, le2, ue2, me2, we2, Re2, Ae2, Pe2, s2, a2, r2, x, function(e3) {
    n2(22, ae2 = (oe2 = e3) ? bl(S4, oe2.items) : void 0);
  }, function(e3) {
    return ce2.apply(this, arguments);
  }, function() {
    n2(9, se2 = false), n2(23, le2 = false), Qe2();
  }, function(e3) {
    if (!q2) {
      d("onSortByHeader", e3);
      var t4 = e3.sortDirection === mo.desc ? -1 : 1;
      Ve2(Zf(S4, [], e3.path, t4), (t5, n3) => ({ state: n3, sortedColumn: e3 }));
    }
  }, Ve2, function(e3) {
    var t4 = !Eo(e3.target, (e4) => e4 === w);
    t4 && Is($e2) && (d("click outside the editor, exit edit mode"), n2(13, $e2 = ks($e2)), fe2 && k2 && (k2.focus(), k2.blur()), d("blur (outside editor)"), k2 && k2.blur());
  }, function(e3) {
    n2(83, je2 = e3.target.scrollTop);
  }, function(e3) {
    if (1 === e3.buttons || 2 === e3.buttons) {
      var t4 = e3.target;
      t4.isContentEditable || Qe2();
      var r3 = Fo(t4);
      if (r3) {
        if (Is($e2) && Us(S4, $e2, r3)) return;
        n2(13, $e2 = zs(r3)), e3.preventDefault();
      }
    }
  }, et2, tt2, function(e3) {
    et2({ anchor: Ao(e3.target, "BUTTON"), offsetTop: 0, width: oi, height: ri, showTip: true });
  }, function() {
    return at2.apply(this, arguments);
  }, function() {
    d("clear pasted json"), n2(21, re2 = void 0), Qe2();
  }, function() {
    H2(co.text);
  }, function(e3) {
    var t4 = Do(e3);
    if (d("keydown", { combo: t4, key: e3.key }), "Ctrl+X" === t4 && (e3.preventDefault(), st2(true)), "Ctrl+Shift+X" === t4 && (e3.preventDefault(), st2(false)), "Ctrl+C" === t4 && (e3.preventDefault(), ct2(true)), "Ctrl+Shift+C" === t4 && (e3.preventDefault(), ct2(false)), "Ctrl+D" === t4 && e3.preventDefault(), "Delete" !== t4 && "Backspace" !== t4 || (e3.preventDefault(), dt()), "Insert" === t4 && e3.preventDefault(), "Ctrl+A" === t4 && e3.preventDefault(), "Ctrl+Q" === t4 && tt2(e3), "ArrowLeft" === t4 && (e3.preventDefault(), Ye2(), $e2)) {
      var r3 = function(e4, t5) {
        var { rowIndex: n3, columnIndex: r4 } = Vm(Ds(t5), e4);
        return r4 > 0 ? zs(Hm({ rowIndex: n3, columnIndex: r4 - 1 }, e4)) : t5;
      }(ve2, $e2);
      n2(13, $e2 = r3), Xe2(Ds(r3));
    }
    if ("ArrowRight" === t4 && (e3.preventDefault(), Ye2(), $e2)) {
      var o2 = function(e4, t5) {
        var { rowIndex: n3, columnIndex: r4 } = Vm(Ds(t5), e4);
        return r4 < e4.length - 1 ? zs(Hm({ rowIndex: n3, columnIndex: r4 + 1 }, e4)) : t5;
      }(ve2, $e2);
      n2(13, $e2 = o2), Xe2(Ds(o2));
    }
    if ("ArrowUp" === t4 && (e3.preventDefault(), Ye2(), $e2)) {
      var a3 = function(e4, t5) {
        var { rowIndex: n3, columnIndex: r4 } = Vm(Ds(t5), e4);
        return n3 > 0 ? zs(Hm({ rowIndex: n3 - 1, columnIndex: r4 }, e4)) : t5;
      }(ve2, $e2);
      n2(13, $e2 = a3), Xe2(Ds(a3));
    }
    if ("ArrowDown" === t4 && (e3.preventDefault(), Ye2(), $e2)) {
      var s3 = function(e4, t5, n3) {
        var { rowIndex: r4, columnIndex: o3 } = Vm(Ds(n3), t5);
        return r4 < e4.length - 1 ? zs(Hm({ rowIndex: r4 + 1, columnIndex: o3 }, t5)) : n3;
      }(S4, ve2, $e2);
      n2(13, $e2 = s3), Xe2(Ds(s3));
    }
    if ("Enter" === t4 && $e2 && ls($e2)) {
      e3.preventDefault();
      var l = $e2.path;
      yr(getIn(S4, l)) ? bt2(l) : q2 || n2(13, $e2 = i(i({}, $e2), {}, { edit: true }));
    }
    if (1 === t4.replace(/^Shift\+/, "").length && $e2) return e3.preventDefault(), void function(e4) {
      ht2.apply(this, arguments);
    }(e3.key);
    if ("Ctrl+Enter" === t4 && ls($e2)) {
      var c = getIn(S4, $e2.path);
      qr(c) && window.open(String(c), "_blank");
    }
    "Escape" === t4 && $e2 && (e3.preventDefault(), n2(13, $e2 = void 0)), "Ctrl+F" === t4 && (e3.preventDefault(), $t2(false)), "Ctrl+H" === t4 && (e3.preventDefault(), $t2(true)), "Ctrl+Z" === t4 && (e3.preventDefault(), wt2()), "Ctrl+Shift+Z" === t4 && (e3.preventDefault(), Ct2());
  }, function(e3) {
    var t4;
    e3.preventDefault();
    var n3 = null === (t4 = e3.clipboardData) || void 0 === t4 ? void 0 : t4.getData("text/plain");
    void 0 !== n3 && th({ clipboardText: n3, json: S4, selection: $e2, readOnly: q2, parser: F3, onPatch: Ve2, onChangeText: jt2, openRepairModal: yt2 });
  }, function(e3) {
    d("select validation error", e3), n2(13, $e2 = zs(e3.path)), Ke2(e3.path);
  }, bt2, function() {
    !function(e3) {
      q2 || void 0 === S4 || (pe2 = true, G2({ id: g, json: S4, rootPath: e3, onSort: (t4) => {
        var { operations: n3, itemPath: r3, direction: o2 } = t4;
        d("onSort", n3, e3, r3, o2), Ve2(n3, (e4, t5) => ({ state: t5, sortedColumn: { path: r3, sortDirection: -1 === o2 ? mo.desc : mo.asc } }));
      }, onClose: () => {
        pe2 = false, setTimeout(Qe2);
      } }));
    }([]);
  }, function() {
    xt2({ rootPath: [] });
  }, wt2, Ct2, function(e3) {
    n2(82, ge2 = e3.getBoundingClientRect().height);
  }, kt2, M3, R3, A, N3, B3, U3, L3, D3, V, W3, Q2, K3, Z3, X2, G2, ee2, te2, Le2, De3, Ke2, Ge2, xt2, y, he2, ge2, je2, function(e3) {
    n2(9, se2 = e3);
  }, function(e3) {
    Tn[e3 ? "unshift" : "push"](() => {
      n2(17, k2 = e3);
    });
  }, () => n2(10, de2 = 1 / 0), (e3, t4) => kt2(t4, e3), function(e3) {
    Tn[e3 ? "unshift" : "push"](() => {
      n2(16, C3 = e3);
    });
  }, () => {
    Qe2();
  }, function(e3) {
    Tn[e3 ? "unshift" : "push"](() => {
      n2(15, w = e3);
    });
  }, () => n2(25, me2 = false), () => {
    var e3;
    null === (e3 = ne2) || void 0 === e3 || e3.onClose(), n2(18, ne2 = void 0);
  }];
}
var Cx = class extends dr {
  constructor(e2) {
    super(), ur(this, e2, wx, yx, Ht, { readOnly: 0, externalContent: 58, externalSelection: 59, mainMenuBar: 1, escapeControlCharacters: 60, escapeUnicodeCharacters: 61, flattenColumns: 62, parser: 2, parseMemoizeOne: 63, validator: 64, validationParser: 65, indentation: 3, onChange: 66, onChangeMode: 4, onSelect: 67, onRenderValue: 68, onRenderMenu: 5, onRenderContextMenu: 69, onFocus: 70, onBlur: 71, onSortModal: 72, onTransformModal: 73, onJSONEditorModal: 74, validate: 75, patch: 76, focus: 6, acceptAutoRepair: 7, scrollTo: 77, findElement: 78, openTransformModal: 79 }, Wj, [-1, -1, -1, -1, -1, -1]);
  }
  get validate() {
    return this.$$.ctx[75];
  }
  get patch() {
    return this.$$.ctx[76];
  }
  get focus() {
    return this.$$.ctx[6];
  }
  get acceptAutoRepair() {
    return this.$$.ctx[7];
  }
  get scrollTo() {
    return this.$$.ctx[77];
  }
  get findElement() {
    return this.$$.ctx[78];
  }
  get openTransformModal() {
    return this.$$.ctx[79];
  }
};
function kx(e2) {
  var t3, n2, r2 = { externalContent: e2[0], externalSelection: e2[1], readOnly: e2[2], indentation: e2[3], mainMenuBar: e2[6], navigationBar: e2[7], escapeControlCharacters: e2[10], escapeUnicodeCharacters: e2[11], parser: e2[13], parseMemoizeOne: e2[14], validator: e2[15], validationParser: e2[16], pathParser: e2[17], onError: e2[23], onChange: e2[18], onChangeMode: e2[19], onSelect: e2[20], onRenderValue: e2[21], onClassName: e2[22], onFocus: e2[24], onBlur: e2[25], onRenderMenu: e2[32], onRenderContextMenu: e2[33], onSortModal: e2[26], onTransformModal: e2[27], onJSONEditorModal: e2[28] };
  return t3 = new Sg({ props: r2 }), e2[50](t3), { c() {
    sr(t3.$$.fragment);
  }, m(e3, r3) {
    lr(t3, e3, r3), n2 = true;
  }, p(e3, n3) {
    var r3 = {};
    1 & n3[0] && (r3.externalContent = e3[0]), 2 & n3[0] && (r3.externalSelection = e3[1]), 4 & n3[0] && (r3.readOnly = e3[2]), 8 & n3[0] && (r3.indentation = e3[3]), 64 & n3[0] && (r3.mainMenuBar = e3[6]), 128 & n3[0] && (r3.navigationBar = e3[7]), 1024 & n3[0] && (r3.escapeControlCharacters = e3[10]), 2048 & n3[0] && (r3.escapeUnicodeCharacters = e3[11]), 8192 & n3[0] && (r3.parser = e3[13]), 16384 & n3[0] && (r3.parseMemoizeOne = e3[14]), 32768 & n3[0] && (r3.validator = e3[15]), 65536 & n3[0] && (r3.validationParser = e3[16]), 131072 & n3[0] && (r3.pathParser = e3[17]), 8388608 & n3[0] && (r3.onError = e3[23]), 262144 & n3[0] && (r3.onChange = e3[18]), 524288 & n3[0] && (r3.onChangeMode = e3[19]), 1048576 & n3[0] && (r3.onSelect = e3[20]), 2097152 & n3[0] && (r3.onRenderValue = e3[21]), 4194304 & n3[0] && (r3.onClassName = e3[22]), 16777216 & n3[0] && (r3.onFocus = e3[24]), 33554432 & n3[0] && (r3.onBlur = e3[25]), 2 & n3[1] && (r3.onRenderMenu = e3[32]), 4 & n3[1] && (r3.onRenderContextMenu = e3[33]), 67108864 & n3[0] && (r3.onSortModal = e3[26]), 134217728 & n3[0] && (r3.onTransformModal = e3[27]), 268435456 & n3[0] && (r3.onJSONEditorModal = e3[28]), t3.$set(r3);
  }, i(e3) {
    n2 || (Xn(t3.$$.fragment, e3), n2 = true);
  }, o(e3) {
    Gn(t3.$$.fragment, e3), n2 = false;
  }, d(n3) {
    e2[50](null), cr(t3, n3);
  } };
}
function Sx(e2) {
  var t3, n2, r2 = { externalContent: e2[0], externalSelection: e2[1], readOnly: e2[2], mainMenuBar: e2[6], escapeControlCharacters: e2[10], escapeUnicodeCharacters: e2[11], flattenColumns: e2[12], parser: e2[13], parseMemoizeOne: e2[14], validator: e2[15], validationParser: e2[16], indentation: e2[3], onChange: e2[18], onChangeMode: e2[19], onSelect: e2[20], onRenderValue: e2[21], onFocus: e2[24], onBlur: e2[25], onRenderMenu: e2[32], onRenderContextMenu: e2[33], onSortModal: e2[26], onTransformModal: e2[27], onJSONEditorModal: e2[28] };
  return t3 = new Cx({ props: r2 }), e2[49](t3), { c() {
    sr(t3.$$.fragment);
  }, m(e3, r3) {
    lr(t3, e3, r3), n2 = true;
  }, p(e3, n3) {
    var r3 = {};
    1 & n3[0] && (r3.externalContent = e3[0]), 2 & n3[0] && (r3.externalSelection = e3[1]), 4 & n3[0] && (r3.readOnly = e3[2]), 64 & n3[0] && (r3.mainMenuBar = e3[6]), 1024 & n3[0] && (r3.escapeControlCharacters = e3[10]), 2048 & n3[0] && (r3.escapeUnicodeCharacters = e3[11]), 4096 & n3[0] && (r3.flattenColumns = e3[12]), 8192 & n3[0] && (r3.parser = e3[13]), 16384 & n3[0] && (r3.parseMemoizeOne = e3[14]), 32768 & n3[0] && (r3.validator = e3[15]), 65536 & n3[0] && (r3.validationParser = e3[16]), 8 & n3[0] && (r3.indentation = e3[3]), 262144 & n3[0] && (r3.onChange = e3[18]), 524288 & n3[0] && (r3.onChangeMode = e3[19]), 1048576 & n3[0] && (r3.onSelect = e3[20]), 2097152 & n3[0] && (r3.onRenderValue = e3[21]), 16777216 & n3[0] && (r3.onFocus = e3[24]), 33554432 & n3[0] && (r3.onBlur = e3[25]), 2 & n3[1] && (r3.onRenderMenu = e3[32]), 4 & n3[1] && (r3.onRenderContextMenu = e3[33]), 67108864 & n3[0] && (r3.onSortModal = e3[26]), 134217728 & n3[0] && (r3.onTransformModal = e3[27]), 268435456 & n3[0] && (r3.onJSONEditorModal = e3[28]), t3.$set(r3);
  }, i(e3) {
    n2 || (Xn(t3.$$.fragment, e3), n2 = true);
  }, o(e3) {
    Gn(t3.$$.fragment, e3), n2 = false;
  }, d(n3) {
    e2[49](null), cr(t3, n3);
  } };
}
function Ox(e2) {
  var t3, n2, r2 = { externalContent: e2[0], externalSelection: e2[1], readOnly: e2[2], indentation: e2[3], tabSize: e2[4], mainMenuBar: e2[6], statusBar: e2[8], askToFormat: e2[9], escapeUnicodeCharacters: e2[11], parser: e2[13], validator: e2[15], validationParser: e2[16], onChange: e2[18], onSelect: e2[20], onChangeMode: e2[19], onError: e2[23], onFocus: e2[24], onBlur: e2[25], onRenderMenu: e2[32], onSortModal: e2[26], onTransformModal: e2[27] };
  return t3 = new jj({ props: r2 }), e2[48](t3), { c() {
    sr(t3.$$.fragment);
  }, m(e3, r3) {
    lr(t3, e3, r3), n2 = true;
  }, p(e3, n3) {
    var r3 = {};
    1 & n3[0] && (r3.externalContent = e3[0]), 2 & n3[0] && (r3.externalSelection = e3[1]), 4 & n3[0] && (r3.readOnly = e3[2]), 8 & n3[0] && (r3.indentation = e3[3]), 16 & n3[0] && (r3.tabSize = e3[4]), 64 & n3[0] && (r3.mainMenuBar = e3[6]), 256 & n3[0] && (r3.statusBar = e3[8]), 512 & n3[0] && (r3.askToFormat = e3[9]), 2048 & n3[0] && (r3.escapeUnicodeCharacters = e3[11]), 8192 & n3[0] && (r3.parser = e3[13]), 32768 & n3[0] && (r3.validator = e3[15]), 65536 & n3[0] && (r3.validationParser = e3[16]), 262144 & n3[0] && (r3.onChange = e3[18]), 1048576 & n3[0] && (r3.onSelect = e3[20]), 524288 & n3[0] && (r3.onChangeMode = e3[19]), 8388608 & n3[0] && (r3.onError = e3[23]), 16777216 & n3[0] && (r3.onFocus = e3[24]), 33554432 & n3[0] && (r3.onBlur = e3[25]), 2 & n3[1] && (r3.onRenderMenu = e3[32]), 67108864 & n3[0] && (r3.onSortModal = e3[26]), 134217728 & n3[0] && (r3.onTransformModal = e3[27]), t3.$set(r3);
  }, i(e3) {
    n2 || (Xn(t3.$$.fragment, e3), n2 = true);
  }, o(e3) {
    Gn(t3.$$.fragment, e3), n2 = false;
  }, d(n3) {
    e2[48](null), cr(t3, n3);
  } };
}
function zx(e2) {
  var t3, n2, r2, o2, a2, i2 = [Ox, Sx, kx], s2 = [];
  function l(e3, n3) {
    return 32 & n3[0] && (t3 = null), null == t3 && (t3 = !(e3[5] !== co.text && "code" !== String(e3[5]))), t3 ? 0 : e3[5] === co.table ? 1 : 2;
  }
  return n2 = l(e2, [-1, -1]), r2 = s2[n2] = i2[n2](e2), { c() {
    r2.c(), o2 = vn();
  }, m(e3, t4) {
    s2[n2].m(e3, t4), on(e3, o2, t4), a2 = true;
  }, p(e3, t4) {
    var a3 = n2;
    (n2 = l(e3, t4)) === a3 ? s2[n2].p(e3, t4) : (Kn(), Gn(s2[a3], 1, 1, () => {
      s2[a3] = null;
    }), Zn(), (r2 = s2[n2]) ? r2.p(e3, t4) : (r2 = s2[n2] = i2[n2](e3)).c(), Xn(r2, 1), r2.m(o2.parentNode, o2));
  }, i(e3) {
    a2 || (Xn(r2), a2 = true);
  }, o(e3) {
    Gn(r2), a2 = false;
  }, d(e3) {
    e3 && an(o2), s2[n2].d(e3);
  } };
}
function qx(e2, t3, n2) {
  var r2, a2, i2, s2, l, c, { content: u } = t3, { selection: d } = t3, { readOnly: v } = t3, { indentation: p } = t3, { tabSize: f } = t3, { mode: m3 } = t3, { mainMenuBar: h2 } = t3, { navigationBar: g } = t3, { statusBar: j } = t3, { askToFormat: x } = t3, { escapeControlCharacters: b2 } = t3, { escapeUnicodeCharacters: y } = t3, { flattenColumns: $2 } = t3, { parser: w } = t3, { parseMemoizeOne: C3 } = t3, { validator: k2 } = t3, { validationParser: S4 } = t3, { pathParser: O } = t3, { insideModal: z3 } = t3, { onChange: q2 } = t3, { onChangeMode: M3 } = t3, { onSelect: R3 } = t3, { onRenderValue: E3 } = t3, { onClassName: P3 } = t3, { onRenderMenu: I3 } = t3, { onRenderContextMenu: T3 } = t3, { onError: A } = t3, { onFocus: N3 } = t3, { onBlur: B3 } = t3, { onSortModal: F3 } = t3, { onTransformModal: U3 } = t3, { onJSONEditorModal: L3 } = t3, D3 = { type: "separator" };
  function J3() {
    return (J3 = o(function* () {
      i2 && (yield i2.refresh());
    })).apply(this, arguments);
  }
  return e2.$$set = (e3) => {
    "content" in e3 && n2(0, u = e3.content), "selection" in e3 && n2(1, d = e3.selection), "readOnly" in e3 && n2(2, v = e3.readOnly), "indentation" in e3 && n2(3, p = e3.indentation), "tabSize" in e3 && n2(4, f = e3.tabSize), "mode" in e3 && n2(5, m3 = e3.mode), "mainMenuBar" in e3 && n2(6, h2 = e3.mainMenuBar), "navigationBar" in e3 && n2(7, g = e3.navigationBar), "statusBar" in e3 && n2(8, j = e3.statusBar), "askToFormat" in e3 && n2(9, x = e3.askToFormat), "escapeControlCharacters" in e3 && n2(10, b2 = e3.escapeControlCharacters), "escapeUnicodeCharacters" in e3 && n2(11, y = e3.escapeUnicodeCharacters), "flattenColumns" in e3 && n2(12, $2 = e3.flattenColumns), "parser" in e3 && n2(13, w = e3.parser), "parseMemoizeOne" in e3 && n2(14, C3 = e3.parseMemoizeOne), "validator" in e3 && n2(15, k2 = e3.validator), "validationParser" in e3 && n2(16, S4 = e3.validationParser), "pathParser" in e3 && n2(17, O = e3.pathParser), "insideModal" in e3 && n2(34, z3 = e3.insideModal), "onChange" in e3 && n2(18, q2 = e3.onChange), "onChangeMode" in e3 && n2(19, M3 = e3.onChangeMode), "onSelect" in e3 && n2(20, R3 = e3.onSelect), "onRenderValue" in e3 && n2(21, E3 = e3.onRenderValue), "onClassName" in e3 && n2(22, P3 = e3.onClassName), "onRenderMenu" in e3 && n2(35, I3 = e3.onRenderMenu), "onRenderContextMenu" in e3 && n2(36, T3 = e3.onRenderContextMenu), "onError" in e3 && n2(23, A = e3.onError), "onFocus" in e3 && n2(24, N3 = e3.onFocus), "onBlur" in e3 && n2(25, B3 = e3.onBlur), "onSortModal" in e3 && n2(26, F3 = e3.onSortModal), "onTransformModal" in e3 && n2(27, U3 = e3.onTransformModal), "onJSONEditorModal" in e3 && n2(28, L3 = e3.onJSONEditorModal);
  }, e2.$$.update = () => {
    524320 & e2.$$.dirty[0] && n2(47, s2 = [{ type: "button", text: "text", title: "Switch to text mode (current mode: ".concat(m3, ")"), className: "jse-group-button jse-first" + (m3 === co.text ? " jse-selected" : ""), onClick: () => M3(co.text) }, { type: "button", text: "tree", title: "Switch to tree mode (current mode: ".concat(m3, ")"), className: "jse-group-button " + (m3 === co.tree ? " jse-selected" : ""), onClick: () => M3(co.tree) }, { type: "button", text: "table", title: "Switch to table mode (current mode: ".concat(m3, ")"), className: "jse-group-button jse-last" + (m3 === co.table ? " jse-selected" : ""), onClick: () => M3(co.table) }]), 36 & e2.$$.dirty[0] | 65560 & e2.$$.dirty[1] && n2(32, l = (e3) => {
      var t4 = ui(e3[0]) ? s2.concat(e3) : s2.concat(D3, e3), n3 = cloneDeep_default(t4);
      return I3(t4, { mode: m3, modal: z3, readOnly: v }) || n3;
    }), 38 & e2.$$.dirty[0] | 40 & e2.$$.dirty[1] && n2(33, c = (e3) => {
      var t4, n3 = cloneDeep_default(e3);
      return null !== (t4 = T3(e3, { mode: m3, modal: z3, readOnly: v, selection: d })) && void 0 !== t4 ? t4 : !v && n3;
    });
  }, [u, d, v, p, f, m3, h2, g, j, x, b2, y, $2, w, C3, k2, S4, O, q2, M3, R3, E3, P3, A, N3, B3, F3, U3, L3, r2, a2, i2, l, c, z3, I3, T3, function(e3) {
    if (r2) return r2.patch(e3);
    if (a2) return a2.patch(e3);
    if (i2) return i2.patch(e3);
    throw new Error('Method patch is not available in mode "'.concat(m3, '"'));
  }, function(e3, t4) {
    if (r2) return r2.expand(e3, t4);
    throw new Error('Method expand is not available in mode "'.concat(m3, '"'));
  }, function(e3, t4) {
    if (r2) return r2.collapse(e3, t4);
    throw new Error('Method collapse is not available in mode "'.concat(m3, '"'));
  }, function(e3) {
    if (i2) i2.openTransformModal(e3);
    else if (r2) r2.openTransformModal(e3);
    else {
      if (!a2) throw new Error('Method transform is not available in mode "'.concat(m3, '"'));
      a2.openTransformModal(e3);
    }
  }, function() {
    if (i2) return i2.validate();
    if (r2) return r2.validate();
    if (a2) return a2.validate();
    throw new Error('Method validate is not available in mode "'.concat(m3, '"'));
  }, function() {
    return r2 ? r2.acceptAutoRepair() : u;
  }, function(e3) {
    if (r2) return r2.scrollTo(e3);
    if (a2) return a2.scrollTo(e3);
    throw new Error('Method scrollTo is not available in mode "'.concat(m3, '"'));
  }, function(e3) {
    if (r2) return r2.findElement(e3);
    if (a2) return a2.findElement(e3);
    throw new Error('Method findElement is not available in mode "'.concat(m3, '"'));
  }, function() {
    i2 ? i2.focus() : r2 ? r2.focus() : a2 && a2.focus();
  }, function() {
    return J3.apply(this, arguments);
  }, s2, function(e3) {
    Tn[e3 ? "unshift" : "push"](() => {
      n2(31, i2 = e3);
    });
  }, function(e3) {
    Tn[e3 ? "unshift" : "push"](() => {
      n2(30, a2 = e3);
    });
  }, function(e3) {
    Tn[e3 ? "unshift" : "push"](() => {
      n2(29, r2 = e3);
    });
  }];
}
var Mx = class extends dr {
  constructor(e2) {
    super(), ur(this, e2, qx, zx, Vt, { content: 0, selection: 1, readOnly: 2, indentation: 3, tabSize: 4, mode: 5, mainMenuBar: 6, navigationBar: 7, statusBar: 8, askToFormat: 9, escapeControlCharacters: 10, escapeUnicodeCharacters: 11, flattenColumns: 12, parser: 13, parseMemoizeOne: 14, validator: 15, validationParser: 16, pathParser: 17, insideModal: 34, onChange: 18, onChangeMode: 19, onSelect: 20, onRenderValue: 21, onClassName: 22, onRenderMenu: 35, onRenderContextMenu: 36, onError: 23, onFocus: 24, onBlur: 25, onSortModal: 26, onTransformModal: 27, onJSONEditorModal: 28, patch: 37, expand: 38, collapse: 39, transform: 40, validate: 41, acceptAutoRepair: 42, scrollTo: 43, findElement: 44, focus: 45, refresh: 46 }, null, [-1, -1]);
  }
  get patch() {
    return this.$$.ctx[37];
  }
  get expand() {
    return this.$$.ctx[38];
  }
  get collapse() {
    return this.$$.ctx[39];
  }
  get transform() {
    return this.$$.ctx[40];
  }
  get validate() {
    return this.$$.ctx[41];
  }
  get acceptAutoRepair() {
    return this.$$.ctx[42];
  }
  get scrollTo() {
    return this.$$.ctx[43];
  }
  get findElement() {
    return this.$$.ctx[44];
  }
  get focus() {
    return this.$$.ctx[45];
  }
  get refresh() {
    return this.$$.ctx[46];
  }
};
function Rx(e2) {
  rn(e2, "svelte-1gqs8yw", '.jse-modal-wrapper.svelte-1gqs8yw.svelte-1gqs8yw{flex:1;display:flex;min-width:0;min-height:0;flex-direction:column}.jse-modal-wrapper.svelte-1gqs8yw .jse-modal-contents.svelte-1gqs8yw{flex:1;display:flex;flex-direction:column;padding:20px;overflow:auto;min-width:0;min-height:0}.jse-modal-wrapper.svelte-1gqs8yw .jse-modal-contents .jse-actions.svelte-1gqs8yw{display:flex;flex-direction:row;justify-content:flex-end;padding-top:var(--jse-padding, 10px)}.jse-modal-wrapper.svelte-1gqs8yw .jse-modal-contents .jse-actions button.jse-primary.svelte-1gqs8yw{border:none;background:transparent;color:inherit;cursor:pointer;font-family:var(--jse-font-family, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif);font-size:var(--jse-font-size, 16px);padding:5px;margin:0;background:var(--jse-button-primary-background, var(--jse-theme-color, #3883fa));color:var(--jse-button-primary-color, #fff);padding:var(--jse-padding, 10px) calc(2 * var(--jse-padding, 10px));border-radius:3px}.jse-modal-wrapper.svelte-1gqs8yw .jse-modal-contents .jse-actions button.jse-primary.svelte-1gqs8yw:hover{background:var(--jse-button-primary-background-highlight, var(--jse-theme-color-highlight, #5f9dff))}.jse-modal-wrapper.svelte-1gqs8yw .jse-modal-contents .jse-actions button.jse-primary.svelte-1gqs8yw:disabled{background:var(--jse-button-primary-background-disabled, #9d9d9d)}.jse-modal-wrapper.svelte-1gqs8yw .jse-modal-contents .jse-label.svelte-1gqs8yw{font-weight:bold;display:block;box-sizing:border-box}.jse-modal-wrapper.svelte-1gqs8yw .jse-modal-contents .jse-label .jse-label-inner.svelte-1gqs8yw{margin-top:calc(2 * var(--jse-padding, 10px));margin-bottom:calc(0.5 * var(--jse-padding, 10px));box-sizing:border-box}.jse-modal-wrapper.svelte-1gqs8yw .jse-modal-contents .jse-label .jse-label-inner button.svelte-1gqs8yw{border:none;background:transparent;color:inherit;cursor:pointer;font-family:var(--jse-font-family, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif);font-size:var(--jse-font-size, 16px);padding:5px;margin:0;font-weight:bold;padding:0}.jse-modal-wrapper.svelte-1gqs8yw .jse-modal-contents .jse-modal-inline-editor.svelte-1gqs8yw{flex:1;min-height:150px;min-width:0;max-width:100%;display:flex;--jse-theme-color:var(--jse-modal-editor-theme-color, #707070);--jse-theme-color-highlight:var(--jse-modal-editor-theme-color-highlight, #646464)}.jse-modal-wrapper.svelte-1gqs8yw .jse-actions.svelte-1gqs8yw{gap:var(--jse-padding, 10px);align-items:center}.jse-modal-wrapper.svelte-1gqs8yw .jse-actions .jse-error.svelte-1gqs8yw{flex:1;color:var(--jse-error-color, #ee5341)}.jse-modal-wrapper.svelte-1gqs8yw .jse-actions button.jse-secondary.svelte-1gqs8yw{border:none;background:transparent;color:inherit;cursor:pointer;font-family:var(--jse-font-family, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif);font-size:var(--jse-font-size, 16px);padding:5px;margin:0;background:var(--jse-button-secondary-background, #d3d3d3);color:var(--jse-button-secondary-color, var(--jse-text-color, #4d4d4d));padding:var(--jse-padding, 10px) calc(2 * var(--jse-padding, 10px));border-radius:3px}.jse-modal-wrapper.svelte-1gqs8yw .jse-actions button.jse-secondary.svelte-1gqs8yw:hover{background:var(--jse-button-secondary-background-highlight, #e1e1e1)}.jse-modal-wrapper.svelte-1gqs8yw .jse-actions button.jse-secondary.svelte-1gqs8yw:disabled{background:var(--jse-button-secondary-background-disabled, #9d9d9d)}.jse-modal-wrapper.svelte-1gqs8yw input.svelte-1gqs8yw{border:var(--jse-input-border, 1px solid #d8dbdf);outline:none;box-sizing:border-box;padding:calc(0.5 * var(--jse-padding, 10px));font-family:var(--jse-font-family-mono, consolas, menlo, monaco, "Ubuntu Mono", "source-code-pro", monospace);font-size:var(--jse-font-size-mono, 14px);color:inherit;background:var(--jse-input-background, var(--jse-background-color, #fff))}.jse-modal-wrapper.svelte-1gqs8yw input.svelte-1gqs8yw:focus{border:var(--jse-input-border-focus, 1px solid var(--jse-input-border-focus, var(--jse-theme-color, #3883fa)))}.jse-modal-wrapper.svelte-1gqs8yw input.svelte-1gqs8yw:read-only{background:var(--jse-input-background-readonly, transparent)}');
}
function Ex(e2) {
  var t3, n2;
  return { c() {
    t3 = ln("div"), n2 = un(e2[23]), hn(t3, "class", "jse-error svelte-1gqs8yw");
  }, m(e3, r2) {
    on(e3, t3, r2), nn(t3, n2);
  }, p(e3, t4) {
    8388608 & t4[0] && yn(n2, e3[23]);
  }, d(e3) {
    e3 && an(t3);
  } };
}
function Px(e2) {
  var t3, n2, r2, o2, a2, i2;
  return n2 = new Ca({ props: { data: faCaretLeft } }), { c() {
    t3 = ln("button"), sr(n2.$$.fragment), r2 = un(" Back"), hn(t3, "type", "button"), hn(t3, "class", "jse-secondary svelte-1gqs8yw");
  }, m(s2, l) {
    on(s2, t3, l), lr(n2, t3, null), nn(t3, r2), o2 = true, a2 || (i2 = pn(t3, "click", e2[28]), a2 = true);
  }, p: Bt, i(e3) {
    o2 || (Xn(n2.$$.fragment, e3), o2 = true);
  }, o(e3) {
    Gn(n2.$$.fragment, e3), o2 = false;
  }, d(e3) {
    e3 && an(t3), cr(n2), a2 = false, i2();
  } };
}
function Ix(e2) {
  var t3, n2, r2;
  return { c() {
    (t3 = ln("button")).textContent = "Close", hn(t3, "type", "button"), hn(t3, "class", "jse-primary svelte-1gqs8yw");
  }, m(o2, a2) {
    on(o2, t3, a2), n2 || (r2 = pn(t3, "click", e2[28]), n2 = true);
  }, p: Bt, d(e3) {
    e3 && an(t3), n2 = false, r2();
  } };
}
function Tx(e2) {
  var t3, n2, r2;
  return { c() {
    (t3 = ln("button")).textContent = "Apply", hn(t3, "type", "button"), hn(t3, "class", "jse-primary svelte-1gqs8yw");
  }, m(o2, a2) {
    on(o2, t3, a2), n2 || (r2 = [pn(t3, "click", e2[27]), en(Fx.call(null, t3))], n2 = true);
  }, p: Bt, d(e3) {
    e3 && an(t3), n2 = false, Dt(r2);
  } };
}
function Ax(e2) {
  var t3, n2, r2, o2, a2, i2, s2, l, c, u, d, v, p, f, m3, h2, g;
  function j(t4) {
    e2[39](t4);
  }
  var x = { title: "Edit nested content " + (e2[20].length > 1 ? " (".concat(e2[20].length, ")") : ""), fullScreenButton: true, onClose: e2[28] };
  void 0 !== e2[22] && (x.fullscreen = e2[22]), t3 = new Ad({ props: x }), Tn.push(() => ir(t3, "fullscreen", j));
  var b2 = { mode: e2[24].mode, content: e2[24].content, selection: e2[24].selection, readOnly: e2[0], indentation: e2[1], tabSize: e2[2], statusBar: e2[5], askToFormat: e2[6], mainMenuBar: e2[3], navigationBar: e2[4], escapeControlCharacters: e2[7], escapeUnicodeCharacters: e2[8], flattenColumns: e2[9], parser: e2[10], parseMemoizeOne: e2[25], validator: e2[11], validationParser: e2[12], pathParser: e2[13], insideModal: true, onError: e2[32], onChange: e2[29], onChangeMode: e2[31], onSelect: e2[30], onRenderValue: e2[14], onClassName: e2[15], onFocus: Dg, onBlur: Dg, onRenderMenu: e2[16], onRenderContextMenu: e2[17], onSortModal: e2[18], onTransformModal: e2[19], onJSONEditorModal: e2[33] };
  v = new Mx({ props: b2 }), e2[40](v);
  var y = e2[23] && Ex(e2), $2 = e2[20].length > 1 && Px(e2);
  function w(e3, t4) {
    return e3[0] ? Ix : Tx;
  }
  var C3 = w(e2), k2 = C3(e2);
  return { c() {
    sr(t3.$$.fragment), r2 = dn(), o2 = ln("div"), (a2 = ln("div")).innerHTML = '<div class="jse-label-inner svelte-1gqs8yw">Path</div>', i2 = dn(), s2 = ln("input"), l = dn(), (c = ln("div")).innerHTML = '<div class="jse-label-inner svelte-1gqs8yw">Contents</div>', u = dn(), d = ln("div"), sr(v.$$.fragment), p = dn(), f = ln("div"), y && y.c(), m3 = dn(), $2 && $2.c(), h2 = dn(), k2.c(), hn(a2, "class", "jse-label svelte-1gqs8yw"), hn(s2, "class", "jse-path svelte-1gqs8yw"), hn(s2, "type", "text"), s2.readOnly = true, hn(s2, "title", "Selected path"), s2.value = e2[26], hn(c, "class", "jse-label svelte-1gqs8yw"), hn(d, "class", "jse-modal-inline-editor svelte-1gqs8yw"), hn(f, "class", "jse-actions svelte-1gqs8yw"), hn(o2, "class", "jse-modal-contents svelte-1gqs8yw");
  }, m(e3, n3) {
    lr(t3, e3, n3), on(e3, r2, n3), on(e3, o2, n3), nn(o2, a2), nn(o2, i2), nn(o2, s2), nn(o2, l), nn(o2, c), nn(o2, u), nn(o2, d), lr(v, d, null), nn(o2, p), nn(o2, f), y && y.m(f, null), nn(f, m3), $2 && $2.m(f, null), nn(f, h2), k2.m(f, null), g = true;
  }, p(e3, r3) {
    var o3 = {};
    1048576 & r3[0] && (o3.title = "Edit nested content " + (e3[20].length > 1 ? " (".concat(e3[20].length, ")") : "")), !n2 && 4194304 & r3[0] && (n2 = true, o3.fullscreen = e3[22], Jn(() => n2 = false)), t3.$set(o3), (!g || 67108864 & r3[0] && s2.value !== e3[26]) && (s2.value = e3[26]);
    var a3 = {};
    16777216 & r3[0] && (a3.mode = e3[24].mode), 16777216 & r3[0] && (a3.content = e3[24].content), 16777216 & r3[0] && (a3.selection = e3[24].selection), 1 & r3[0] && (a3.readOnly = e3[0]), 2 & r3[0] && (a3.indentation = e3[1]), 4 & r3[0] && (a3.tabSize = e3[2]), 32 & r3[0] && (a3.statusBar = e3[5]), 64 & r3[0] && (a3.askToFormat = e3[6]), 8 & r3[0] && (a3.mainMenuBar = e3[3]), 16 & r3[0] && (a3.navigationBar = e3[4]), 128 & r3[0] && (a3.escapeControlCharacters = e3[7]), 256 & r3[0] && (a3.escapeUnicodeCharacters = e3[8]), 512 & r3[0] && (a3.flattenColumns = e3[9]), 1024 & r3[0] && (a3.parser = e3[10]), 33554432 & r3[0] && (a3.parseMemoizeOne = e3[25]), 2048 & r3[0] && (a3.validator = e3[11]), 4096 & r3[0] && (a3.validationParser = e3[12]), 8192 & r3[0] && (a3.pathParser = e3[13]), 16384 & r3[0] && (a3.onRenderValue = e3[14]), 32768 & r3[0] && (a3.onClassName = e3[15]), 65536 & r3[0] && (a3.onRenderMenu = e3[16]), 131072 & r3[0] && (a3.onRenderContextMenu = e3[17]), 262144 & r3[0] && (a3.onSortModal = e3[18]), 524288 & r3[0] && (a3.onTransformModal = e3[19]), v.$set(a3), e3[23] ? y ? y.p(e3, r3) : ((y = Ex(e3)).c(), y.m(f, m3)) : y && (y.d(1), y = null), e3[20].length > 1 ? $2 ? ($2.p(e3, r3), 1048576 & r3[0] && Xn($2, 1)) : (($2 = Px(e3)).c(), Xn($2, 1), $2.m(f, h2)) : $2 && (Kn(), Gn($2, 1, 1, () => {
      $2 = null;
    }), Zn()), C3 === (C3 = w(e3)) && k2 ? k2.p(e3, r3) : (k2.d(1), (k2 = C3(e3)) && (k2.c(), k2.m(f, null)));
  }, i(e3) {
    g || (Xn(t3.$$.fragment, e3), Xn(v.$$.fragment, e3), Xn($2), g = true);
  }, o(e3) {
    Gn(t3.$$.fragment, e3), Gn(v.$$.fragment, e3), Gn($2), g = false;
  }, d(n3) {
    n3 && (an(r2), an(o2)), cr(t3, n3), e2[40](null), cr(v), y && y.d(), $2 && $2.d(), k2.d();
  } };
}
function Nx(e2) {
  var t3, n2, r2;
  return n2 = new ra({ props: { $$slots: { default: [Ax] }, $$scope: { ctx: e2 } } }), { c() {
    t3 = ln("div"), sr(n2.$$.fragment), hn(t3, "class", "jse-modal-wrapper svelte-1gqs8yw");
  }, m(e3, o2) {
    on(e3, t3, o2), lr(n2, t3, null), r2 = true;
  }, p(e3, t4) {
    var r3 = {};
    134217727 & t4[0] | 32768 & t4[1] && (r3.$$scope = { dirty: t4, ctx: e3 }), n2.$set(r3);
  }, i(e3) {
    r2 || (Xn(n2.$$.fragment, e3), r2 = true);
  }, o(e3) {
    Gn(n2.$$.fragment, e3), r2 = false;
  }, d(e3) {
    e3 && an(t3), cr(n2);
  } };
}
function Bx(e2) {
  var t3, n2;
  return t3 = new kv({ props: { onClose: e2[28], className: "jse-jsoneditor-modal", fullscreen: e2[22], $$slots: { default: [Nx] }, $$scope: { ctx: e2 } } }), { c() {
    sr(t3.$$.fragment);
  }, m(e3, r2) {
    lr(t3, e3, r2), n2 = true;
  }, p(e3, n3) {
    var r2 = {};
    4194304 & n3[0] && (r2.fullscreen = e3[22]), 134217727 & n3[0] | 32768 & n3[1] && (r2.$$scope = { dirty: n3, ctx: e3 }), t3.$set(r2);
  }, i(e3) {
    n2 || (Xn(t3.$$.fragment, e3), n2 = true);
  }, o(e3) {
    Gn(t3.$$.fragment, e3), n2 = false;
  }, d(e3) {
    cr(t3, e3);
  } };
}
function Fx(e2) {
  e2.focus();
}
function Ux(e2, t3, n2) {
  var r2, o2, a2, s2, l, u, d = vr("jsoneditor:JSONEditorModal"), { content: v } = t3, { path: f } = t3, { onPatch: m3 } = t3, { readOnly: h2 } = t3, { indentation: g } = t3, { tabSize: j } = t3, { mainMenuBar: x } = t3, { navigationBar: b2 } = t3, { statusBar: y } = t3, { askToFormat: w } = t3, { escapeControlCharacters: C3 } = t3, { escapeUnicodeCharacters: k2 } = t3, { flattenColumns: S4 } = t3, { parser: O } = t3, { validator: z3 } = t3, { validationParser: q2 } = t3, { pathParser: M3 } = t3, { onRenderValue: R3 } = t3, { onClassName: I3 } = t3, { onRenderMenu: A } = t3, { onRenderContextMenu: N3 } = t3, { onSortModal: B3 } = t3, { onTransformModal: F3 } = t3, { onClose: U3 } = t3, L3 = { mode: V(v), content: v, selection: void 0, relativePath: f }, D3 = [L3], J3 = void 0;
  function V(e3) {
    return Xr(e3) && isJSONArray(e3.json) ? co.table : co.tree;
  }
  function H2() {
    var e3, t4 = null === (e3 = last_default(D3)) || void 0 === e3 ? void 0 : e3.selection;
    ds(t4) && l.scrollTo(Ds(t4));
  }
  function _2(e3) {
    var t4 = e3(last_default(D3));
    n2(20, D3 = [...initial_default(D3), t4]);
  }
  return qn(() => {
    var e3;
    null === (e3 = l) || void 0 === e3 || e3.focus();
  }), e2.$$set = (e3) => {
    "content" in e3 && n2(34, v = e3.content), "path" in e3 && n2(35, f = e3.path), "onPatch" in e3 && n2(36, m3 = e3.onPatch), "readOnly" in e3 && n2(0, h2 = e3.readOnly), "indentation" in e3 && n2(1, g = e3.indentation), "tabSize" in e3 && n2(2, j = e3.tabSize), "mainMenuBar" in e3 && n2(3, x = e3.mainMenuBar), "navigationBar" in e3 && n2(4, b2 = e3.navigationBar), "statusBar" in e3 && n2(5, y = e3.statusBar), "askToFormat" in e3 && n2(6, w = e3.askToFormat), "escapeControlCharacters" in e3 && n2(7, C3 = e3.escapeControlCharacters), "escapeUnicodeCharacters" in e3 && n2(8, k2 = e3.escapeUnicodeCharacters), "flattenColumns" in e3 && n2(9, S4 = e3.flattenColumns), "parser" in e3 && n2(10, O = e3.parser), "validator" in e3 && n2(11, z3 = e3.validator), "validationParser" in e3 && n2(12, q2 = e3.validationParser), "pathParser" in e3 && n2(13, M3 = e3.pathParser), "onRenderValue" in e3 && n2(14, R3 = e3.onRenderValue), "onClassName" in e3 && n2(15, I3 = e3.onClassName), "onRenderMenu" in e3 && n2(16, A = e3.onRenderMenu), "onRenderContextMenu" in e3 && n2(17, N3 = e3.onRenderContextMenu), "onSortModal" in e3 && n2(18, B3 = e3.onSortModal), "onTransformModal" in e3 && n2(19, F3 = e3.onTransformModal), "onClose" in e3 && n2(37, U3 = e3.onClose);
  }, e2.$$.update = () => {
    1048576 & e2.$$.dirty[0] && n2(24, r2 = last_default(D3) || L3), 1048576 & e2.$$.dirty[0] && n2(38, o2 = D3.flatMap((e3) => e3.relativePath)), 128 & e2.$$.dirty[1] && n2(26, a2 = isEmpty_default(o2) ? "(document root)" : _l(o2)), 1024 & e2.$$.dirty[0] && n2(25, s2 = memoizeOne(O.parse));
  }, [h2, g, j, x, b2, y, w, C3, k2, S4, O, z3, q2, M3, R3, I3, A, N3, B3, F3, D3, l, u, J3, r2, s2, a2, function() {
    if (d("handleApply"), !h2) try {
      n2(23, J3 = void 0);
      var e3 = r2.relativePath, t4 = r2.content, o3 = [{ op: "replace", path: compileJSONPointer(e3), value: eo(t4, O).json }];
      if (D3.length > 1) {
        var a3 = eo(D3[D3.length - 2].content, O).json, s3 = { json: immutableJSONPatch(a3, o3) }, l2 = i(i({}, D3[D3.length - 2] || L3), {}, { content: s3 });
        n2(20, D3 = [...D3.slice(0, D3.length - 2), l2]), Ln().then(H2);
      } else m3(o3), U3();
    } catch (e4) {
      n2(23, J3 = String(e4));
    }
  }, function() {
    d("handleClose"), u ? n2(22, u = false) : D3.length > 1 ? (n2(20, D3 = initial_default(D3)), Ln().then(() => {
      var e3;
      null === (e3 = l) || void 0 === e3 || e3.focus(), H2();
    }), n2(23, J3 = void 0)) : U3();
  }, function(e3) {
    d("handleChange", e3), _2((t4) => i(i({}, t4), {}, { content: e3 }));
  }, function(e3) {
    d("handleChangeSelection", e3), _2((t4) => i(i({}, t4), {}, { selection: e3 }));
  }, function(e3) {
    d("handleChangeMode", e3), _2((t4) => i(i({}, t4), {}, { mode: e3 }));
  }, function(e3) {
    n2(23, J3 = e3.toString()), console.error(e3);
  }, function(e3) {
    var { content: t4, path: r3 } = e3;
    d("handleJSONEditorModal", { content: t4, path: r3 });
    var o3 = { mode: V(t4), content: t4, selection: void 0, relativePath: r3 };
    n2(20, D3 = [...D3, o3]), Ln().then(() => {
      var e4;
      return null === (e4 = l) || void 0 === e4 ? void 0 : e4.focus();
    });
  }, v, f, m3, U3, o2, function(e3) {
    n2(22, u = e3);
  }, function(e3) {
    Tn[e3 ? "unshift" : "push"](() => {
      n2(21, l = e3);
    });
  }];
}
var Lx = class extends dr {
  constructor(e2) {
    super(), ur(this, e2, Ux, Bx, Ht, { content: 34, path: 35, onPatch: 36, readOnly: 0, indentation: 1, tabSize: 2, mainMenuBar: 3, navigationBar: 4, statusBar: 5, askToFormat: 6, escapeControlCharacters: 7, escapeUnicodeCharacters: 8, flattenColumns: 9, parser: 10, validator: 11, validationParser: 12, pathParser: 13, onRenderValue: 14, onClassName: 15, onRenderMenu: 16, onRenderContextMenu: 17, onSortModal: 18, onTransformModal: 19, onClose: 37 }, Rx, [-1, -1]);
  }
};
var Dx = {};
function Jx(e2) {
  rn(e2, "svelte-i2yd9i", '.jse-modal-contents.svelte-i2yd9i.svelte-i2yd9i{flex:1;display:flex;flex-direction:column;padding:20px;overflow:auto;min-width:0;min-height:0}.jse-modal-contents.svelte-i2yd9i .jse-actions.svelte-i2yd9i{display:flex;flex-direction:row;justify-content:flex-end;padding-top:var(--jse-padding, 10px)}.jse-modal-contents.svelte-i2yd9i .jse-actions button.jse-primary.svelte-i2yd9i{border:none;background:transparent;color:inherit;cursor:pointer;font-family:var(--jse-font-family, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif);font-size:var(--jse-font-size, 16px);padding:5px;margin:0;background:var(--jse-button-primary-background, var(--jse-theme-color, #3883fa));color:var(--jse-button-primary-color, #fff);padding:var(--jse-padding, 10px) calc(2 * var(--jse-padding, 10px));border-radius:3px}.jse-modal-contents.svelte-i2yd9i .jse-actions button.jse-primary.svelte-i2yd9i:hover{background:var(--jse-button-primary-background-highlight, var(--jse-theme-color-highlight, #5f9dff))}.jse-modal-contents.svelte-i2yd9i .jse-actions button.jse-primary.svelte-i2yd9i:disabled{background:var(--jse-button-primary-background-disabled, #9d9d9d)}.jse-modal-contents.svelte-i2yd9i table.svelte-i2yd9i{width:100%;border-collapse:collapse;border-spacing:0}.jse-modal-contents.svelte-i2yd9i table th.svelte-i2yd9i,.jse-modal-contents.svelte-i2yd9i table td.svelte-i2yd9i{text-align:left;vertical-align:middle;font-weight:normal;padding-bottom:var(--jse-padding, 10px)}.jse-modal-contents.svelte-i2yd9i table th input.jse-path.svelte-i2yd9i,.jse-modal-contents.svelte-i2yd9i table td input.jse-path.svelte-i2yd9i{width:100%;box-sizing:border-box;padding:6px 16px;border:var(--jse-input-border, 1px solid #d8dbdf);border-radius:var(--jse-input-radius, 3px);font-family:inherit;font-size:inherit;background:inherit;color:inherit;outline:none}.jse-modal-contents.svelte-i2yd9i table th input.jse-path.svelte-i2yd9i:read-only,.jse-modal-contents.svelte-i2yd9i table td input.jse-path.svelte-i2yd9i:read-only{background:var(--jse-input-background-readonly, transparent)}.jse-modal-contents.svelte-i2yd9i table th.svelte-i2yd9i .svelte-select input,.jse-modal-contents.svelte-i2yd9i table td.svelte-i2yd9i .svelte-select input{box-sizing:border-box}.jse-modal-contents.svelte-i2yd9i .jse-space.svelte-i2yd9i{height:200px}.jse-modal-contents.svelte-i2yd9i .jse-space .jse-error.svelte-i2yd9i{color:var(--jse-error-color, #ee5341)}');
}
function Vx(e2) {
  var t3, n2, r2, o2, a2, i2, s2;
  function l(t4) {
    e2[15](t4);
  }
  var c = { showChevron: true, items: e2[6] };
  return void 0 !== e2[2] && (c.value = e2[2]), a2 = new gd({ props: c }), Tn.push(() => ir(a2, "value", l)), { c() {
    t3 = ln("tr"), (n2 = ln("th")).textContent = "Property", r2 = dn(), o2 = ln("td"), sr(a2.$$.fragment), hn(n2, "class", "svelte-i2yd9i"), hn(o2, "class", "svelte-i2yd9i");
  }, m(e3, i3) {
    on(e3, t3, i3), nn(t3, n2), nn(t3, r2), nn(t3, o2), lr(a2, o2, null), s2 = true;
  }, p(e3, t4) {
    var n3 = {};
    64 & t4 && (n3.items = e3[6]), !i2 && 4 & t4 && (i2 = true, n3.value = e3[2], Jn(() => i2 = false)), a2.$set(n3);
  }, i(e3) {
    s2 || (Xn(a2.$$.fragment, e3), s2 = true);
  }, o(e3) {
    Gn(a2.$$.fragment, e3), s2 = false;
  }, d(e3) {
    e3 && an(t3), cr(a2);
  } };
}
function Hx(e2) {
  var t3, n2;
  return { c() {
    t3 = ln("div"), n2 = un(e2[5]), hn(t3, "class", "jse-error svelte-i2yd9i");
  }, m(e3, r2) {
    on(e3, t3, r2), nn(t3, n2);
  }, p(e3, t4) {
    32 & t4 && yn(n2, e3[5]);
  }, d(e3) {
    e3 && an(t3);
  } };
}
function _x(e2) {
  var t3, n2, r2, o2, a2, i2, s2, l, c, u, d, v, p, f, m3, h2, g, j, x, b2, y, $2, w, C3, k2, S4, O, z3, q2, M3, R3, E3;
  n2 = new Ad({ props: { title: e2[4] ? "Sort array items" : "Sort object keys", onClose: e2[1] } });
  var P3 = e2[4] && (e2[6] && (null === (t3 = e2[6]) || void 0 === t3 ? void 0 : t3.length) > 1 || void 0 === e2[2]) && Vx(e2);
  function I3(t4) {
    e2[16](t4);
  }
  var A = { showChevron: true, clearable: false, items: e2[7] };
  void 0 !== e2[3] && (A.value = e2[3]), y = new gd({ props: A }), Tn.push(() => ir(y, "value", I3));
  var N3 = e2[5] && Hx(e2);
  return { c() {
    var t4;
    sr(n2.$$.fragment), r2 = dn(), o2 = ln("div"), a2 = ln("table"), (i2 = ln("colgroup")).innerHTML = '<col width="25%"/> <col width="75%"/>', s2 = dn(), l = ln("tbody"), c = ln("tr"), (u = ln("th")).textContent = "Path", d = dn(), v = ln("td"), p = ln("input"), m3 = dn(), P3 && P3.c(), h2 = dn(), g = ln("tr"), (j = ln("th")).textContent = "Direction", x = dn(), b2 = ln("td"), sr(y.$$.fragment), w = dn(), C3 = ln("div"), N3 && N3.c(), k2 = dn(), S4 = ln("div"), O = ln("button"), z3 = un("Sort"), hn(u, "class", "svelte-i2yd9i"), hn(p, "class", "jse-path svelte-i2yd9i"), hn(p, "type", "text"), p.readOnly = true, hn(p, "title", "Selected path"), p.value = f = e2[0] && !isEmpty_default(e2[0]) ? _l(e2[0]) : "(document root)", hn(v, "class", "svelte-i2yd9i"), hn(j, "class", "svelte-i2yd9i"), hn(b2, "class", "svelte-i2yd9i"), hn(a2, "class", "svelte-i2yd9i"), hn(C3, "class", "jse-space svelte-i2yd9i"), hn(O, "type", "button"), hn(O, "class", "jse-primary svelte-i2yd9i"), O.disabled = q2 = !!(e2[4] && e2[6] && (null === (t4 = e2[6]) || void 0 === t4 ? void 0 : t4.length) > 1) && !e2[2], hn(S4, "class", "jse-actions svelte-i2yd9i"), hn(o2, "class", "jse-modal-contents svelte-i2yd9i");
  }, m(t4, f2) {
    lr(n2, t4, f2), on(t4, r2, f2), on(t4, o2, f2), nn(o2, a2), nn(a2, i2), nn(a2, s2), nn(a2, l), nn(l, c), nn(c, u), nn(c, d), nn(c, v), nn(v, p), nn(l, m3), P3 && P3.m(l, null), nn(l, h2), nn(l, g), nn(g, j), nn(g, x), nn(g, b2), lr(y, b2, null), nn(o2, w), nn(o2, C3), N3 && N3.m(C3, null), nn(o2, k2), nn(o2, S4), nn(S4, O), nn(O, z3), M3 = true, R3 || (E3 = [pn(O, "click", e2[8]), en(Qx.call(null, O))], R3 = true);
  }, p(e3, t4) {
    var r3, o3, a3 = {};
    16 & t4 && (a3.title = e3[4] ? "Sort array items" : "Sort object keys"), 2 & t4 && (a3.onClose = e3[1]), n2.$set(a3), (!M3 || 1 & t4 && f !== (f = e3[0] && !isEmpty_default(e3[0]) ? _l(e3[0]) : "(document root)") && p.value !== f) && (p.value = f), e3[4] && (e3[6] && (null === (r3 = e3[6]) || void 0 === r3 ? void 0 : r3.length) > 1 || void 0 === e3[2]) ? P3 ? (P3.p(e3, t4), 84 & t4 && Xn(P3, 1)) : ((P3 = Vx(e3)).c(), Xn(P3, 1), P3.m(l, h2)) : P3 && (Kn(), Gn(P3, 1, 1, () => {
      P3 = null;
    }), Zn());
    var i3 = {};
    !$2 && 8 & t4 && ($2 = true, i3.value = e3[3], Jn(() => $2 = false)), y.$set(i3), e3[5] ? N3 ? N3.p(e3, t4) : ((N3 = Hx(e3)).c(), N3.m(C3, null)) : N3 && (N3.d(1), N3 = null), (!M3 || 84 & t4 && q2 !== (q2 = !!(e3[4] && e3[6] && (null === (o3 = e3[6]) || void 0 === o3 ? void 0 : o3.length) > 1) && !e3[2])) && (O.disabled = q2);
  }, i(e3) {
    M3 || (Xn(n2.$$.fragment, e3), Xn(P3), Xn(y.$$.fragment, e3), M3 = true);
  }, o(e3) {
    Gn(n2.$$.fragment, e3), Gn(P3), Gn(y.$$.fragment, e3), M3 = false;
  }, d(e3) {
    e3 && (an(r2), an(o2)), cr(n2, e3), P3 && P3.d(), cr(y), N3 && N3.d(), R3 = false, Dt(E3);
  } };
}
function Wx(e2) {
  var t3, n2;
  return t3 = new kv({ props: { onClose: e2[1], className: "jse-sort-modal", $$slots: { default: [_x] }, $$scope: { ctx: e2 } } }), { c() {
    sr(t3.$$.fragment);
  }, m(e3, r2) {
    lr(t3, e3, r2), n2 = true;
  }, p(e3, n3) {
    var [r2] = n3, o2 = {};
    2 & r2 && (o2.onClose = e3[1]), 2097279 & r2 && (o2.$$scope = { dirty: r2, ctx: e3 }), t3.$set(o2);
  }, i(e3) {
    n2 || (Xn(t3.$$.fragment, e3), n2 = true);
  }, o(e3) {
    Gn(t3.$$.fragment, e3), n2 = false;
  }, d(e3) {
    cr(t3, e3);
  } };
}
function Qx(e2) {
  e2.focus();
}
function Yx(e2, t3, n2) {
  var r2, o2, a2, i2, s2, l, d = vr("jsoneditor:SortModal"), { id: v } = t3, { json: p } = t3, { rootPath: f } = t3, { onSort: m3 } = t3, { onClose: h2 } = t3, g = { value: 1, label: "ascending" }, j = [g, { value: -1, label: "descending" }], x = "".concat(v, ":").concat(compileJSONPointer(f)), b2 = null === (r2 = Dx[x]) || void 0 === r2 ? void 0 : r2.selectedProperty, y = (null === (o2 = Dx[x]) || void 0 === o2 ? void 0 : o2.selectedDirection) || g, $2 = void 0;
  return e2.$$set = (e3) => {
    "id" in e3 && n2(9, v = e3.id), "json" in e3 && n2(10, p = e3.json), "rootPath" in e3 && n2(0, f = e3.rootPath), "onSort" in e3 && n2(11, m3 = e3.onSort), "onClose" in e3 && n2(1, h2 = e3.onClose);
  }, e2.$$.update = () => {
    1025 & e2.$$.dirty && n2(14, a2 = getIn(p, f)), 16384 & e2.$$.dirty && n2(4, i2 = Array.isArray(a2)), 16400 & e2.$$.dirty && n2(13, s2 = i2 ? Ar(a2) : void 0), 8192 & e2.$$.dirty && n2(6, l = s2 ? s2.map(Ql) : void 0), 4108 & e2.$$.dirty && (n2(12, Dx[x] = { selectedProperty: b2, selectedDirection: y }, Dx), d("store state in memory", x, Dx[x]));
  }, [f, h2, b2, y, i2, $2, l, j, function() {
    try {
      var e3, t4, r3;
      n2(5, $2 = void 0);
      var o3 = (null === (e3 = b2) || void 0 === e3 ? void 0 : e3.value) || (null === (t4 = l) || void 0 === t4 || null === (t4 = t4[0]) || void 0 === t4 ? void 0 : t4.value) || [], a3 = null === (r3 = y) || void 0 === r3 ? void 0 : r3.value, i3 = Zf(p, f, o3, a3);
      void 0 !== m3 && void 0 !== f && m3({ operations: i3, rootPath: f, itemPath: o3, direction: a3 }), h2();
    } catch (e4) {
      n2(5, $2 = String(e4));
    }
  }, v, p, m3, Dx, s2, a2, function(e3) {
    n2(2, b2 = e3);
  }, function(e3) {
    n2(3, y = e3);
  }];
}
var Kx = class extends dr {
  constructor(e2) {
    super(), ur(this, e2, Yx, Wx, Ht, { id: 9, json: 10, rootPath: 0, onSort: 11, onClose: 1 }, Jx);
  }
};
function Zx(e2) {
  rn(e2, "svelte-57bmz4", '.jse-main.svelte-57bmz4{width:100%;height:100%;min-width:0;min-height:150px;font-family:var(--jse-font-family, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif);font-size:var(--jse-font-size, 16px);line-height:normal;position:relative;display:flex;flex-direction:row}.jse-main.svelte-57bmz4:not(.jse-focus){--jse-selection-background-color:var(--jse-selection-background-inactive-color, #e8e8e8);--jse-context-menu-pointer-background:var(--jse-context-menu-pointer-hover-background, #b2b2b2)}');
}
function Xx(e2) {
  var t3, n2, r2 = { mode: e2[2], content: e2[0], selection: e2[1], readOnly: e2[3], indentation: e2[4], tabSize: e2[5], statusBar: e2[8], askToFormat: e2[9], mainMenuBar: e2[6], navigationBar: e2[7], escapeControlCharacters: e2[10], escapeUnicodeCharacters: e2[11], flattenColumns: e2[12], parser: e2[13], parseMemoizeOne: e2[28], validator: e2[14], validationParser: e2[15], pathParser: e2[16], insideModal: false, onError: e2[21], onChange: e2[29], onChangeMode: e2[33], onSelect: e2[30], onRenderValue: e2[17], onClassName: e2[18], onFocus: e2[31], onBlur: e2[32], onRenderMenu: e2[19], onRenderContextMenu: e2[20], onSortModal: e2[35], onTransformModal: e2[34], onJSONEditorModal: e2[36] };
  return t3 = new Mx({ props: r2 }), e2[62](t3), { c() {
    sr(t3.$$.fragment);
  }, m(e3, r3) {
    lr(t3, e3, r3), n2 = true;
  }, p(e3, n3) {
    var r3 = {};
    4 & n3[0] && (r3.mode = e3[2]), 1 & n3[0] && (r3.content = e3[0]), 2 & n3[0] && (r3.selection = e3[1]), 8 & n3[0] && (r3.readOnly = e3[3]), 16 & n3[0] && (r3.indentation = e3[4]), 32 & n3[0] && (r3.tabSize = e3[5]), 256 & n3[0] && (r3.statusBar = e3[8]), 512 & n3[0] && (r3.askToFormat = e3[9]), 64 & n3[0] && (r3.mainMenuBar = e3[6]), 128 & n3[0] && (r3.navigationBar = e3[7]), 1024 & n3[0] && (r3.escapeControlCharacters = e3[10]), 2048 & n3[0] && (r3.escapeUnicodeCharacters = e3[11]), 4096 & n3[0] && (r3.flattenColumns = e3[12]), 8192 & n3[0] && (r3.parser = e3[13]), 268435456 & n3[0] && (r3.parseMemoizeOne = e3[28]), 16384 & n3[0] && (r3.validator = e3[14]), 32768 & n3[0] && (r3.validationParser = e3[15]), 65536 & n3[0] && (r3.pathParser = e3[16]), 2097152 & n3[0] && (r3.onError = e3[21]), 131072 & n3[0] && (r3.onRenderValue = e3[17]), 262144 & n3[0] && (r3.onClassName = e3[18]), 524288 & n3[0] && (r3.onRenderMenu = e3[19]), 1048576 & n3[0] && (r3.onRenderContextMenu = e3[20]), t3.$set(r3);
  }, i(e3) {
    n2 || (Xn(t3.$$.fragment, e3), n2 = true);
  }, o(e3) {
    Gn(t3.$$.fragment, e3), n2 = false;
  }, d(n3) {
    e2[62](null), cr(t3, n3);
  } };
}
function Gx(e2) {
  for (var t3, n2, r2 = [e2[26], { onClose: e2[63] }], o2 = {}, a2 = 0; a2 < r2.length; a2 += 1) o2 = Ft(o2, r2[a2]);
  return t3 = new Kx({ props: o2 }), { c() {
    sr(t3.$$.fragment);
  }, m(e3, r3) {
    lr(t3, e3, r3), n2 = true;
  }, p(e3, n3) {
    var o3 = 67108864 & n3[0] ? or(r2, [67108864 & n3[0] && ar(e3[26]), { onClose: e3[63] }]) : {};
    t3.$set(o3);
  }, i(e3) {
    n2 || (Xn(t3.$$.fragment, e3), n2 = true);
  }, o(e3) {
    Gn(t3.$$.fragment, e3), n2 = false;
  }, d(e3) {
    cr(t3, e3);
  } };
}
function eb(e2) {
  for (var t3, n2, r2 = [e2[27], { onClose: e2[64] }], o2 = {}, a2 = 0; a2 < r2.length; a2 += 1) o2 = Ft(o2, r2[a2]);
  return t3 = new Lg({ props: o2 }), { c() {
    sr(t3.$$.fragment);
  }, m(e3, r3) {
    lr(t3, e3, r3), n2 = true;
  }, p(e3, n3) {
    var o3 = 134217728 & n3[0] ? or(r2, [134217728 & n3[0] && ar(e3[27]), { onClose: e3[64] }]) : {};
    t3.$set(o3);
  }, i(e3) {
    n2 || (Xn(t3.$$.fragment, e3), n2 = true);
  }, o(e3) {
    Gn(t3.$$.fragment, e3), n2 = false;
  }, d(e3) {
    cr(t3, e3);
  } };
}
function tb(e2) {
  for (var t3, n2, r2 = [e2[25], { onClose: e2[65] }], o2 = {}, a2 = 0; a2 < r2.length; a2 += 1) o2 = Ft(o2, r2[a2]);
  return t3 = new Lx({ props: o2 }), { c() {
    sr(t3.$$.fragment);
  }, m(e3, r3) {
    lr(t3, e3, r3), n2 = true;
  }, p(e3, n3) {
    var o3 = 33554432 & n3[0] ? or(r2, [33554432 & n3[0] && ar(e3[25]), { onClose: e3[65] }]) : {};
    t3.$set(o3);
  }, i(e3) {
    n2 || (Xn(t3.$$.fragment, e3), n2 = true);
  }, o(e3) {
    Gn(t3.$$.fragment, e3), n2 = false;
  }, d(e3) {
    cr(t3, e3);
  } };
}
function nb(e2) {
  var t3, n2, r2, o2, a2, i2, s2 = e2[22], l = Xx(e2), c = e2[26] && Gx(e2), u = e2[27] && eb(e2), d = e2[25] && tb(e2);
  return { c() {
    t3 = ln("div"), l.c(), n2 = dn(), c && c.c(), r2 = dn(), u && u.c(), o2 = dn(), d && d.c(), a2 = vn(), hn(t3, "class", "jse-main svelte-57bmz4"), kn(t3, "jse-focus", e2[23]);
  }, m(e3, s3) {
    on(e3, t3, s3), l.m(t3, null), on(e3, n2, s3), c && c.m(e3, s3), on(e3, r2, s3), u && u.m(e3, s3), on(e3, o2, s3), d && d.m(e3, s3), on(e3, a2, s3), i2 = true;
  }, p(e3, n3) {
    4194304 & n3[0] && Ht(s2, s2 = e3[22]) ? (Kn(), Gn(l, 1, 1, Bt), Zn(), (l = Xx(e3)).c(), Xn(l, 1), l.m(t3, null)) : l.p(e3, n3), (!i2 || 8388608 & n3[0]) && kn(t3, "jse-focus", e3[23]), e3[26] ? c ? (c.p(e3, n3), 67108864 & n3[0] && Xn(c, 1)) : ((c = Gx(e3)).c(), Xn(c, 1), c.m(r2.parentNode, r2)) : c && (Kn(), Gn(c, 1, 1, () => {
      c = null;
    }), Zn()), e3[27] ? u ? (u.p(e3, n3), 134217728 & n3[0] && Xn(u, 1)) : ((u = eb(e3)).c(), Xn(u, 1), u.m(o2.parentNode, o2)) : u && (Kn(), Gn(u, 1, 1, () => {
      u = null;
    }), Zn()), e3[25] ? d ? (d.p(e3, n3), 33554432 & n3[0] && Xn(d, 1)) : ((d = tb(e3)).c(), Xn(d, 1), d.m(a2.parentNode, a2)) : d && (Kn(), Gn(d, 1, 1, () => {
      d = null;
    }), Zn());
  }, i(e3) {
    i2 || (Xn(l), Xn(c), Xn(u), Xn(d), i2 = true);
  }, o(e3) {
    Gn(l), Gn(c), Gn(u), Gn(d), i2 = false;
  }, d(e3) {
    e3 && (an(t3), an(n2), an(r2), an(o2), an(a2)), l.d(e3), c && c.d(e3), u && u.d(e3), d && d.d(e3);
  } };
}
function rb(e2) {
  var t3, n2;
  return t3 = new ra({ props: { $$slots: { default: [nb] }, $$scope: { ctx: e2 } } }), { c() {
    sr(t3.$$.fragment);
  }, m(e3, r2) {
    lr(t3, e3, r2), n2 = true;
  }, p(e3, n3) {
    var r2 = {};
    536870911 & n3[0] | 64 & n3[2] && (r2.$$scope = { dirty: n3, ctx: e3 }), t3.$set(r2);
  }, i(e3) {
    n2 || (Xn(t3.$$.fragment, e3), n2 = true);
  }, o(e3) {
    Gn(t3.$$.fragment, e3), n2 = false;
  }, d(e3) {
    cr(t3, e3);
  } };
}
function ob(e2, t3, n2) {
  var r2, a2, i2, s2, l = vr("jsoneditor:JSONEditor"), { content: c = { text: "" } } = t3, { selection: u } = t3, { readOnly: d = false } = t3, { indentation: v = 2 } = t3, { tabSize: p = 4 } = t3, { mode: f = co.tree } = t3, { mainMenuBar: m3 = true } = t3, { navigationBar: h2 = true } = t3, { statusBar: g = true } = t3, { askToFormat: j = true } = t3, { escapeControlCharacters: x = false } = t3, { escapeUnicodeCharacters: b2 = false } = t3, { flattenColumns: y = true } = t3, { parser: $2 = JSON } = t3, { validator: w } = t3, { validationParser: C3 = JSON } = t3, { pathParser: k2 = { parse: Wl, stringify: _l } } = t3, { queryLanguages: S4 = [sa] } = t3, { queryLanguageId: O = S4[0].id } = t3, { onChangeQueryLanguage: z3 = Dg } = t3, { onChange: q2 } = t3, { onSelect: M3 } = t3, { onRenderValue: R3 = Hl } = t3, { onClassName: E3 = () => {
  } } = t3, { onRenderMenu: P3 = Dg } = t3, { onRenderContextMenu: I3 = Dg } = t3, { onChangeMode: T3 = Dg } = t3, { onError: A = (e3) => {
    console.error(e3), alert(e3.toString());
  } } = t3, { onFocus: N3 = Dg } = t3, { onBlur: B3 = Dg } = t3, F3 = hr(), U3 = false, L3 = void 0, D3 = $2;
  function J3() {
    return (J3 = o(function* (e3) {
      l("set");
      var t4 = Yr(e3);
      if (t4) throw new Error(t4);
      n2(22, F3 = hr()), n2(0, c = e3);
    })).apply(this, arguments);
  }
  function V() {
    return (V = o(function* (e3) {
      l("update");
      var t4 = Yr(e3);
      if (t4) throw new Error(t4);
      n2(0, c = e3), yield Ln();
    })).apply(this, arguments);
  }
  function H2() {
    return (H2 = o(function* (e3) {
      if (Zr(c)) try {
        n2(0, c = { json: $2.parse(c.text), text: void 0 });
      } catch (e4) {
        throw new Error("Cannot apply patch: current document contains invalid JSON");
      }
      var t4 = a2.patch(e3);
      return yield Ln(), t4;
    })).apply(this, arguments);
  }
  function _2() {
    return (_2 = o(function* (e3) {
      n2(1, u = e3), yield Ln();
    })).apply(this, arguments);
  }
  function Q2() {
    return (Q2 = o(function* (e3, t4) {
      a2.expand(e3, t4), yield Ln();
    })).apply(this, arguments);
  }
  function Y2() {
    return Y2 = o(function* (e3) {
      var t4 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
      a2.collapse(e3, t4), yield Ln();
    }), Y2.apply(this, arguments);
  }
  function K3() {
    return K3 = o(function* () {
      var e3 = a2.acceptAutoRepair();
      return yield Ln(), e3;
    }), K3.apply(this, arguments);
  }
  function Z3() {
    return (Z3 = o(function* (e3) {
      yield a2.scrollTo(e3);
    })).apply(this, arguments);
  }
  function X2() {
    return G2.apply(this, arguments);
  }
  function G2() {
    return (G2 = o(function* () {
      a2.focus(), yield Ln();
    })).apply(this, arguments);
  }
  function ee2() {
    return (ee2 = o(function* () {
      yield a2.refresh();
    })).apply(this, arguments);
  }
  function te2() {
    return (te2 = o(function* (e3) {
      this.$set(e3), yield Ln();
    })).apply(this, arguments);
  }
  function ne2() {
    return (ne2 = o(function* () {
      this.$destroy(), yield Ln();
    })).apply(this, arguments);
  }
  function re2() {
    return (re2 = o(function* (e3) {
      f !== e3 && (n2(2, f = e3), yield Ln(), yield X2(), T3(e3));
    })).apply(this, arguments);
  }
  function oe2(e3) {
    l("handleChangeQueryLanguage", e3), n2(37, O = e3), z3(e3);
  }
  function ae2(e3) {
    var { id: t4, json: o2, rootPath: a3, onTransform: i3, onClose: l2 } = e3;
    d || n2(27, s2 = { id: t4, json: o2, rootPath: a3, indentation: v, escapeControlCharacters: x, escapeUnicodeCharacters: b2, parser: $2, parseMemoizeOne: r2, validationParser: C3, pathParser: k2, queryLanguages: S4, queryLanguageId: O, onChangeQueryLanguage: oe2, onRenderValue: R3, onRenderMenu: (e4) => P3(e4, { mode: f, modal: true, readOnly: d }), onRenderContextMenu: (e4) => I3(e4, { mode: f, modal: true, readOnly: d, selection: u }), onClassName: E3, onTransform: i3, onClose: l2 });
  }
  function ie4(e3) {
    d || n2(26, i2 = e3);
  }
  return e2.$$set = (e3) => {
    "content" in e3 && n2(0, c = e3.content), "selection" in e3 && n2(1, u = e3.selection), "readOnly" in e3 && n2(3, d = e3.readOnly), "indentation" in e3 && n2(4, v = e3.indentation), "tabSize" in e3 && n2(5, p = e3.tabSize), "mode" in e3 && n2(2, f = e3.mode), "mainMenuBar" in e3 && n2(6, m3 = e3.mainMenuBar), "navigationBar" in e3 && n2(7, h2 = e3.navigationBar), "statusBar" in e3 && n2(8, g = e3.statusBar), "askToFormat" in e3 && n2(9, j = e3.askToFormat), "escapeControlCharacters" in e3 && n2(10, x = e3.escapeControlCharacters), "escapeUnicodeCharacters" in e3 && n2(11, b2 = e3.escapeUnicodeCharacters), "flattenColumns" in e3 && n2(12, y = e3.flattenColumns), "parser" in e3 && n2(13, $2 = e3.parser), "validator" in e3 && n2(14, w = e3.validator), "validationParser" in e3 && n2(15, C3 = e3.validationParser), "pathParser" in e3 && n2(16, k2 = e3.pathParser), "queryLanguages" in e3 && n2(38, S4 = e3.queryLanguages), "queryLanguageId" in e3 && n2(37, O = e3.queryLanguageId), "onChangeQueryLanguage" in e3 && n2(39, z3 = e3.onChangeQueryLanguage), "onChange" in e3 && n2(40, q2 = e3.onChange), "onSelect" in e3 && n2(41, M3 = e3.onSelect), "onRenderValue" in e3 && n2(17, R3 = e3.onRenderValue), "onClassName" in e3 && n2(18, E3 = e3.onClassName), "onRenderMenu" in e3 && n2(19, P3 = e3.onRenderMenu), "onRenderContextMenu" in e3 && n2(20, I3 = e3.onRenderContextMenu), "onChangeMode" in e3 && n2(42, T3 = e3.onChangeMode), "onError" in e3 && n2(21, A = e3.onError), "onFocus" in e3 && n2(43, N3 = e3.onFocus), "onBlur" in e3 && n2(44, B3 = e3.onBlur);
  }, e2.$$.update = () => {
    if (8193 & e2.$$.dirty[0] | 1073741824 & e2.$$.dirty[1] && !so($2, D3)) {
      if (l("parser changed, recreate editor"), Xr(c)) {
        var t4 = D3.stringify(c.json);
        n2(0, c = { json: void 0 !== t4 ? $2.parse(t4) : void 0 });
      }
      n2(61, D3 = $2), n2(22, F3 = hr());
    }
    if (1 & e2.$$.dirty[0]) {
      var o2 = Yr(c);
      o2 && console.error("Error: " + o2);
    }
    2 & e2.$$.dirty[0] && null === u && console.warn("selection is invalid: it is null but should be undefined"), 8192 & e2.$$.dirty[0] && n2(28, r2 = memoizeOne($2.parse)), 4 & e2.$$.dirty[0] && l("mode changed to", f);
  }, [c, u, f, d, v, p, m3, h2, g, j, x, b2, y, $2, w, C3, k2, R3, E3, P3, I3, A, F3, U3, a2, L3, i2, s2, r2, function(e3, t4, r3) {
    n2(0, c = e3), q2 && q2(e3, t4, r3);
  }, function(e3) {
    n2(1, u = e3), M3 && M3(cloneDeep_default(e3));
  }, function() {
    n2(23, U3 = true), N3 && N3();
  }, function() {
    n2(23, U3 = false), B3 && B3();
  }, function(e3) {
    return re2.apply(this, arguments);
  }, ae2, ie4, function(e3) {
    var { content: t4, path: r3, onPatch: o2, onClose: a3 } = e3;
    l("onJSONEditorModal", { content: t4, path: r3 }), n2(25, L3 = { content: t4, path: r3, onPatch: o2, readOnly: d, indentation: v, tabSize: p, mainMenuBar: m3, navigationBar: h2, statusBar: g, askToFormat: j, escapeControlCharacters: x, escapeUnicodeCharacters: b2, flattenColumns: y, parser: $2, validator: void 0, validationParser: C3, pathParser: k2, onRenderValue: R3, onClassName: E3, onRenderMenu: P3, onRenderContextMenu: I3, onSortModal: ie4, onTransformModal: ae2, onClose: a3 });
  }, O, S4, z3, q2, M3, T3, N3, B3, function() {
    return c;
  }, function(e3) {
    return J3.apply(this, arguments);
  }, function(e3) {
    return V.apply(this, arguments);
  }, function(e3) {
    return H2.apply(this, arguments);
  }, function(e3) {
    return _2.apply(this, arguments);
  }, function(e3, t4) {
    return Q2.apply(this, arguments);
  }, function(e3) {
    return Y2.apply(this, arguments);
  }, function(e3) {
    a2.transform(e3);
  }, function() {
    return a2.validate();
  }, function() {
    return K3.apply(this, arguments);
  }, function(e3) {
    return Z3.apply(this, arguments);
  }, function(e3) {
    return a2.findElement(e3);
  }, X2, function() {
    return ee2.apply(this, arguments);
  }, function(e3) {
    return te2.apply(this, arguments);
  }, function() {
    return ne2.apply(this, arguments);
  }, D3, function(e3) {
    Tn[e3 ? "unshift" : "push"](() => {
      n2(24, a2 = e3);
    });
  }, () => {
    var e3;
    null === (e3 = i2) || void 0 === e3 || e3.onClose(), n2(26, i2 = void 0);
  }, () => {
    var e3;
    null === (e3 = s2) || void 0 === e3 || e3.onClose(), n2(27, s2 = void 0);
  }, () => {
    var e3;
    null === (e3 = L3) || void 0 === e3 || e3.onClose(), n2(25, L3 = void 0);
  }];
}
var ab = class extends dr {
  constructor(e2) {
    super(), ur(this, e2, ob, rb, Ht, { content: 0, selection: 1, readOnly: 3, indentation: 4, tabSize: 5, mode: 2, mainMenuBar: 6, navigationBar: 7, statusBar: 8, askToFormat: 9, escapeControlCharacters: 10, escapeUnicodeCharacters: 11, flattenColumns: 12, parser: 13, validator: 14, validationParser: 15, pathParser: 16, queryLanguages: 38, queryLanguageId: 37, onChangeQueryLanguage: 39, onChange: 40, onSelect: 41, onRenderValue: 17, onClassName: 18, onRenderMenu: 19, onRenderContextMenu: 20, onChangeMode: 42, onError: 21, onFocus: 43, onBlur: 44, get: 45, set: 46, update: 47, patch: 48, select: 49, expand: 50, collapse: 51, transform: 52, validate: 53, acceptAutoRepair: 54, scrollTo: 55, findElement: 56, focus: 57, refresh: 58, updateProps: 59, destroy: 60 }, Zx, [-1, -1, -1]);
  }
  get get() {
    return this.$$.ctx[45];
  }
  get set() {
    return this.$$.ctx[46];
  }
  get update() {
    return this.$$.ctx[47];
  }
  get patch() {
    return this.$$.ctx[48];
  }
  get select() {
    return this.$$.ctx[49];
  }
  get expand() {
    return this.$$.ctx[50];
  }
  get collapse() {
    return this.$$.ctx[51];
  }
  get transform() {
    return this.$$.ctx[52];
  }
  get validate() {
    return this.$$.ctx[53];
  }
  get acceptAutoRepair() {
    return this.$$.ctx[54];
  }
  get scrollTo() {
    return this.$$.ctx[55];
  }
  get findElement() {
    return this.$$.ctx[56];
  }
  get focus() {
    return this.$$.ctx[57];
  }
  get refresh() {
    return this.$$.ctx[58];
  }
  get updateProps() {
    return this.$$.ctx[59];
  }
  get destroy() {
    return this.$$.ctx[60];
  }
};
function kb(e2) {
  var { target: t3, props: n2 } = e2;
  return new ab({ target: t3, props: n2 });
}

// node_modules/json-editor-vue/node_modules/vue-demi/lib/index.mjs
var isVue3 = true;

// node_modules/json-editor-vue/dist/json-editor-vue.mjs
var pn2 = /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/;
var dn2 = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/;
var vn2 = /^\s*["[{]|^\s*-?\d{1,16}(\.\d{1,17})?([Ee][+-]?\d+)?\s*$/;
function bn2(t3, r2) {
  if (t3 === "__proto__" || t3 === "constructor" && r2 && typeof r2 == "object" && "prototype" in r2) {
    yn2(t3);
    return;
  }
  return r2;
}
function yn2(t3) {
  console.warn(`[destr] Dropping "${t3}" key to prevent prototype pollution.`);
}
function Q(t3, r2 = {}) {
  if (typeof t3 != "string")
    return t3;
  const n2 = t3.trim();
  if (
    // eslint-disable-next-line unicorn/prefer-at
    t3[0] === '"' && t3.endsWith('"') && !t3.includes("\\")
  )
    return n2.slice(1, -1);
  if (n2.length <= 9) {
    const e2 = n2.toLowerCase();
    if (e2 === "true")
      return true;
    if (e2 === "false")
      return false;
    if (e2 === "undefined")
      return;
    if (e2 === "null")
      return null;
    if (e2 === "nan")
      return Number.NaN;
    if (e2 === "infinity")
      return Number.POSITIVE_INFINITY;
    if (e2 === "-infinity")
      return Number.NEGATIVE_INFINITY;
  }
  if (!vn2.test(t3)) {
    if (r2.strict)
      throw new SyntaxError("[destr] Invalid JSON");
    return t3;
  }
  try {
    if (pn2.test(t3) || dn2.test(t3)) {
      if (r2.strict)
        throw new Error("[destr] Possible prototype pollution");
      return JSON.parse(t3, bn2);
    }
    return JSON.parse(t3);
  } catch (e2) {
    if (r2.strict)
      throw e2;
    return t3;
  }
}
function hn2(t3, r2 = {}) {
  return Q(t3, { ...r2, strict: true });
}
var gn2 = typeof global == "object" && global && global.Object === Object && global;
var jn2 = typeof self == "object" && self && self.Object === Object && self;
var Sr2 = gn2 || jn2 || Function("return this")();
var nt = Sr2.Symbol;
var Er = Object.prototype;
var mn2 = Er.hasOwnProperty;
var _n2 = Er.toString;
var W2 = nt ? nt.toStringTag : void 0;
function On2(t3) {
  var r2 = mn2.call(t3, W2), n2 = t3[W2];
  try {
    t3[W2] = void 0;
    var e2 = true;
  } catch {
  }
  var i2 = _n2.call(t3);
  return e2 && (r2 ? t3[W2] = n2 : delete t3[W2]), i2;
}
var wn2 = Object.prototype;
var An2 = wn2.toString;
function xn2(t3) {
  return An2.call(t3);
}
var Sn2 = "[object Null]";
var En2 = "[object Undefined]";
var Wt2 = nt ? nt.toStringTag : void 0;
function Tn2(t3) {
  return t3 == null ? t3 === void 0 ? En2 : Sn2 : Wt2 && Wt2 in Object(t3) ? On2(t3) : xn2(t3);
}
function In2(t3) {
  return t3 != null && typeof t3 == "object";
}
var Fn2 = "[object Symbol]";
function Pn2(t3) {
  return typeof t3 == "symbol" || In2(t3) && Tn2(t3) == Fn2;
}
var kn2 = /\s/;
function zn2(t3) {
  for (var r2 = t3.length; r2-- && kn2.test(t3.charAt(r2)); )
    ;
  return r2;
}
var Cn = /^\s+/;
function Nn2(t3) {
  return t3 && t3.slice(0, zn2(t3) + 1).replace(Cn, "");
}
function gt(t3) {
  var r2 = typeof t3;
  return t3 != null && (r2 == "object" || r2 == "function");
}
var Rt = NaN;
var $n2 = /^[-+]0x[0-9a-f]+$/i;
var Ln2 = /^0b[01]+$/i;
var Mn2 = /^0o[0-7]+$/i;
var Bn2 = parseInt;
function Gt2(t3) {
  if (typeof t3 == "number")
    return t3;
  if (Pn2(t3))
    return Rt;
  if (gt(t3)) {
    var r2 = typeof t3.valueOf == "function" ? t3.valueOf() : t3;
    t3 = gt(r2) ? r2 + "" : r2;
  }
  if (typeof t3 != "string")
    return t3 === 0 ? t3 : +t3;
  t3 = Nn2(t3);
  var n2 = Ln2.test(t3);
  return n2 || Mn2.test(t3) ? Bn2(t3.slice(2), n2 ? 2 : 8) : $n2.test(t3) ? Rt : +t3;
}
var vt = function() {
  return Sr2.Date.now();
};
var Dn2 = "Expected a function";
var Un2 = Math.max;
var Vn2 = Math.min;
function Wn2(t3, r2, n2) {
  var e2, i2, o2, a2, u, c, f = 0, s2 = false, d = false, v = true;
  if (typeof t3 != "function")
    throw new TypeError(Dn2);
  r2 = Gt2(r2) || 0, gt(n2) && (s2 = !!n2.leading, d = "maxWait" in n2, o2 = d ? Un2(Gt2(n2.maxWait) || 0, r2) : o2, v = "trailing" in n2 ? !!n2.trailing : v);
  function h2(g) {
    var x = e2, V = i2;
    return e2 = i2 = void 0, f = g, a2 = t3.apply(V, x), a2;
  }
  function p(g) {
    return f = g, u = setTimeout(l, r2), s2 ? h2(g) : a2;
  }
  function j(g) {
    var x = g - c, V = g - f, Ut2 = r2 - x;
    return d ? Vn2(Ut2, o2 - V) : Ut2;
  }
  function A(g) {
    var x = g - c, V = g - f;
    return c === void 0 || x >= r2 || x < 0 || d && V >= o2;
  }
  function l() {
    var g = vt();
    if (A(g))
      return y(g);
    u = setTimeout(l, j(g));
  }
  function y(g) {
    return u = void 0, v && e2 ? h2(g) : (e2 = i2 = void 0, a2);
  }
  function w() {
    u !== void 0 && clearTimeout(u), f = 0, e2 = c = i2 = u = void 0;
  }
  function b2() {
    return u === void 0 ? a2 : y(vt());
  }
  function O() {
    var g = vt(), x = A(g);
    if (e2 = arguments, i2 = this, c = g, x) {
      if (u === void 0)
        return p(c);
      if (d)
        return clearTimeout(u), u = setTimeout(l, r2), h2(c);
    }
    return u === void 0 && (u = setTimeout(l, r2)), a2;
  }
  return O.cancel = w, O.flush = b2, O;
}
var Tr2 = typeof global == "object" && global && global.Object === Object && global;
var Rn2 = typeof self == "object" && self && self.Object === Object && self;
var P2 = Tr2 || Rn2 || Function("return this")();
var I2 = P2.Symbol;
var Ir2 = Object.prototype;
var Gn2 = Ir2.hasOwnProperty;
var Jn2 = Ir2.toString;
var R2 = I2 ? I2.toStringTag : void 0;
function qn2(t3) {
  var r2 = Gn2.call(t3, R2), n2 = t3[R2];
  try {
    t3[R2] = void 0;
    var e2 = true;
  } catch {
  }
  var i2 = Jn2.call(t3);
  return e2 && (r2 ? t3[R2] = n2 : delete t3[R2]), i2;
}
var Kn2 = Object.prototype;
var Yn2 = Kn2.toString;
function Hn2(t3) {
  return Yn2.call(t3);
}
var Xn2 = "[object Null]";
var Qn2 = "[object Undefined]";
var Jt2 = I2 ? I2.toStringTag : void 0;
function M2(t3) {
  return t3 == null ? t3 === void 0 ? Qn2 : Xn2 : Jt2 && Jt2 in Object(t3) ? qn2(t3) : Hn2(t3);
}
function F2(t3) {
  return t3 != null && typeof t3 == "object";
}
var Zn2 = "[object Symbol]";
function Et(t3) {
  return typeof t3 == "symbol" || F2(t3) && M2(t3) == Zn2;
}
function te(t3, r2) {
  for (var n2 = -1, e2 = t3 == null ? 0 : t3.length, i2 = Array(e2); ++n2 < e2; )
    i2[n2] = r2(t3[n2], n2, t3);
  return i2;
}
var S3 = Array.isArray;
var re = 1 / 0;
var qt = I2 ? I2.prototype : void 0;
var Kt2 = qt ? qt.toString : void 0;
function Fr2(t3) {
  if (typeof t3 == "string")
    return t3;
  if (S3(t3))
    return te(t3, Fr2) + "";
  if (Et(t3))
    return Kt2 ? Kt2.call(t3) : "";
  var r2 = t3 + "";
  return r2 == "0" && 1 / t3 == -re ? "-0" : r2;
}
function k(t3) {
  var r2 = typeof t3;
  return t3 != null && (r2 == "object" || r2 == "function");
}
function Tt2(t3) {
  return t3;
}
var ne = "[object AsyncFunction]";
var ee = "[object Function]";
var oe = "[object GeneratorFunction]";
var ie3 = "[object Proxy]";
function It(t3) {
  if (!k(t3))
    return false;
  var r2 = M2(t3);
  return r2 == ee || r2 == oe || r2 == ne || r2 == ie3;
}
var bt = P2["__core-js_shared__"];
var Yt2 = function() {
  var t3 = /[^.]+$/.exec(bt && bt.keys && bt.keys.IE_PROTO || "");
  return t3 ? "Symbol(src)_1." + t3 : "";
}();
function ae(t3) {
  return !!Yt2 && Yt2 in t3;
}
var ue = Function.prototype;
var ce = ue.toString;
function B2(t3) {
  if (t3 != null) {
    try {
      return ce.call(t3);
    } catch {
    }
    try {
      return t3 + "";
    } catch {
    }
  }
  return "";
}
var fe = /[\\^$.*+?()[\]{}|]/g;
var se = /^\[object .+?Constructor\]$/;
var le = Function.prototype;
var pe = Object.prototype;
var de = le.toString;
var ve = pe.hasOwnProperty;
var be = RegExp(
  "^" + de.call(ve).replace(fe, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function ye(t3) {
  if (!k(t3) || ae(t3))
    return false;
  var r2 = It(t3) ? be : se;
  return r2.test(B2(t3));
}
function he(t3, r2) {
  return t3 == null ? void 0 : t3[r2];
}
function D2(t3, r2) {
  var n2 = he(t3, r2);
  return ye(n2) ? n2 : void 0;
}
var jt = D2(P2, "WeakMap");
var Ht2 = Object.create;
var ge = /* @__PURE__ */ function() {
  function t3() {
  }
  return function(r2) {
    if (!k(r2))
      return {};
    if (Ht2)
      return Ht2(r2);
    t3.prototype = r2;
    var n2 = new t3();
    return t3.prototype = void 0, n2;
  };
}();
function je(t3, r2, n2) {
  switch (n2.length) {
    case 0:
      return t3.call(r2);
    case 1:
      return t3.call(r2, n2[0]);
    case 2:
      return t3.call(r2, n2[0], n2[1]);
    case 3:
      return t3.call(r2, n2[0], n2[1], n2[2]);
  }
  return t3.apply(r2, n2);
}
function me(t3, r2) {
  var n2 = -1, e2 = t3.length;
  for (r2 || (r2 = Array(e2)); ++n2 < e2; )
    r2[n2] = t3[n2];
  return r2;
}
var _e = 800;
var Oe = 16;
var we = Date.now;
function Ae(t3) {
  var r2 = 0, n2 = 0;
  return function() {
    var e2 = we(), i2 = Oe - (e2 - n2);
    if (n2 = e2, i2 > 0) {
      if (++r2 >= _e)
        return arguments[0];
    } else
      r2 = 0;
    return t3.apply(void 0, arguments);
  };
}
function xe(t3) {
  return function() {
    return t3;
  };
}
var et = function() {
  try {
    var t3 = D2(Object, "defineProperty");
    return t3({}, "", {}), t3;
  } catch {
  }
}();
var Se = et ? function(t3, r2) {
  return et(t3, "toString", {
    configurable: true,
    enumerable: false,
    value: xe(r2),
    writable: true
  });
} : Tt2;
var Ee = Ae(Se);
function Te(t3, r2) {
  for (var n2 = -1, e2 = t3 == null ? 0 : t3.length; ++n2 < e2 && r2(t3[n2], n2, t3) !== false; )
    ;
  return t3;
}
var Ie = 9007199254740991;
var Fe = /^(?:0|[1-9]\d*)$/;
function Ft2(t3, r2) {
  var n2 = typeof t3;
  return r2 = r2 ?? Ie, !!r2 && (n2 == "number" || n2 != "symbol" && Fe.test(t3)) && t3 > -1 && t3 % 1 == 0 && t3 < r2;
}
function ut(t3, r2, n2) {
  r2 == "__proto__" && et ? et(t3, r2, {
    configurable: true,
    enumerable: true,
    value: n2,
    writable: true
  }) : t3[r2] = n2;
}
function H(t3, r2) {
  return t3 === r2 || t3 !== t3 && r2 !== r2;
}
var Pe = Object.prototype;
var ke = Pe.hasOwnProperty;
function Pr2(t3, r2, n2) {
  var e2 = t3[r2];
  (!(ke.call(t3, r2) && H(e2, n2)) || n2 === void 0 && !(r2 in t3)) && ut(t3, r2, n2);
}
function kr2(t3, r2, n2, e2) {
  var i2 = !n2;
  n2 || (n2 = {});
  for (var o2 = -1, a2 = r2.length; ++o2 < a2; ) {
    var u = r2[o2], c = e2 ? e2(n2[u], t3[u], u, n2, t3) : void 0;
    c === void 0 && (c = t3[u]), i2 ? ut(n2, u, c) : Pr2(n2, u, c);
  }
  return n2;
}
var Xt2 = Math.max;
function ze(t3, r2, n2) {
  return r2 = Xt2(r2 === void 0 ? t3.length - 1 : r2, 0), function() {
    for (var e2 = arguments, i2 = -1, o2 = Xt2(e2.length - r2, 0), a2 = Array(o2); ++i2 < o2; )
      a2[i2] = e2[r2 + i2];
    i2 = -1;
    for (var u = Array(r2 + 1); ++i2 < r2; )
      u[i2] = e2[i2];
    return u[r2] = n2(a2), je(t3, this, u);
  };
}
function Ce(t3, r2) {
  return Ee(ze(t3, r2, Tt2), t3 + "");
}
var Ne = 9007199254740991;
function Pt(t3) {
  return typeof t3 == "number" && t3 > -1 && t3 % 1 == 0 && t3 <= Ne;
}
function ct(t3) {
  return t3 != null && Pt(t3.length) && !It(t3);
}
function $e(t3, r2, n2) {
  if (!k(n2))
    return false;
  var e2 = typeof r2;
  return (e2 == "number" ? ct(n2) && Ft2(r2, n2.length) : e2 == "string" && r2 in n2) ? H(n2[r2], t3) : false;
}
function zr2(t3) {
  return Ce(function(r2, n2) {
    var e2 = -1, i2 = n2.length, o2 = i2 > 1 ? n2[i2 - 1] : void 0, a2 = i2 > 2 ? n2[2] : void 0;
    for (o2 = t3.length > 3 && typeof o2 == "function" ? (i2--, o2) : void 0, a2 && $e(n2[0], n2[1], a2) && (o2 = i2 < 3 ? void 0 : o2, i2 = 1), r2 = Object(r2); ++e2 < i2; ) {
      var u = n2[e2];
      u && t3(r2, u, e2, o2);
    }
    return r2;
  });
}
var Le = Object.prototype;
function kt(t3) {
  var r2 = t3 && t3.constructor, n2 = typeof r2 == "function" && r2.prototype || Le;
  return t3 === n2;
}
function Me(t3, r2) {
  for (var n2 = -1, e2 = Array(t3); ++n2 < t3; )
    e2[n2] = r2(n2);
  return e2;
}
var Be = "[object Arguments]";
function Qt2(t3) {
  return F2(t3) && M2(t3) == Be;
}
var Cr2 = Object.prototype;
var De2 = Cr2.hasOwnProperty;
var Ue = Cr2.propertyIsEnumerable;
var ot = Qt2(/* @__PURE__ */ function() {
  return arguments;
}()) ? Qt2 : function(t3) {
  return F2(t3) && De2.call(t3, "callee") && !Ue.call(t3, "callee");
};
function Ve() {
  return false;
}
var Nr2 = typeof exports == "object" && exports && !exports.nodeType && exports;
var Zt2 = Nr2 && typeof module == "object" && module && !module.nodeType && module;
var We = Zt2 && Zt2.exports === Nr2;
var tr2 = We ? P2.Buffer : void 0;
var Re = tr2 ? tr2.isBuffer : void 0;
var q = Re || Ve;
var Ge = "[object Arguments]";
var Je = "[object Array]";
var qe = "[object Boolean]";
var Ke = "[object Date]";
var Ye = "[object Error]";
var He = "[object Function]";
var Xe = "[object Map]";
var Qe = "[object Number]";
var Ze = "[object Object]";
var to2 = "[object RegExp]";
var ro2 = "[object Set]";
var no2 = "[object String]";
var eo2 = "[object WeakMap]";
var oo2 = "[object ArrayBuffer]";
var io2 = "[object DataView]";
var ao2 = "[object Float32Array]";
var uo2 = "[object Float64Array]";
var co2 = "[object Int8Array]";
var fo2 = "[object Int16Array]";
var so2 = "[object Int32Array]";
var lo2 = "[object Uint8Array]";
var po2 = "[object Uint8ClampedArray]";
var vo2 = "[object Uint16Array]";
var bo2 = "[object Uint32Array]";
var _ = {};
_[ao2] = _[uo2] = _[co2] = _[fo2] = _[so2] = _[lo2] = _[po2] = _[vo2] = _[bo2] = true;
_[Ge] = _[Je] = _[oo2] = _[qe] = _[io2] = _[Ke] = _[Ye] = _[He] = _[Xe] = _[Qe] = _[Ze] = _[to2] = _[ro2] = _[no2] = _[eo2] = false;
function yo2(t3) {
  return F2(t3) && Pt(t3.length) && !!_[M2(t3)];
}
function zt(t3) {
  return function(r2) {
    return t3(r2);
  };
}
var $r2 = typeof exports == "object" && exports && !exports.nodeType && exports;
var G = $r2 && typeof module == "object" && module && !module.nodeType && module;
var ho2 = G && G.exports === $r2;
var yt = ho2 && Tr2.process;
var U2 = function() {
  try {
    var t3 = G && G.require && G.require("util").types;
    return t3 || yt && yt.binding && yt.binding("util");
  } catch {
  }
}();
var rr2 = U2 && U2.isTypedArray;
var Ct = rr2 ? zt(rr2) : yo2;
var go2 = Object.prototype;
var jo2 = go2.hasOwnProperty;
function Lr2(t3, r2) {
  var n2 = S3(t3), e2 = !n2 && ot(t3), i2 = !n2 && !e2 && q(t3), o2 = !n2 && !e2 && !i2 && Ct(t3), a2 = n2 || e2 || i2 || o2, u = a2 ? Me(t3.length, String) : [], c = u.length;
  for (var f in t3)
    (r2 || jo2.call(t3, f)) && !(a2 && // Safari 9 has enumerable `arguments.length` in strict mode.
    (f == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    i2 && (f == "offset" || f == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    o2 && (f == "buffer" || f == "byteLength" || f == "byteOffset") || // Skip index properties.
    Ft2(f, c))) && u.push(f);
  return u;
}
function Mr2(t3, r2) {
  return function(n2) {
    return t3(r2(n2));
  };
}
var mo2 = Mr2(Object.keys, Object);
var _o2 = Object.prototype;
var Oo2 = _o2.hasOwnProperty;
function wo2(t3) {
  if (!kt(t3))
    return mo2(t3);
  var r2 = [];
  for (var n2 in Object(t3))
    Oo2.call(t3, n2) && n2 != "constructor" && r2.push(n2);
  return r2;
}
function Nt(t3) {
  return ct(t3) ? Lr2(t3) : wo2(t3);
}
function Ao2(t3) {
  var r2 = [];
  if (t3 != null)
    for (var n2 in Object(t3))
      r2.push(n2);
  return r2;
}
var xo2 = Object.prototype;
var So2 = xo2.hasOwnProperty;
function Eo2(t3) {
  if (!k(t3))
    return Ao2(t3);
  var r2 = kt(t3), n2 = [];
  for (var e2 in t3)
    e2 == "constructor" && (r2 || !So2.call(t3, e2)) || n2.push(e2);
  return n2;
}
function $t(t3) {
  return ct(t3) ? Lr2(t3, true) : Eo2(t3);
}
var To2 = zr2(function(t3, r2, n2, e2) {
  kr2(r2, $t(r2), t3, e2);
});
var Io2 = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
var Fo2 = /^\w*$/;
function Lt2(t3, r2) {
  if (S3(t3))
    return false;
  var n2 = typeof t3;
  return n2 == "number" || n2 == "symbol" || n2 == "boolean" || t3 == null || Et(t3) ? true : Fo2.test(t3) || !Io2.test(t3) || r2 != null && t3 in Object(r2);
}
var K2 = D2(Object, "create");
function Po2() {
  this.__data__ = K2 ? K2(null) : {}, this.size = 0;
}
function ko2(t3) {
  var r2 = this.has(t3) && delete this.__data__[t3];
  return this.size -= r2 ? 1 : 0, r2;
}
var zo2 = "__lodash_hash_undefined__";
var Co2 = Object.prototype;
var No2 = Co2.hasOwnProperty;
function $o2(t3) {
  var r2 = this.__data__;
  if (K2) {
    var n2 = r2[t3];
    return n2 === zo2 ? void 0 : n2;
  }
  return No2.call(r2, t3) ? r2[t3] : void 0;
}
var Lo2 = Object.prototype;
var Mo2 = Lo2.hasOwnProperty;
function Bo2(t3) {
  var r2 = this.__data__;
  return K2 ? r2[t3] !== void 0 : Mo2.call(r2, t3);
}
var Do2 = "__lodash_hash_undefined__";
function Uo2(t3, r2) {
  var n2 = this.__data__;
  return this.size += this.has(t3) ? 0 : 1, n2[t3] = K2 && r2 === void 0 ? Do2 : r2, this;
}
function L2(t3) {
  var r2 = -1, n2 = t3 == null ? 0 : t3.length;
  for (this.clear(); ++r2 < n2; ) {
    var e2 = t3[r2];
    this.set(e2[0], e2[1]);
  }
}
L2.prototype.clear = Po2;
L2.prototype.delete = ko2;
L2.prototype.get = $o2;
L2.prototype.has = Bo2;
L2.prototype.set = Uo2;
function Vo2() {
  this.__data__ = [], this.size = 0;
}
function ft(t3, r2) {
  for (var n2 = t3.length; n2--; )
    if (H(t3[n2][0], r2))
      return n2;
  return -1;
}
var Wo2 = Array.prototype;
var Ro2 = Wo2.splice;
function Go2(t3) {
  var r2 = this.__data__, n2 = ft(r2, t3);
  if (n2 < 0)
    return false;
  var e2 = r2.length - 1;
  return n2 == e2 ? r2.pop() : Ro2.call(r2, n2, 1), --this.size, true;
}
function Jo2(t3) {
  var r2 = this.__data__, n2 = ft(r2, t3);
  return n2 < 0 ? void 0 : r2[n2][1];
}
function qo2(t3) {
  return ft(this.__data__, t3) > -1;
}
function Ko2(t3, r2) {
  var n2 = this.__data__, e2 = ft(n2, t3);
  return e2 < 0 ? (++this.size, n2.push([t3, r2])) : n2[e2][1] = r2, this;
}
function z2(t3) {
  var r2 = -1, n2 = t3 == null ? 0 : t3.length;
  for (this.clear(); ++r2 < n2; ) {
    var e2 = t3[r2];
    this.set(e2[0], e2[1]);
  }
}
z2.prototype.clear = Vo2;
z2.prototype.delete = Go2;
z2.prototype.get = Jo2;
z2.prototype.has = qo2;
z2.prototype.set = Ko2;
var Y = D2(P2, "Map");
function Yo2() {
  this.size = 0, this.__data__ = {
    hash: new L2(),
    map: new (Y || z2)(),
    string: new L2()
  };
}
function Ho2(t3) {
  var r2 = typeof t3;
  return r2 == "string" || r2 == "number" || r2 == "symbol" || r2 == "boolean" ? t3 !== "__proto__" : t3 === null;
}
function st(t3, r2) {
  var n2 = t3.__data__;
  return Ho2(r2) ? n2[typeof r2 == "string" ? "string" : "hash"] : n2.map;
}
function Xo2(t3) {
  var r2 = st(this, t3).delete(t3);
  return this.size -= r2 ? 1 : 0, r2;
}
function Qo2(t3) {
  return st(this, t3).get(t3);
}
function Zo2(t3) {
  return st(this, t3).has(t3);
}
function ti2(t3, r2) {
  var n2 = st(this, t3), e2 = n2.size;
  return n2.set(t3, r2), this.size += n2.size == e2 ? 0 : 1, this;
}
function C2(t3) {
  var r2 = -1, n2 = t3 == null ? 0 : t3.length;
  for (this.clear(); ++r2 < n2; ) {
    var e2 = t3[r2];
    this.set(e2[0], e2[1]);
  }
}
C2.prototype.clear = Yo2;
C2.prototype.delete = Xo2;
C2.prototype.get = Qo2;
C2.prototype.has = Zo2;
C2.prototype.set = ti2;
var ri2 = "Expected a function";
function Mt(t3, r2) {
  if (typeof t3 != "function" || r2 != null && typeof r2 != "function")
    throw new TypeError(ri2);
  var n2 = function() {
    var e2 = arguments, i2 = r2 ? r2.apply(this, e2) : e2[0], o2 = n2.cache;
    if (o2.has(i2))
      return o2.get(i2);
    var a2 = t3.apply(this, e2);
    return n2.cache = o2.set(i2, a2) || o2, a2;
  };
  return n2.cache = new (Mt.Cache || C2)(), n2;
}
Mt.Cache = C2;
var ni2 = 500;
function ei2(t3) {
  var r2 = Mt(t3, function(e2) {
    return n2.size === ni2 && n2.clear(), e2;
  }), n2 = r2.cache;
  return r2;
}
var oi2 = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var ii2 = /\\(\\)?/g;
var ai2 = ei2(function(t3) {
  var r2 = [];
  return t3.charCodeAt(0) === 46 && r2.push(""), t3.replace(oi2, function(n2, e2, i2, o2) {
    r2.push(i2 ? o2.replace(ii2, "$1") : e2 || n2);
  }), r2;
});
function ui2(t3) {
  return t3 == null ? "" : Fr2(t3);
}
function Br2(t3, r2) {
  return S3(t3) ? t3 : Lt2(t3, r2) ? [t3] : ai2(ui2(t3));
}
var ci2 = 1 / 0;
function lt(t3) {
  if (typeof t3 == "string" || Et(t3))
    return t3;
  var r2 = t3 + "";
  return r2 == "0" && 1 / t3 == -ci2 ? "-0" : r2;
}
function Dr2(t3, r2) {
  r2 = Br2(r2, t3);
  for (var n2 = 0, e2 = r2.length; t3 != null && n2 < e2; )
    t3 = t3[lt(r2[n2++])];
  return n2 && n2 == e2 ? t3 : void 0;
}
function fi2(t3, r2, n2) {
  var e2 = t3 == null ? void 0 : Dr2(t3, r2);
  return e2 === void 0 ? n2 : e2;
}
function si2(t3, r2) {
  for (var n2 = -1, e2 = r2.length, i2 = t3.length; ++n2 < e2; )
    t3[i2 + n2] = r2[n2];
  return t3;
}
var Ur2 = Mr2(Object.getPrototypeOf, Object);
var li2 = "[object Object]";
var pi2 = Function.prototype;
var di2 = Object.prototype;
var Vr2 = pi2.toString;
var vi2 = di2.hasOwnProperty;
var bi2 = Vr2.call(Object);
function yi(t3) {
  if (!F2(t3) || M2(t3) != li2)
    return false;
  var r2 = Ur2(t3);
  if (r2 === null)
    return true;
  var n2 = vi2.call(r2, "constructor") && r2.constructor;
  return typeof n2 == "function" && n2 instanceof n2 && Vr2.call(n2) == bi2;
}
function hi2() {
  this.__data__ = new z2(), this.size = 0;
}
function gi2(t3) {
  var r2 = this.__data__, n2 = r2.delete(t3);
  return this.size = r2.size, n2;
}
function ji2(t3) {
  return this.__data__.get(t3);
}
function mi2(t3) {
  return this.__data__.has(t3);
}
var _i2 = 200;
function Oi2(t3, r2) {
  var n2 = this.__data__;
  if (n2 instanceof z2) {
    var e2 = n2.__data__;
    if (!Y || e2.length < _i2 - 1)
      return e2.push([t3, r2]), this.size = ++n2.size, this;
    n2 = this.__data__ = new C2(e2);
  }
  return n2.set(t3, r2), this.size = n2.size, this;
}
function T2(t3) {
  var r2 = this.__data__ = new z2(t3);
  this.size = r2.size;
}
T2.prototype.clear = hi2;
T2.prototype.delete = gi2;
T2.prototype.get = ji2;
T2.prototype.has = mi2;
T2.prototype.set = Oi2;
var Wr2 = typeof exports == "object" && exports && !exports.nodeType && exports;
var nr2 = Wr2 && typeof module == "object" && module && !module.nodeType && module;
var wi2 = nr2 && nr2.exports === Wr2;
var er2 = wi2 ? P2.Buffer : void 0;
var or2 = er2 ? er2.allocUnsafe : void 0;
function Rr(t3, r2) {
  if (r2)
    return t3.slice();
  var n2 = t3.length, e2 = or2 ? or2(n2) : new t3.constructor(n2);
  return t3.copy(e2), e2;
}
function Ai2(t3, r2) {
  for (var n2 = -1, e2 = t3 == null ? 0 : t3.length, i2 = 0, o2 = []; ++n2 < e2; ) {
    var a2 = t3[n2];
    r2(a2, n2, t3) && (o2[i2++] = a2);
  }
  return o2;
}
function xi2() {
  return [];
}
var Si2 = Object.prototype;
var Ei2 = Si2.propertyIsEnumerable;
var ir2 = Object.getOwnPropertySymbols;
var Ti2 = ir2 ? function(t3) {
  return t3 == null ? [] : (t3 = Object(t3), Ai2(ir2(t3), function(r2) {
    return Ei2.call(t3, r2);
  }));
} : xi2;
function Ii2(t3, r2, n2) {
  var e2 = r2(t3);
  return S3(t3) ? e2 : si2(e2, n2(t3));
}
function mt(t3) {
  return Ii2(t3, Nt, Ti2);
}
var _t2 = D2(P2, "DataView");
var Ot = D2(P2, "Promise");
var wt = D2(P2, "Set");
var ar2 = "[object Map]";
var Fi2 = "[object Object]";
var ur2 = "[object Promise]";
var cr2 = "[object Set]";
var fr2 = "[object WeakMap]";
var sr2 = "[object DataView]";
var Pi2 = B2(_t2);
var ki2 = B2(Y);
var zi2 = B2(Ot);
var Ci2 = B2(wt);
var Ni2 = B2(jt);
var E2 = M2;
(_t2 && E2(new _t2(new ArrayBuffer(1))) != sr2 || Y && E2(new Y()) != ar2 || Ot && E2(Ot.resolve()) != ur2 || wt && E2(new wt()) != cr2 || jt && E2(new jt()) != fr2) && (E2 = function(t3) {
  var r2 = M2(t3), n2 = r2 == Fi2 ? t3.constructor : void 0, e2 = n2 ? B2(n2) : "";
  if (e2)
    switch (e2) {
      case Pi2:
        return sr2;
      case ki2:
        return ar2;
      case zi2:
        return ur2;
      case Ci2:
        return cr2;
      case Ni2:
        return fr2;
    }
  return r2;
});
var $i2 = Object.prototype;
var Li2 = $i2.hasOwnProperty;
function Mi2(t3) {
  var r2 = t3.length, n2 = new t3.constructor(r2);
  return r2 && typeof t3[0] == "string" && Li2.call(t3, "index") && (n2.index = t3.index, n2.input = t3.input), n2;
}
var it = P2.Uint8Array;
function Bt2(t3) {
  var r2 = new t3.constructor(t3.byteLength);
  return new it(r2).set(new it(t3)), r2;
}
function Bi2(t3, r2) {
  var n2 = Bt2(t3.buffer);
  return new t3.constructor(n2, t3.byteOffset, t3.byteLength);
}
var Di2 = /\w*$/;
function Ui2(t3) {
  var r2 = new t3.constructor(t3.source, Di2.exec(t3));
  return r2.lastIndex = t3.lastIndex, r2;
}
var lr2 = I2 ? I2.prototype : void 0;
var pr2 = lr2 ? lr2.valueOf : void 0;
function Vi2(t3) {
  return pr2 ? Object(pr2.call(t3)) : {};
}
function Gr2(t3, r2) {
  var n2 = r2 ? Bt2(t3.buffer) : t3.buffer;
  return new t3.constructor(n2, t3.byteOffset, t3.length);
}
var Wi2 = "[object Boolean]";
var Ri2 = "[object Date]";
var Gi2 = "[object Map]";
var Ji2 = "[object Number]";
var qi2 = "[object RegExp]";
var Ki2 = "[object Set]";
var Yi2 = "[object String]";
var Hi2 = "[object Symbol]";
var Xi2 = "[object ArrayBuffer]";
var Qi2 = "[object DataView]";
var Zi2 = "[object Float32Array]";
var ta2 = "[object Float64Array]";
var ra2 = "[object Int8Array]";
var na2 = "[object Int16Array]";
var ea2 = "[object Int32Array]";
var oa2 = "[object Uint8Array]";
var ia2 = "[object Uint8ClampedArray]";
var aa2 = "[object Uint16Array]";
var ua2 = "[object Uint32Array]";
function ca2(t3, r2, n2) {
  var e2 = t3.constructor;
  switch (r2) {
    case Xi2:
      return Bt2(t3);
    case Wi2:
    case Ri2:
      return new e2(+t3);
    case Qi2:
      return Bi2(t3);
    case Zi2:
    case ta2:
    case ra2:
    case na2:
    case ea2:
    case oa2:
    case ia2:
    case aa2:
    case ua2:
      return Gr2(t3, n2);
    case Gi2:
      return new e2();
    case Ji2:
    case Yi2:
      return new e2(t3);
    case qi2:
      return Ui2(t3);
    case Ki2:
      return new e2();
    case Hi2:
      return Vi2(t3);
  }
}
function Jr2(t3) {
  return typeof t3.constructor == "function" && !kt(t3) ? ge(Ur2(t3)) : {};
}
var fa2 = "[object Map]";
function sa2(t3) {
  return F2(t3) && E2(t3) == fa2;
}
var dr2 = U2 && U2.isMap;
var la2 = dr2 ? zt(dr2) : sa2;
var pa2 = "[object Set]";
function da2(t3) {
  return F2(t3) && E2(t3) == pa2;
}
var vr2 = U2 && U2.isSet;
var va2 = vr2 ? zt(vr2) : da2;
var ba2 = 1;
var qr2 = "[object Arguments]";
var ya2 = "[object Array]";
var ha2 = "[object Boolean]";
var ga2 = "[object Date]";
var ja2 = "[object Error]";
var Kr = "[object Function]";
var ma2 = "[object GeneratorFunction]";
var _a3 = "[object Map]";
var Oa2 = "[object Number]";
var Yr2 = "[object Object]";
var wa2 = "[object RegExp]";
var Aa2 = "[object Set]";
var xa2 = "[object String]";
var Sa2 = "[object Symbol]";
var Ea2 = "[object WeakMap]";
var Ta2 = "[object ArrayBuffer]";
var Ia2 = "[object DataView]";
var Fa2 = "[object Float32Array]";
var Pa2 = "[object Float64Array]";
var ka2 = "[object Int8Array]";
var za2 = "[object Int16Array]";
var Ca2 = "[object Int32Array]";
var Na2 = "[object Uint8Array]";
var $a2 = "[object Uint8ClampedArray]";
var La2 = "[object Uint16Array]";
var Ma2 = "[object Uint32Array]";
var m2 = {};
m2[qr2] = m2[ya2] = m2[Ta2] = m2[Ia2] = m2[ha2] = m2[ga2] = m2[Fa2] = m2[Pa2] = m2[ka2] = m2[za2] = m2[Ca2] = m2[_a3] = m2[Oa2] = m2[Yr2] = m2[wa2] = m2[Aa2] = m2[xa2] = m2[Sa2] = m2[Na2] = m2[$a2] = m2[La2] = m2[Ma2] = true;
m2[ja2] = m2[Kr] = m2[Ea2] = false;
function Z2(t3, r2, n2, e2, i2, o2) {
  var a2, u = r2 & ba2;
  if (a2 !== void 0)
    return a2;
  if (!k(t3))
    return t3;
  var c = S3(t3);
  if (c)
    a2 = Mi2(t3);
  else {
    var f = E2(t3), s2 = f == Kr || f == ma2;
    if (q(t3))
      return Rr(t3, u);
    if (f == Yr2 || f == qr2 || s2 && !i2)
      a2 = s2 ? {} : Jr2(t3);
    else {
      if (!m2[f])
        return i2 ? t3 : {};
      a2 = ca2(t3, f, u);
    }
  }
  o2 || (o2 = new T2());
  var d = o2.get(t3);
  if (d)
    return d;
  o2.set(t3, a2), va2(t3) ? t3.forEach(function(p) {
    a2.add(Z2(p, r2, n2, p, t3, o2));
  }) : la2(t3) && t3.forEach(function(p, j) {
    a2.set(j, Z2(p, r2, n2, j, t3, o2));
  });
  var v = mt, h2 = c ? void 0 : v(t3);
  return Te(h2 || t3, function(p, j) {
    h2 && (j = p, p = t3[j]), Pr2(a2, j, Z2(p, r2, n2, j, t3, o2));
  }), a2;
}
var Ba2 = 1;
var Da2 = 4;
function Ua2(t3) {
  return Z2(t3, Ba2 | Da2);
}
var Va2 = "__lodash_hash_undefined__";
function Wa2(t3) {
  return this.__data__.set(t3, Va2), this;
}
function Ra2(t3) {
  return this.__data__.has(t3);
}
function at(t3) {
  var r2 = -1, n2 = t3 == null ? 0 : t3.length;
  for (this.__data__ = new C2(); ++r2 < n2; )
    this.add(t3[r2]);
}
at.prototype.add = at.prototype.push = Wa2;
at.prototype.has = Ra2;
function Ga2(t3, r2) {
  for (var n2 = -1, e2 = t3 == null ? 0 : t3.length; ++n2 < e2; )
    if (r2(t3[n2], n2, t3))
      return true;
  return false;
}
function Ja2(t3, r2) {
  return t3.has(r2);
}
var qa2 = 1;
var Ka2 = 2;
function Hr2(t3, r2, n2, e2, i2, o2) {
  var a2 = n2 & qa2, u = t3.length, c = r2.length;
  if (u != c && !(a2 && c > u))
    return false;
  var f = o2.get(t3), s2 = o2.get(r2);
  if (f && s2)
    return f == r2 && s2 == t3;
  var d = -1, v = true, h2 = n2 & Ka2 ? new at() : void 0;
  for (o2.set(t3, r2), o2.set(r2, t3); ++d < u; ) {
    var p = t3[d], j = r2[d];
    if (e2)
      var A = a2 ? e2(j, p, d, r2, t3, o2) : e2(p, j, d, t3, r2, o2);
    if (A !== void 0) {
      if (A)
        continue;
      v = false;
      break;
    }
    if (h2) {
      if (!Ga2(r2, function(l, y) {
        if (!Ja2(h2, y) && (p === l || i2(p, l, n2, e2, o2)))
          return h2.push(y);
      })) {
        v = false;
        break;
      }
    } else if (!(p === j || i2(p, j, n2, e2, o2))) {
      v = false;
      break;
    }
  }
  return o2.delete(t3), o2.delete(r2), v;
}
function Ya2(t3) {
  var r2 = -1, n2 = Array(t3.size);
  return t3.forEach(function(e2, i2) {
    n2[++r2] = [i2, e2];
  }), n2;
}
function Ha2(t3) {
  var r2 = -1, n2 = Array(t3.size);
  return t3.forEach(function(e2) {
    n2[++r2] = e2;
  }), n2;
}
var Xa2 = 1;
var Qa2 = 2;
var Za2 = "[object Boolean]";
var tu2 = "[object Date]";
var ru2 = "[object Error]";
var nu2 = "[object Map]";
var eu2 = "[object Number]";
var ou2 = "[object RegExp]";
var iu2 = "[object Set]";
var au2 = "[object String]";
var uu2 = "[object Symbol]";
var cu2 = "[object ArrayBuffer]";
var fu2 = "[object DataView]";
var br2 = I2 ? I2.prototype : void 0;
var ht = br2 ? br2.valueOf : void 0;
function su2(t3, r2, n2, e2, i2, o2, a2) {
  switch (n2) {
    case fu2:
      if (t3.byteLength != r2.byteLength || t3.byteOffset != r2.byteOffset)
        return false;
      t3 = t3.buffer, r2 = r2.buffer;
    case cu2:
      return !(t3.byteLength != r2.byteLength || !o2(new it(t3), new it(r2)));
    case Za2:
    case tu2:
    case eu2:
      return H(+t3, +r2);
    case ru2:
      return t3.name == r2.name && t3.message == r2.message;
    case ou2:
    case au2:
      return t3 == r2 + "";
    case nu2:
      var u = Ya2;
    case iu2:
      var c = e2 & Xa2;
      if (u || (u = Ha2), t3.size != r2.size && !c)
        return false;
      var f = a2.get(t3);
      if (f)
        return f == r2;
      e2 |= Qa2, a2.set(t3, r2);
      var s2 = Hr2(u(t3), u(r2), e2, i2, o2, a2);
      return a2.delete(t3), s2;
    case uu2:
      if (ht)
        return ht.call(t3) == ht.call(r2);
  }
  return false;
}
var lu2 = 1;
var pu2 = Object.prototype;
var du2 = pu2.hasOwnProperty;
function vu2(t3, r2, n2, e2, i2, o2) {
  var a2 = n2 & lu2, u = mt(t3), c = u.length, f = mt(r2), s2 = f.length;
  if (c != s2 && !a2)
    return false;
  for (var d = c; d--; ) {
    var v = u[d];
    if (!(a2 ? v in r2 : du2.call(r2, v)))
      return false;
  }
  var h2 = o2.get(t3), p = o2.get(r2);
  if (h2 && p)
    return h2 == r2 && p == t3;
  var j = true;
  o2.set(t3, r2), o2.set(r2, t3);
  for (var A = a2; ++d < c; ) {
    v = u[d];
    var l = t3[v], y = r2[v];
    if (e2)
      var w = a2 ? e2(y, l, v, r2, t3, o2) : e2(l, y, v, t3, r2, o2);
    if (!(w === void 0 ? l === y || i2(l, y, n2, e2, o2) : w)) {
      j = false;
      break;
    }
    A || (A = v == "constructor");
  }
  if (j && !A) {
    var b2 = t3.constructor, O = r2.constructor;
    b2 != O && "constructor" in t3 && "constructor" in r2 && !(typeof b2 == "function" && b2 instanceof b2 && typeof O == "function" && O instanceof O) && (j = false);
  }
  return o2.delete(t3), o2.delete(r2), j;
}
var bu2 = 1;
var yr2 = "[object Arguments]";
var hr2 = "[object Array]";
var X = "[object Object]";
var yu2 = Object.prototype;
var gr2 = yu2.hasOwnProperty;
function hu2(t3, r2, n2, e2, i2, o2) {
  var a2 = S3(t3), u = S3(r2), c = a2 ? hr2 : E2(t3), f = u ? hr2 : E2(r2);
  c = c == yr2 ? X : c, f = f == yr2 ? X : f;
  var s2 = c == X, d = f == X, v = c == f;
  if (v && q(t3)) {
    if (!q(r2))
      return false;
    a2 = true, s2 = false;
  }
  if (v && !s2)
    return o2 || (o2 = new T2()), a2 || Ct(t3) ? Hr2(t3, r2, n2, e2, i2, o2) : su2(t3, r2, c, n2, e2, i2, o2);
  if (!(n2 & bu2)) {
    var h2 = s2 && gr2.call(t3, "__wrapped__"), p = d && gr2.call(r2, "__wrapped__");
    if (h2 || p) {
      var j = h2 ? t3.value() : t3, A = p ? r2.value() : r2;
      return o2 || (o2 = new T2()), i2(j, A, n2, e2, o2);
    }
  }
  return v ? (o2 || (o2 = new T2()), vu2(t3, r2, n2, e2, i2, o2)) : false;
}
function Dt2(t3, r2, n2, e2, i2) {
  return t3 === r2 ? true : t3 == null || r2 == null || !F2(t3) && !F2(r2) ? t3 !== t3 && r2 !== r2 : hu2(t3, r2, n2, e2, Dt2, i2);
}
var gu2 = 1;
var ju2 = 2;
function mu2(t3, r2, n2, e2) {
  var i2 = n2.length, o2 = i2;
  if (t3 == null)
    return !o2;
  for (t3 = Object(t3); i2--; ) {
    var a2 = n2[i2];
    if (a2[2] ? a2[1] !== t3[a2[0]] : !(a2[0] in t3))
      return false;
  }
  for (; ++i2 < o2; ) {
    a2 = n2[i2];
    var u = a2[0], c = t3[u], f = a2[1];
    if (a2[2]) {
      if (c === void 0 && !(u in t3))
        return false;
    } else {
      var s2 = new T2(), d;
      if (!(d === void 0 ? Dt2(f, c, gu2 | ju2, e2, s2) : d))
        return false;
    }
  }
  return true;
}
function Xr2(t3) {
  return t3 === t3 && !k(t3);
}
function _u2(t3) {
  for (var r2 = Nt(t3), n2 = r2.length; n2--; ) {
    var e2 = r2[n2], i2 = t3[e2];
    r2[n2] = [e2, i2, Xr2(i2)];
  }
  return r2;
}
function Qr2(t3, r2) {
  return function(n2) {
    return n2 == null ? false : n2[t3] === r2 && (r2 !== void 0 || t3 in Object(n2));
  };
}
function Ou2(t3) {
  var r2 = _u2(t3);
  return r2.length == 1 && r2[0][2] ? Qr2(r2[0][0], r2[0][1]) : function(n2) {
    return n2 === t3 || mu2(n2, t3, r2);
  };
}
function wu2(t3, r2) {
  return t3 != null && r2 in Object(t3);
}
function Au2(t3, r2, n2) {
  r2 = Br2(r2, t3);
  for (var e2 = -1, i2 = r2.length, o2 = false; ++e2 < i2; ) {
    var a2 = lt(r2[e2]);
    if (!(o2 = t3 != null && n2(t3, a2)))
      break;
    t3 = t3[a2];
  }
  return o2 || ++e2 != i2 ? o2 : (i2 = t3 == null ? 0 : t3.length, !!i2 && Pt(i2) && Ft2(a2, i2) && (S3(t3) || ot(t3)));
}
function xu2(t3, r2) {
  return t3 != null && Au2(t3, r2, wu2);
}
var Su2 = 1;
var Eu2 = 2;
function Tu2(t3, r2) {
  return Lt2(t3) && Xr2(r2) ? Qr2(lt(t3), r2) : function(n2) {
    var e2 = fi2(n2, t3);
    return e2 === void 0 && e2 === r2 ? xu2(n2, t3) : Dt2(r2, e2, Su2 | Eu2);
  };
}
function Iu2(t3) {
  return function(r2) {
    return r2 == null ? void 0 : r2[t3];
  };
}
function Fu2(t3) {
  return function(r2) {
    return Dr2(r2, t3);
  };
}
function Pu2(t3) {
  return Lt2(t3) ? Iu2(lt(t3)) : Fu2(t3);
}
function ku2(t3) {
  return typeof t3 == "function" ? t3 : t3 == null ? Tt2 : typeof t3 == "object" ? S3(t3) ? Tu2(t3[0], t3[1]) : Ou2(t3) : Pu2(t3);
}
function zu2(t3) {
  return function(r2, n2, e2) {
    for (var i2 = -1, o2 = Object(r2), a2 = e2(r2), u = a2.length; u--; ) {
      var c = a2[++i2];
      if (n2(o2[c], c, o2) === false)
        break;
    }
    return r2;
  };
}
var Zr2 = zu2();
function Cu2(t3, r2) {
  return t3 && Zr2(t3, r2, Nt);
}
function At2(t3, r2, n2) {
  (n2 !== void 0 && !H(t3[r2], n2) || n2 === void 0 && !(r2 in t3)) && ut(t3, r2, n2);
}
function Nu2(t3) {
  return F2(t3) && ct(t3);
}
function xt(t3, r2) {
  if (!(r2 === "constructor" && typeof t3[r2] == "function") && r2 != "__proto__")
    return t3[r2];
}
function $u2(t3) {
  return kr2(t3, $t(t3));
}
function Lu2(t3, r2, n2, e2, i2, o2, a2) {
  var u = xt(t3, n2), c = xt(r2, n2), f = a2.get(c);
  if (f) {
    At2(t3, n2, f);
    return;
  }
  var s2 = o2 ? o2(u, c, n2 + "", t3, r2, a2) : void 0, d = s2 === void 0;
  if (d) {
    var v = S3(c), h2 = !v && q(c), p = !v && !h2 && Ct(c);
    s2 = c, v || h2 || p ? S3(u) ? s2 = u : Nu2(u) ? s2 = me(u) : h2 ? (d = false, s2 = Rr(c, true)) : p ? (d = false, s2 = Gr2(c, true)) : s2 = [] : yi(c) || ot(c) ? (s2 = u, ot(u) ? s2 = $u2(u) : (!k(u) || It(u)) && (s2 = Jr2(c))) : d = false;
  }
  d && (a2.set(c, s2), i2(s2, c, e2, o2, a2), a2.delete(c)), At2(t3, n2, s2);
}
function tn2(t3, r2, n2, e2, i2) {
  t3 !== r2 && Zr2(r2, function(o2, a2) {
    if (i2 || (i2 = new T2()), k(o2))
      Lu2(t3, r2, a2, n2, tn2, e2, i2);
    else {
      var u = e2 ? e2(xt(t3, a2), o2, a2 + "", t3, r2, i2) : void 0;
      u === void 0 && (u = o2), At2(t3, a2, u);
    }
  }, $t);
}
var Mu2 = zr2(function(t3, r2, n2, e2) {
  tn2(t3, r2, n2, e2);
});
function Bu2(t3, r2) {
  var n2 = {};
  return r2 = ku2(r2), Cu2(t3, function(e2, i2, o2) {
    ut(n2, r2(e2, i2, o2), e2);
  }), n2;
}
var Du2 = new RegExp("([\\p{Ll}\\d])(\\p{Lu})", "gu");
var Uu2 = new RegExp("(\\p{Lu})([\\p{Lu}][\\p{Ll}])", "gu");
var Vu2 = new RegExp("(\\d)\\p{Ll}|(\\p{L})\\d", "u");
var Wu2 = /[^\p{L}\d]+/giu;
var jr2 = "$1\0$2";
var mr2 = "";
function rn2(t3) {
  let r2 = t3.trim();
  r2 = r2.replace(Du2, jr2).replace(Uu2, jr2), r2 = r2.replace(Wu2, "\0");
  let n2 = 0, e2 = r2.length;
  for (; r2.charAt(n2) === "\0"; )
    n2++;
  if (n2 === e2)
    return [];
  for (; r2.charAt(e2 - 1) === "\0"; )
    e2--;
  return r2.slice(n2, e2).split(/\0/g);
}
function Ru2(t3) {
  const r2 = rn2(t3);
  for (let n2 = 0; n2 < r2.length; n2++) {
    const e2 = r2[n2], i2 = Vu2.exec(e2);
    if (i2) {
      const o2 = i2.index + (i2[1] ?? i2[2]).length;
      r2.splice(n2, 1, e2.slice(0, o2), e2.slice(o2));
    }
  }
  return r2;
}
function Gu2(t3, r2) {
  const [n2, e2, i2] = Yu2(t3, r2), o2 = Ju2(void 0), a2 = qu2(void 0), u = Ku2(o2, a2);
  return n2 + e2.map((c, f) => f === 0 ? o2(c) : u(c, f)).join("") + i2;
}
function Ju2(t3) {
  return (r2) => r2.toLocaleLowerCase(t3);
}
function qu2(t3) {
  return (r2) => r2.toLocaleUpperCase(t3);
}
function Ku2(t3, r2) {
  return (n2, e2) => {
    const i2 = n2[0];
    return (e2 > 0 && i2 >= "0" && i2 <= "9" ? "_" + i2 : r2(i2)) + t3(n2.slice(1));
  };
}
function Yu2(t3, r2 = {}) {
  const n2 = r2.split ?? (r2.separateNumbers ? Ru2 : rn2), e2 = r2.prefixCharacters ?? mr2, i2 = r2.suffixCharacters ?? mr2;
  let o2 = 0, a2 = t3.length;
  for (; o2 < t3.length; ) {
    const u = t3.charAt(o2);
    if (!e2.includes(u))
      break;
    o2++;
  }
  for (; a2 > o2; ) {
    const u = a2 - 1, c = t3.charAt(u);
    if (!i2.includes(c))
      break;
    a2 = u;
  }
  return [
    t3.slice(0, o2),
    n2(t3.slice(o2, a2)),
    t3.slice(a2)
  ];
}
var J2 = (t3) => /.+-.+/.test(t3) ? Gu2(t3) : t3;
var Hu2 = (t3) => Object.prototype.toString.call(t3).slice(8, -1) === "Object";
function Xu2(t3, r2) {
  const n2 = /* @__PURE__ */ Object.create(null), e2 = t3.split(",");
  for (let i2 = 0; i2 < e2.length; i2++)
    n2[e2[i2]] = true;
  return (i2) => !!n2[i2];
}
var Qu2 = Xu2("String,Number,Boolean,Function,Symbol,BigInt");
function Zu2(t3) {
  const r2 = t3 == null ? void 0 : t3.toString().match(/^\s*function (\w+)/);
  return r2 ? r2[1] : t3 === null ? "null" : "";
}
function tc2(t3, r2) {
  let n2;
  const e2 = Zu2(r2);
  if (Qu2(e2)) {
    const i2 = typeof t3;
    n2 = i2 === e2.toLowerCase(), !n2 && i2 === "object" && (n2 = t3 instanceof r2);
  } else e2 === "Object" ? n2 = k(t3) : e2 === "Array" ? n2 = Array.isArray(t3) : e2 === "null" ? n2 = t3 === null : n2 = t3 instanceof r2;
  return {
    valid: n2,
    expectedType: e2
  };
}
function rc2({
  prop: t3,
  type: r2,
  validator: n2
}) {
  if (![void 0, null].includes(t3) && r2) {
    let e2 = false;
    const i2 = Array.isArray(r2) ? r2 : [r2], o2 = [];
    for (let a2 = 0; a2 < i2.length && !e2; a2++) {
      const { valid: u, expectedType: c } = tc2(t3, i2[a2]);
      o2.push(c || ""), e2 = u;
    }
    if (!e2)
      throw new TypeError(
        `Invalid prop: type check failed, expecting [${o2.join(
          ", "
        )}], receiving: ${t3}`
      );
  }
  if (n2 && !n2(t3))
    throw new Error(`Invalid prop: validator check failed, receiving: ${t3}`);
}
function nc2(t3, {
  mergeObject: r2,
  mergeObjectCustomizer: n2,
  mergeFunction: e2
}) {
  const i2 = [];
  for (let a2 = t3.length - 1; a2 >= 0; a2--)
    i2.push(t3[a2]);
  const o2 = n2 || (e2 ? (a2, u) => typeof a2 == "function" && typeof u == "function" ? e2 == null ? void 0 : e2(u, a2) : void 0 : void 0);
  return r2 === "deep" ? Mu2(...i2, o2) : To2(...i2, o2);
}
function ec2(t3, {
  mergeFunction: r2
}) {
  return t3.reduce(r2, () => {
  });
}
function $(t3, r2 = {}) {
  const {
    type: n2,
    default: e2,
    defaultIsDynamic: i2 = false,
    required: o2 = false,
    validator: a2,
    camelizeObjectKeys: u = false,
    mergeObjectApplyOnlyToDefault: c = false,
    mergeFunctionApplyOnlyToDefault: f = true
  } = r2;
  let { mergeObject: s2 = "deep", mergeObjectCustomizer: d, mergeFunction: v = false } = r2;
  const h2 = [];
  let p, j = false, A = false;
  const l = (y) => {
    if (y !== void 0) {
      rc2({ type: n2, prop: y, validator: a2 });
      const w = Hu2(y), b2 = typeof y == "function";
      return j = w, A = b2, w ? (y = Ua2(y), u ? Bu2(y, (O, g) => J2(g)) : y) : y;
    }
  };
  for (const y of t3)
    h2.push(l(y));
  if (!i2)
    h2.push(l(e2));
  else if (typeof e2 != "function")
    throw new TypeError(
      `Invalid option: options.default should be Function when options.defaultIsDynamic enabled, receiving: ${e2}`
    );
  j || (s2 = false, A || (v = false));
  for (let y = 0; y < h2.length; y++) {
    const w = h2[y];
    if (w !== void 0) {
      y === h2.length - 1 ? p = w : s2 ? p = nc2(
        c ? [w, e2] : h2,
        {
          mergeObject: s2,
          mergeObjectCustomizer: d,
          mergeFunction: v
        }
      ) : v ? p = ec2(
        f ? [w, e2] : h2,
        {
          mergeFunction: v
        }
      ) : p = w;
      break;
    }
  }
  if (o2 && [void 0, null].includes(p))
    throw new Error("Missing required prop");
  return i2 ? $(t3, {
    ...r2,
    default: e2(p),
    defaultIsDynamic: false
  }) : p;
}
function _r2(t3) {
  const r2 = Array.from(J2(t3));
  return r2[0] = r2[0].toUpperCase(), r2.unshift("o", "n"), r2.join("");
}
function oc2(t3, {
  props: r2 = [],
  camelizePropNames: n2 = false
} = {}) {
  const e2 = {
    props: {},
    attrs: {},
    listeners: {},
    hooks: {},
    slots: {}
  };
  let i2;
  if (Array.isArray(r2))
    i2 = n2 ? r2.map((o2) => J2(o2)) : r2;
  else if (n2) {
    i2 = [];
    for (const o2 in r2)
      i2.push(J2(o2));
  } else
    i2 = Object.keys(r2);
  for (const o2 in t3)
    if (o2.startsWith("@")) {
      const a2 = o2.substring(1);
      if (isVue3)
        if (a2.startsWith("vue:"))
          e2.hooks[_r2(a2.replace("vue:", "vnode-"))] = t3[o2];
        else {
          if (a2.startsWith("vnode"))
            throw new Error("@vnode-* hooks are no longer supported. Use the vue: prefix instead. For example, @vnode-mounted should be changed to @vue:mounted. @vnode-* hooks support has been removed in Vue 3.4.");
          e2.listeners[_r2(a2)] = t3[o2];
        }
      else
        a2.startsWith("hook:") ? e2.hooks[a2] = t3[o2] : e2.listeners[a2] = t3[o2];
    } else if (o2.startsWith("#")) {
      const a2 = o2.substring(1);
      a2 && (e2.slots[a2] = t3[o2]);
    } else {
      const a2 = n2 ? J2(o2) : o2;
      i2.includes(a2) ? e2.props[a2] = t3[o2] : e2.attrs[o2] = t3[o2];
    }
  return e2;
}
var Or2 = "JsonEditorVue";
var N2 = {};
var wr2 = {};
var tt = isVue3 ? "modelValue" : "value";
var Ar2 = isVue3 ? "update:modelValue" : "input";
var rt = [
  "mainMenuBar",
  "navigationBar",
  "statusBar",
  "askToFormat",
  "readOnly",
  "escapeControlCharacters",
  "escapeUnicodeCharacters",
  "flattenColumns"
];
var xr2 = {
  [tt]: {},
  mode: {
    type: String
  },
  debounce: {
    type: Number
  },
  stringified: {
    type: Boolean,
    default: void 0
  },
  ...Object.fromEntries(
    rt.map((t3) => [
      t3,
      {
        type: Boolean,
        default: void 0
      }
    ])
  )
};
var uc2 = defineComponent({
  name: Or2,
  install(t3, r2) {
    const n2 = oc2(r2 || {}, { props: xr2 });
    Object.assign(N2, n2.props), Object.assign(wr2, n2.attrs), t3.component(Or2, this);
  },
  props: xr2,
  emits: {
    [Ar2](t3) {
      return true;
    },
    "update:mode": function(t3) {
      return true;
    }
  },
  setup(t3, { attrs: r2, emit: n2, expose: e2 }) {
    var A;
    const i2 = (A = getCurrentInstance()) == null ? void 0 : A.proxy, o2 = ref(), a2 = ref(false), u = ref();
    watchEffect(() => {
      var l;
      u.value = $([t3.mode, N2.mode], {
        type: String
      }), (l = o2.value) == null || l.updateProps({
        mode: u.value || co.tree
      });
    });
    const c = (l) => {
      n2("update:mode", l);
    };
    N2.mode !== void 0 && t3.mode === void 0 && c(N2.mode);
    const f = computed(() => $([t3.debounce, N2.debounce, 300], {
      type: Number
    })), s2 = computed(() => $([t3.stringified, N2.stringified, true], {
      type: Boolean
    }));
    let d = Q;
    const v = (l) => {
      a2.value = true, !s2.value && l.text && (o2.value && !o2.value.validate() && (l.json = d(l.text)), l.text = void 0), n2(
        Ar2,
        l.text === void 0 ? l.json : l.text
      );
    }, h2 = Wn2(v, f.value), p = (l) => {
      u.value === "text" ? h2(l) : v(l);
    }, j = (l, y) => (...w) => {
      l(...w), y(...w);
    };
    return e2 == null || e2({ jsonEditor: o2 }), onUnmounted(() => {
      var l;
      (l = o2.value) == null || l.destroy();
    }), onMounted(() => {
      const l = $([t3[tt], N2[tt]]), y = Object.fromEntries(
        Array.from(rt, (b2) => [b2, $([t3[b2], N2[b2]])]).filter(
          ([, b2]) => b2 !== void 0
        )
      ), w = $(
        [
          y,
          r2,
          wr2
        ],
        {
          camelizeObjectKeys: true,
          defaultIsDynamic: true,
          default: (b2) => {
            var O;
            return d = ((O = b2.parser) == null ? void 0 : O.parse) || Q, {
              onChange: p,
              onChangeMode: c,
              mode: u.value,
              // Can not just pass one of parse and stringify
              parser: {
                // SafeDestr is used by default so that it will not affect the result of jsonEditor.value.validate()
                // When stringified is disabled, destr is used by default for better performance (destr is only called when JSON is valid)
                parse: hn2,
                stringify: JSON.stringify
              },
              ...l !== void 0 && {
                content: {
                  [typeof l == "string" && u.value === "text" && s2.value ? "text" : "json"]: l
                }
              }
            };
          },
          mergeFunction: j,
          mergeObject: "shallow",
          type: Object
        }
      );
      o2.value = kb({
        target: i2 == null ? void 0 : i2.$refs.jsonEditorRef,
        props: w
      }), watch(
        () => t3[tt],
        (b2) => {
          if (a2.value) {
            a2.value = false;
            return;
          }
          o2.value && o2.value.set(
            [void 0, ""].includes(b2) ? {
              text: ""
            } : {
              [typeof b2 == "string" && u.value === "text" && s2.value ? "text" : "json"]: b2
            }
          );
        },
        {
          deep: true
        }
      ), watch(
        () => Array.from(rt, (b2) => t3[b2]),
        (b2) => {
          var O;
          (O = o2.value) == null || O.updateProps(
            Object.fromEntries(Array.from(b2, (g, x) => [rt[x], g]).filter(([, g]) => g !== void 0))
          );
        }
      ), watch(
        () => r2,
        (b2) => {
          var g, x;
          const O = {};
          (b2.onChange || b2["on-change"]) && (O.onChange = p), (b2.onChangeMode || b2["on-change-mode"]) && (O.onChangeMode = c), d = ((g = b2.parser) == null ? void 0 : g.parse) || Q, (x = o2.value) == null || x.updateProps(
            Object.getOwnPropertyNames(O).length > 0 ? $([b2, O], {
              camelizeObjectKeys: true,
              mergeFunction: j,
              mergeObject: "shallow",
              type: Object
            }) : b2
          );
        },
        {
          deep: true
        }
      ), e2 || (e2 = (b2) => {
        for (const O in b2)
          i2[O] = unref(b2[O]);
      }, e2({ jsonEditor: o2 }));
    }), () => h("div", { ref: "jsonEditorRef" });
  }
});
export {
  uc2 as default
};
/*! Bundled license information:

natural-compare-lite/index.js:
  (*
   * @version    1.4.0
   * @date       2015-10-26
   * @stability  3 - Stable
   * @author     Lauri Rooden (https://github.com/litejs/natural-compare-lite)
   * @license    MIT License
   *)
*/
//# sourceMappingURL=json-editor-vue.js.map
